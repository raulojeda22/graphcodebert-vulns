@Test 	void permitAllForHealth() { 		this.contextRunner.withUserConfiguration(UserDetailsServiceConfiguration.class) 			.run((context) -> assertThat(getAuthenticateHeader(context, "/actuator/health")).isNull()); 	}
@Test 	void securesEverythingElse() { 		this.contextRunner.withUserConfiguration(UserDetailsServiceConfiguration.class).run((context) -> { 			assertThat(getAuthenticateHeader(context, "/actuator").get(0)).contains("Basic realm="); 			assertThat(getAuthenticateHeader(context, "/foo").toString()).contains("Basic realm="); 		}); 	}
@Test 	void usesMatchersBasedOffConfiguredActuatorBasePath() { 		this.contextRunner.withUserConfiguration(UserDetailsServiceConfiguration.class) 			.withPropertyValues("management.endpoints.web.base-path=/") 			.run((context) -> { 				assertThat(getAuthenticateHeader(context, "/health")).isNull(); 				assertThat(getAuthenticateHeader(context, "/foo").get(0)).contains("Basic realm="); 			}); 	}
@Override 	public Stream<? extends Arguments> provideArguments(ExtensionContext extensionContext) { 		String customPrefix = "CUSTOM_AUTHORITY_PREFIX_"; 		String customDelimiter = "[~,#:]"; 		String customAuthoritiesClaim = "custom_authorities"; 		String customPrincipalClaim = "custom_principal"; 		String jwkSetUriProperty = "spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com"; 		String authorityPrefixProperty = "spring.security.oauth2.resourceserver.jwt.authority-prefix=" + customPrefix; 		String authoritiesDelimiterProperty = "spring.security.oauth2.resourceserver.jwt.authorities-claim-delimiter=" 				+ customDelimiter; 		String authoritiesClaimProperty = "spring.security.oauth2.resourceserver.jwt.authorities-claim-name=" 				+ customAuthoritiesClaim; 		String principalClaimProperty = "spring.security.oauth2.resourceserver.jwt.principal-claim-name=" 				+ customPrincipalClaim; 		String[] customPrefixProps = { jwkSetUriProperty, authorityPrefixProperty }; 		String[] customDelimiterProps = { jwkSetUriProperty, authorityPrefixProperty, authoritiesDelimiterProperty }; 		String[] customAuthoritiesClaimProps = { jwkSetUriProperty, authoritiesClaimProperty }; 		String[] customPrincipalClaimProps = { jwkSetUriProperty, principalClaimProperty }; 		String[] allJwtConverterProps = { jwkSetUriProperty, authorityPrefixProperty, authoritiesDelimiterProperty, 				authoritiesClaimProperty, principalClaimProperty }; 		String[] jwtScopes = { "custom_scope0", "custom_scope1" }; 		String subjectValue = UUID.randomUUID().toString(); 		String customPrincipalValue = UUID.randomUUID().toString(); 		Jwt.Builder jwtBuilder = Jwt.withTokenValue("token") 			.header("alg", "none") 			.expiresAt(Instant.MAX) 			.issuedAt(Instant.MIN) 			.issuer("https://issuer.example.org") 			.jti("jti") 			.notBefore(Instant.MIN) 			.subject(subjectValue) 			.claim(customPrincipalClaim, customPrincipalValue); 		Jwt noAuthoritiesCustomizationsJwt = jwtBuilder.claim("scp", jwtScopes[0] + " " + jwtScopes[1]).build(); 		Jwt customAuthoritiesDelimiterJwt = jwtBuilder.claim("scp", jwtScopes[0] + "~" + jwtScopes[1]).build(); 		Jwt customAuthoritiesClaimJwt = jwtBuilder.claim("scp", null) 			.claim(customAuthoritiesClaim, jwtScopes[0] + " " + jwtScopes[1]) 			.build(); 		Jwt customAuthoritiesClaimAndDelimiterJwt = jwtBuilder.claim("scp", null) 			.claim(customAuthoritiesClaim, jwtScopes[0] + "~" + jwtScopes[1]) 			.build(); 		String[] customPrefixAuthorities = { customPrefix + jwtScopes[0], customPrefix + jwtScopes[1] }; 		String[] defaultPrefixAuthorities = { "SCOPE_" + jwtScopes[0], "SCOPE_" + jwtScopes[1] }; 		return Stream.of( 				Arguments.of(Named.named("Custom prefix for GrantedAuthority", customPrefixProps), 						noAuthoritiesCustomizationsJwt, subjectValue, customPrefixAuthorities), 				Arguments.of(Named.named("Custom delimiter for JWT scopes", customDelimiterProps), 						customAuthoritiesDelimiterJwt, subjectValue, customPrefixAuthorities), 				Arguments.of(Named.named("Custom JWT authority claim name", customAuthoritiesClaimProps), 						customAuthoritiesClaimJwt, subjectValue, defaultPrefixAuthorities), 				Arguments.of(Named.named("Custom JWT principal claim name", customPrincipalClaimProps), 						noAuthoritiesCustomizationsJwt, customPrincipalValue, defaultPrefixAuthorities), 				Arguments.of(Named.named("All JWT converter customizations", allJwtConverterProps), 						customAuthoritiesClaimAndDelimiterJwt, customPrincipalValue, customPrefixAuthorities)); 	}
@Bean 		ReactiveOpaqueTokenIntrospector decoder() { 			return mock(ReactiveOpaqueTokenIntrospector.class); 		}
@Bean 		ReactiveJwtDecoder decoder() { 			return mock(ReactiveJwtDecoder.class); 		}
@Bean 		OpaqueTokenIntrospector decoder() { 			return mock(OpaqueTokenIntrospector.class); 		}
@Bean 		JwtDecoder decoder() { 			return mock(JwtDecoder.class); 		}
@Bean 		ReactiveOpaqueTokenIntrospector decoder() { 			return mock(ReactiveOpaqueTokenIntrospector.class); 		}
@Bean 		ReactiveJwtDecoder decoder() { 			return mock(ReactiveJwtDecoder.class); 		}
@Test 	void enablesWebFluxSecurityWhenUserDetailsServiceIsPresent() { 		this.contextRunner.withUserConfiguration(UserDetailsServiceConfiguration.class).run((context) -> { 			assertThat(context).hasSingleBean(WebFilterChainProxy.class); 			assertThat(context).doesNotHaveBean("denyAllAuthenticationManager"); 		}); 	}
@Test 	void enablesWebFluxSecurityWhenReactiveAuthenticationManagerIsPresent() { 		this.contextRunner 			.withBean(ReactiveAuthenticationManager.class, () -> mock(ReactiveAuthenticationManager.class)) 			.run((context) -> { 				assertThat(context).hasSingleBean(WebFilterChainProxy.class); 				assertThat(context).doesNotHaveBean("denyAllAuthenticationManager"); 			}); 	}
@Test 	void enablesWebFluxSecurityWhenSecurityWebFilterChainIsPresent() { 		this.contextRunner.withBean(SecurityWebFilterChain.class, () -> mock(SecurityWebFilterChain.class)) 			.run((context) -> { 				assertThat(context).hasSingleBean(WebFilterChainProxy.class); 				assertThat(context).doesNotHaveBean("denyAllAuthenticationManager"); 			}); 	}
@Test 	void autoConfigurationShouldConfigureResourceServer() { 		this.contextRunner 			.withPropertyValues("spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com") 			.run((context) -> { 				assertThat(context).hasSingleBean(NimbusReactiveJwtDecoder.class); 				assertFilterConfiguredWithJwtAuthenticationManager(context); 			}); 	}
@Test 	void autoConfigurationWhenIntrospectionUriAvailableShouldConfigureIntrospectionClient() { 		this.contextRunner 			.withPropertyValues( 					"spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://check-token.com", 					"spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id", 					"spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret") 			.run((context) -> { 				assertThat(context).hasSingleBean(ReactiveOpaqueTokenIntrospector.class); 				assertFilterConfiguredWithOpaqueTokenAuthenticationManager(context); 			}); 	}
@Bean 		ReactiveOpaqueTokenIntrospector decoder() { 			return mock(ReactiveOpaqueTokenIntrospector.class); 		}
@Bean 		ReactiveJwtDecoder decoder() { 			return mock(ReactiveJwtDecoder.class); 		}
@Test 	void autoConfigurationShouldConfigureResourceServer() { 		this.contextRunner 			.withPropertyValues("spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com") 			.withInitializer(ConditionEvaluationReportLoggingListener.forLogLevel(LogLevel.INFO)) 			.run((context) -> { 				assertThat(context).hasSingleBean(NimbusReactiveJwtDecoder.class); 				assertFilterConfiguredWithJwtAuthenticationManager(context); 			}); 	}
@Test 	void autoConfigurationWhenIntrospectionUriAvailableShouldConfigureIntrospectionClient() { 		this.contextRunner.withInitializer(ConditionEvaluationReportLoggingListener.forLogLevel(LogLevel.INFO)) 			.withPropertyValues( 					"spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://check-token.com", 					"spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id", 					"spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret") 			.run((context) -> { 				assertThat(context).hasSingleBean(ReactiveOpaqueTokenIntrospector.class); 				assertFilterConfiguredWithOpaqueTokenAuthenticationManager(context); 			}); 	}
@Bean 		ReactiveOpaqueTokenIntrospector decoder() { 			return mock(ReactiveOpaqueTokenIntrospector.class); 		}
@Bean 		ReactiveJwtDecoder decoder() { 			return mock(ReactiveJwtDecoder.class); 		}
@Test 	void executeWithSecurityOptionsExecutesPhases() throws Exception { 		given(this.docker.container().create(any())).willAnswer(answerWithGeneratedContainerId()); 		given(this.docker.container().create(any(), any())).willAnswer(answerWithGeneratedContainerId()); 		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null)); 		BuildRequest request = getTestRequest().withSecurityOptions(List.of("label=user:USER", "label=role:ROLE")); 		createLifecycle(request).execute(); 		assertPhaseWasRun("creator", withExpectedConfig("lifecycle-creator-security-opts.json", true)); 		assertThat(this.out.toString()).contains("Successfully built image 'docker.io/library/my-application:latest'"); 	}
private IOConsumer<ContainerConfig> withExpectedConfig(String name) { 		return withExpectedConfig(name, false); 	}
@Bean 		ReactiveOpaqueTokenIntrospector decoder() { 			return mock(ReactiveOpaqueTokenIntrospector.class); 		}
@Bean 		ReactiveJwtDecoder decoder() { 			return mock(ReactiveJwtDecoder.class); 		}
public BuildRequest withBuilder(ImageReference builder) { 		Assert.notNull(builder, "Builder must not be null"); 		return new BuildRequest(this.name, this.applicationContent, builder.inTaggedOrDigestForm(), this.runImage, 				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, 				this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache, 				this.launchCache, this.createdDate, this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withRunImage(ImageReference runImageName) { 		return new BuildRequest(this.name, this.applicationContent, this.builder, runImageName.inTaggedOrDigestForm(), 				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, 				this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache, 				this.launchCache, this.createdDate, this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withCreator(Creator creator) { 		Assert.notNull(creator, "Creator must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withEnv(String name, String value) { 		Assert.hasText(name, "Name must not be empty"); 		Assert.hasText(value, "Value must not be empty"); 		Map<String, String> env = new LinkedHashMap<>(this.env); 		env.put(name, value); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, 				Collections.unmodifiableMap(env), this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, 				this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache, 				this.launchCache, this.createdDate, this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withEnv(Map<String, String> env) { 		Assert.notNull(env, "Env must not be null"); 		Map<String, String> updatedEnv = new LinkedHashMap<>(this.env); 		updatedEnv.putAll(env); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, 				Collections.unmodifiableMap(updatedEnv), this.cleanCache, this.verboseLogging, this.pullPolicy, 				this.publish, this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace, 				this.buildCache, this.launchCache, this.createdDate, this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withCleanCache(boolean cleanCache) { 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withVerboseLogging(boolean verboseLogging) { 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withPullPolicy(PullPolicy pullPolicy) { 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withPublish(boolean publish) { 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withBuildpacks(List<BuildpackReference> buildpacks) { 		Assert.notNull(buildpacks, "Buildpacks must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withBindings(List<Binding> bindings) { 		Assert.notNull(bindings, "Bindings must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withNetwork(String network) { 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withTags(List<ImageReference> tags) { 		Assert.notNull(tags, "Tags must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withBuildWorkspace(Cache buildWorkspace) { 		Assert.notNull(buildWorkspace, "BuildWorkspace must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withBuildCache(Cache buildCache) { 		Assert.notNull(buildCache, "BuildCache must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withLaunchCache(Cache launchCache) { 		Assert.notNull(launchCache, "LaunchCache must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, launchCache, this.createdDate, 				this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withCreatedDate(String createdDate) { 		Assert.notNull(createdDate, "CreatedDate must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, 				parseCreatedDate(createdDate), this.applicationDirectory, this.securityOptions); 	}
public BuildRequest withApplicationDirectory(String applicationDirectory) { 		Assert.notNull(applicationDirectory, "ApplicationDirectory must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				applicationDirectory, this.securityOptions); 	}
private void configureDaemonAccess(Phase phase) { 		if (this.dockerHost != null) { 			if (this.dockerHost.isRemote()) { 				phase.withEnv("DOCKER_HOST", this.dockerHost.getAddress()); 				if (this.dockerHost.isSecure()) { 					phase.withEnv("DOCKER_TLS_VERIFY", "1"); 					phase.withEnv("DOCKER_CERT_PATH", this.dockerHost.getCertificatePath()); 				} 			} 			else { 				phase.withBinding(Binding.from(this.dockerHost.getAddress(), DOMAIN_SOCKET_PATH)); 			} 		} 		else { 			phase.withBinding(Binding.from(DOMAIN_SOCKET_PATH, DOMAIN_SOCKET_PATH)); 		} 		if (this.securityOptions != null) { 			this.securityOptions.forEach(phase::withSecurityOption); 		} 	}
private BuildRequest customize(BuildRequest request) { 		request = customizeBuilder(request); 		request = customizeRunImage(request); 		request = customizeEnvironment(request); 		request = customizeCreator(request); 		request = request.withCleanCache(getCleanCache().get()); 		request = request.withVerboseLogging(getVerboseLogging().get()); 		request = customizePullPolicy(request); 		request = customizePublish(request); 		request = customizeBuildpacks(request); 		request = customizeBindings(request); 		request = customizeTags(request); 		request = customizeCaches(request); 		request = request.withNetwork(getNetwork().getOrNull()); 		request = customizeCreatedDate(request); 		request = customizeApplicationDirectory(request); 		request = customizeSecurityOptions(request); 		return request; 	}
private BuildRequest customize(BuildRequest request) { 		if (StringUtils.hasText(this.builder)) { 			request = request.withBuilder(ImageReference.of(this.builder)); 		} 		if (StringUtils.hasText(this.runImage)) { 			request = request.withRunImage(ImageReference.of(this.runImage)); 		} 		if (this.env != null && !this.env.isEmpty()) { 			request = request.withEnv(this.env); 		} 		if (this.cleanCache != null) { 			request = request.withCleanCache(this.cleanCache); 		} 		request = request.withVerboseLogging(this.verboseLogging); 		if (this.pullPolicy != null) { 			request = request.withPullPolicy(this.pullPolicy); 		} 		if (this.publish != null) { 			request = request.withPublish(this.publish); 		} 		if (!CollectionUtils.isEmpty(this.buildpacks)) { 			request = request.withBuildpacks(this.buildpacks.stream().map(BuildpackReference::of).toList()); 		} 		if (!CollectionUtils.isEmpty(this.bindings)) { 			request = request.withBindings(this.bindings.stream().map(Binding::of).toList()); 		} 		request = request.withNetwork(this.network); 		if (!CollectionUtils.isEmpty(this.tags)) { 			request = request.withTags(this.tags.stream().map(ImageReference::of).toList()); 		} 		if (this.buildWorkspace != null) { 			request = request.withBuildWorkspace(this.buildWorkspace.asCache()); 		} 		if (this.buildCache != null) { 			request = request.withBuildCache(this.buildCache.asCache()); 		} 		if (this.launchCache != null) { 			request = request.withLaunchCache(this.launchCache.asCache()); 		} 		if (StringUtils.hasText(this.createdDate)) { 			request = request.withCreatedDate(this.createdDate); 		} 		if (StringUtils.hasText(this.applicationDirectory)) { 			request = request.withApplicationDirectory(this.applicationDirectory); 		} 		if (this.securityOptions != null) { 			request = request.withSecurityOptions(this.securityOptions); 		} 		return request; 	}
@Override 		public boolean supportsContext(Context context) { 			return true; 		}
@Override 		public boolean supportsContext(Context context) { 			return context instanceof CustomContext; 		}
@Override 		public boolean supportsContext(Context context) { 			return true; 		}
@Override 		public boolean supportsContext(Context context) { 			return true; 		}
@Override 				public boolean supportsContext(Context context) { 					return true; 				}
@Override 		public boolean supportsContext(Context context) { 			return context instanceof CustomContext; 		}
@Override 				public boolean supportsContext(Context context) { 					return true; 				}
@Override 		public boolean supportsContext(Context context) { 			return true; 		}
@Override 		public boolean supportsContext(Context context) { 			return true; 		}
@Override 		public boolean supportsContext(Context context) { 			return true; 		}
@Override 				public boolean supportsContext(Context context) { 					return true; 				}
@Override 		public boolean supportsContext(Context context) { 			return context instanceof CustomContext; 		}
@Override 				public boolean supportsContext(Context context) { 					return true; 				}
@Override 		public boolean supportsContext(Context context) { 			return context instanceof CustomContext; 		}
AuthorizationServerSettings asAuthorizationServerSettings() { 		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 		OAuth2AuthorizationServerProperties.Endpoint endpoint = this.properties.getEndpoint(); 		OAuth2AuthorizationServerProperties.OidcEndpoint oidc = endpoint.getOidc(); 		AuthorizationServerSettings.Builder builder = AuthorizationServerSettings.builder(); 		map.from(this.properties::getIssuer).to(builder::issuer); 		map.from(endpoint::getAuthorizationUri).to(builder::authorizationEndpoint); 		map.from(endpoint::getDeviceAuthorizationUri).to(builder::deviceAuthorizationEndpoint); 		map.from(endpoint::getDeviceVerificationUri).to(builder::deviceVerificationEndpoint); 		map.from(endpoint::getTokenUri).to(builder::tokenEndpoint); 		map.from(endpoint::getJwkSetUri).to(builder::jwkSetEndpoint); 		map.from(endpoint::getTokenRevocationUri).to(builder::tokenRevocationEndpoint); 		map.from(endpoint::getTokenIntrospectionUri).to(builder::tokenIntrospectionEndpoint); 		map.from(oidc::getLogoutUri).to(builder::oidcLogoutEndpoint); 		map.from(oidc::getClientRegistrationUri).to(builder::oidcClientRegistrationEndpoint); 		map.from(oidc::getUserInfoUri).to(builder::oidcUserInfoEndpoint); 		return builder.build(); 	}
private TokenSettings getTokenSettings(Client client, PropertyMapper map) { 		OAuth2AuthorizationServerProperties.Token token = client.getToken(); 		TokenSettings.Builder builder = TokenSettings.builder(); 		map.from(token::getAuthorizationCodeTimeToLive).to(builder::authorizationCodeTimeToLive); 		map.from(token::getAccessTokenTimeToLive).to(builder::accessTokenTimeToLive); 		map.from(token::getAccessTokenFormat).as(OAuth2TokenFormat::new).to(builder::accessTokenFormat); 		map.from(token::getDeviceCodeTimeToLive).to(builder::deviceCodeTimeToLive); 		map.from(token::isReuseRefreshTokens).to(builder::reuseRefreshTokens); 		map.from(token::getRefreshTokenTimeToLive).to(builder::refreshTokenTimeToLive); 		map.from(token::getIdTokenSignatureAlgorithm) 			.as(this::signatureAlgorithm) 			.to(builder::idTokenSignatureAlgorithm); 		return builder.build(); 	}
@Test 	void authorizationServerSettingsBeanShouldBeCreatedWhenPropertiesPresent() { 		this.contextRunner 			.withPropertyValues(PROPERTIES_PREFIX + ".issuer=https://example.com", 					PROPERTIES_PREFIX + ".endpoint.authorization-uri=/authorize", 					PROPERTIES_PREFIX + ".endpoint.device-authorization-uri=/device_authorization", 					PROPERTIES_PREFIX + ".endpoint.device-verification-uri=/device_verification", 					PROPERTIES_PREFIX + ".endpoint.token-uri=/token", PROPERTIES_PREFIX + ".endpoint.jwk-set-uri=/jwks", 					PROPERTIES_PREFIX + ".endpoint.token-revocation-uri=/revoke", 					PROPERTIES_PREFIX + ".endpoint.token-introspection-uri=/introspect", 					PROPERTIES_PREFIX + ".endpoint.oidc.logout-uri=/logout", 					PROPERTIES_PREFIX + ".endpoint.oidc.client-registration-uri=/register", 					PROPERTIES_PREFIX + ".endpoint.oidc.user-info-uri=/user") 			.run((context) -> { 				AuthorizationServerSettings settings = context.getBean(AuthorizationServerSettings.class); 				assertThat(settings.getIssuer()).isEqualTo("https://example.com"); 				assertThat(settings.getAuthorizationEndpoint()).isEqualTo("/authorize"); 				assertThat(settings.getDeviceAuthorizationEndpoint()).isEqualTo("/device_authorization"); 				assertThat(settings.getDeviceVerificationEndpoint()).isEqualTo("/device_verification"); 				assertThat(settings.getTokenEndpoint()).isEqualTo("/token"); 				assertThat(settings.getJwkSetEndpoint()).isEqualTo("/jwks"); 				assertThat(settings.getTokenRevocationEndpoint()).isEqualTo("/revoke"); 				assertThat(settings.getTokenIntrospectionEndpoint()).isEqualTo("/introspect"); 				assertThat(settings.getOidcLogoutEndpoint()).isEqualTo("/logout"); 				assertThat(settings.getOidcClientRegistrationEndpoint()).isEqualTo("/register"); 				assertThat(settings.getOidcUserInfoEndpoint()).isEqualTo("/user"); 			}); 	}
private OAuth2AuthorizationServerProperties.Client createClient() { 		OAuth2AuthorizationServerProperties.Client client = new OAuth2AuthorizationServerProperties.Client(); 		client.setRequireProofKey(true); 		client.setRequireAuthorizationConsent(true); 		client.setJwkSetUri("https://example.com/jwks"); 		client.setTokenEndpointAuthenticationSigningAlgorithm("rs256"); 		OAuth2AuthorizationServerProperties.Registration registration = client.getRegistration(); 		registration.setClientId("foo"); 		registration.setClientSecret("secret"); 		registration.getClientAuthenticationMethods().add("client_secret_basic"); 		registration.getAuthorizationGrantTypes().add("authorization_code"); 		registration.getRedirectUris().add("https://example.com/redirect"); 		registration.getPostLogoutRedirectUris().add("https://example.com/logout"); 		registration.getScopes().add("user.read"); 		OAuth2AuthorizationServerProperties.Token token = client.getToken(); 		token.setAccessTokenFormat("reference"); 		token.setAccessTokenTimeToLive(Duration.ofSeconds(300)); 		token.setRefreshTokenTimeToLive(Duration.ofHours(24)); 		token.setDeviceCodeTimeToLive(Duration.ofMinutes(30)); 		token.setReuseRefreshTokens(true); 		token.setIdTokenSignatureAlgorithm("rs512"); 		return client; 	}
@Test 	void getAuthorizationServerSettingsWhenValidParametersShouldAdapt() { 		this.properties.setIssuer("https://example.com"); 		OAuth2AuthorizationServerProperties.Endpoint endpoints = this.properties.getEndpoint(); 		endpoints.setAuthorizationUri("/authorize"); 		endpoints.setDeviceAuthorizationUri("/device_authorization"); 		endpoints.setDeviceVerificationUri("/device_verification"); 		endpoints.setTokenUri("/token"); 		endpoints.setJwkSetUri("/jwks"); 		endpoints.setTokenRevocationUri("/revoke"); 		endpoints.setTokenIntrospectionUri("/introspect"); 		OAuth2AuthorizationServerProperties.OidcEndpoint oidc = endpoints.getOidc(); 		oidc.setLogoutUri("/logout"); 		oidc.setClientRegistrationUri("/register"); 		oidc.setUserInfoUri("/user"); 		AuthorizationServerSettings settings = this.mapper.asAuthorizationServerSettings(); 		assertThat(settings.getIssuer()).isEqualTo("https://example.com"); 		assertThat(settings.getAuthorizationEndpoint()).isEqualTo("/authorize"); 		assertThat(settings.getDeviceAuthorizationEndpoint()).isEqualTo("/device_authorization"); 		assertThat(settings.getDeviceVerificationEndpoint()).isEqualTo("/device_verification"); 		assertThat(settings.getTokenEndpoint()).isEqualTo("/token"); 		assertThat(settings.getJwkSetEndpoint()).isEqualTo("/jwks"); 		assertThat(settings.getTokenRevocationEndpoint()).isEqualTo("/revoke"); 		assertThat(settings.getTokenIntrospectionEndpoint()).isEqualTo("/introspect"); 		assertThat(settings.getOidcLogoutEndpoint()).isEqualTo("/logout"); 		assertThat(settings.getOidcClientRegistrationEndpoint()).isEqualTo("/register"); 		assertThat(settings.getOidcUserInfoEndpoint()).isEqualTo("/user"); 	}
@Test 	void defaultFilterDispatcherTypes() { 		this.contextRunner.withConfiguration(AutoConfigurations.of(SecurityFilterAutoConfiguration.class)) 				.run((context) -> { 					DelegatingFilterProxyRegistrationBean bean = context.getBean("securityFilterChainRegistration", 							DelegatingFilterProxyRegistrationBean.class); 					assertThat(bean) 							.extracting("dispatcherTypes", InstanceOfAssertFactories.iterable(DispatcherType.class)) 							.containsOnly(DispatcherType.ASYNC, DispatcherType.ERROR, DispatcherType.REQUEST, 									DispatcherType.INCLUDE, DispatcherType.FORWARD); 				}); 	}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.csrf().disable(); 			http.authorizeHttpRequests((requests) -> { 				requests.dispatcherTypeMatchers(DispatcherType.FORWARD).permitAll(); 				requests.anyRequest().fullyAuthenticated(); 			}); 			http.httpBasic(); 			http.formLogin((form) -> form.loginPage("/login").permitAll()); 			http.exceptionHandling((exceptions) -> exceptions.accessDeniedPage("/access")); 			return http.build(); 		}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.csrf().disable(); 			http.authorizeHttpRequests((requests) -> { 				requests.dispatcherTypeMatchers(DispatcherType.FORWARD).permitAll(); 				requests.anyRequest().fullyAuthenticated(); 			}); 			http.formLogin((form) -> form.loginPage("/login").permitAll()); 			return http.build(); 		}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.csrf().disable(); 			http.authorizeHttpRequests((requests) -> { 				requests.dispatcherTypeMatchers(DispatcherType.FORWARD).permitAll(); 				requests.anyRequest().fullyAuthenticated(); 			}); 			http.formLogin((form) -> form.loginPage("/login").permitAll()); 			return http.build(); 		}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.csrf().disable(); 			http.authorizeHttpRequests((requests) -> { 				requests.requestMatchers("/public/**").permitAll(); 				requests.dispatcherTypeMatchers(DispatcherType.FORWARD).permitAll(); 				requests.anyRequest().fullyAuthenticated(); 			}); 			http.httpBasic(); 			http.formLogin((form) -> form.loginPage("/login").permitAll()); 			return http.build(); 		}
@Test 	void testFilterOrdering() { 		load(); 		List<RegisteredFilter> registeredFilters = this.context.getBean(MockServletWebServerFactory.class) 				.getWebServer().getRegisteredFilters(); 		List<Filter> filters = new ArrayList<>(registeredFilters.size()); 		for (RegisteredFilter registeredFilter : registeredFilters) { 			filters.add(registeredFilter.getFilter()); 		} 		Iterator<Filter> iterator = filters.iterator(); 		assertThat(iterator.next()).isInstanceOf(OrderedCharacterEncodingFilter.class); 		assertThat(iterator.next()).isInstanceOf(SessionRepositoryFilter.class); 		assertThat(iterator.next()).isInstanceOf(Filter.class); 		assertThat(iterator.next()).isInstanceOf(Filter.class); 		assertThat(iterator.next()).isInstanceOf(OrderedRequestContextFilter.class); 		assertThat(iterator.next()).isInstanceOf(FilterChainProxy.class); 	}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.authorizeHttpRequests((requests) -> { 				requests.antMatchers("/custom/servlet/path/public/**").permitAll(); 				requests.anyRequest().fullyAuthenticated(); 			}); 			http.httpBasic(); 			http.formLogin((form) -> form.loginPage("/custom/servlet/path/login").permitAll()); 			return http.build(); 		}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.authorizeHttpRequests((requests) -> { 				requests.antMatchers("/public/**").permitAll(); 				requests.anyRequest().fullyAuthenticated(); 			}); 			http.httpBasic(); 			http.formLogin((form) -> form.loginPage("/login").permitAll()); 			return http.build(); 		}
@Bean 		SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { 			http.sessionManagement((session) -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) 					.authorizeHttpRequests((requests) -> { 						requests.antMatchers("/public/**").permitAll(); 						requests.anyRequest().authenticated(); 					}); 			http.httpBasic(); 			return http.build(); 		}
private void configureDaemonAccess(Phase phase) { 		if (this.dockerHost != null) { 			if (this.dockerHost.isRemote()) { 				phase.withEnv("DOCKER_HOST", this.dockerHost.getAddress()); 				if (this.dockerHost.isSecure()) { 					phase.withEnv("DOCKER_TLS_VERIFY", "1"); 					phase.withEnv("DOCKER_CERT_PATH", this.dockerHost.getCertificatePath()); 				} 			} 			else { 				phase.withBinding(Binding.from(this.dockerHost.getAddress(), DOMAIN_SOCKET_PATH)); 			} 		} 		else { 			phase.withBinding(Binding.from(DOMAIN_SOCKET_PATH, DOMAIN_SOCKET_PATH)); 		} 		if (!Platform.isWindows()) { 			phase.withSecurityOption("label=disable"); 		} 	}
void apply(ContainerConfig.Update update) { 		if (this.daemonAccess) { 			update.withUser("root"); 		} 		update.withCommand("/cnb/lifecycle/" + this.name, StringUtils.toStringArray(this.args)); 		update.withLabel("author", "spring-boot"); 		this.bindings.forEach(update::withBinding); 		this.env.forEach(update::withEnv); 		if (this.networkMode != null) { 			update.withNetworkMode(this.networkMode); 		} 		this.securityOptions.forEach(update::withSecurityOption); 	}
private ContainerConfig run(Consumer<Update> update) { 			update.accept(this); 			try { 				return new ContainerConfig(this.user, this.image, this.command, this.args, this.labels, this.bindings, 						this.env, this.networkMode, this.securityOptions); 			} 			catch (IOException ex) { 				throw new IllegalStateException(ex); 			} 		}
@Test 	void writeToWritesJson() throws Exception { 		ImageReference imageReference = ImageReference.of("ubuntu:bionic"); 		ContainerConfig containerConfig = ContainerConfig.of(imageReference, (update) -> { 			update.withUser("root"); 			update.withCommand("ls", "-l"); 			update.withArgs("-h"); 			update.withLabel("spring", "boot"); 			update.withBinding(Binding.from("bind-source", "bind-dest")); 			update.withEnv("name1", "value1"); 			update.withEnv("name2", "value2"); 			update.withNetworkMode("test"); 			update.withSecurityOption("option=value"); 		}); 		ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); 		containerConfig.writeTo(outputStream); 		String actualJson = new String(outputStream.toByteArray(), StandardCharsets.UTF_8); 		String expectedJson = StreamUtils.copyToString(getContent("container-config.json"), StandardCharsets.UTF_8); 		JSONAssert.assertEquals(expectedJson, actualJson, true); 	}
@Bean 	SecurityFilterChain configure(HttpSecurity http) throws Exception { 		http.authorizeRequests((requests) -> { 			requests.mvcMatchers("/actuator/beans").hasRole("BEANS"); 			requests.requestMatchers(EndpointRequest.to("health")).permitAll(); 			requests.requestMatchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)) 					.hasRole("ACTUATOR"); 			requests.requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll(); 			requests.antMatchers("/foo").permitAll(); 			requests.antMatchers("/error").permitAll(); 			requests.antMatchers("/**").hasRole("USER"); 		}); 		http.cors(Customizer.withDefaults()); 		http.httpBasic(); 		return http.build(); 	}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.csrf().disable(); 			http.authorizeRequests((requests) -> requests.anyRequest().fullyAuthenticated() 					.filterSecurityInterceptorOncePerRequest(true)); 			http.formLogin((form) -> form.loginPage("/login").permitAll()); 			http.exceptionHandling((exceptions) -> exceptions.accessDeniedPage("/access")); 			return http.build(); 		}
@Bean 		SecurityFilterChain actuatorSecurity(HttpSecurity http) throws Exception { 			http.csrf().disable(); 			http.requestMatcher(EndpointRequest.toAnyEndpoint()); 			http.authorizeRequests( 					(requests) -> requests.anyRequest().authenticated().filterSecurityInterceptorOncePerRequest(true)); 			http.httpBasic(); 			return http.build(); 		}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.authorizeRequests((requests) -> { 				requests.antMatchers("/custom/servlet/path/public/**").permitAll(); 				requests.anyRequest().fullyAuthenticated(); 				requests.filterSecurityInterceptorOncePerRequest(true); 			}); 			http.httpBasic(); 			http.formLogin((form) -> form.loginPage("/custom/servlet/path/login").permitAll()); 			return http.build(); 		}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.authorizeRequests((requests) -> { 				requests.antMatchers("/public/**").permitAll(); 				requests.anyRequest().fullyAuthenticated(); 				requests.filterSecurityInterceptorOncePerRequest(true); 			}); 			http.httpBasic(); 			http.formLogin((form) -> form.loginPage("/login").permitAll()); 			return http.build(); 		}
@Bean 		SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { 			http.sessionManagement((session) -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) 					.authorizeRequests((requests) -> { 						requests.antMatchers("/public/**").permitAll(); 						requests.anyRequest().authenticated(); 						requests.filterSecurityInterceptorOncePerRequest(true); 					}); 			http.httpBasic(); 			return http.build(); 		}
@Bean 		FilterRegistrationBean<OrderedCharacterEncodingFilter> filterRegistration() { 			return new FilterRegistrationBean<>(new OrderedCharacterEncodingFilter()); 		}
@Bean 		FilterRegistrationBean<ResourceUrlEncodingFilter> filterRegistration() { 			FilterRegistrationBean<ResourceUrlEncodingFilter> bean = new FilterRegistrationBean<>( 					new ResourceUrlEncodingFilter()); 			bean.setDispatcherTypes(EnumSet.of(DispatcherType.INCLUDE)); 			return bean; 		}
@Test 	void backOffIfSaml2RelyingPartyAutoConfigurationPresent() { 		this.contextRunner.withConfiguration(AutoConfigurations.of(Saml2RelyingPartyAutoConfiguration.class)) 				.withPropertyValues( 						"spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.single-sign-on.url=https://simplesaml-for-spring-saml/SSOService.php", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.single-sign-on.sign-request=false", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.verification.credentials[0].certificate-location=classpath:saml/certificate-location") 				.run((context) -> assertThat(context).doesNotHaveBean(ManagementWebSecurityAutoConfiguration.class) 						.doesNotHaveBean(MANAGEMENT_SECURITY_FILTER_CHAIN_BEAN)); 	}
public List<Credential> getCredentials() { 			return this.credentials; 		}
public void setCredentials(List<Credential> credentials) { 			this.credentials = credentials; 		}
public Resource getPrivateKeyLocation() { 				return this.privateKeyLocation; 			}
public void setPrivateKeyLocation(Resource privateKey) { 				this.privateKeyLocation = privateKey; 			}
public Resource getCertificateLocation() { 				return this.certificateLocation; 			}
public Resource getCertificateLocation() { 					return this.certificate; 				}
public void setCertificateLocation(Resource certificate) { 				this.certificateLocation = certificate; 			}
public void setCertificateLocation(Resource certificate) { 					this.certificate = certificate; 				}
public List<Credential> getCredentials() { 				return this.credentials; 			}
public List<Credential> getCredentials() { 				return this.credentials; 			}
public void setCredentials(List<Credential> credentials) { 				this.credentials = credentials; 			}
public void setCredentials(List<Credential> credentials) { 				this.credentials = credentials; 			}
public Resource getPrivateKeyLocation() { 					return this.privateKeyLocation; 				}
public void setPrivateKeyLocation(Resource privateKey) { 					this.privateKeyLocation = privateKey; 				}
public Resource getCertificateLocation() { 					return this.certificateLocation; 				}
public Resource getCertificateLocation() { 					return this.certificate; 				}
public void setCertificateLocation(Resource certificate) { 					this.certificateLocation = certificate; 				}
public void setCertificateLocation(Resource certificate) { 					this.certificate = certificate; 				}
public List<Credential> getCredentials() { 			return this.credentials; 		}
public void setCredentials(List<Credential> credentials) { 			this.credentials = credentials; 		}
public Resource getCertificateLocation() { 					return this.certificateLocation; 				}
public Resource getCertificateLocation() { 				return this.certificateLocation; 			}
public void setCertificateLocation(Resource certificate) { 					this.certificateLocation = certificate; 				}
public void setCertificateLocation(Resource certificate) { 				this.certificateLocation = certificate; 			}
@SuppressWarnings("deprecation") 		private <T> T get(String name, Function<AssertingParty, T> getter) { 			T newValue = getter.apply(this.registration.getAssertingparty()); 			if (newValue != null) { 				return newValue; 			} 			T deprecatedValue = getter.apply(this.registration.getIdentityprovider()); 			if (deprecatedValue != null) { 				logger.warn(LogMessage.format( 						"Property 'spring.security.saml2.relyingparty.registration.identityprovider.%1$s.%2$s' is deprecated, " 								+ "please use 'spring.security.saml2.relyingparty.registration.assertingparty.%1$s.%2$s' instead", 						this.id, name)); 				return deprecatedValue; 			} 			return newValue; 		}
@Test 	void autoconfigurationShouldQueryAssertingPartyMetadataWhenMetadataUrlIsPresent() throws Exception { 		try (MockWebServer server = new MockWebServer()) { 			server.start(); 			String metadataUrl = server.url("").toString(); 			setupMockResponse(server, new ClassPathResource("saml/idp-metadata")); 			this.contextRunner.withPropertyValues(PREFIX + ".foo.assertingparty.metadata-uri=" + metadataUrl) 					.run((context) -> { 						assertThat(context).hasSingleBean(RelyingPartyRegistrationRepository.class); 						assertThat(server.getRequestCount()).isEqualTo(1); 					}); 		} 	}
@Test 	void autoconfigurationShouldUseBindingFromMetadataUrlIfPresent() throws Exception { 		try (MockWebServer server = new MockWebServer()) { 			server.start(); 			String metadataUrl = server.url("").toString(); 			setupMockResponse(server, new ClassPathResource("saml/idp-metadata")); 			this.contextRunner.withPropertyValues(PREFIX + ".foo.assertingparty.metadata-uri=" + metadataUrl) 					.run((context) -> { 						RelyingPartyRegistrationRepository repository = context 								.getBean(RelyingPartyRegistrationRepository.class); 						RelyingPartyRegistration registration = repository.findByRegistrationId("foo"); 						assertThat(registration.getAssertingPartyDetails().getSingleSignOnServiceBinding()) 								.isEqualTo(Saml2MessageBinding.POST); 					}); 		} 	}
@Test 	void autoconfigurationWhenMetadataUrlAndPropertyPresentShouldUseBindingFromProperty() throws Exception { 		try (MockWebServer server = new MockWebServer()) { 			server.start(); 			String metadataUrl = server.url("").toString(); 			setupMockResponse(server, new ClassPathResource("saml/idp-metadata")); 			this.contextRunner.withPropertyValues(PREFIX + ".foo.assertingparty.metadata-uri=" + metadataUrl, 					PREFIX + ".foo.assertingparty.singlesignon.binding=redirect").run((context) -> { 						RelyingPartyRegistrationRepository repository = context 								.getBean(RelyingPartyRegistrationRepository.class); 						RelyingPartyRegistration registration = repository.findByRegistrationId("foo"); 						assertThat(registration.getAssertingPartyDetails().getSingleSignOnServiceBinding()) 								.isEqualTo(Saml2MessageBinding.REDIRECT); 					}); 		} 	}
private String[] getPropertyValuesWithoutSigningCredentials(boolean signRequests, boolean useDeprecated) { 		String assertingParty = useDeprecated ? "identityprovider" : "assertingparty"; 		return new String[] { 				PREFIX + ".foo." + assertingParty 						+ ".singlesignon.url=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php", 				PREFIX + ".foo." + assertingParty + ".singlesignon.binding=post", 				PREFIX + ".foo." + assertingParty + ".singlesignon.sign-request=" + signRequests, 				PREFIX + ".foo." + assertingParty 						+ ".entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php", 				PREFIX + ".foo." + assertingParty 						+ ".verification.credentials[0].certificate-location=classpath:saml/certificate-location" }; 	}
private String[] getPropertyValuesWithoutSsoBinding(boolean useDeprecated) { 		String assertingParty = useDeprecated ? "identityprovider" : "assertingparty"; 		return new String[] { 				PREFIX + ".foo." + assertingParty 						+ ".singlesignon.url=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php", 				PREFIX + ".foo." + assertingParty + ".singlesignon.sign-request=false", 				PREFIX + ".foo." + assertingParty 						+ ".entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php", 				PREFIX + ".foo." + assertingParty 						+ ".verification.credentials[0].certificate-location=classpath:saml/certificate-location" }; 	}
private String[] getPropertyValues(boolean useDeprecated) { 		String assertingParty = useDeprecated ? "identityprovider" : "assertingparty"; 		return new String[] { 				PREFIX + ".foo.signing.credentials[0].private-key-location=classpath:saml/private-key-location", 				PREFIX + ".foo.signing.credentials[0].certificate-location=classpath:saml/certificate-location", 				PREFIX + ".foo.decryption.credentials[0].private-key-location=classpath:saml/private-key-location", 				PREFIX + ".foo.decryption.credentials[0].certificate-location=classpath:saml/certificate-location", 				PREFIX + ".foo." + assertingParty 						+ ".singlesignon.url=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php", 				PREFIX + ".foo." + assertingParty + ".singlesignon.binding=post", 				PREFIX + ".foo." + assertingParty + ".singlesignon.sign-request=false", 				PREFIX + ".foo." + assertingParty 						+ ".entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php", 				PREFIX + ".foo." + assertingParty 						+ ".verification.credentials[0].certificate-location=classpath:saml/certificate-location", 				PREFIX + ".foo.entity-id={baseUrl}/saml2/foo-entity-id", 				PREFIX + ".foo.acs.location={baseUrl}/login/saml2/foo-entity-id", 				PREFIX + ".foo.acs.binding=redirect" }; 	}
@Test 	void customizeSsoUrl() { 		bind("spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.single-sign-on.url", 				"https://simplesaml-for-spring-saml/SSOService.php"); 		assertThat( 				this.properties.getRegistration().get("simplesamlphp").getAssertingparty().getSinglesignon().getUrl()) 						.isEqualTo("https://simplesaml-for-spring-saml/SSOService.php"); 	}
@Test 	void customizeSsoBinding() { 		bind("spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.single-sign-on.binding", 				"post"); 		assertThat(this.properties.getRegistration().get("simplesamlphp").getAssertingparty().getSinglesignon() 				.getBinding()).isEqualTo(Saml2MessageBinding.POST); 	}
@Test 	void customizeSsoSignRequests() { 		bind("spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.single-sign-on.sign-request", 				"false"); 		assertThat(this.properties.getRegistration().get("simplesamlphp").getAssertingparty().getSinglesignon() 				.getSignRequest()).isEqualTo(false); 	}
@Test 	void customizeAssertingPartyMetadataUri() { 		bind("spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.metadata-uri", 				"https://idp.example.org/metadata"); 		assertThat(this.properties.getRegistration().get("simplesamlphp").getAssertingparty().getMetadataUri()) 				.isEqualTo("https://idp.example.org/metadata"); 	}
@Test 	void backOffIfSaml2RelyingPartyAutoConfigurationPresent() { 		this.contextRunner.withConfiguration(AutoConfigurations.of(Saml2RelyingPartyAutoConfiguration.class)) 				.withPropertyValues( 						"spring.security.saml2.relyingparty.registration.simplesamlphp.asserting-party.single-sign-on.url=https://simplesaml-for-spring-saml/SSOService.php", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.asserting-party.single-sign-on.sign-request=false", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.asserting-party.entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.asserting-party.verification.credentials[0].certificate-location=classpath:saml/certificate-location") 				.run((context) -> assertThat(context).doesNotHaveBean(ManagementWebSecurityAutoConfiguration.class) 						.doesNotHaveBean(MANAGEMENT_SECURITY_FILTER_CHAIN_BEAN)); 	}
public List<Credential> getCredentials() { 			return this.credentials; 		}
public void setCredentials(List<Credential> credentials) { 			this.credentials = credentials; 		}
public Resource getPrivateKeyLocation() { 				return this.privateKeyLocation; 			}
public void setPrivateKeyLocation(Resource privateKey) { 				this.privateKeyLocation = privateKey; 			}
public Resource getCertificateLocation() { 				return this.certificateLocation; 			}
public Resource getCertificateLocation() { 					return this.certificate; 				}
public void setCertificateLocation(Resource certificate) { 				this.certificateLocation = certificate; 			}
public void setCertificateLocation(Resource certificate) { 					this.certificate = certificate; 				}
public List<Credential> getCredentials() { 				return this.credentials; 			}
public List<Credential> getCredentials() { 				return this.credentials; 			}
public void setCredentials(List<Credential> credentials) { 				this.credentials = credentials; 			}
public void setCredentials(List<Credential> credentials) { 				this.credentials = credentials; 			}
public Resource getPrivateKeyLocation() { 					return this.privateKeyLocation; 				}
public void setPrivateKeyLocation(Resource privateKey) { 					this.privateKeyLocation = privateKey; 				}
public Resource getCertificateLocation() { 					return this.certificateLocation; 				}
public Resource getCertificateLocation() { 					return this.certificate; 				}
public void setCertificateLocation(Resource certificate) { 					this.certificateLocation = certificate; 				}
public void setCertificateLocation(Resource certificate) { 					this.certificate = certificate; 				}
public List<Credential> getCredentials() { 			return this.credentials; 		}
public void setCredentials(List<Credential> credentials) { 			this.credentials = credentials; 		}
public Resource getCertificateLocation() { 					return this.certificateLocation; 				}
public Resource getCertificateLocation() { 				return this.certificateLocation; 			}
public void setCertificateLocation(Resource certificate) { 					this.certificateLocation = certificate; 				}
public void setCertificateLocation(Resource certificate) { 				this.certificateLocation = certificate; 			}
private RelyingPartyRegistration asRegistration(String id, Registration properties) { 		boolean usingMetadata = StringUtils 				.hasText(getFromAssertingParty(properties, id, "metadata-uri", AssertingParty::getMetadataUri)); 		Builder builder = (usingMetadata) ? RelyingPartyRegistrations 				.fromMetadataLocation( 						getFromAssertingParty(properties, id, "metadata-uri", AssertingParty::getMetadataUri)) 				.registrationId(id) : RelyingPartyRegistration.withRegistrationId(id); 		builder.assertionConsumerServiceLocation(properties.getAcs().getLocation()); 		builder.assertionConsumerServiceBinding(properties.getAcs().getBinding()); 		builder.assertingPartyDetails(mapAssertingParty(properties, id, usingMetadata)); 		builder.signingX509Credentials((credentials) -> properties.getSigning().getCredentials().stream() 				.map(this::asSigningCredential).forEach(credentials::add)); 		builder.decryptionX509Credentials((credentials) -> properties.getDecryption().getCredentials().stream() 				.map(this::asDecryptionCredential).forEach(credentials::add)); 		builder.assertingPartyDetails((details) -> details.verificationX509Credentials( 				(credentials) -> getFromAssertingParty(properties, id, "verification", AssertingParty::getVerification) 						.getCredentials().stream().map(this::asVerificationCredential).forEach(credentials::add))); 		builder.entityId(properties.getEntityId()); 		RelyingPartyRegistration registration = builder.build(); 		boolean signRequest = registration.getAssertingPartyDetails().getWantAuthnRequestsSigned(); 		validateSigningCredentials(properties, signRequest); 		return registration; 	}
@Test 	void autoConfigurationShouldBeConditionalOnRelyingPartyRegistrationRepositoryClass() { 		this.contextRunner.withPropertyValues(getPropertyValues(false)).withClassLoader(new FilteredClassLoader( 				"org.springframework.security.saml2.provider.service.registration.RelyingPartyRegistrationRepository")) 				.run((context) -> assertThat(context).doesNotHaveBean(RelyingPartyRegistrationRepository.class)); 	}
@Test 	void autoConfigurationShouldBeConditionalOnServletWebApplication() { 		new ApplicationContextRunner() 				.withConfiguration(AutoConfigurations.of(Saml2RelyingPartyAutoConfiguration.class)) 				.withPropertyValues(getPropertyValues(false)) 				.run((context) -> assertThat(context).doesNotHaveBean(RelyingPartyRegistrationRepository.class)); 	}
@Test 	void relyingPartyRegistrationRepositoryBeanShouldBeCreatedWhenPropertiesPresent() { 		this.contextRunner.withPropertyValues(getPropertyValues(false)).run((context) -> { 			RelyingPartyRegistrationRepository repository = context.getBean(RelyingPartyRegistrationRepository.class); 			RelyingPartyRegistration registration = repository.findByRegistrationId("foo");  			assertThat(registration.getAssertingPartyDetails().getSingleSignOnServiceLocation()) 					.isEqualTo("https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php"); 			assertThat(registration.getAssertingPartyDetails().getEntityId()) 					.isEqualTo("https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php"); 			assertThat(registration.getAssertionConsumerServiceLocation()) 					.isEqualTo("{baseUrl}/login/saml2/foo-entity-id"); 			assertThat(registration.getAssertionConsumerServiceBinding()).isEqualTo(Saml2MessageBinding.REDIRECT); 			assertThat(registration.getAssertingPartyDetails().getSingleSignOnServiceBinding()) 					.isEqualTo(Saml2MessageBinding.POST); 			assertThat(registration.getAssertingPartyDetails().getWantAuthnRequestsSigned()).isEqualTo(false); 			assertThat(registration.getSigningX509Credentials()).hasSize(1); 			assertThat(registration.getDecryptionX509Credentials()).hasSize(1); 			assertThat(registration.getAssertingPartyDetails().getVerificationX509Credentials()).isNotNull(); 			assertThat(registration.getEntityId()).isEqualTo("{baseUrl}/saml2/foo-entity-id"); 		}); 	}
@Test 	void autoConfigurationWhenSignRequestsTrueAndNoSigningCredentialsShouldThrowException() { 		this.contextRunner.withPropertyValues(getPropertyValuesWithoutSigningCredentials(true, false)) 				.run((context) -> { 					assertThat(context).hasFailed(); 					assertThat(context.getStartupFailure()).hasMessageContaining( 							"Signing credentials must not be empty when authentication requests require signing."); 				}); 	}
@Test 	void autoConfigurationWhenSignRequestsFalseAndNoSigningCredentialsShouldNotThrowException() { 		this.contextRunner.withPropertyValues(getPropertyValuesWithoutSigningCredentials(false, false)) 				.run((context) -> assertThat(context).hasSingleBean(RelyingPartyRegistrationRepository.class)); 	}
@Test 	void autoconfigurationShouldUseBindingFromMetadataUrlIfPresent() throws Exception { 		try (MockWebServer server = new MockWebServer()) { 			server.start(); 			String metadataUrl = server.url("").toString(); 			setupMockResponse(server, new ClassPathResource("saml/idp-metadata")); 			this.contextRunner.withPropertyValues(PREFIX + ".foo.asserting-party.metadata-uri=" + metadataUrl) 					.run((context) -> { 						RelyingPartyRegistrationRepository repository = context 								.getBean(RelyingPartyRegistrationRepository.class); 						RelyingPartyRegistration registration = repository.findByRegistrationId("foo"); 						assertThat(registration.getAssertingPartyDetails().getSingleSignOnServiceBinding()) 								.isEqualTo(Saml2MessageBinding.POST); 					}); 		} 	}
@Test 	void autoconfigurationWhenMetadataUrlAndPropertyPresentShouldUseBindingFromProperty() throws Exception { 		try (MockWebServer server = new MockWebServer()) { 			server.start(); 			String metadataUrl = server.url("").toString(); 			setupMockResponse(server, new ClassPathResource("saml/idp-metadata")); 			this.contextRunner.withPropertyValues(PREFIX + ".foo.asserting-party.metadata-uri=" + metadataUrl, 					PREFIX + ".foo.asserting-party.singlesignon.binding=redirect").run((context) -> { 						RelyingPartyRegistrationRepository repository = context 								.getBean(RelyingPartyRegistrationRepository.class); 						RelyingPartyRegistration registration = repository.findByRegistrationId("foo"); 						assertThat(registration.getAssertingPartyDetails().getSingleSignOnServiceBinding()) 								.isEqualTo(Saml2MessageBinding.REDIRECT); 					}); 		} 	}
@Test 	void autoconfigurationWhenNoMetadataUrlOrPropertyPresentShouldUseRedirectBinding() { 		this.contextRunner.withPropertyValues(getPropertyValuesWithoutSsoBinding(false)).run((context) -> { 			RelyingPartyRegistrationRepository repository = context.getBean(RelyingPartyRegistrationRepository.class); 			RelyingPartyRegistration registration = repository.findByRegistrationId("foo"); 			assertThat(registration.getAssertingPartyDetails().getSingleSignOnServiceBinding()) 					.isEqualTo(Saml2MessageBinding.REDIRECT); 		}); 	}
@Test 	void relyingPartyRegistrationRepositoryShouldBeConditionalOnMissingBean() { 		this.contextRunner.withPropertyValues(getPropertyValues(false)) 				.withUserConfiguration(RegistrationRepositoryConfiguration.class).run((context) -> { 					assertThat(context).hasSingleBean(RelyingPartyRegistrationRepository.class); 					assertThat(context).hasBean("testRegistrationRepository"); 				}); 	}
@Test 	void samlLoginShouldBeConfigured() { 		this.contextRunner.withPropertyValues(getPropertyValues(false)) 				.run((context) -> assertThat(hasFilter(context, Saml2WebSsoAuthenticationFilter.class)).isTrue()); 	}
@Test 	void samlLoginShouldBackOffWhenAWebSecurityConfigurerAdapterIsDefined() { 		this.contextRunner.withUserConfiguration(WebSecurityConfigurerAdapterConfiguration.class) 				.withPropertyValues(getPropertyValues(false)) 				.run((context) -> assertThat(hasFilter(context, Saml2WebSsoAuthenticationFilter.class)).isFalse()); 	}
@Test 	void samlLoginShouldBackOffWhenASecurityFilterChainBeanIsPresent() { 		this.contextRunner.withUserConfiguration(TestSecurityFilterChainConfig.class) 				.withPropertyValues(getPropertyValues(false)) 				.run((context) -> assertThat(hasFilter(context, Saml2WebSsoAuthenticationFilter.class)).isFalse()); 	}
@Test 	void samlLoginShouldShouldBeConditionalOnSecurityWebFilterClass() { 		this.contextRunner.withClassLoader(new FilteredClassLoader(SecurityFilterChain.class)) 				.withPropertyValues(getPropertyValues(false)) 				.run((context) -> assertThat(context).doesNotHaveBean(SecurityFilterChain.class)); 	}
@Test 	void customizeSsoUrl() { 		bind("spring.security.saml2.relyingparty.registration.simplesamlphp.asserting-party.single-sign-on.url", 				"https://simplesaml-for-spring-saml/SSOService.php"); 		assertThat( 				this.properties.getRegistration().get("simplesamlphp").getAssertingParty().getSinglesignon().getUrl()) 						.isEqualTo("https://simplesaml-for-spring-saml/SSOService.php"); 	}
@Test 	void customizeSsoBinding() { 		bind("spring.security.saml2.relyingparty.registration.simplesamlphp.asserting-party.single-sign-on.binding", 				"post"); 		assertThat(this.properties.getRegistration().get("simplesamlphp").getAssertingParty().getSinglesignon() 				.getBinding()).isEqualTo(Saml2MessageBinding.POST); 	}
@Test 	void customizeSsoSignRequests() { 		bind("spring.security.saml2.relyingparty.registration.simplesamlphp.asserting-party.single-sign-on.sign-request", 				"false"); 		assertThat(this.properties.getRegistration().get("simplesamlphp").getAssertingParty().getSinglesignon() 				.getSignRequest()).isEqualTo(false); 	}
private boolean isAllowed(HttpServletRequest request, Integer errorCode) { 		Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); 		if (isUnauthenticated(authentication) && isNotAuthenticationError(errorCode)) { 			return true; 		} 		return getPrivilegeEvaluator().isAllowed(this.urlPathHelper.getPathWithinApplication(request), authentication); 	}
@Test 	void testNoCredentials() { 		final ResponseEntity<JsonNode> response = this.testRestTemplate.exchange(this.pathPrefix + "/test", 				HttpMethod.GET, null, JsonNode.class); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED); 		JsonNode jsonResponse = response.getBody(); 		assertThat(jsonResponse).isNull(); 	}
@Test 	void testPublicNotFoundPage() { 		final ResponseEntity<JsonNode> response = this.testRestTemplate.exchange(this.pathPrefix + "/public/notfound", 				HttpMethod.GET, null, JsonNode.class); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND); 		JsonNode jsonResponse = response.getBody(); 		assertThat(jsonResponse.get("error").asText()).isEqualTo("Not Found"); 	}
@Test 	void testPublicNotFoundPageWithCorrectCredentials() { 		final ResponseEntity<JsonNode> response = this.testRestTemplate.withBasicAuth("username", "password") 				.exchange(this.pathPrefix + "/public/notfound", HttpMethod.GET, null, JsonNode.class); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND); 		JsonNode jsonResponse = response.getBody(); 		assertThat(jsonResponse.get("error").asText()).isEqualTo("Not Found"); 	}
@Test 	void testPublicNotFoundPageWithBadCredentials() { 		final ResponseEntity<JsonNode> response = this.testRestTemplate.withBasicAuth("username", "wrong") 				.exchange(this.pathPrefix + "/public/notfound", HttpMethod.GET, null, JsonNode.class); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED); 		JsonNode jsonResponse = response.getBody(); 		assertThat(jsonResponse).isNull(); 	}
@Test 	void testCorrectCredentialsWithControllerException() { 		final ResponseEntity<JsonNode> response = this.testRestTemplate.withBasicAuth("username", "password") 				.exchange(this.pathPrefix + "/fail", HttpMethod.GET, null, JsonNode.class); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 		JsonNode jsonResponse = response.getBody(); 		assertThat(jsonResponse.get("error").asText()).isEqualTo("Internal Server Error"); 	}
@Test 	void testCorrectCredentials() { 		final ResponseEntity<String> response = this.testRestTemplate.withBasicAuth("username", "password") 				.exchange(this.pathPrefix + "/test", HttpMethod.GET, null, String.class); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK); 		response.getBody(); 		assertThat(response.getBody()).isEqualTo("test"); 	}
@Override 	public void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) 			throws IOException, ServletException { 		if (DispatcherType.ERROR.equals(request.getDispatcherType())) { 			Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); 			if (!getPrivilegeEvaluator().isAllowed(request.getRequestURI(), authentication)) { 				sendError(request, response); 				return; 			} 		} 		chain.doFilter(request, response); 	}
@BeforeEach 	void setup() { 		this.request.setDispatcherType(DispatcherType.ERROR); 		given(this.context.getBean(WebInvocationPrivilegeEvaluator.class)).willReturn(this.privilegeEvaluator); 		this.securityFilter = new ErrorPageSecurityFilter(this.context); 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		http.authorizeRequests((requests) -> { 			requests.requestMatchers(EndpointRequest.to(HealthEndpoint.class, InfoEndpoint.class)).permitAll(); 			requests.anyRequest().authenticated(); 		}); 		if (ClassUtils.isPresent("org.springframework.web.servlet.DispatcherServlet", null)) { 			http.cors(); 		} 		http.formLogin(Customizer.withDefaults()); 		http.httpBasic(Customizer.withDefaults()); 	}
protected void testJerseyEndpoints(Class<?>[] userConfigurations) { 		getContextRunner(userConfigurations, getAutoconfigurations()).run((context) -> { 			int port = context.getSourceApplicationContext(AnnotationConfigServletWebServerApplicationContext.class) 					.getWebServer().getPort(); 			WebTestClient client = WebTestClient.bindToServer().baseUrl("http://localhost:" + port).build(); 			client.get().uri("/actuator").exchange().expectStatus().isOk().expectBody().jsonPath("_links.beans") 					.isNotEmpty().jsonPath("_links.restcontroller").doesNotExist().jsonPath("_links.controller") 					.doesNotExist(); 		}); 	}
@Test 	void backsOffIfSecurityFilterChainBeanIsPresent() { 		this.contextRunner.withUserConfiguration(TestSecurityFilterChainConfig.class).run((context) -> { 			assertThat(context.getBeansOfType(SecurityFilterChain.class)).isNotEmpty(); 			assertThat(context.containsBean("testSecurityFilterChain")).isTrue(); 		}); 	}
private void configureTestConventions(Project project) { 		project.getTasks().withType(Test.class, (test) -> { 			withOptionalBuildJavaHome(project, (javaHome) -> test.setExecutable(javaHome + "/bin/java")); 			test.useJUnitPlatform(); 			test.setMaxHeapSize("1024M"); 			CopyJdk8156584SecurityProperties copyJdk8156584SecurityProperties = new CopyJdk8156584SecurityProperties( 					project); 			if (buildingWithJava8(project)) { 				test.systemProperty("java.security.properties", 						"file:" + test.getWorkingDir().toPath().relativize(copyJdk8156584SecurityProperties.output)); 				test.setDebug(true); 			} 			test.doFirst(copyJdk8156584SecurityProperties); 		}); 		project.getPlugins().withType(JavaPlugin.class, (javaPlugin) -> project.getDependencies() 				.add(JavaPlugin.TEST_RUNTIME_ONLY_CONFIGURATION_NAME, "org.junit.platform:junit-platform-launcher")); 		project.getPlugins().apply(TestRetryPlugin.class); 		project.getTasks().withType(Test.class, 				(test) -> project.getPlugins().withType(TestRetryPlugin.class, (testRetryPlugin) -> { 					TestRetryTaskExtension testRetry = test.getExtensions().getByType(TestRetryTaskExtension.class); 					testRetry.getFailOnPassedAfterRetry().set(true); 					testRetry.getMaxRetries().set(isCi() ? 3 : 0); 				})); 	}
private void configureTestConventions(Project project) { 		project.getTasks().withType(Test.class, (test) -> { 			withOptionalBuildJavaHome(project, (javaHome) -> test.setExecutable(javaHome + "/bin/java")); 			test.useJUnitPlatform(); 			test.setMaxHeapSize("1024M"); 			if (buildingWithJava8(project)) { 				test.systemProperty("java.security.properties", 						getClass().getClassLoader().getResource("jdk-8156584-security.properties")); 			} 		}); 		project.getPlugins().withType(JavaPlugin.class, (javaPlugin) -> project.getDependencies() 				.add(JavaPlugin.TEST_RUNTIME_ONLY_CONFIGURATION_NAME, "org.junit.platform:junit-platform-launcher")); 		project.getPlugins().apply(TestRetryPlugin.class); 		project.getTasks().withType(Test.class, 				(test) -> project.getPlugins().withType(TestRetryPlugin.class, (testRetryPlugin) -> { 					TestRetryTaskExtension testRetry = test.getExtensions().getByType(TestRetryTaskExtension.class); 					testRetry.getFailOnPassedAfterRetry().set(true); 					testRetry.getMaxRetries().set(isCi() ? 3 : 0); 				})); 	}
@Test 	void securityConfigurationShouldAllowAccess() throws Exception { 		this.context = getContext(() -> loadContext("spring.devtools.remote.secret:supersecret")); 		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); 		MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context).apply(springSecurity()).addFilter(filter) 				.build(); 		mockMvc.perform(MockMvcRequestBuilders.get(DEFAULT_CONTEXT_PATH + "/restart").header(DEFAULT_SECRET_HEADER_NAME, 				"supersecret")).andExpect(status().isOk()); 		assertRestartInvoked(true); 		assertThat(this.context.containsBean("devtoolsSecurityFilterChain")).isTrue(); 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		http.authorizeRequests((requests) -> { 			requests.requestMatchers(EndpointRequest.to(HealthEndpoint.class, InfoEndpoint.class)).permitAll(); 			requests.anyRequest().authenticated(); 		}); 		http.cors(); 		http.formLogin(Customizer.withDefaults()); 		http.httpBasic(Customizer.withDefaults()); 	}
@Test 	void backOffIfOAuth2ResourceServerAutoConfigurationPresent() { 		this.contextRunner.withConfiguration(AutoConfigurations.of(OAuth2ResourceServerAutoConfiguration.class)) 				.withPropertyValues("spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://authserver") 				.run((context) -> assertThat(context).doesNotHaveBean( 						ManagementWebSecurityAutoConfiguration.ManagementWebSecurityConfigurerAdapter.class)); 	}
@Test 	void backOffIfSaml2RelyingPartyAutoConfigurationPresent() { 		this.contextRunner.withConfiguration(AutoConfigurations.of(Saml2RelyingPartyAutoConfiguration.class)) 				.withPropertyValues( 						"spring.security.saml2.relyingparty.registration.simplesamlphp.identity-provider.single-sign-on.url=https://simplesaml-for-spring-saml/SSOService.php", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.identity-provider.single-sign-on.sign-request=false", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.identityprovider.entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.identityprovider.verification.credentials[0].certificate-location=classpath:saml/certificate-location") 				.run((context) -> assertThat(context).doesNotHaveBean( 						ManagementWebSecurityAutoConfiguration.ManagementWebSecurityConfigurerAdapter.class)); 	}
@Bean 		OpaqueTokenIntrospector decoder() { 			return mock(OpaqueTokenIntrospector.class); 		}
@Bean 		JwtDecoder decoder() { 			return mock(JwtDecoder.class); 		}
@Test 	void matchWhenHasNoControllers() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithNoControllers.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); 		assertThat(excludes(filter, SecurityFilterChain.class)).isFalse(); 		assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); 		assertThat(excludes(filter, ExampleModule.class)).isFalse(); 	}
@Test 	void matchWhenHasController() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithController.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); 		assertThat(excludes(filter, SecurityFilterChain.class)).isFalse(); 		assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); 		assertThat(excludes(filter, ExampleModule.class)).isFalse(); 	}
@Test 	void matchNotUsingDefaultFilters() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(NotUsingDefaultFilters.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isTrue(); 		assertThat(excludes(filter, ExampleWeb.class)).isTrue(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isTrue(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isTrue(); 		assertThat(excludes(filter, SecurityFilterChain.class)).isTrue(); 		assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isTrue(); 		assertThat(excludes(filter, ExampleModule.class)).isTrue(); 	}
@Test 	void matchWithExcludeFilter() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithExcludeFilter.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); 		assertThat(excludes(filter, SecurityFilterChain.class)).isFalse(); 		assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); 		assertThat(excludes(filter, ExampleModule.class)).isFalse(); 	}
public List<String> getBootstrapServers() { 			return this.bootstrapServers; 		}
public List<String> getBootstrapServers() { 			return this.bootstrapServers; 		}
public List<String> getBootstrapServers() { 			return this.bootstrapServers; 		}
public void setBootstrapServers(List<String> bootstrapServers) { 			this.bootstrapServers = bootstrapServers; 		}
public void setBootstrapServers(List<String> bootstrapServers) { 			this.bootstrapServers = bootstrapServers; 		}
public void setBootstrapServers(List<String> bootstrapServers) { 			this.bootstrapServers = bootstrapServers; 		}
public String getClientId() { 			return this.clientId; 		}
public String getClientId() { 			return this.clientId; 		}
public String getClientId() { 			return this.clientId; 		}
public String getClientId() { 			return this.clientId; 		}
public String getClientId() { 			return this.clientId; 		}
public void setClientId(String clientId) { 			this.clientId = clientId; 		}
public void setClientId(String clientId) { 			this.clientId = clientId; 		}
public void setClientId(String clientId) { 			this.clientId = clientId; 		}
public void setClientId(String clientId) { 			this.clientId = clientId; 		}
public void setClientId(String clientId) { 			this.clientId = clientId; 		}
public Map<String, String> getProperties() { 			return this.properties; 		}
public Map<String, String> getProperties() { 			return this.properties; 		}
public Map<String, String> getProperties() { 			return this.properties; 		}
public Map<String, String> getProperties() { 			return this.properties; 		}
public Ssl getSsl() { 			return this.ssl; 		}
public Ssl getSsl() { 			return this.ssl; 		}
public Ssl getSsl() { 			return this.ssl; 		}
public Ssl getSsl() { 			return this.ssl; 		}
private Map<String, Object> buildCommonProperties() { 		Map<String, Object> properties = new HashMap<>(); 		if (this.bootstrapServers != null) { 			properties.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, this.bootstrapServers); 		} 		if (this.clientId != null) { 			properties.put(CommonClientConfigs.CLIENT_ID_CONFIG, this.clientId); 		} 		properties.putAll(this.ssl.buildProperties()); 		properties.putAll(this.security.buildProperties()); 		if (!CollectionUtils.isEmpty(this.properties)) { 			properties.putAll(this.properties); 		} 		return properties; 	}
public Ssl getSsl() { 		return this.ssl; 	}
public List<String> getBootstrapServers() { 		return this.bootstrapServers; 	}
public void setBootstrapServers(List<String> bootstrapServers) { 		this.bootstrapServers = bootstrapServers; 	}
public String getClientId() { 		return this.clientId; 	}
public void setClientId(String clientId) { 		this.clientId = clientId; 	}
public Map<String, String> getProperties() { 		return this.properties; 	}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAutoCommitInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG)); 			map.from(this::getAutoOffsetReset).to(properties.in(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getClientId).to(properties.in(ConsumerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getEnableAutoCommit).to(properties.in(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG)); 			map.from(this::getFetchMaxWait).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG)); 			map.from(this::getFetchMinSize).asInt(DataSize::toBytes) 					.to(properties.in(ConsumerConfig.FETCH_MIN_BYTES_CONFIG)); 			map.from(this::getGroupId).to(properties.in(ConsumerConfig.GROUP_ID_CONFIG)); 			map.from(this::getHeartbeatInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG)); 			map.from(() -> getIsolationLevel().name().toLowerCase(Locale.ROOT)) 					.to(properties.in(ConsumerConfig.ISOLATION_LEVEL_CONFIG)); 			map.from(this::getKeyDeserializer).to(properties.in(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getValueDeserializer).to(properties.in(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getMaxPollRecords).to(properties.in(ConsumerConfig.MAX_POLL_RECORDS_CONFIG)); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAcks).to(properties.in(ProducerConfig.ACKS_CONFIG)); 			map.from(this::getBatchSize).asInt(DataSize::toBytes).to(properties.in(ProducerConfig.BATCH_SIZE_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getBufferMemory).as(DataSize::toBytes) 					.to(properties.in(ProducerConfig.BUFFER_MEMORY_CONFIG)); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getCompressionType).to(properties.in(ProducerConfig.COMPRESSION_TYPE_CONFIG)); 			map.from(this::getKeySerializer).to(properties.in(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG)); 			map.from(this::getRetries).to(properties.in(ProducerConfig.RETRIES_CONFIG)); 			map.from(this::getValueSerializer).to(properties.in(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG)); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getApplicationId).to(properties.in("application.id")); 			map.from(this::getBootstrapServers).to(properties.in(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getCacheMaxSizeBuffering).asInt(DataSize::toBytes) 					.to(properties.in("cache.max.bytes.buffering")); 			map.from(this::getClientId).to(properties.in(CommonClientConfigs.CLIENT_ID_CONFIG)); 			map.from(this::getReplicationFactor).to(properties.in("replication.factor")); 			map.from(this::getStateDir).to(properties.in("state.dir")); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getKeyPassword).to(properties.in(SslConfigs.SSL_KEY_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)); 			map.from(this::getKeyStorePassword).to(properties.in(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreType).to(properties.in(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)); 			map.from(this::getTrustStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)); 			map.from(this::getTrustStorePassword).to(properties.in(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)); 			map.from(this::getTrustStoreType).to(properties.in(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)); 			map.from(this::getProtocol).to(properties.in(SslConfigs.SSL_PROTOCOL_CONFIG)); 			return properties; 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getProtocol).to(properties.in(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG)); 			return properties; 		}
public Ssl getSsl() { 		return this.ssl; 	}
public List<String> getBootstrapServers() { 		return this.bootstrapServers; 	}
public void setBootstrapServers(List<String> bootstrapServers) { 		this.bootstrapServers = bootstrapServers; 	}
public String getClientId() { 		return this.clientId; 	}
public void setClientId(String clientId) { 		this.clientId = clientId; 	}
public Map<String, String> getProperties() { 		return this.properties; 	}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAutoCommitInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG)); 			map.from(this::getAutoOffsetReset).to(properties.in(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getClientId).to(properties.in(ConsumerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getEnableAutoCommit).to(properties.in(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG)); 			map.from(this::getFetchMaxWait).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG)); 			map.from(this::getFetchMinSize).asInt(DataSize::toBytes) 					.to(properties.in(ConsumerConfig.FETCH_MIN_BYTES_CONFIG)); 			map.from(this::getGroupId).to(properties.in(ConsumerConfig.GROUP_ID_CONFIG)); 			map.from(this::getHeartbeatInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG)); 			map.from(() -> getIsolationLevel().name().toLowerCase(Locale.ROOT)) 					.to(properties.in(ConsumerConfig.ISOLATION_LEVEL_CONFIG)); 			map.from(this::getKeyDeserializer).to(properties.in(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getValueDeserializer).to(properties.in(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getMaxPollRecords).to(properties.in(ConsumerConfig.MAX_POLL_RECORDS_CONFIG)); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAcks).to(properties.in(ProducerConfig.ACKS_CONFIG)); 			map.from(this::getBatchSize).asInt(DataSize::toBytes).to(properties.in(ProducerConfig.BATCH_SIZE_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getBufferMemory).as(DataSize::toBytes) 					.to(properties.in(ProducerConfig.BUFFER_MEMORY_CONFIG)); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getCompressionType).to(properties.in(ProducerConfig.COMPRESSION_TYPE_CONFIG)); 			map.from(this::getKeySerializer).to(properties.in(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG)); 			map.from(this::getRetries).to(properties.in(ProducerConfig.RETRIES_CONFIG)); 			map.from(this::getValueSerializer).to(properties.in(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG)); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getApplicationId).to(properties.in("application.id")); 			map.from(this::getBootstrapServers).to(properties.in(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getCacheMaxSizeBuffering).asInt(DataSize::toBytes) 					.to(properties.in("cache.max.bytes.buffering")); 			map.from(this::getClientId).to(properties.in(CommonClientConfigs.CLIENT_ID_CONFIG)); 			map.from(this::getReplicationFactor).to(properties.in("replication.factor")); 			map.from(this::getStateDir).to(properties.in("state.dir")); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getKeyPassword).to(properties.in(SslConfigs.SSL_KEY_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)); 			map.from(this::getKeyStorePassword).to(properties.in(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreType).to(properties.in(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)); 			map.from(this::getTrustStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)); 			map.from(this::getTrustStorePassword).to(properties.in(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)); 			map.from(this::getTrustStoreType).to(properties.in(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)); 			map.from(this::getProtocol).to(properties.in(SslConfigs.SSL_PROTOCOL_CONFIG)); 			return properties; 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getProtocol).to(properties.in(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG)); 			return properties; 		}
public Ssl getSsl() { 		return this.ssl; 	}
public String getClientId() { 		return this.clientId; 	}
public void setClientId(String clientId) { 		this.clientId = clientId; 	}
public Map<String, String> getProperties() { 		return this.properties; 	}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAutoCommitInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG)); 			map.from(this::getAutoOffsetReset).to(properties.in(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getClientId).to(properties.in(ConsumerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getEnableAutoCommit).to(properties.in(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG)); 			map.from(this::getFetchMaxWait).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG)); 			map.from(this::getFetchMinSize).asInt(DataSize::toBytes) 					.to(properties.in(ConsumerConfig.FETCH_MIN_BYTES_CONFIG)); 			map.from(this::getGroupId).to(properties.in(ConsumerConfig.GROUP_ID_CONFIG)); 			map.from(this::getHeartbeatInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG)); 			map.from(() -> getIsolationLevel().name().toLowerCase(Locale.ROOT)) 					.to(properties.in(ConsumerConfig.ISOLATION_LEVEL_CONFIG)); 			map.from(this::getKeyDeserializer).to(properties.in(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getValueDeserializer).to(properties.in(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getMaxPollRecords).to(properties.in(ConsumerConfig.MAX_POLL_RECORDS_CONFIG)); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAcks).to(properties.in(ProducerConfig.ACKS_CONFIG)); 			map.from(this::getBatchSize).asInt(DataSize::toBytes).to(properties.in(ProducerConfig.BATCH_SIZE_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getBufferMemory).as(DataSize::toBytes) 					.to(properties.in(ProducerConfig.BUFFER_MEMORY_CONFIG)); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getCompressionType).to(properties.in(ProducerConfig.COMPRESSION_TYPE_CONFIG)); 			map.from(this::getKeySerializer).to(properties.in(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG)); 			map.from(this::getRetries).to(properties.in(ProducerConfig.RETRIES_CONFIG)); 			map.from(this::getValueSerializer).to(properties.in(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG)); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getApplicationId).to(properties.in("application.id")); 			map.from(this::getBootstrapServers).to(properties.in(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getCacheMaxSizeBuffering).asInt(DataSize::toBytes) 					.to(properties.in("cache.max.bytes.buffering")); 			map.from(this::getClientId).to(properties.in(CommonClientConfigs.CLIENT_ID_CONFIG)); 			map.from(this::getReplicationFactor).to(properties.in("replication.factor")); 			map.from(this::getStateDir).to(properties.in("state.dir")); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getKeyPassword).to(properties.in(SslConfigs.SSL_KEY_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)); 			map.from(this::getKeyStorePassword).to(properties.in(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreType).to(properties.in(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)); 			map.from(this::getTrustStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)); 			map.from(this::getTrustStorePassword).to(properties.in(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)); 			map.from(this::getTrustStoreType).to(properties.in(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)); 			map.from(this::getProtocol).to(properties.in(SslConfigs.SSL_PROTOCOL_CONFIG)); 			return properties; 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getProtocol).to(properties.in(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG)); 			return properties; 		}
public Ssl getSsl() { 		return this.ssl; 	}
public List<String> getBootstrapServers() { 		return this.bootstrapServers; 	}
public void setBootstrapServers(List<String> bootstrapServers) { 		this.bootstrapServers = bootstrapServers; 	}
public String getClientId() { 		return this.clientId; 	}
public void setClientId(String clientId) { 		this.clientId = clientId; 	}
public Map<String, String> getProperties() { 		return this.properties; 	}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAutoCommitInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG)); 			map.from(this::getAutoOffsetReset).to(properties.in(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getClientId).to(properties.in(ConsumerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getEnableAutoCommit).to(properties.in(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG)); 			map.from(this::getFetchMaxWait).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG)); 			map.from(this::getFetchMinSize).asInt(DataSize::toBytes) 					.to(properties.in(ConsumerConfig.FETCH_MIN_BYTES_CONFIG)); 			map.from(this::getGroupId).to(properties.in(ConsumerConfig.GROUP_ID_CONFIG)); 			map.from(this::getHeartbeatInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG)); 			map.from(() -> getIsolationLevel().name().toLowerCase(Locale.ROOT)) 					.to(properties.in(ConsumerConfig.ISOLATION_LEVEL_CONFIG)); 			map.from(this::getKeyDeserializer).to(properties.in(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getValueDeserializer).to(properties.in(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getMaxPollRecords).to(properties.in(ConsumerConfig.MAX_POLL_RECORDS_CONFIG)); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAcks).to(properties.in(ProducerConfig.ACKS_CONFIG)); 			map.from(this::getBatchSize).asInt(DataSize::toBytes).to(properties.in(ProducerConfig.BATCH_SIZE_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getBufferMemory).as(DataSize::toBytes) 					.to(properties.in(ProducerConfig.BUFFER_MEMORY_CONFIG)); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getCompressionType).to(properties.in(ProducerConfig.COMPRESSION_TYPE_CONFIG)); 			map.from(this::getKeySerializer).to(properties.in(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG)); 			map.from(this::getRetries).to(properties.in(ProducerConfig.RETRIES_CONFIG)); 			map.from(this::getValueSerializer).to(properties.in(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG)); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getApplicationId).to(properties.in("application.id")); 			map.from(this::getBootstrapServers).to(properties.in(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getCacheMaxSizeBuffering).asInt(DataSize::toBytes) 					.to(properties.in("cache.max.bytes.buffering")); 			map.from(this::getClientId).to(properties.in(CommonClientConfigs.CLIENT_ID_CONFIG)); 			map.from(this::getReplicationFactor).to(properties.in("replication.factor")); 			map.from(this::getStateDir).to(properties.in("state.dir")); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getKeyPassword).to(properties.in(SslConfigs.SSL_KEY_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)); 			map.from(this::getKeyStorePassword).to(properties.in(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreType).to(properties.in(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)); 			map.from(this::getTrustStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)); 			map.from(this::getTrustStorePassword).to(properties.in(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)); 			map.from(this::getTrustStoreType).to(properties.in(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)); 			map.from(this::getProtocol).to(properties.in(SslConfigs.SSL_PROTOCOL_CONFIG)); 			return properties; 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getProtocol).to(properties.in(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG)); 			return properties; 		}
public String getClientId() { 		return this.clientId; 	}
public void setClientId(String clientId) { 		this.clientId = clientId; 	}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAutoCommitInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG)); 			map.from(this::getAutoOffsetReset).to(properties.in(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getClientId).to(properties.in(ConsumerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getEnableAutoCommit).to(properties.in(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG)); 			map.from(this::getFetchMaxWait).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG)); 			map.from(this::getFetchMinSize).asInt(DataSize::toBytes) 					.to(properties.in(ConsumerConfig.FETCH_MIN_BYTES_CONFIG)); 			map.from(this::getGroupId).to(properties.in(ConsumerConfig.GROUP_ID_CONFIG)); 			map.from(this::getHeartbeatInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG)); 			map.from(() -> getIsolationLevel().name().toLowerCase(Locale.ROOT)) 					.to(properties.in(ConsumerConfig.ISOLATION_LEVEL_CONFIG)); 			map.from(this::getKeyDeserializer).to(properties.in(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getValueDeserializer).to(properties.in(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getMaxPollRecords).to(properties.in(ConsumerConfig.MAX_POLL_RECORDS_CONFIG)); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAcks).to(properties.in(ProducerConfig.ACKS_CONFIG)); 			map.from(this::getBatchSize).asInt(DataSize::toBytes).to(properties.in(ProducerConfig.BATCH_SIZE_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getBufferMemory).as(DataSize::toBytes) 					.to(properties.in(ProducerConfig.BUFFER_MEMORY_CONFIG)); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getCompressionType).to(properties.in(ProducerConfig.COMPRESSION_TYPE_CONFIG)); 			map.from(this::getKeySerializer).to(properties.in(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG)); 			map.from(this::getRetries).to(properties.in(ProducerConfig.RETRIES_CONFIG)); 			map.from(this::getValueSerializer).to(properties.in(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG)); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getApplicationId).to(properties.in("application.id")); 			map.from(this::getBootstrapServers).to(properties.in(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getCacheMaxSizeBuffering).asInt(DataSize::toBytes) 					.to(properties.in("cache.max.bytes.buffering")); 			map.from(this::getClientId).to(properties.in(CommonClientConfigs.CLIENT_ID_CONFIG)); 			map.from(this::getReplicationFactor).to(properties.in("replication.factor")); 			map.from(this::getStateDir).to(properties.in("state.dir")); 			return properties.with(this.ssl, this.security, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getProtocol).to(properties.in(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG)); 			return properties; 		}
@Test 	void consumerProperties() { 		this.contextRunner.withPropertyValues("spring.kafka.bootstrap-servers=foo:1234", 				"spring.kafka.properties.foo=bar", "spring.kafka.properties.baz=qux", 				"spring.kafka.properties.foo.bar.baz=qux.fiz.buz", "spring.kafka.ssl.key-password=p1", 				"spring.kafka.ssl.key-store-location=classpath:ksLoc", "spring.kafka.ssl.key-store-password=p2", 				"spring.kafka.ssl.key-store-type=PKCS12", "spring.kafka.ssl.trust-store-location=classpath:tsLoc", 				"spring.kafka.ssl.trust-store-password=p3", "spring.kafka.ssl.trust-store-type=PKCS12", 				"spring.kafka.ssl.protocol=TLSv1.2", "spring.kafka.consumer.auto-commit-interval=123", 				"spring.kafka.consumer.max-poll-records=42", "spring.kafka.consumer.auto-offset-reset=earliest", 				"spring.kafka.consumer.client-id=ccid", // test override common 				"spring.kafka.consumer.enable-auto-commit=false", "spring.kafka.consumer.fetch-max-wait=456", 				"spring.kafka.consumer.properties.fiz.buz=fix.fox", "spring.kafka.consumer.fetch-min-size=1KB", 				"spring.kafka.consumer.group-id=bar", "spring.kafka.consumer.heartbeat-interval=234", 				"spring.kafka.consumer.isolation-level = read-committed", 				"spring.kafka.consumer.security.protocol = SSL", 				"spring.kafka.consumer.key-deserializer = org.apache.kafka.common.serialization.LongDeserializer", 				"spring.kafka.consumer.value-deserializer = org.apache.kafka.common.serialization.IntegerDeserializer") 				.run((context) -> { 					DefaultKafkaConsumerFactory<?, ?> consumerFactory = context 							.getBean(DefaultKafkaConsumerFactory.class); 					Map<String, Object> configs = consumerFactory.getConfigurationProperties(); 					// common 					assertThat(configs.get(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG)) 							.isEqualTo(Collections.singletonList("foo:1234")); 					assertThat(configs.get(SslConfigs.SSL_KEY_PASSWORD_CONFIG)).isEqualTo("p1"); 					assertThat((String) configs.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "ksLoc"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)).isEqualTo("p2"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat((String) configs.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "tsLoc"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)).isEqualTo("p3"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat(configs.get(SslConfigs.SSL_PROTOCOL_CONFIG)).isEqualTo("TLSv1.2"); 					// consumer 					assertThat(configs.get(ConsumerConfig.CLIENT_ID_CONFIG)).isEqualTo("ccid"); // override 					assertThat(configs.get(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG)).isEqualTo(Boolean.FALSE); 					assertThat(configs.get(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG)).isEqualTo(123); 					assertThat(configs.get(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG)).isEqualTo("earliest"); 					assertThat(configs.get(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG)).isEqualTo(456); 					assertThat(configs.get(ConsumerConfig.FETCH_MIN_BYTES_CONFIG)).isEqualTo(1024); 					assertThat(configs.get(ConsumerConfig.GROUP_ID_CONFIG)).isEqualTo("bar"); 					assertThat(configs.get(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG)).isEqualTo(234); 					assertThat(configs.get(ConsumerConfig.ISOLATION_LEVEL_CONFIG)).isEqualTo("read_committed"); 					assertThat(configs.get(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG)) 							.isEqualTo(LongDeserializer.class); 					assertThat(configs.get(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG)).isEqualTo("SSL"); 					assertThat(configs.get(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG)) 							.isEqualTo(IntegerDeserializer.class); 					assertThat(configs.get(ConsumerConfig.MAX_POLL_RECORDS_CONFIG)).isEqualTo(42); 					assertThat(configs.get("foo")).isEqualTo("bar"); 					assertThat(configs.get("baz")).isEqualTo("qux"); 					assertThat(configs.get("foo.bar.baz")).isEqualTo("qux.fiz.buz"); 					assertThat(configs.get("fiz.buz")).isEqualTo("fix.fox"); 				}); 	}
@Test 	void producerProperties() { 		this.contextRunner.withPropertyValues("spring.kafka.clientId=cid", 				"spring.kafka.properties.foo.bar.baz=qux.fiz.buz", "spring.kafka.producer.acks=all", 				"spring.kafka.producer.batch-size=2KB", "spring.kafka.producer.bootstrap-servers=bar:1234", // test 				// override 				"spring.kafka.producer.buffer-memory=4KB", "spring.kafka.producer.compression-type=gzip", 				"spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.LongSerializer", 				"spring.kafka.producer.retries=2", "spring.kafka.producer.properties.fiz.buz=fix.fox", 				"spring.kafka.producer.security.protocol=SSL", "spring.kafka.producer.ssl.key-password=p4", 				"spring.kafka.producer.ssl.key-store-location=classpath:ksLocP", 				"spring.kafka.producer.ssl.key-store-password=p5", "spring.kafka.producer.ssl.key-store-type=PKCS12", 				"spring.kafka.producer.ssl.trust-store-location=classpath:tsLocP", 				"spring.kafka.producer.ssl.trust-store-password=p6", 				"spring.kafka.producer.ssl.trust-store-type=PKCS12", "spring.kafka.producer.ssl.protocol=TLSv1.2", 				"spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.IntegerSerializer") 				.run((context) -> { 					DefaultKafkaProducerFactory<?, ?> producerFactory = context 							.getBean(DefaultKafkaProducerFactory.class); 					Map<String, Object> configs = producerFactory.getConfigurationProperties(); 					// common 					assertThat(configs.get(ProducerConfig.CLIENT_ID_CONFIG)).isEqualTo("cid"); 					// producer 					assertThat(configs.get(ProducerConfig.ACKS_CONFIG)).isEqualTo("all"); 					assertThat(configs.get(ProducerConfig.BATCH_SIZE_CONFIG)).isEqualTo(2048); 					assertThat(configs.get(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG)) 							.isEqualTo(Collections.singletonList("bar:1234")); // override 					assertThat(configs.get(ProducerConfig.BUFFER_MEMORY_CONFIG)).isEqualTo(4096L); 					assertThat(configs.get(ProducerConfig.COMPRESSION_TYPE_CONFIG)).isEqualTo("gzip"); 					assertThat(configs.get(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG)).isEqualTo(LongSerializer.class); 					assertThat(configs.get(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG)).isEqualTo("SSL"); 					assertThat(configs.get(SslConfigs.SSL_KEY_PASSWORD_CONFIG)).isEqualTo("p4"); 					assertThat((String) configs.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "ksLocP"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)).isEqualTo("p5"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat((String) configs.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "tsLocP"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)).isEqualTo("p6"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat(configs.get(SslConfigs.SSL_PROTOCOL_CONFIG)).isEqualTo("TLSv1.2"); 					assertThat(configs.get(ProducerConfig.RETRIES_CONFIG)).isEqualTo(2); 					assertThat(configs.get(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG)) 							.isEqualTo(IntegerSerializer.class); 					assertThat(context.getBeansOfType(KafkaJaasLoginModuleInitializer.class)).isEmpty(); 					assertThat(context.getBeansOfType(KafkaTransactionManager.class)).isEmpty(); 					assertThat(configs.get("foo.bar.baz")).isEqualTo("qux.fiz.buz"); 					assertThat(configs.get("fiz.buz")).isEqualTo("fix.fox"); 				}); 	}
@Test 	void adminProperties() { 		this.contextRunner 				.withPropertyValues("spring.kafka.clientId=cid", "spring.kafka.properties.foo.bar.baz=qux.fiz.buz", 						"spring.kafka.admin.fail-fast=true", "spring.kafka.admin.properties.fiz.buz=fix.fox", 						"spring.kafka.admin.security.protocol=SSL", "spring.kafka.admin.ssl.key-password=p4", 						"spring.kafka.admin.ssl.key-store-location=classpath:ksLocP", 						"spring.kafka.admin.ssl.key-store-password=p5", "spring.kafka.admin.ssl.key-store-type=PKCS12", 						"spring.kafka.admin.ssl.trust-store-location=classpath:tsLocP", 						"spring.kafka.admin.ssl.trust-store-password=p6", 						"spring.kafka.admin.ssl.trust-store-type=PKCS12", "spring.kafka.admin.ssl.protocol=TLSv1.2") 				.run((context) -> { 					KafkaAdmin admin = context.getBean(KafkaAdmin.class); 					Map<String, Object> configs = admin.getConfig(); 					// common 					assertThat(configs.get(AdminClientConfig.CLIENT_ID_CONFIG)).isEqualTo("cid"); 					// admin 					assertThat(configs.get(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG)).isEqualTo("SSL"); 					assertThat(configs.get(SslConfigs.SSL_KEY_PASSWORD_CONFIG)).isEqualTo("p4"); 					assertThat((String) configs.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "ksLocP"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)).isEqualTo("p5"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat((String) configs.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "tsLocP"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)).isEqualTo("p6"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat(configs.get(SslConfigs.SSL_PROTOCOL_CONFIG)).isEqualTo("TLSv1.2"); 					assertThat(context.getBeansOfType(KafkaJaasLoginModuleInitializer.class)).isEmpty(); 					assertThat(configs.get("foo.bar.baz")).isEqualTo("qux.fiz.buz"); 					assertThat(configs.get("fiz.buz")).isEqualTo("fix.fox"); 					assertThat(admin).hasFieldOrPropertyWithValue("fatalIfBrokerNotAvailable", true); 				}); 	}
@SuppressWarnings("unchecked") 	@Test 	void streamsProperties() { 		this.contextRunner.withUserConfiguration(EnableKafkaStreamsConfiguration.class).withPropertyValues( 				"spring.kafka.client-id=cid", "spring.kafka.bootstrap-servers=localhost:9092,localhost:9093", 				"spring.application.name=appName", "spring.kafka.properties.foo.bar.baz=qux.fiz.buz", 				"spring.kafka.streams.auto-startup=false", "spring.kafka.streams.cache-max-size-buffering=1KB", 				"spring.kafka.streams.client-id=override", "spring.kafka.streams.properties.fiz.buz=fix.fox", 				"spring.kafka.streams.replication-factor=2", "spring.kafka.streams.state-dir=/tmp/state", 				"spring.kafka.streams.security.protocol=SSL", "spring.kafka.streams.ssl.key-password=p7", 				"spring.kafka.streams.ssl.key-store-location=classpath:ksLocP", 				"spring.kafka.streams.ssl.key-store-password=p8", "spring.kafka.streams.ssl.key-store-type=PKCS12", 				"spring.kafka.streams.ssl.trust-store-location=classpath:tsLocP", 				"spring.kafka.streams.ssl.trust-store-password=p9", "spring.kafka.streams.ssl.trust-store-type=PKCS12", 				"spring.kafka.streams.ssl.protocol=TLSv1.2").run((context) -> { 					Properties configs = context 							.getBean(KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_CONFIG_BEAN_NAME, 									KafkaStreamsConfiguration.class) 							.asProperties(); 					assertThat((List<String>) configs.get(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG)) 							.containsExactly("localhost:9092", "localhost:9093"); 					assertThat(configs.get(StreamsConfig.CACHE_MAX_BYTES_BUFFERING_CONFIG)).isEqualTo(1024); 					assertThat(configs.get(StreamsConfig.CLIENT_ID_CONFIG)).isEqualTo("override"); 					assertThat(configs.get(StreamsConfig.REPLICATION_FACTOR_CONFIG)).isEqualTo(2); 					assertThat(configs.get(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG)).isEqualTo("SSL"); 					assertThat(configs.get(StreamsConfig.STATE_DIR_CONFIG)).isEqualTo("/tmp/state"); 					assertThat(configs.get(SslConfigs.SSL_KEY_PASSWORD_CONFIG)).isEqualTo("p7"); 					assertThat((String) configs.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "ksLocP"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)).isEqualTo("p8"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat((String) configs.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "tsLocP"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)).isEqualTo("p9"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat(configs.get(SslConfigs.SSL_PROTOCOL_CONFIG)).isEqualTo("TLSv1.2"); 					assertThat(context.getBeansOfType(KafkaJaasLoginModuleInitializer.class)).isEmpty(); 					assertThat(configs.get("foo.bar.baz")).isEqualTo("qux.fiz.buz"); 					assertThat(configs.get("fiz.buz")).isEqualTo("fix.fox"); 					assertThat(context.getBean(KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_BUILDER_BEAN_NAME)) 							.isNotNull(); 				}); 	}
@Test 	void securityConfigurationShouldAllowAccess() throws Exception { 		this.context = getContext(() -> loadContext("spring.devtools.remote.secret:supersecret")); 		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); 		MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context).apply(springSecurity()).addFilter(filter) 				.build(); 		mockMvc.perform(MockMvcRequestBuilders.get(DEFAULT_CONTEXT_PATH + "/restart").header(DEFAULT_SECRET_HEADER_NAME, 				"supersecret")).andExpect(status().isOk()); 		assertRestartInvoked(true); 	}
@Test 	void securityConfigurationShouldAllowAccessToCustomPath() throws Exception { 		this.context = getContext(() -> loadContext("spring.devtools.remote.secret:supersecret", 				"server.servlet.context-path:/test", "spring.devtools.remote.context-path:/custom")); 		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); 		MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context).apply(springSecurity()).addFilter(filter) 				.build(); 		mockMvc.perform( 				MockMvcRequestBuilders.get("/test/custom/restart").header(DEFAULT_SECRET_HEADER_NAME, "supersecret")) 				.andExpect(status().isOk()); 		assertRestartInvoked(true); 	}
@Bean 	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 		http.authorizeExchange((exchanges) -> { 			exchanges.matchers(EndpointRequest.to(HealthEndpoint.class, InfoEndpoint.class)).permitAll(); 			exchanges.anyExchange().authenticated(); 		}); 		http.httpBasic(Customizer.withDefaults()); 		http.formLogin(Customizer.withDefaults()); 		return http.build(); 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		http.authorizeRequests((requests) -> { 			requests.requestMatchers(EndpointRequest.to(HealthEndpoint.class, InfoEndpoint.class)).permitAll(); 			requests.anyRequest().authenticated(); 		}); 		http.formLogin(Customizer.withDefaults()); 		http.httpBasic(Customizer.withDefaults()); 	}
@Bean 	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 		http.authorizeExchange((exchanges) -> { 			exchanges.matchers(HEALTH_OR_INFO_ENDPOINT).permitAll(); 			exchanges.anyExchange().authenticated(); 		}); 		http.httpBasic(Customizer.withDefaults()); 		http.formLogin(Customizer.withDefaults()); 		return http.build(); 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		http.authorizeRequests((requests) -> { 			requests.requestMatchers(HEALTH_OR_INFO_ENDPOINT).permitAll(); 			requests.anyRequest().authenticated(); 		}); 		http.formLogin(Customizer.withDefaults()); 		http.httpBasic(Customizer.withDefaults()); 	}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			http.authorizeExchange((exchanges) -> { 				exchanges.pathMatchers("/foo").permitAll(); 				exchanges.anyExchange().authenticated(); 			}); 			http.formLogin(Customizer.withDefaults()); 			return http.build(); 		}
private List<SecurityWebFilterChain> getFilterChains(ServerHttpSecurity http) throws Exception { 			http.authorizeExchange((exchanges) -> exchanges.anyExchange().authenticated()); 			http.formLogin(Customizer.withDefaults()); 			return Collections.singletonList(http.build()); 		}
@ReadOperation 		Object getAll() { 			return "endpoint 2"; 		}
@ReadOperation 		Object getAll() { 			return null; 		}
@ReadOperation 		Object getAll() { 			return "endpoint 1"; 		}
@ReadOperation 		Object getAll() { 			return null; 		}
@ReadOperation 		Object getAll() { 			return "endpoint 1"; 		}
@ReadOperation 		Object getAll() { 			return "endpoint 2"; 		}
@Bean 		WebSecurityConfigurerAdapter webSecurityConfigurerAdapter() { 			return new WebSecurityConfigurerAdapter() {  				@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests((requests) -> { 						requests.requestMatchers(EndpointRequest.toLinks()).permitAll(); 						requests.requestMatchers(EndpointRequest.to(TestEndpoint1.class)).permitAll(); 						requests.requestMatchers(EndpointRequest.toAnyEndpoint()).authenticated(); 						requests.anyRequest().hasRole("ADMIN"); 					}); 					http.httpBasic(); 				}  			}; 		}
@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests((requests) -> { 						requests.requestMatchers(EndpointRequest.toLinks()).permitAll(); 						requests.requestMatchers(EndpointRequest.to(TestEndpoint1.class)).permitAll(); 						requests.requestMatchers(EndpointRequest.toAnyEndpoint()).authenticated(); 						requests.anyRequest().hasRole("ADMIN"); 					}); 					http.httpBasic(); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests((requests) -> { 				requests.antMatchers("/foo").permitAll(); 				requests.anyRequest().authenticated(); 			}); 			http.formLogin(Customizer.withDefaults()); 			http.httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests((requests) -> requests.anyRequest().authenticated()); 			http.oauth2Login(Customizer.withDefaults()); 			http.oauth2Client(); 		}
@Bean 		@ConditionalOnBean(ReactiveJwtDecoder.class) 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http, ReactiveJwtDecoder jwtDecoder) 				throws Exception { 			http.authorizeExchange((exchanges) -> exchanges.anyExchange().authenticated()); 			http.oauth2ResourceServer((server) -> customDecoder(server, jwtDecoder)); 			return http.build(); 		}
@Bean 		@ConditionalOnBean(ReactiveOAuth2TokenIntrospectionClient.class) 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			http.authorizeExchange((exchanges) -> exchanges.anyExchange().authenticated()); 			http.oauth2ResourceServer(OAuth2ResourceServerSpec::opaqueToken); 			return http.build(); 		}
@Bean 		@ConditionalOnBean(JwtDecoder.class) 		WebSecurityConfigurerAdapter jwtDecoderWebSecurityConfigurerAdapter() { 			return new WebSecurityConfigurerAdapter() {  				@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests((requests) -> requests.anyRequest().authenticated()); 					http.oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt); 				}  			}; 		}
@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests((requests) -> requests.anyRequest().authenticated()); 					http.oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt); 				}
@Bean 		@ConditionalOnBean(OAuth2TokenIntrospectionClient.class) 		WebSecurityConfigurerAdapter opaqueTokenWebSecurityConfigurerAdapter() { 			return new WebSecurityConfigurerAdapter() {  				@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests((requests) -> requests.anyRequest().authenticated()); 					http.oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken); 				}  			}; 		}
@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests((requests) -> requests.anyRequest().authenticated()); 					http.oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken); 				}
@Bean 		ReactiveOAuth2TokenIntrospectionClient decoder() { 			return mock(ReactiveOAuth2TokenIntrospectionClient.class); 		}
@Bean 		ReactiveJwtDecoder decoder() { 			return mock(ReactiveJwtDecoder.class); 		}
@Bean 		SecurityWebFilterChain testSpringSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			http.authorizeExchange((exchanges) -> { 				exchanges.pathMatchers("/message/**").hasRole("ADMIN"); 				exchanges.anyExchange().authenticated(); 			}); 			http.httpBasic(); 			return http.build(); 		}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			http.authorizeExchange((exchanges) -> exchanges.anyExchange().permitAll()); 			return http.build(); 		}
@Bean 	public InMemoryUserDetailsManager inMemoryUserDetailsManager() { 		List<UserDetails> userDetails = new ArrayList<>(); 		userDetails.add(createUserDetails("user", "password", "ROLE_USER")); 		userDetails.add(createUserDetails("beans", "beans", "ROLE_BEANS")); 		userDetails.add(createUserDetails("admin", "admin", "ROLE_ACTUATOR", "ROLE_USER")); 		return new InMemoryUserDetailsManager(userDetails); 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		http.authorizeRequests((requests) -> { 			requests.mvcMatchers("/actuator/beans").hasRole("BEANS"); 			requests.requestMatchers(EndpointRequest.to("health", "info")).permitAll(); 			requests.requestMatchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)) 					.hasRole("ACTUATOR"); 			requests.requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll(); 			requests.antMatchers("/foo").permitAll(); 			requests.antMatchers("/**").hasRole("USER"); 		}); 		http.cors(Customizer.withDefaults()); 		http.httpBasic(); 	}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			http.authorizeExchange((exchanges) -> { 				exchanges.matchers(EndpointRequest.to("health", "info")).permitAll(); 				exchanges.matchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)) 						.hasRole("ACTUATOR"); 				exchanges.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll(); 				exchanges.pathMatchers("/login").permitAll(); 				exchanges.anyExchange().authenticated(); 			}); 			http.httpBasic(); 			return http.build(); 		}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			http.authorizeExchange((exchanges) -> { 				exchanges.matchers(EndpointRequest.to("health", "info")).permitAll(); 				exchanges.matchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)) 						.hasRole("ACTUATOR"); 				exchanges.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll(); 				exchanges.pathMatchers("/login").permitAll(); 				exchanges.anyExchange().authenticated(); 			}); 			http.httpBasic(Customizer.withDefaults()); 			return http.build(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests((requests) -> { 				requests.antMatchers("/login").permitAll(); 				requests.anyRequest().fullyAuthenticated(); 			}); 			http.formLogin((form) -> { 				form.loginPage("/login"); 				form.failureUrl("/login?error"); 			}); 			http.logout((logout) -> logout.logoutRequestMatcher(new AntPathRequestMatcher("/logout"))); 			http.exceptionHandling((exceptions) -> exceptions.accessDeniedPage("/access?error")); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(EndpointRequest.toAnyEndpoint()); 			http.authorizeRequests((requests) -> requests.anyRequest().authenticated()); 			http.httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests((requests) -> { 				requests.antMatchers("/login").permitAll(); 				requests.anyRequest().fullyAuthenticated(); 			}); 			http.formLogin((form) -> { 				form.loginPage("/login"); 				form.failureUrl("/login?error"); 			}); 			http.logout((logout) -> logout.logoutRequestMatcher(new AntPathRequestMatcher("/logout"))); 			http.exceptionHandling((exceptions) -> exceptions.accessDeniedPage("/access?error")); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(EndpointRequest.toAnyEndpoint()); 			http.authorizeRequests((requests) -> requests.anyRequest().authenticated()); 			http.httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests((requests) -> { 				requests.antMatchers("/css/**").permitAll(); 				requests.anyRequest().fullyAuthenticated(); 			}); 			http.formLogin((form) -> { 				form.loginPage("/login"); 				form.failureUrl("/login?error").permitAll(); 			}); 			http.logout(LogoutConfigurer::permitAll); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests((requests) -> { 				requests.antMatchers("/css/**").permitAll(); 				requests.anyRequest().fullyAuthenticated(); 			}); 			http.formLogin((form) -> { 				form.loginPage("/login"); 				form.failureUrl("/login?error").permitAll(); 			}); 			http.logout(LogoutConfigurer::permitAll); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests((requests) -> { 				requests.requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll(); 				requests.anyRequest().fullyAuthenticated(); 			}); 			http.formLogin((form) -> { 				form.loginPage("/login"); 				form.failureUrl("/login?error").permitAll(); 			}); 			http.logout(LogoutConfigurer::permitAll); 		}
@Bean 	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 		// @formatter:off 		http.authorizeExchange((exchanges) -> 				exchanges 					.matchers(EndpointRequest.to(HealthEndpoint.class, InfoEndpoint.class)).permitAll() 					.anyExchange().authenticated()) 			.httpBasic(Customizer.withDefaults()) 			.formLogin(Customizer.withDefaults()); 		// @formatter:on 		return http.build(); 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		// @formatter:off 		http.authorizeRequests((requests) -> 				requests 					.requestMatchers(EndpointRequest.to(HealthEndpoint.class, InfoEndpoint.class)).permitAll() 					.anyRequest().authenticated()) 			.formLogin(Customizer.withDefaults()) 			.httpBasic(Customizer.withDefaults()); 		// @formatter:on 	}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			return http 					.authorizeExchange( 							(exchanges) -> exchanges.pathMatchers("/foo").permitAll().anyExchange().authenticated()) 					.formLogin(Customizer.withDefaults()).build(); 		}
private List<SecurityWebFilterChain> getFilterChains(ServerHttpSecurity http) throws Exception { 			return Collections 					.singletonList(http.authorizeExchange((exchanges) -> exchanges.anyExchange().authenticated()) 							.formLogin(Customizer.withDefaults()).build()); 		}
@ReadOperation 		Object getAll() { 			return "endpoint 2"; 		}
@ReadOperation 		Object getAll() { 			return null; 		}
@ReadOperation 		Object getAll() { 			return "endpoint 1"; 		}
@ReadOperation 		Object getAll() { 			return null; 		}
@ReadOperation 		Object getAll() { 			return "endpoint 1"; 		}
@ReadOperation 		Object getAll() { 			return "endpoint 2"; 		}
@Bean 		WebSecurityConfigurerAdapter webSecurityConfigurerAdapter() { 			return new WebSecurityConfigurerAdapter() { 				@Override 				protected void configure(HttpSecurity http) throws Exception { 					// @formatter:off 					http.authorizeRequests((requests) -> requests 							.requestMatchers(EndpointRequest.toLinks()).permitAll() 							.requestMatchers(EndpointRequest.to(TestEndpoint1.class)).permitAll() 							.requestMatchers(EndpointRequest.toAnyEndpoint()).authenticated().anyRequest() 							.hasRole("ADMIN")) 						.httpBasic(); 					// @formatter:on 				} 			}; 		}
@Override 				protected void configure(HttpSecurity http) throws Exception { 					// @formatter:off 					http.authorizeRequests((requests) -> requests 							.requestMatchers(EndpointRequest.toLinks()).permitAll() 							.requestMatchers(EndpointRequest.to(TestEndpoint1.class)).permitAll() 							.requestMatchers(EndpointRequest.toAnyEndpoint()).authenticated().anyRequest() 							.hasRole("ADMIN")) 						.httpBasic(); 					// @formatter:on 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests((requests) -> requests.antMatchers("/foo").permitAll().anyRequest().authenticated()) 					.formLogin(Customizer.withDefaults()).httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests((requests) -> requests.anyRequest().authenticated()) 					.oauth2Login(Customizer.withDefaults()).oauth2Client(); 		}
@Bean 		@ConditionalOnBean(ReactiveJwtDecoder.class) 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http, ReactiveJwtDecoder jwtDecoder) 				throws Exception { 			http.authorizeExchange((exchanges) -> exchanges.anyExchange().authenticated()) 					.oauth2ResourceServer((server) -> server.jwt((jwt) -> jwt.jwtDecoder(jwtDecoder))); 			return http.build(); 		}
@Bean 		@ConditionalOnBean(ReactiveOAuth2TokenIntrospectionClient.class) 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			http.authorizeExchange((exchanges) -> exchanges.anyExchange().authenticated()) 					.oauth2ResourceServer(ServerHttpSecurity.OAuth2ResourceServerSpec::opaqueToken); 			return http.build(); 		}
@Bean 		@ConditionalOnBean(JwtDecoder.class) 		WebSecurityConfigurerAdapter jwtDecoderWebSecurityConfigurerAdapter() { 			return new WebSecurityConfigurerAdapter() { 				@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests((requests) -> requests.anyRequest().authenticated()) 							.oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt); 				} 			}; 		}
@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests((requests) -> requests.anyRequest().authenticated()) 							.oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt); 				}
@Bean 		@ConditionalOnBean(OAuth2TokenIntrospectionClient.class) 		WebSecurityConfigurerAdapter opaqueTokenWebSecurityConfigurerAdapter() { 			return new WebSecurityConfigurerAdapter() { 				@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests((requests) -> requests.anyRequest().authenticated()) 							.oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken); 				} 			}; 		}
@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests((requests) -> requests.anyRequest().authenticated()) 							.oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken); 				}
@Bean 		ReactiveOAuth2TokenIntrospectionClient decoder() { 			return mock(ReactiveOAuth2TokenIntrospectionClient.class); 		}
@Bean 		ReactiveJwtDecoder decoder() { 			return mock(ReactiveJwtDecoder.class); 		}
@Bean 		SecurityWebFilterChain testSpringSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			http.authorizeExchange( 					(exchanges) -> exchanges.pathMatchers("/message/**").hasRole("ADMIN").anyExchange().authenticated()) 					.httpBasic(); 			return http.build(); 		}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			return http.authorizeExchange((exchanges) -> exchanges.anyExchange().permitAll()).build(); 		}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		// @formatter:off 		http.authorizeRequests((requests) -> 				requests 					.mvcMatchers("/actuator/beans").hasRole("BEANS") 					.requestMatchers(EndpointRequest.to("health", "info")).permitAll() 					.requestMatchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)).hasRole("ACTUATOR") 					.requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll() 					.antMatchers("/foo").permitAll() 					.antMatchers("/**").hasRole("USER")) 			.cors(Customizer.withDefaults()) 			.httpBasic(); 		// @formatter:on 	}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeExchange((exchanges) -> 					exchanges 						.matchers(EndpointRequest.to("health", "info")).permitAll() 						.matchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)).hasRole("ACTUATOR") 						.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll() 						.pathMatchers("/login").permitAll() 						.anyExchange().authenticated()) 				.httpBasic(); 			// @formatter:on 			return http.build(); 		}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeExchange((exchanges) -> 					exchanges 						.matchers(EndpointRequest.to("health", "info")).permitAll() 						.matchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)).hasRole("ACTUATOR") 						.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll() 						.pathMatchers("/login").permitAll() 						.anyExchange().authenticated()) 				.httpBasic(Customizer.withDefaults()); 			// @formatter:off 			return http.build(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests((requests) -> 					requests 						.antMatchers("/login").permitAll() 						.anyRequest().fullyAuthenticated()) 				.formLogin((form) -> form.loginPage("/login").failureUrl("/login?error")) 				.logout((logout) -> logout.logoutRequestMatcher(new AntPathRequestMatcher("/logout"))) 				.exceptionHandling((exceptions) -> exceptions.accessDeniedPage("/access?error")); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(EndpointRequest.toAnyEndpoint()) 					.authorizeRequests((requests) -> requests.anyRequest().authenticated()).httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests((requests) -> 					requests 						.antMatchers("/login").permitAll() 						.anyRequest().fullyAuthenticated()) 				.formLogin((form) -> form.loginPage("/login").failureUrl("/login?error")) 				.logout((logout) -> logout.logoutRequestMatcher(new AntPathRequestMatcher("/logout"))) 				.exceptionHandling((exceptions) -> exceptions.accessDeniedPage("/access?error")); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(EndpointRequest.toAnyEndpoint()) 					.authorizeRequests((requests) -> requests.anyRequest().authenticated()).httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests((requests) -> 					requests 						.antMatchers("/css/**").permitAll().anyRequest().fullyAuthenticated()) 				.formLogin((form) -> form.loginPage("/login").failureUrl("/login?error").permitAll()) 				.logout(LogoutConfigurer::permitAll); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests( 					(requests) -> requests.antMatchers("/css/**").permitAll().anyRequest().fullyAuthenticated()) 					.formLogin((form) -> form.loginPage("/login").failureUrl("/login?error").permitAll()) 					.logout(LogoutConfigurer::permitAll); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests((requests) -> 					requests 						.requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll() 						.anyRequest().fullyAuthenticated()) 				.formLogin((form) -> 					form.loginPage("/login").failureUrl("/login?error").permitAll()) 				.logout(LogoutConfigurer::permitAll); 			// @formatter:on 		}
@Test 	public void matchWhenHasNoControllers() throws Exception { 		WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter( 				WithNoControllers.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 	}
@Test 	public void matchWhenHasController() throws Exception { 		WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter( 				WithController.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 	}
@Test 	public void matchNotUsingDefaultFilters() throws Exception { 		WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter( 				NotUsingDefaultFilters.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isTrue(); 		assertThat(excludes(filter, ExampleWeb.class)).isTrue(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 	}
@Test 	public void matchWithIncludeFilter() throws Exception { 		WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter( 				WithIncludeFilter.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isFalse(); 	}
@Test 	public void matchWithExcludeFilter() throws Exception { 		WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter( 				WithExcludeFilter.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 	}
@Test 	public void useSecurityDialect() { 		load(BaseConfiguration.class); 		ISpringWebFluxTemplateEngine engine = this.context 				.getBean(ISpringWebFluxTemplateEngine.class); 		MockServerWebExchange exchange = MockServerWebExchange 				.from(MockServerHttpRequest.get("/test").build()); 		exchange.getAttributes().put( 				SpringSecurityContextUtils.SECURITY_CONTEXT_MODEL_ATTRIBUTE_NAME, 				new SecurityContextImpl( 						new TestingAuthenticationToken("alice", "admin"))); 		IContext attrs = new SpringWebFluxContext(exchange); 		String result = engine.process("security-dialect", attrs); 		assertThat(result).isEqualTo( 				"<html><body><div>alice</div></body></html>" + System.lineSeparator()); 	}
@Test 	public void useSecurityDialect() { 		load(BaseConfiguration.class); 		TemplateEngine engine = this.context.getBean(TemplateEngine.class); 		WebContext attrs = new WebContext(new MockHttpServletRequest(), 				new MockHttpServletResponse(), new MockServletContext()); 		try { 			SecurityContextHolder.setContext(new SecurityContextImpl( 					new TestingAuthenticationToken("alice", "admin"))); 			String result = engine.process("security-dialect", attrs); 			assertThat(result).isEqualTo("<html><body><div>alice</div></body></html>" 					+ System.lineSeparator()); 		} 		finally { 			SecurityContextHolder.clearContext(); 		} 	}
@Bean 		public FilterRegistrationBean<OrderedCharacterEncodingFilter> filterRegistration() { 			return new FilterRegistrationBean<OrderedCharacterEncodingFilter>( 					new OrderedCharacterEncodingFilter()); 		}
@Bean 		public FilterRegistrationBean<ResourceUrlEncodingFilter> filterRegistration() { 			FilterRegistrationBean<ResourceUrlEncodingFilter> bean = new FilterRegistrationBean<ResourceUrlEncodingFilter>( 					new ResourceUrlEncodingFilter()); 			bean.setDispatcherTypes(EnumSet.of(DispatcherType.INCLUDE)); 			return bean; 		}
@ReadOperation 		public Object getAll() { 			return "endpoint 2"; 		}
@ReadOperation 		public Object getAll() { 			return null; 		}
@ReadOperation 		public Object getAll() { 			return "endpoint 1"; 		}
@ReadOperation 		public Object getAll() { 			return null; 		}
@ReadOperation 		public Object getAll() { 			return "endpoint 1"; 		}
@ReadOperation 		public Object getAll() { 			return "endpoint 2"; 		}
@Override 	protected WebApplicationContextRunner getContextRunner() { 		return new WebApplicationContextRunner( 				AnnotationConfigServletWebServerApplicationContext::new) 						.withUserConfiguration(JerseyEndpointConfiguration.class, 								SecurityConfiguration.class, BaseConfiguration.class) 						.withConfiguration(AutoConfigurations.of( 								SecurityAutoConfiguration.class, 								UserDetailsServiceAutoConfiguration.class, 								SecurityRequestMatcherProviderAutoConfiguration.class, 								JacksonAutoConfiguration.class, 								JerseyAutoConfiguration.class)); 	}
@Override 	protected WebApplicationContextRunner getContextRunner() { 		return new WebApplicationContextRunner( 				AnnotationConfigServletWebServerApplicationContext::new) 						.withUserConfiguration(WebMvcEndpointConfiguration.class, 								SecurityConfiguration.class, BaseConfiguration.class) 						.withConfiguration(AutoConfigurations.of( 								SecurityAutoConfiguration.class, 								UserDetailsServiceAutoConfiguration.class, 								WebMvcAutoConfiguration.class, 								SecurityRequestMatcherProviderAutoConfiguration.class, 								JacksonAutoConfiguration.class, 								HttpMessageConvertersAutoConfiguration.class, 								DispatcherServletAutoConfiguration.class)); 	}
private void load() { 		this.context = new AnnotationConfigServletWebServerApplicationContext(); 		this.context.register(MockWebServerConfiguration.class, 				TestSessionConfiguration.class, TestRedisConfiguration.class, 				WebMvcAutoConfiguration.class, SecurityAutoConfiguration.class, 				SessionAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class, 				HttpEncodingAutoConfiguration.class); 		this.context.refresh(); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests() 					.anyRequest().authenticated() 					.and() 				.httpBasic(); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.antMatchers("/login").permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error") 					.and() 				.logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout")) 					.and() 				.exceptionHandling().accessDeniedPage("/access?error"); 			// @formatter:on 		}
@Override 		protected RequestMatcher createDelegate(WebApplicationContext context, 				RequestMatcherFactory requestMatcherFactory) { 			WebEndpointProperties properties = context 					.getBean(WebEndpointProperties.class); 			String basePath = properties.getBasePath(); 			if (StringUtils.hasText(basePath)) { 				return new OrRequestMatcher(getLinksMatchers(requestMatcherFactory, 						getRequestMatcherProvider(context), basePath)); 			} 			return EMPTY_MATCHER; 		}
@Override 		protected RequestMatcher createDelegate(WebApplicationContext context, 				RequestMatcherFactory requestMatcherFactory) { 			PathMappedEndpoints pathMappedEndpoints = context 					.getBean(PathMappedEndpoints.class); 			RequestMatcherProvider matcherProvider = getRequestMatcherProvider(context); 			Set<String> paths = new LinkedHashSet<>(); 			if (this.includes.isEmpty()) { 				paths.addAll(pathMappedEndpoints.getAllPaths()); 			} 			streamPaths(this.includes, pathMappedEndpoints).forEach(paths::add); 			streamPaths(this.excludes, pathMappedEndpoints).forEach(paths::remove); 			List<RequestMatcher> delegateMatchers = getDelegateMatchers( 					requestMatcherFactory, matcherProvider, paths); 			String basePath = pathMappedEndpoints.getBasePath(); 			if (this.includeLinks && StringUtils.hasText(basePath)) { 				delegateMatchers.addAll(getLinksMatchers(requestMatcherFactory, 						matcherProvider, basePath)); 			} 			return new OrRequestMatcher(delegateMatchers); 		}
private void load() { 		this.context = new AnnotationConfigServletWebServerApplicationContext(); 		this.context.register(MockWebServerConfiguration.class, 				TestSessionConfiguration.class, TestRedisConfiguration.class, 				WebMvcAutoConfiguration.class, SecurityAutoConfiguration.class, 				ServletWebSecurityAutoConfiguration.class, SessionAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class, 				HttpEncodingAutoConfiguration.class); 		this.context.refresh(); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests() 					.anyRequest().authenticated() 					.and() 				.httpBasic(); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.antMatchers("/login").permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error") 					.and() 				.logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout")) 					.and() 				.exceptionHandling().accessDeniedPage("/access?error"); 			// @formatter:on 		}
@Bean 		@ConditionalOnMissingBean(ISpringWebFluxTemplateEngine.class) 		public SpringWebFluxTemplateEngine templateEngine() { 			SpringWebFluxTemplateEngine engine = new SpringWebFluxTemplateEngine(); 			engine.setEnableSpringELCompiler(this.properties.isEnableSpringElCompiler()); 			this.templateResolvers.forEach(engine::addTemplateResolver); 			this.dialects.orderedStream().forEach(engine::addDialect); 			return engine; 		}
@Bean 		@ConditionalOnMissingBean 		public SpringTemplateEngine templateEngine() { 			SpringTemplateEngine engine = new SpringTemplateEngine(); 			engine.setEnableSpringELCompiler(this.properties.isEnableSpringElCompiler()); 			this.templateResolvers.forEach(engine::addTemplateResolver); 			this.dialects.orderedStream().forEach(engine::addDialect); 			return engine; 		}
@Override 	protected Set<Class<?>> getDefaultIncludes() { 		if (this.annotation.secure()) { 			if (ObjectUtils.isEmpty(this.annotation.controllers())) { 				return DEFAULT_INCLUDES_SECURITY_CONFIGURER_AND_CONTROLLER; 			} 			return DEFAULT_INCLUDES_AND_SECURITY_CONFIGURER; 		} 		if (ObjectUtils.isEmpty(this.annotation.controllers())) { 			return DEFAULT_INCLUDES_AND_CONTROLLER; 		} 		return DEFAULT_INCLUDES; 	}
@Test 	public void matchWhenHasNoControllers() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				WithNoControllers.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); 	}
@Test 	public void matchWhenHasController() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				WithController.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); 	}
@Test 	public void matchNotUsingDefaultFilters() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				NotUsingDefaultFilters.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isTrue(); 		assertThat(excludes(filter, ExampleWeb.class)).isTrue(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isTrue(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isTrue(); 	}
@Test 	public void matchWithExcludeFilter() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				WithExcludeFilter.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); 	}
public String getProvider() { 			return this.provider; 		}
@Deprecated 		public String getRedirectUriTemplate() { 			return getRedirectUri(); 		}
public Map<String, Provider> getProvider() { 		return this.provider; 	}
private void addProperties( 			Map.Entry<String, OAuth2ClientProperties.LoginClientRegistration> entry, 			ConfigurationPropertySource source, Map<String, Object> map) { 		OAuth2ClientProperties.LoginClientRegistration registration = entry.getValue(); 		String registrationId = entry.getKey(); 		addProperty(registrationId, "client-id", registration::getClientId, map, source); 		addProperty(registrationId, "client-secret", registration::getClientSecret, map, 				source); 		addProperty(registrationId, "client-name", registration::getClientName, map, 				source); 		addProperty(registrationId, "redirect-uri-template", registration::getRedirectUri, 				map, source); 		addProperty(registrationId, "authorization-grant-type", 				registration::getAuthorizationGrantType, map, source); 		addProperty(registrationId, "client-authentication-method", 				registration::getClientAuthenticationMethod, map, source); 		addProperty(registrationId, "provider", registration::getProvider, map, source); 		addProperty(registrationId, "scope", registration::getScope, map, source); 	}
private static ClientRegistration getLoginClientRegistration(String registrationId, 			OAuth2ClientProperties.LoginClientRegistration properties, 			Map<String, Provider> providers) { 		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 		Builder builder = getBuilder(map, registrationId, properties, providers); 		map.from(properties::getRedirectUri).to(builder::redirectUriTemplate); 		return builder.build(); 	}
@Test 	public void getClientRegistrationsWhenUsingDefinedProviderShouldAdapt() { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		Provider provider = new Provider(); 		provider.setAuthorizationUri("http://example.com/auth"); 		provider.setTokenUri("http://example.com/token"); 		provider.setUserInfoUri("http://example.com/info"); 		provider.setUserInfoAuthenticationMethod("form"); 		provider.setUserNameAttribute("sub"); 		provider.setJwkSetUri("http://example.com/jwk"); 		OAuth2ClientProperties.LoginClientRegistration login = new OAuth2ClientProperties.LoginClientRegistration(); 		login.setProvider("provider"); 		login.setClientId("clientId"); 		login.setClientSecret("clientSecret"); 		login.setClientAuthenticationMethod("post"); 		login.setAuthorizationGrantType("authorization_code"); 		login.setRedirectUri("http://example.com/redirect"); 		login.setScope(Collections.singleton("scope")); 		login.setClientName("clientName"); 		properties.getRegistration().getLogin().put("registration", login); 		properties.getProvider().put("provider", provider); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("registration"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("http://example.com/auth"); 		assertThat(adaptedProvider.getTokenUri()).isEqualTo("http://example.com/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("http://example.com/info"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getAuthenticationMethod()) 				.isEqualTo( 						org.springframework.security.oauth2.core.AuthenticationMethod.FORM); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUserNameAttributeName()) 				.isEqualTo("sub"); 		assertThat(adaptedProvider.getJwkSetUri()).isEqualTo("http://example.com/jwk"); 		assertThat(adapted.getRegistrationId()).isEqualTo("registration"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.POST); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUriTemplate()) 				.isEqualTo("http://example.com/redirect"); 		assertThat(adapted.getScopes()).containsExactly("scope"); 		assertThat(adapted.getClientName()).isEqualTo("clientName"); 	}
@Test 	public void getClientRegistrationsWhenUsingCommonProviderWithOverrideShouldAdapt() { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		OAuth2ClientProperties.LoginClientRegistration login = new OAuth2ClientProperties.LoginClientRegistration(); 		login.setProvider("google"); 		login.setClientId("clientId"); 		login.setClientSecret("clientSecret"); 		login.setClientAuthenticationMethod("post"); 		login.setAuthorizationGrantType("authorization_code"); 		login.setRedirectUri("http://example.com/redirect"); 		login.setScope(Collections.singleton("scope")); 		login.setClientName("clientName"); 		properties.getRegistration().getLogin().put("registration", login); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("registration"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("https://accounts.google.com/o/oauth2/v2/auth"); 		assertThat(adaptedProvider.getTokenUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v4/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/userinfo"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUserNameAttributeName()) 				.isEqualTo(IdTokenClaimNames.SUB); 		assertThat(adaptedProvider.getUserInfoEndpoint().getAuthenticationMethod()) 				.isEqualTo( 						org.springframework.security.oauth2.core.AuthenticationMethod.HEADER); 		assertThat(adaptedProvider.getJwkSetUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/certs"); 		assertThat(adapted.getRegistrationId()).isEqualTo("registration"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.POST); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUriTemplate()) 				.isEqualTo("http://example.com/redirect"); 		assertThat(adapted.getScopes()).containsExactly("scope"); 		assertThat(adapted.getClientName()).isEqualTo("clientName"); 	}
@Test 	public void oidcProviderConfigurationWithCustomConfigurationOverridesProviderDefaults() 			throws Exception { 		this.server = new MockWebServer(); 		this.server.start(); 		String issuer = this.server.url("").toString(); 		String cleanIssuerPath = cleanIssuerPath(issuer); 		setupMockResponse(cleanIssuerPath); 		OAuth2ClientProperties.LoginClientRegistration login = new OAuth2ClientProperties.LoginClientRegistration(); 		login.setProvider("okta-oidc"); 		login.setClientId("clientId"); 		login.setClientSecret("clientSecret"); 		login.setClientAuthenticationMethod("post"); 		login.setRedirectUri("http://example.com/redirect"); 		login.setScope(Collections.singleton("user")); 		Provider provider = new Provider(); 		provider.setIssuerUri(issuer); 		provider.setAuthorizationUri("http://example.com/auth"); 		provider.setTokenUri("http://example.com/token"); 		provider.setUserInfoUri("http://example.com/info"); 		provider.setUserNameAttribute("sub"); 		provider.setJwkSetUri("http://example.com/jwk"); 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		properties.getProvider().put("okta-oidc", provider); 		properties.getRegistration().getLogin().put("okta", login); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("okta"); 		ProviderDetails providerDetails = adapted.getProviderDetails(); 		assertThat(adapted.getClientAuthenticationMethod()) 				.isEqualTo(ClientAuthenticationMethod.POST); 		assertThat(adapted.getAuthorizationGrantType()) 				.isEqualTo(AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRegistrationId()).isEqualTo("okta"); 		assertThat(adapted.getClientName()).isEqualTo(cleanIssuerPath); 		assertThat(adapted.getScopes()).containsOnly("user"); 		assertThat(adapted.getRedirectUriTemplate()) 				.isEqualTo("http://example.com/redirect"); 		assertThat(providerDetails.getAuthorizationUri()) 				.isEqualTo("http://example.com/auth"); 		assertThat(providerDetails.getTokenUri()).isEqualTo("http://example.com/token"); 		assertThat(providerDetails.getJwkSetUri()).isEqualTo("http://example.com/jwk"); 		assertThat(providerDetails.getUserInfoEndpoint().getUri()) 				.isEqualTo("http://example.com/info"); 		assertThat(providerDetails.getUserInfoEndpoint().getUserNameAttributeName()) 				.isEqualTo("sub"); 	}
@Test 	public void testHiddenHttpMethodFilterOrderedFirst() throws Exception { 		this.context = SpringApplication.run(DenyPostRequestConfig.class, 				"--server.port=0"); 		int port = Integer 				.parseInt(this.context.getEnvironment().getProperty("local.server.port")); 		TestRestTemplate rest = new TestRestTemplate();  		// not overriding causes forbidden 		MultiValueMap<String, String> form = new LinkedMultiValueMap<String, String>();  		ResponseEntity<Object> result = rest 				.postForEntity("http://localhost:" + port + "/", form, Object.class); 		assertThat(result.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);  		// override method with DELETE 		form = new LinkedMultiValueMap<String, String>(); 		form.add("_method", "DELETE");  		result = rest.postForEntity("http://localhost:" + port + "/", form, Object.class); 		assertThat(result.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().mvcMatchers(HttpMethod.POST, "/**").denyAll().and() 					.csrf().disable(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().denyAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().mvcMatchers(HttpMethod.POST, "/**").denyAll().and() 					.csrf().disable(); 		}
public static EndpointServerWebExchangeMatcher toAnyEndpoint() { 		return new EndpointServerWebExchangeMatcher(true); 	}
public static EndpointServerWebExchangeMatcher to(Class<?>... endpoints) { 		return new EndpointServerWebExchangeMatcher(endpoints, false); 	}
public static EndpointServerWebExchangeMatcher to(String... endpoints) { 		return new EndpointServerWebExchangeMatcher(endpoints, false); 	}
public EndpointServerWebExchangeMatcher excluding(Class<?>... endpoints) { 			List<Object> excludes = new ArrayList<>(this.excludes); 			excludes.addAll(Arrays.asList((Object[]) endpoints)); 			return new EndpointServerWebExchangeMatcher(this.includes, excludes, this.includeLinks); 		}
public EndpointServerWebExchangeMatcher excluding(String... endpoints) { 			List<Object> excludes = new ArrayList<>(this.excludes); 			excludes.addAll(Arrays.asList((Object[]) endpoints)); 			return new EndpointServerWebExchangeMatcher(this.includes, excludes, this.includeLinks); 		}
private ServerWebExchangeMatcher createDelegate( 				PathMappedEndpoints pathMappedEndpoints) { 			Set<String> paths = new LinkedHashSet<>(); 			if (this.includes.isEmpty()) { 				paths.addAll(pathMappedEndpoints.getAllPaths()); 			} 			streamPaths(this.includes, pathMappedEndpoints).forEach(paths::add); 			streamPaths(this.excludes, pathMappedEndpoints).forEach(paths::remove); 			List<ServerWebExchangeMatcher> delegateMatchers = getDelegateMatchers(paths); 			if (this.includeLinks && StringUtils.hasText(pathMappedEndpoints.getBasePath())) { 				delegateMatchers.add(new PathPatternParserServerWebExchangeMatcher(pathMappedEndpoints.getBasePath())); 			} 			return new OrServerWebExchangeMatcher(delegateMatchers); 		}
public static EndpointRequestMatcher toAnyEndpoint() { 		return new EndpointRequestMatcher(true); 	}
public static EndpointRequestMatcher to(Class<?>... endpoints) { 		return new EndpointRequestMatcher(endpoints, false); 	}
public static EndpointRequestMatcher to(String... endpoints) { 		return new EndpointRequestMatcher(endpoints, false); 	}
public EndpointRequestMatcher excluding(Class<?>... endpoints) { 			List<Object> excludes = new ArrayList<>(this.excludes); 			excludes.addAll(Arrays.asList((Object[]) endpoints)); 			return new EndpointRequestMatcher(this.includes, excludes, this.includeLinks); 		}
public EndpointRequestMatcher excluding(String... endpoints) { 			List<Object> excludes = new ArrayList<>(this.excludes); 			excludes.addAll(Arrays.asList((Object[]) endpoints)); 			return new EndpointRequestMatcher(this.includes, excludes, this.includeLinks); 		}
private RequestMatcher createDelegate(PathMappedEndpoints pathMappedEndpoints) { 			Set<String> paths = new LinkedHashSet<>(); 			if (this.includes.isEmpty()) { 				paths.addAll(pathMappedEndpoints.getAllPaths()); 			} 			streamPaths(this.includes, pathMappedEndpoints).forEach(paths::add); 			streamPaths(this.excludes, pathMappedEndpoints).forEach(paths::remove); 			List<RequestMatcher> delegateMatchers = getDelegateMatchers(paths); 			if (this.includeLinks && StringUtils.hasText(pathMappedEndpoints.getBasePath())) { 				delegateMatchers.add(new AntPathRequestMatcher(pathMappedEndpoints.getBasePath())); 			} 			return new OrRequestMatcher(delegateMatchers); 		}
@Test 	public void toAnyEndpointShouldMatchEndpointPath() { 		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint(); 		assertMatcher(matcher).matches("/actuator/foo"); 		assertMatcher(matcher).matches("/actuator/bar"); 		assertMatcher(matcher).matches("/actuator"); 	}
@Test 	public void excludeByClassShouldNotMatchExcluded() { 		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint() 				.excluding(FooEndpoint.class); 		assertMatcher(matcher).doesNotMatch("/actuator/foo"); 		assertMatcher(matcher).matches("/actuator/bar"); 		assertMatcher(matcher).matches("/actuator"); 	}
@Test 	public void excludeByIdShouldNotMatchExcluded() { 		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint() 				.excluding("foo"); 		assertMatcher(matcher).doesNotMatch("/actuator/foo"); 		assertMatcher(matcher).matches("/actuator/bar"); 		assertMatcher(matcher).matches("/actuator"); 	}
@Test 	public void noEndpointPathsBeansShouldNeverMatch() { 		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint(); 		assertMatcher(matcher, (PathMappedEndpoints) null).doesNotMatch("/actuator/foo"); 		assertMatcher(matcher, (PathMappedEndpoints) null).doesNotMatch("/actuator/bar"); 	}
private RequestMatcherAssert assertMatcher(ServerWebExchangeMatcher matcher) { 		return assertMatcher(matcher, mockPathMappedEndpoints("/actuator")); 	}
private RequestMatcherAssert assertMatcher(ServerWebExchangeMatcher matcher, 			PathMappedEndpoints pathMappedEndpoints) { 		StaticApplicationContext context = new StaticApplicationContext(); 		context.registerBean(WebEndpointProperties.class); 		if (pathMappedEndpoints != null) { 			context.registerBean(PathMappedEndpoints.class, () -> pathMappedEndpoints); 			WebEndpointProperties properties = context.getBean(WebEndpointProperties.class); 			if (!properties.getBasePath().equals(pathMappedEndpoints.getBasePath())) { 				properties.setBasePath(pathMappedEndpoints.getBasePath()); 			} 		} 		return assertThat(new RequestMatcherAssert(context, matcher)); 	}
@Test 	public void toAnyEndpointShouldMatchEndpointPath() { 		RequestMatcher matcher = EndpointRequest.toAnyEndpoint(); 		assertMatcher(matcher).matches("/actuator/foo"); 		assertMatcher(matcher).matches("/actuator/bar"); 		assertMatcher(matcher).matches("/actuator"); 	}
@Test 	public void toEndpointClassShouldNotMatchOtherPath() { 		RequestMatcher matcher = EndpointRequest.to(FooEndpoint.class); 		assertMatcher(matcher).doesNotMatch("/actuator/bar"); 		assertMatcher(matcher).doesNotMatch("/actuator"); 	}
@Test 	public void toEndpointIdShouldNotMatchOtherPath() { 		RequestMatcher matcher = EndpointRequest.to("foo"); 		assertMatcher(matcher).doesNotMatch("/actuator/bar"); 		assertMatcher(matcher).doesNotMatch("/actuator"); 	}
@Test 	public void excludeByClassShouldNotMatchExcluded() { 		RequestMatcher matcher = EndpointRequest.toAnyEndpoint() 				.excluding(FooEndpoint.class); 		assertMatcher(matcher).doesNotMatch("/actuator/foo"); 		assertMatcher(matcher).matches("/actuator/bar"); 		assertMatcher(matcher).matches("/actuator"); 	}
@Test 	public void excludeByIdShouldNotMatchExcluded() { 		RequestMatcher matcher = EndpointRequest.toAnyEndpoint().excluding("foo"); 		assertMatcher(matcher).doesNotMatch("/actuator/foo"); 		assertMatcher(matcher).matches("/actuator/bar"); 		assertMatcher(matcher).matches("/actuator"); 	}
@Test 	public void noEndpointPathsBeansShouldNeverMatch() { 		RequestMatcher matcher = EndpointRequest.toAnyEndpoint(); 		assertMatcher(matcher, (PathMappedEndpoints) null).doesNotMatch("/actuator/foo"); 		assertMatcher(matcher, (PathMappedEndpoints) null).doesNotMatch("/actuator/bar"); 	}
private RequestMatcherAssert assertMatcher(RequestMatcher matcher) { 		return assertMatcher(matcher, mockPathMappedEndpoints("/actuator")); 	}
private RequestMatcherAssert assertMatcher(RequestMatcher matcher, 			PathMappedEndpoints pathMappedEndpoints) { 		StaticWebApplicationContext context = new StaticWebApplicationContext(); 		context.registerBean(WebEndpointProperties.class); 		if (pathMappedEndpoints != null) { 			context.registerBean(PathMappedEndpoints.class, () -> pathMappedEndpoints); 			WebEndpointProperties properties = context.getBean(WebEndpointProperties.class); 			if (!properties.getBasePath().equals(pathMappedEndpoints.getBasePath())) { 				properties.setBasePath(pathMappedEndpoints.getBasePath()); 			} 		} 		return assertThat(new RequestMatcherAssert(context, matcher)); 	}
@SuppressWarnings("unchecked") 	private Supplier<C> createContext(ServerWebExchange exchange) { 		ApplicationContext context = exchange.getApplicationContext(); 		Assert.state(context != null, "No WebApplicationContext found."); 		if (this.contextClass.isInstance(context)) { 			return () -> (C) context; 		} 		return () -> context.getBean(this.contextClass); 	}
@SuppressWarnings("unchecked") 	private Supplier<C> createContext(HttpServletRequest request) { 		WebApplicationContext context = WebApplicationContextUtils 				.getRequiredWebApplicationContext(request.getServletContext()); 		if (this.contextClass.isInstance(context)) { 			return () -> (C) context; 		} 		return () -> context.getBean(this.contextClass); 	}
@Test 	public void matchesWhenContextClassIsApplicationContextShouldProvideContext() { 		ServerWebExchange exchange = createHttpWebHandlerAdapter(); 		StaticApplicationContext context = (StaticApplicationContext) exchange 				.getApplicationContext(); 		assertThat(new TestApplicationContextServerWebExchangeMatcher<>( 				ApplicationContext.class).callMatchesAndReturnProvidedContext(exchange) 						.get()).isEqualTo(context); 	}
@Test 	public void matchesWhenContextClassIsExistingBeanShouldProvideBean() { 		ServerWebExchange exchange = createHttpWebHandlerAdapter(); 		StaticApplicationContext context = (StaticApplicationContext) exchange 				.getApplicationContext(); 		context.registerSingleton("existingBean", ExistingBean.class); 		assertThat( 				new TestApplicationContextServerWebExchangeMatcher<>(ExistingBean.class) 						.callMatchesAndReturnProvidedContext(exchange).get()) 								.isEqualTo(context.getBean(ExistingBean.class)); 	}
@Test 	public void matchesWhenContextClassIsApplicationContextShouldProvideContext() { 		StaticWebApplicationContext context = createWebApplicationContext(); 		assertThat(new TestApplicationContextRequestMatcher<>(ApplicationContext.class) 				.callMatchesAndReturnProvidedContext(context).get()).isEqualTo(context); 	}
@Test 	public void matchesWhenContextClassIsExistingBeanShouldProvideBean() { 		StaticWebApplicationContext context = createWebApplicationContext(); 		context.registerSingleton("existingBean", ExistingBean.class); 		assertThat(new TestApplicationContextRequestMatcher<>(ExistingBean.class) 				.callMatchesAndReturnProvidedContext(context).get()) 						.isEqualTo(context.getBean(ExistingBean.class)); 	}
@Test 	public void getEndpointsShouldAddCloudFoundryHealthExtension() { 		load(TestConfiguration.class, (discoverer) -> { 			Collection<ExposableWebEndpoint> endpoints = discoverer.getEndpoints(); 			assertThat(endpoints.size()).isEqualTo(2); 			for (ExposableWebEndpoint endpoint : endpoints) { 				if (endpoint.getId().equals("health")) { 					WebOperation operation = endpoint.getOperations().iterator().next(); 					assertThat(operation.invoke(new InvocationContext( 							mock(SecurityContext.class), Collections.emptyMap()))) 									.isEqualTo("cf"); 				} 			} 		}); 	}
@ReadOperation 		public Object getAll() { 			return "cf"; 		}
@ReadOperation 		public Object getAll() { 			return "cf"; 		}
@ReadOperation 		public Object getAll() { 			return "cf"; 		}
@ReadOperation 		public Object getAll() { 			return null; 		}
@ReadOperation 		public Object getAll() { 			return null; 		}
@ReadOperation 		public Object getAll() { 			return null; 		}
@Test 	public void runWithCustomHealthMappingShouldMapStatusCode() { 		this.contextRunner 				.withPropertyValues("management.health.status.http-mapping.CUSTOM=500") 				.run((context) -> { 					Object extension = context.getBean(HealthEndpointWebExtension.class); 					HealthWebEndpointResponseMapper responseMapper = (HealthWebEndpointResponseMapper) ReflectionTestUtils 							.getField(extension, "responseMapper"); 					Class<SecurityContext> securityContext = SecurityContext.class; 					assertThat(responseMapper 							.map(Health.down().build(), mock(securityContext)) 							.getStatus()).isEqualTo(503); 					assertThat(responseMapper.map(Health.status("OUT_OF_SERVICE").build(), 							mock(securityContext)).getStatus()).isEqualTo(503); 					assertThat(responseMapper 							.map(Health.status("CUSTOM").build(), mock(securityContext)) 							.getStatus()).isEqualTo(500); 				}); 	}
@Test 	public void unauthenticatedUsersAreNotShownDetailsByDefault() { 		this.contextRunner.run((context) -> { 			HealthEndpointWebExtension extension = context 					.getBean(HealthEndpointWebExtension.class); 			assertThat(extension.getHealth(mock(SecurityContext.class)).getBody() 					.getDetails()).isEmpty(); 		}); 	}
@Test 	public void authenticatedUsersAreShownDetailsByDefault() { 		this.contextRunner.run((context) -> { 			HealthEndpointWebExtension extension = context 					.getBean(HealthEndpointWebExtension.class); 			SecurityContext securityContext = mock(SecurityContext.class); 			given(securityContext.getPrincipal()).willReturn(mock(Principal.class)); 			assertThat(extension.getHealth(securityContext).getBody().getDetails()) 					.isNotEmpty(); 		}); 	}
@Test 	public void detailsCanBeHiddenFromAuthenticatedUsers() { 		this.contextRunner 				.withPropertyValues("management.endpoint.health.show-details=never") 				.run((context) -> { 					HealthEndpointWebExtension extension = context 							.getBean(HealthEndpointWebExtension.class); 					assertThat(extension.getHealth(mock(SecurityContext.class)).getBody() 							.getDetails()).isEmpty(); 				}); 	}
@Test 	public void runWithCustomHealthMappingShouldMapStatusCode() { 		this.contextRunner 				.withPropertyValues("management.health.status.http-mapping.CUSTOM=500") 				.run((context) -> { 					Object extension = context 							.getBean(ReactiveHealthEndpointWebExtension.class); 					HealthWebEndpointResponseMapper responseMapper = (HealthWebEndpointResponseMapper) ReflectionTestUtils 							.getField(extension, "responseMapper"); 					Class<SecurityContext> securityContext = SecurityContext.class; 					assertThat(responseMapper 							.map(Health.down().build(), mock(securityContext)) 							.getStatus()).isEqualTo(503); 					assertThat(responseMapper.map(Health.status("OUT_OF_SERVICE").build(), 							mock(securityContext)).getStatus()).isEqualTo(503); 					assertThat(responseMapper 							.map(Health.status("CUSTOM").build(), mock(securityContext)) 							.getStatus()).isEqualTo(500); 				}); 	}
@Test 	public void regularAndReactiveHealthIndicatorsMatch() { 		this.contextRunner.withUserConfiguration(HealthIndicatorsConfiguration.class) 				.run((context) -> { 					HealthEndpoint endpoint = context.getBean(HealthEndpoint.class); 					ReactiveHealthEndpointWebExtension extension = context 							.getBean(ReactiveHealthEndpointWebExtension.class); 					Health endpointHealth = endpoint.health(); 					SecurityContext securityContext = mock(SecurityContext.class); 					given(securityContext.getPrincipal()) 							.willReturn(mock(Principal.class)); 					Health extensionHealth = extension.health(securityContext).block() 							.getBody(); 					assertThat(endpointHealth.getDetails()) 							.containsOnlyKeys("application", "first", "second"); 					assertThat(extensionHealth.getDetails()) 							.containsOnlyKeys("application", "first", "second"); 				}); 	}
@Test 	public void unauthenticatedUsersAreNotShownDetailsByDefault() { 		this.contextRunner.run((context) -> { 			ReactiveHealthEndpointWebExtension extension = context 					.getBean(ReactiveHealthEndpointWebExtension.class); 			assertThat(extension.health(mock(SecurityContext.class)).block().getBody() 					.getDetails()).isEmpty(); 		}); 	}
@Test 	public void authenticatedUsersAreShownDetailsByDefault() { 		this.contextRunner.run((context) -> { 			ReactiveHealthEndpointWebExtension extension = context 					.getBean(ReactiveHealthEndpointWebExtension.class); 			SecurityContext securityContext = mock(SecurityContext.class); 			given(securityContext.getPrincipal()).willReturn(mock(Principal.class)); 			assertThat(extension.health(securityContext).block().getBody().getDetails()) 					.isNotEmpty(); 		}); 	}
@Test 	public void detailsCanBeHiddenFromAuthenticatedUsers() { 		this.contextRunner 				.withPropertyValues("management.endpoint.health.show-details=never") 				.run((context) -> { 					ReactiveHealthEndpointWebExtension extension = context 							.getBean(ReactiveHealthEndpointWebExtension.class); 					SecurityContext securityContext = mock(SecurityContext.class); 					assertThat(extension.health(securityContext).block().getBody() 							.getDetails()).isEmpty(); 				}); 	}
private boolean isMissing(InvocationContext context, OperationParameter parameter) { 		if (!parameter.isMandatory()) { 			return false; 		} 		if (Principal.class.equals(parameter.getType())) { 			return context.getSecurityContext().getPrincipal() == null; 		} 		if (SecurityContext.class.equals(parameter.getType())) { 			return false; 		} 		return context.getArguments().get(parameter.getName()) == null; 	}
private Object resolveArgument(OperationParameter parameter, 			InvocationContext context) { 		if (Principal.class.equals(parameter.getType())) { 			return context.getSecurityContext().getPrincipal(); 		} 		if (SecurityContext.class.equals(parameter.getType())) { 			return context.getSecurityContext(); 		} 		Object value = context.getArguments().get(parameter.getName()); 		return this.parameterValueMapper.mapParameterValue(parameter, value); 	}
private boolean hasInput(InvocationContext context) { 		if (context.getSecurityContext().getPrincipal() != null) { 			return true; 		} 		Map<String, Object> arguments = context.getArguments(); 		if (!ObjectUtils.isEmpty(arguments)) { 			return arguments.values().stream().anyMatch(Objects::nonNull); 		} 		return false; 	}
private Object invoke(JmxOperation operation, Object[] params) { 		try { 			String[] parameterNames = operation.getParameters().stream() 					.map(JmxOperationParameter::getName).toArray(String[]::new); 			Map<String, Object> arguments = getArguments(parameterNames, params); 			Object result = operation 					.invoke(new InvocationContext(new JmxSecurityContext(), arguments)); 			if (REACTOR_PRESENT) { 				result = ReactiveHandler.handle(result); 			} 			return this.responseMapper.mapResponse(result); 		} 		catch (InvalidEndpointRequestException ex) { 			throw new IllegalArgumentException(ex.getMessage(), ex); 		} 	}
@Override 		public Response apply(ContainerRequestContext data) { 			Map<String, Object> arguments = new HashMap<>(); 			if (this.readBody) { 				arguments.putAll(extractBodyArguments(data)); 			} 			arguments.putAll(extractPathParameters(data)); 			arguments.putAll(extractQueryParameters(data)); 			try { 				Object response = this.operation.invoke(new InvocationContext( 						new JerseySecurityContext(data.getSecurityContext()), arguments)); 				return convertToJaxRsResponse(response, data.getRequest().getMethod()); 			} 			catch (InvalidEndpointRequestException ex) { 				return Response.status(Status.BAD_REQUEST).build(); 			} 		}
@Override 		public Object apply(Object body) { 			if (body instanceof Mono) { 				return ((Mono<?>) body).block(); 			} 			return body; 		}
@Override 		public Object apply(Object body) { 			if (body instanceof org.springframework.core.io.Resource) { 				try { 					return ((org.springframework.core.io.Resource) body).getInputStream(); 				} 				catch (IOException ex) { 					throw new IllegalStateException(); 				} 			} 			return body; 		}
@Override 		public Mono<ResponseEntity<Object>> handle(ServerWebExchange exchange, 				Map<String, String> body) { 			Map<String, Object> arguments = getArguments(exchange, body); 			return this.securityContextSupplier.get() 					.map((securityContext) -> new InvocationContext(securityContext, 							arguments)) 					.flatMap((invocationContext) -> handleResult( 							(Publisher<?>) this.invoker.invoke(invocationContext), 							exchange.getRequest().getMethod())); 		}
@Override 		public Object handle(HttpServletRequest request, 				@RequestBody(required = false) Map<String, String> body) { 			Map<String, Object> arguments = getArguments(request, body); 			try { 				return handleResult( 						this.invoker.invoke(new InvocationContext( 								new ServletSecurityContext(request), arguments)), 						HttpMethod.valueOf(request.getMethod())); 			} 			catch (InvalidEndpointRequestException ex) { 				throw new BadOperationRequestException(ex.getReason()); 			} 		}
@ResponseBody 		public Object handle(HttpServletRequest request, 				@RequestBody(required = false) Map<String, String> body) { 			return this.operation.handle(request, body); 		}
@Override 		public Object handle(HttpServletRequest request, 				@RequestBody(required = false) Map<String, String> body) { 			Map<String, Object> arguments = getArguments(request, body); 			try { 				return handleResult( 						this.invoker.invoke(new InvocationContext( 								new ServletSecurityContext(request), arguments)), 						HttpMethod.valueOf(request.getMethod())); 			} 			catch (InvalidEndpointRequestException ex) { 				throw new BadOperationRequestException(ex.getReason()); 			} 		}
@Test 	public void createOperationsShouldProviderInvoker() { 		TestOperation operation = getFirst( 				this.factory.createOperations("test", new ExampleWithParams())); 		Map<String, Object> params = Collections.singletonMap("name", 123); 		Object result = operation 				.invoke(new InvocationContext(mock(SecurityContext.class), params)); 		assertThat(result).isEqualTo("123"); 	}
@Test 	public void createOperationShouldApplyAdvisors() { 		TestOperationInvokerAdvisor advisor = new TestOperationInvokerAdvisor(); 		this.invokerAdvisors.add(advisor); 		TestOperation operation = getFirst( 				this.factory.createOperations("test", new ExampleRead())); 		operation.invoke(new InvocationContext(mock(SecurityContext.class), 				Collections.emptyMap())); 		assertThat(advisor.getEndpointId()).isEqualTo("test"); 		assertThat(advisor.getOperationType()).isEqualTo(OperationType.READ); 		assertThat(advisor.getParameters()).isEmpty(); 	}
@Test 	public void invokeShouldInvokeMethod() { 		ReflectiveOperationInvoker invoker = new ReflectiveOperationInvoker(this.target, 				this.operationMethod, this.parameterValueMapper); 		Object result = invoker.invoke(new InvocationContext(mock(SecurityContext.class), 				Collections.singletonMap("name", "boot"))); 		assertThat(result).isEqualTo("toob"); 	}
@Test 	public void invokeWhenMissingNonNullableArgumentShouldThrowException() { 		ReflectiveOperationInvoker invoker = new ReflectiveOperationInvoker(this.target, 				this.operationMethod, this.parameterValueMapper); 		this.thrown.expect(MissingParametersException.class); 		invoker.invoke(new InvocationContext(mock(SecurityContext.class), 				Collections.singletonMap("name", null))); 	}
@Test 	public void invokeWhenMissingNullableArgumentShouldInvoke() { 		OperationMethod operationMethod = new OperationMethod(ReflectionUtils.findMethod( 				Example.class, "reverseNullable", String.class), OperationType.READ); 		ReflectiveOperationInvoker invoker = new ReflectiveOperationInvoker(this.target, 				operationMethod, this.parameterValueMapper); 		Object result = invoker.invoke(new InvocationContext(mock(SecurityContext.class), 				Collections.singletonMap("name", null))); 		assertThat(result).isEqualTo("llun"); 	}
@Test 	public void invokeShouldResolveParameters() { 		ReflectiveOperationInvoker invoker = new ReflectiveOperationInvoker(this.target, 				this.operationMethod, this.parameterValueMapper); 		Object result = invoker.invoke(new InvocationContext(mock(SecurityContext.class), 				Collections.singletonMap("name", 1234))); 		assertThat(result).isEqualTo("4321"); 	}
private void assertCacheIsUsed(Map<String, Object> parameters) { 		OperationInvoker target = mock(OperationInvoker.class); 		Object expected = new Object(); 		InvocationContext context = new InvocationContext(mock(SecurityContext.class), 				parameters); 		given(target.invoke(context)).willReturn(expected); 		CachingOperationInvoker invoker = new CachingOperationInvoker(target, 500L); 		Object response = invoker.invoke(context); 		assertThat(response).isSameAs(expected); 		verify(target, times(1)).invoke(context); 		Object cachedResponse = invoker.invoke(context); 		assertThat(cachedResponse).isSameAs(response); 		verifyNoMoreInteractions(target); 	}
@Test 	public void targetAlwaysInvokedWithArguments() { 		OperationInvoker target = mock(OperationInvoker.class); 		Map<String, Object> parameters = new HashMap<>(); 		parameters.put("test", "value"); 		parameters.put("something", null); 		InvocationContext context = new InvocationContext(mock(SecurityContext.class), 				parameters); 		given(target.invoke(context)).willReturn(new Object()); 		CachingOperationInvoker invoker = new CachingOperationInvoker(target, 500L); 		invoker.invoke(context); 		invoker.invoke(context); 		invoker.invoke(context); 		verify(target, times(3)).invoke(context); 	}
@Test 	public void targetInvokedWhenCacheExpires() throws InterruptedException { 		OperationInvoker target = mock(OperationInvoker.class); 		Map<String, Object> parameters = new HashMap<>(); 		InvocationContext context = new InvocationContext(mock(SecurityContext.class), 				parameters); 		given(target.invoke(context)).willReturn(new Object()); 		CachingOperationInvoker invoker = new CachingOperationInvoker(target, 50L); 		invoker.invoke(context); 		Thread.sleep(55); 		invoker.invoke(context); 		verify(target, times(2)).invoke(context); 	}
@Bean 		public MonoResponseEndpoint testEndpoint(EndpointDelegate endpointDelegate) { 			return new MonoResponseEndpoint(); 		}
@Bean 		public QueryWithListEndpoint queryEndpoint() { 			return new QueryWithListEndpoint(); 		}
@Bean 		public QueryEndpoint queryEndpoint() { 			return new QueryEndpoint(); 		}
@Bean 		public ResourceWebEndpointResponseEndpoint resourceEndpoint() { 			return new ResourceWebEndpointResponseEndpoint(); 		}
@Bean 		public ResourceEndpoint resourceEndpoint() { 			return new ResourceEndpoint(); 		}
@Bean 		public TestEndpoint testEndpoint(EndpointDelegate endpointDelegate) { 			return new TestEndpoint(endpointDelegate); 		}
@WriteOperation 		public Object write() { 			this.delegate.write(); 			return null; 		}
@WriteOperation 		public void write() { 			this.delegate.write(); 		}
@ReadOperation 		public WebEndpointResponse<Resource> read() { 			return new WebEndpointResponse<>( 					new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }), 					200); 		}
@ReadOperation(produces = "text/plain") 		public String read() { 			return "read"; 		}
@ReadOperation 		public Resource read() { 			return new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }); 		}
@ReadOperation(produces = "text/plain") 		public String read() { 			return "read"; 		}
@ReadOperation 		public Resource read() { 			return new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }); 		}
@ReadOperation 		public WebEndpointResponse<Resource> read() { 			return new WebEndpointResponse<>( 					new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }), 					200); 		}
@Bean 		public Filter securityFilter() { 			return new OncePerRequestFilter() {  				@Override 				protected void doFilterInternal(HttpServletRequest request, 						HttpServletResponse response, FilterChain filterChain) 						throws ServletException, IOException { 					SecurityContext context = SecurityContextHolder.createEmptyContext(); 					context.setAuthentication(new UsernamePasswordAuthenticationToken( 							"Alice", "secret", 							Arrays.asList(new SimpleGrantedAuthority("ROLE_ACTUATOR")))); 					SecurityContextHolder.setContext(context); 					try { 						filterChain.doFilter(new SecurityContextHolderAwareRequestWrapper( 								request, "ROLE_"), response); 					} 					finally { 						SecurityContextHolder.clearContext(); 					} 				}  			}; 		}
@Override 				protected void doFilterInternal(HttpServletRequest request, 						HttpServletResponse response, FilterChain filterChain) 						throws ServletException, IOException { 					SecurityContext context = SecurityContextHolder.createEmptyContext(); 					context.setAuthentication(new UsernamePasswordAuthenticationToken( 							"Alice", "secret", 							Arrays.asList(new SimpleGrantedAuthority("ROLE_ACTUATOR")))); 					SecurityContextHolder.setContext(context); 					try { 						filterChain.doFilter(new SecurityContextHolderAwareRequestWrapper( 								request, "ROLE_"), response); 					} 					finally { 						SecurityContextHolder.clearContext(); 					} 				}
@Bean 		public WebFilter webFilter() { 			return new WebFilter() {  				@Override 				public Mono<Void> filter(ServerWebExchange exchange, 						WebFilterChain chain) { 					return chain.filter(exchange).subscriberContext( 							ReactiveSecurityContextHolder.withAuthentication( 									new UsernamePasswordAuthenticationToken("Alice", 											"secret", 											Arrays.asList(new SimpleGrantedAuthority( 													"ROLE_ACTUATOR"))))); 				}  			}; 		}
@Override 				public Mono<Void> filter(ServerWebExchange exchange, 						WebFilterChain chain) { 					return chain.filter(exchange).subscriberContext( 							ReactiveSecurityContextHolder.withAuthentication( 									new UsernamePasswordAuthenticationToken("Alice", 											"secret", 											Arrays.asList(new SimpleGrantedAuthority( 													"ROLE_ACTUATOR"))))); 				}
@Bean 		public Filter securityFilter() { 			return new OncePerRequestFilter() {  				@Override 				protected void doFilterInternal(HttpServletRequest request, 						HttpServletResponse response, FilterChain filterChain) 						throws ServletException, IOException { 					SecurityContext context = SecurityContextHolder.createEmptyContext(); 					context.setAuthentication(new UsernamePasswordAuthenticationToken( 							"Alice", "secret", 							Arrays.asList(new SimpleGrantedAuthority("ROLE_ACTUATOR")))); 					SecurityContextHolder.setContext(context); 					try { 						filterChain.doFilter(new SecurityContextHolderAwareRequestWrapper( 								request, "ROLE_"), response); 					} 					finally { 						SecurityContextHolder.clearContext(); 					} 				}  			}; 		}
@Override 				protected void doFilterInternal(HttpServletRequest request, 						HttpServletResponse response, FilterChain filterChain) 						throws ServletException, IOException { 					SecurityContext context = SecurityContextHolder.createEmptyContext(); 					context.setAuthentication(new UsernamePasswordAuthenticationToken( 							"Alice", "secret", 							Arrays.asList(new SimpleGrantedAuthority("ROLE_ACTUATOR")))); 					SecurityContextHolder.setContext(context); 					try { 						filterChain.doFilter(new SecurityContextHolderAwareRequestWrapper( 								request, "ROLE_"), response); 					} 					finally { 						SecurityContextHolder.clearContext(); 					} 				}
@Bean 		public HealthEndpointWebExtension healthWebEndpointExtension( 				Map<String, HealthIndicator> healthIndicators) { 			return new HealthEndpointWebExtension( 					new CompositeHealthIndicatorFactory().createHealthIndicator( 							new OrderedHealthAggregator(), healthIndicators), 					new HealthWebEndpointResponseMapper(new HealthStatusHttpMapper(), 							ShowDetails.ALWAYS, 							new HashSet<>(Arrays.asList("ACTUATOR")))); 		}
@Test 	public void excludeFromSetWhenSetIsNullShouldThrowException() { 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("Locations must not be null"); 		this.resourceRequest.atCommonLocations().excluding(null); 	}
@Bean 		public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { 			http.authorizeExchange().matchers(EndpointRequest.to("health", "info")) 					.permitAll().matchers(EndpointRequest.toAnyEndpoint()) 					.hasRole("ACTUATOR") 					.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll() 					.pathMatchers("/login").permitAll().anyExchange().authenticated() 					.and().httpBasic(); 			return http.build(); 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return endpoint.isSensitive(); 			}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return endpoint.isSensitive(); 			}
@Test 	public void securityConfigurerBacksOffWhenOtherWebSecurityAdapterPresent() 			throws Exception { 		this.contextRunner 				.withUserConfiguration(TestWebSecurityConfigurerConfig.class, 						OAuth2WebSecurityConfiguration.class) 				.run((context) -> { 					assertThat(getAuthCodeFilters(context)).isEmpty(); 					assertThat(context).getBean(OAuth2AuthorizedClientService.class).isNotNull(); 				}); 	}
@Test 	public void getClientRegistrationsWhenUsingCommonProviderShouldAdapt() 			throws Exception { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		Registration registration = new Registration(); 		registration.setProvider("google"); 		registration.setClientId("clientId"); 		registration.setClientSecret("clientSecret"); 		properties.getRegistration().put("registration", registration); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("registration"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("https://accounts.google.com/o/oauth2/v2/auth"); 		assertThat(adaptedProvider.getTokenUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v4/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/userinfo"); 		assertThat(adaptedProvider.getJwkSetUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/certs"); 		assertThat(adapted.getRegistrationId()).isEqualTo("registration"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.BASIC); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUri()).isEqualTo( 				"{scheme}://{serverName}:{serverPort}{contextPath}/login/oauth2/code/{registrationId}"); 		assertThat(adapted.getScopes()).containsExactly("openid", "profile", "email", 				"address", "phone"); 		assertThat(adapted.getClientName()).isEqualTo("Google"); 	}
@Test 	public void getClientRegistrationsWhenProviderNotSpecifiedShouldUseRegistrationId() 			throws Exception { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		Registration registration = new Registration(); 		registration.setClientId("clientId"); 		registration.setClientSecret("clientSecret"); 		properties.getRegistration().put("google", registration); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("google"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("https://accounts.google.com/o/oauth2/v2/auth"); 		assertThat(adaptedProvider.getTokenUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v4/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/userinfo"); 		assertThat(adaptedProvider.getJwkSetUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/certs"); 		assertThat(adapted.getRegistrationId()).isEqualTo("google"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.BASIC); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUri()).isEqualTo( 				"{scheme}://{serverName}:{serverPort}{contextPath}/login/oauth2/code/{registrationId}"); 		assertThat(adapted.getScopes()).containsExactly("openid", "profile", "email", 				"address", "phone"); 		assertThat(adapted.getClientName()).isEqualTo("Google"); 	}
private static Builder getBuilder(String registrationId, String configuredProviderId, 			Map<String, Provider> providers) { 		String providerId = (configuredProviderId == null ? registrationId : configuredProviderId); 		CommonOAuth2Provider provider = getCommonProvider(providerId); 		if (provider == null && !providers.containsKey(providerId)) { 			throw new IllegalStateException(getErrorMessage(configuredProviderId, registrationId)); 		} 		Builder builder = (provider != null ? provider.getBuilder(registrationId) 				: ClientRegistration.withRegistrationId(registrationId)); 		if (providers.containsKey(providerId)) { 			return getBuilder(builder, providers.get(providerId)); 		} 		return builder; 	}
@Test 	public void getClientRegistrationsWhenUsingDefinedProviderShouldAdapt() 			throws Exception { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		Provider provider = new Provider(); 		provider.setAuthorizationUri("http://example.com/auth"); 		provider.setTokenUri("http://example.com/token"); 		provider.setUserInfoUri("http://example.com/info"); 		provider.setJwkSetUri("http://example.com/jwk"); 		Registration registration = new Registration(); 		registration.setProvider("provider"); 		registration.setClientId("clientId"); 		registration.setClientSecret("clientSecret"); 		registration.setClientAuthenticationMethod("post"); 		registration.setAuthorizationGrantType("authorization_code"); 		registration.setRedirectUri("http://example.com/redirect"); 		registration.setScope(Collections.singleton("scope")); 		registration.setClientName("clientName"); 		properties.getProvider().put("provider", provider); 		properties.getRegistration().put("registration", registration); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("registration"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("http://example.com/auth"); 		assertThat(adaptedProvider.getTokenUri()).isEqualTo("http://example.com/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("http://example.com/info"); 		assertThat(adaptedProvider.getJwkSetUri()).isEqualTo("http://example.com/jwk"); 		assertThat(adapted.getRegistrationId()).isEqualTo("registration"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.POST); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUri()).isEqualTo("http://example.com/redirect"); 		assertThat(adapted.getScopes()).containsExactly("scope"); 		assertThat(adapted.getClientName()).isEqualTo("clientName"); 	}
@Test 	public void getClientRegistrationsWhenUsingCommonProviderShouldAdapt() 			throws Exception { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		Registration registration = new Registration(); 		registration.setProvider("google"); 		registration.setClientId("clientId"); 		registration.setClientSecret("clientSecret"); 		properties.getRegistration().put("registration", registration); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("registration"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("https://accounts.google.com/o/oauth2/v2/auth"); 		assertThat(adaptedProvider.getTokenUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v4/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/userinfo"); 		assertThat(adaptedProvider.getJwkSetUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/certs"); 		assertThat(adapted.getRegistrationId()).isEqualTo("registration"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.BASIC); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUri()).isEqualTo( 				"{scheme}://{serverName}:{serverPort}{contextPath}/oauth2/authorize/code/{registrationId}"); 		assertThat(adapted.getScopes()).containsExactly("openid", "profile", "email", 				"address", "phone"); 		assertThat(adapted.getClientName()).isEqualTo("Google"); 	}
@Test 	public void getClientRegistrationsWhenUsingCommonProviderWithOverrideShouldAdapt() 			throws Exception { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		Registration registration = new Registration(); 		registration.setProvider("google"); 		registration.setClientId("clientId"); 		registration.setClientSecret("clientSecret"); 		registration.setClientAuthenticationMethod("post"); 		registration.setAuthorizationGrantType("authorization_code"); 		registration.setRedirectUri("http://example.com/redirect"); 		registration.setScope(Collections.singleton("scope")); 		registration.setClientName("clientName"); 		properties.getRegistration().put("registration", registration); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("registration"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("https://accounts.google.com/o/oauth2/v2/auth"); 		assertThat(adaptedProvider.getTokenUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v4/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/userinfo"); 		assertThat(adaptedProvider.getJwkSetUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/certs"); 		assertThat(adapted.getRegistrationId()).isEqualTo("registration"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.POST); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUri()).isEqualTo("http://example.com/redirect"); 		assertThat(adapted.getScopes()).containsExactly("scope"); 		assertThat(adapted.getClientName()).isEqualTo("clientName"); 	}
@Test 	public void getClientRegistrationsWhenProviderNotSpecifiedShouldUseRegistrationId() 			throws Exception { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		Registration registration = new Registration(); 		registration.setClientId("clientId"); 		registration.setClientSecret("clientSecret"); 		properties.getRegistration().put("google", registration); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("google"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("https://accounts.google.com/o/oauth2/v2/auth"); 		assertThat(adaptedProvider.getTokenUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v4/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/userinfo"); 		assertThat(adaptedProvider.getJwkSetUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/certs"); 		assertThat(adapted.getRegistrationId()).isEqualTo("google"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.BASIC); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUri()).isEqualTo( 				"{scheme}://{serverName}:{serverPort}{contextPath}/oauth2/authorize/code/{registrationId}"); 		assertThat(adapted.getScopes()).containsExactly("openid", "profile", "email", 				"address", "phone"); 		assertThat(adapted.getClientName()).isEqualTo("Google"); 	}
@SuppressWarnings("unchecked") 	private List<Filter> getAuthCodeFilters(AssertableApplicationContext context) { 		FilterChainProxy filterChain = (FilterChainProxy) context 				.getBean("springSecurityFilterChain"); 		List<SecurityFilterChain> filterChains = filterChain.getFilterChains(); 		List<Filter> filters = (List<Filter>) ReflectionTestUtils 				.getField(filterChains.get(0), "filters"); 		List<Filter> oauth2Filters = filters.stream() 				.filter((f) -> f instanceof AuthorizationCodeAuthenticationFilter 						|| f instanceof AuthorizationRequestRedirectFilter) 				.collect(Collectors.toList()); 		return oauth2Filters.stream() 				.filter((f) -> f instanceof AuthorizationCodeAuthenticationFilter) 				.collect(Collectors.toList()); 	}
private boolean isEqual(ClientRegistration reg1, ClientRegistration reg2) { 		boolean result = ObjectUtils.nullSafeEquals(reg1.getClientId(), 				reg2.getClientId()); 		result = result 				&& ObjectUtils.nullSafeEquals(reg1.getClientName(), reg2.getClientName()); 		result = result && ObjectUtils.nullSafeEquals(reg1.getClientSecret(), 				reg2.getClientSecret()); 		result = result && ObjectUtils.nullSafeEquals(reg1.getScopes(), reg2.getScopes()); 		result = result && ObjectUtils.nullSafeEquals(reg1.getRedirectUri(), 				reg2.getRedirectUri()); 		result = result && ObjectUtils.nullSafeEquals(reg1.getRegistrationId(), 				reg2.getRegistrationId()); 		result = result && ObjectUtils.nullSafeEquals(reg1.getAuthorizationGrantType(), 				reg2.getAuthorizationGrantType()); 		result = result && ObjectUtils.nullSafeEquals( 				reg1.getProviderDetails().getAuthorizationUri(), 				reg2.getProviderDetails().getAuthorizationUri()); 		result = result && ObjectUtils.nullSafeEquals( 				reg1.getProviderDetails().getUserInfoEndpoint(), 				reg2.getProviderDetails().getUserInfoEndpoint()); 		result = result 				&& ObjectUtils.nullSafeEquals(reg1.getProviderDetails().getTokenUri(), 						reg2.getProviderDetails().getTokenUri()); 		return result; 	}
private ClientRegistration getClientRegistration(String id, String userInfoUri) { 			ClientRegistration.Builder builder = ClientRegistration.withRegistrationId(id); 			builder.clientName("foo").clientId("foo") 					.clientAuthenticationMethod( 							org.springframework.security.oauth2.core.ClientAuthenticationMethod.BASIC) 					.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) 					.scope("read").clientSecret("secret") 					.redirectUri("http://redirect-uri.com") 					.authorizationUri("http://authorization-uri.com") 					.tokenUri("http://token-uri.com").userInfoUri(userInfoUri) 					.userNameAttributeName("login"); 			return builder.build(); 		}
@Test 	public void enablesWebFluxSecurity() { 		this.contextRunner.withUserConfiguration(TestConfig.class) 				.withConfiguration( 						AutoConfigurations.of(ReactiveSecurityAutoConfiguration.class)) 				.run((context) -> { 					assertThat(context).getBean(ServerHttpSecurityConfiguration.class) 							.isNotNull(); 					assertThat(context).getBean(WebFluxSecurityConfiguration.class) 							.isNotNull(); 					assertThat(context).getBean(WebFilterChainProxy.class).isNotNull(); 				}); 	}
@Test 	public void configuresADefaultUser() { 		this.contextRunner.withUserConfiguration(TestConfig.class) 				.withConfiguration( 						AutoConfigurations.of(ReactiveSecurityAutoConfiguration.class)) 				.run((context) -> { 					ReactiveUserDetailsService userDetailsService = context 							.getBean(ReactiveUserDetailsService.class); 					assertThat(userDetailsService.findByUsername("user").block()) 							.isNotNull(); 				}); 	}
@Test 	public void doesNotConfigureDefaultUserIfUserDetailsRepositoryAvailable() { 		this.contextRunner.withUserConfiguration(UserConfig.class, TestConfig.class) 				.withConfiguration( 						AutoConfigurations.of(ReactiveSecurityAutoConfiguration.class)) 				.run((context) -> { 					ReactiveUserDetailsService userDetailsService = context 							.getBean(ReactiveUserDetailsService.class); 					assertThat(userDetailsService.findByUsername("user").block()) 							.isNull(); 					assertThat(userDetailsService.findByUsername("foo").block()) 							.isNotNull(); 					assertThat(userDetailsService.findByUsername("admin").block()) 							.isNotNull(); 				}); 	}
@Test 	public void doesNotConfigureDefaultUserIfAuthenticationManagerAvailable() { 		this.contextRunner 				.withUserConfiguration(AuthenticationManagerConfig.class, 						TestConfig.class) 				.withConfiguration( 						AutoConfigurations.of(ReactiveSecurityAutoConfiguration.class)) 				.run((context) -> assertThat(context).getBean(ReactiveUserDetailsService.class) 						.isNull()); 	}
@Bean 	public ReactiveUserDetailsService userDetailsRepository() { 		return new MapReactiveUserDetailsService( 				User.withUsername("foo").password("password").roles("USER").build()); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests() 					.anyRequest().authenticated() 					.and() 				.httpBasic(); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.antMatchers("/login").permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error") 					.and() 				.logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout")) 					.and() 				.exceptionHandling().accessDeniedPage("/access?error"); 			// @formatter:on 		}
@Bean 	@ConditionalOnBean(name = DEFAULT_FILTER_NAME) 	public DelegatingFilterProxyRegistrationBean securityFilterChainRegistration( 			SecurityProperties securityProperties) { 		DelegatingFilterProxyRegistrationBean registration = new DelegatingFilterProxyRegistrationBean( 				DEFAULT_FILTER_NAME); 		registration.setOrder(securityProperties.getFilter().getOrder()); 		registration.setDispatcherTypes(getDispatcherTypes(securityProperties)); 		return registration; 	}
private EnumSet<DispatcherType> getDispatcherTypes( 			SecurityProperties securityProperties) { 		if (securityProperties.getFilter().getDispatcherTypes() == null) { 			return null; 		} 		return securityProperties.getFilter().getDispatcherTypes().stream() 				.map((type) -> DispatcherType.valueOf(type.name())).collect(Collectors 						.collectingAndThen(Collectors.toSet(), EnumSet::copyOf)); 	}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		public FilterRegistrationBean<OAuth2ClientContextFilter> oauth2ClientFilterRegistration( 				OAuth2ClientContextFilter filter, SecurityProperties security) { 			FilterRegistrationBean<OAuth2ClientContextFilter> registration = new FilterRegistrationBean<>(); 			registration.setFilter(filter); 			registration.setOrder(security.getFilter().getOrder() - 10); 			return registration; 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Test 	public void testCustomFilterOrder() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		TestPropertyValues.of("spring.security.filter.order:12345").applyTo(this.context); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				SecurityFilterAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertThat(this.context.getBean("securityFilterChainRegistration", 				DelegatingFilterProxyRegistrationBean.class).getOrder()).isEqualTo(12345); 	}
@Test 	public void customFilterDispatcherTypes() { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				SecurityFilterAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		TestPropertyValues.of("spring.security.filter.dispatcher-types:INCLUDE,ERROR") 				.applyTo(this.context); 		this.context.refresh(); 		DelegatingFilterProxyRegistrationBean bean = this.context.getBean( 				"securityFilterChainRegistration", 				DelegatingFilterProxyRegistrationBean.class); 		@SuppressWarnings("unchecked") 		EnumSet<DispatcherType> dispatcherTypes = (EnumSet<DispatcherType>) ReflectionTestUtils 				.getField(bean, "dispatcherTypes"); 		assertThat(dispatcherTypes).containsOnly(DispatcherType.INCLUDE, 				DispatcherType.ERROR); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.userDetails = http.getSharedObject(UserDetailsService.class); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.authenticationManager = (authentication) -> this.builder.getOrBuild() 					.authenticate(authentication); 		}
@Test 	public void testBinding() { 		bind("spring.security.filter.order", "55"); 		assertThat(this.security.getFilter().getOrder()).isEqualTo(55); 	}
private void bind(ConfigurationPropertySource source) { 		new Binder(source).bind("spring.security", Bindable.ofInstance(this.security)); 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		// @formatter:off 		http.authorizeRequests() 				.requestMatchers(EndpointRequest.to("status", "info")).permitAll() 				.requestMatchers(EndpointRequest.toAnyEndpoint()).hasRole("ACTUATOR") 				.requestMatchers(StaticResourceRequest.toCommonLocations()).permitAll() 				.antMatchers("/foo").permitAll() 				.antMatchers("/**").hasRole("USER") 				.and() 			.cors() 				.and() 			.httpBasic(); 		// @formatter:on 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		// @formatter:off 		http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests() 				.antMatchers("/**").authenticated() 				.and() 			.httpBasic(); 		// @formatter:on 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests() 					.anyRequest().authenticated() 					.and() 				.httpBasic(); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.antMatchers("/login").permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error") 					.and() 				.logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout")) 					.and() 				.exceptionHandling().accessDeniedPage("/access?error"); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests() 					.anyRequest().authenticated() 					.and() 				.httpBasic(); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.requestMatchers(StaticResourceRequest.toCommonLocations()).permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error").permitAll() 					.and() 				.logout().permitAll(); 			// @formatter:on 		}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		// FIXME 		// @formatter:off //		http.authorizeRequests() //				.requestMatchers(endpointIds("status", "info")).permitAll() //				.requestMatchers(endpointIds(SpringBootSecurity.ALL_ENDPOINTS)).hasRole("ACTUATOR") //				.requestMatchers(staticResources()).permitAll() //				.antMatchers("/foo").permitAll() //				.antMatchers("/**").hasRole("USER") //				.and() //			.cors() //				.and() //			.httpBasic(); 		// @formatter:on 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		// FIXME 		// @formatter:off //		http.requestMatcher(ALL_ENDPOINTS).authorizeRequests() //				.antMatchers("/**").authenticated() //				.and() //			.httpBasic(); 		// @formatter:on 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// FIXME 			// http.requestMatcher(ALL_ENDPOINTS) 			// .authorizeRequests().anyRequest().authenticated().and().httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.antMatchers("/login").permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error") 					.and() 				.logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout")) 					.and() 				.exceptionHandling().accessDeniedPage("/access?error"); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// FIXME 			// http.requestMatcher(ALL_ENDPOINTS) 			// .authorizeRequests().anyRequest().authenticated().and().httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// FIXME 			// @formatter:off //			http.authorizeRequests() //					.requestMatchers(staticResources()).permitAll() //					.anyRequest().fullyAuthenticated() //					.and() //				.formLogin().loginPage("/login").failureUrl("/login?error").permitAll() //					.and() //				.logout().permitAll(); 			// @formatter:on 		}
@Override 	protected void configure(HttpSecurity http) throws Exception {  		// @formatter:off 		http.authorizeRequests() 				.requestMatchers(this.bootSecurity.endpointIds("status", "info")).permitAll() 				.requestMatchers(this.bootSecurity.endpointIds(SpringBootSecurity.ALL_ENDPOINTS)).hasRole("ACTUATOR") 				.requestMatchers(this.bootSecurity.staticResources()).permitAll() 				.antMatchers("/foo").permitAll() 				.antMatchers("/**").hasRole("USER") 				.and() 			.cors() 				.and() 			.httpBasic(); 		// @formatter:on 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		// @formatter:off 		http.requestMatcher(this.springBootSecurity.endpointIds(SpringBootSecurity.ALL_ENDPOINTS)).authorizeRequests() 				.antMatchers("/**").authenticated() 				.and() 			.httpBasic(); 		// @formatter:on 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.antMatchers("/login").permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error") 					.and() 				.logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout")) 					.and() 				.exceptionHandling().accessDeniedPage("/access?error"); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher( 					this.springBootSecurity.endpointIds(SpringBootSecurity.ALL_ENDPOINTS)) 					.authorizeRequests().anyRequest().authenticated().and().httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.antMatchers("/login").permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error") 					.and() 				.logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout")) 					.and() 				.exceptionHandling().accessDeniedPage("/access?error"); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.requestMatchers(this.springBootSecurity.staticResources()).permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error").permitAll() 					.and() 				.logout().permitAll(); 			// @formatter:on 		}
@Test 	public void endpointsAreSecureByDefault() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(SecureConfiguration.class); 		MockMvc mockMvc = createSecureMockMvc(); 		mockMvc.perform(get("/application/beans") 				.accept(MediaType.APPLICATION_JSON)).andExpect(status().isUnauthorized()); 	}
@Test 	public void endpointsAreSecureByDefaultWithCustomContextPath() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(SecureConfiguration.class); 		TestPropertyValues.of("management.context-path:/management") 				.applyTo(this.context); 		MockMvc mockMvc = createSecureMockMvc(); 		mockMvc.perform(get("/management/beans") 				.accept(MediaType.APPLICATION_JSON)).andExpect(status().isUnauthorized()); 	}
@Test 	public void endpointsAreSecureWithActuatorRoleWithCustomContextPath() 			throws Exception { 		TestSecurityContextHolder.getContext().setAuthentication( 				new TestingAuthenticationToken("user", "N/A", "ROLE_ACTUATOR")); 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(SecureConfiguration.class); 		TestPropertyValues.of("management.context-path:/management", 				"endpoints.all.web.enabled=true") 				.applyTo(this.context); 		MockMvc mockMvc = createSecureMockMvc(); 		mockMvc.perform(get("/management/beans")).andExpect(status().isOk()); 	}
@Override 			public void configure(HttpSecurity http) throws Exception { 				String path = this.console.getPath(); 				String antPattern = (path.endsWith("/") ? path + "**" : path + "/**"); 				HttpSecurity h2Console = http.antMatcher(antPattern); 				h2Console.csrf().disable(); 				h2Console.httpBasic(); 				h2Console.headers().frameOptions().sameOrigin(); 				http.authorizeRequests().anyRequest().authenticated(); 			}
@Override 		public void configure(AuthenticationManagerBuilder auth) throws Exception { 			if (auth.isConfigured()) { 				return; 			} 			String password = UUID.randomUUID().toString(); 			logger.info(String.format("%n%nUsing default security password: %s%n", 					password)); 			withUser("user").password(password) 					.roles(); 			setField(auth, "defaultUserDetailsService", getUserDetailsService()); 			super.configure(auth); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			super.configure(http); 			http.csrf().disable(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			super.configure(http); 			http.csrf().disable(); 		}
@Test 	public void noPrincipal() throws Exception { 		MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context) 				.apply(springSecurity()).build(); 		mockMvc.perform(get("/h2-console/").accept(MediaType.APPLICATION_JSON)).andExpect(status().isUnauthorized()); 	}
@Test 	public void userPrincipal() throws Exception { 		MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context) 				.apply(springSecurity()).build(); 		mockMvc.perform(get("/h2-console/").accept(MediaType.APPLICATION_JSON).with(user("test").roles("USER"))) 				.andExpect(status().isOk()) 				.andExpect(header().string("X-Frame-Options", "SAMEORIGIN")); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertThat(this.context.getBean(AuthenticationManagerBuilder.class)).isNotNull(); 		assertThat(this.context.getBean(FilterChainProxy.class).getFilterChains()) 				.hasSize(1); 	}
@Test 	public void testDefaultUsernamePassword() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class); 		this.context.refresh(); 		String password = this.outputCapture.toString().split("Using default security password: ")[1].split("\n")[0]; 		AuthenticationManager manager = this.context.getBean(AuthenticationManager.class); 		UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken( 				"user", password); 		assertThat(manager.authenticate(token)).isNotNull(); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.userDetails = http.getSharedObject(UserDetailsService.class); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.authenticationManager = (authentication) -> this.builder.getOrBuild() 					.authenticate(authentication); 		}
@Test 	public void testSecurityFilterDoesNotCauseEarlyInitialization() throws Exception { 		try (AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext()) { 			TestPropertyValues.of("server.port:0") 					.applyTo(context); 			context.register(Config.class); 			context.refresh(); 			int port = context.getWebServer().getPort(); 			String password = this.outputCapture.toString().split("Using default security password: ")[1].split("\n")[0]; 			new TestRestTemplate("user", password) 					.getForEntity("http://localhost:" + port, Object.class); 			// If early initialization occurred a ConverterNotFoundException is thrown  		} 	}
@Test 	public void requiresAuthentication() throws Exception { 		this.request.addHeader("Accept", "application/json"); 		this.springSecurityFilterChain.doFilter(this.request, this.response, this.chain); 		assertThat(this.response.getStatus()) 				.isEqualTo(HttpServletResponse.SC_UNAUTHORIZED); 	}
@Test 	public void userAuthenticates() throws Exception { 		this.request.addHeader("Accept", "application/json"); 		this.request.addHeader("Authorization", "Basic " + new String( 				Base64.getEncoder().encode("user:password".getBytes("UTF-8"))));  		this.springSecurityFilterChain.doFilter(this.request, this.response, this.chain);  		assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_OK); 	}
@Test 	public void validateLoggersEndpoint() throws Exception { 		this.mvc.perform(get("/application/loggers/org.apache.coyote.http11.Http11NioProtocol") 		.header("Authorization", "Basic " + getBasicAuth())) 				.andExpect(status().isOk()) 				.andExpect(content().string(equalTo("{\"configuredLevel\":\"WARN\"," 						+ "\"effectiveLevel\":\"WARN\"}"))); 	}
private String getPassword() { 		return "password"; 	}
@Test 	public void testHome() throws Exception { 		HttpHeaders headers = new HttpHeaders(); 		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML)); 		ResponseEntity<String> entity = this.restTemplate.withBasicAuth("user", getPassword()) 				.exchange("/", HttpMethod.GET, 				new HttpEntity<Void>(headers), String.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK); 		assertThat(entity.getBody()).contains("<title>Hello"); 	}
@Test 	public void testError() throws Exception { 		HttpHeaders headers = new HttpHeaders(); 		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML)); 		ResponseEntity<String> entity = this.restTemplate.withBasicAuth("user", getPassword()) 				.exchange("/error", 				HttpMethod.GET, new HttpEntity<Void>(headers), String.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 		assertThat(entity.getBody()).contains("<html>").contains("<body>") 				.contains("Please contact the operator with the above information"); 	}
private String getPassword() { 		return "password"; 	}
private String getPassword() { 		return "password"; 	}
private String getPassword() { 		return "password"; 	}
@Test 	public void testErrorPage() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = new TestRestTemplate("user", getPassword()) 				.getForEntity("http://localhost:" + this.port + "/error", Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertThat(body.get("status")).isEqualTo(999); 	}
@Test 	public void testManagementErrorPage() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = new TestRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:" + this.managementPort + "/error", Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertThat(body.get("status")).isEqualTo(999); 	}
private String getPassword() { 		return "password"; 	}
@Test 	public void testErrorPage() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = new TestRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:" + this.managementPort + "/error", Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertThat(body.get("status")).isEqualTo(999); 	}
private String getPassword() { 		return "password"; 	}
private String getPassword() { 		return "password"; 	}
@Test 	public void testErrorPageDirectAccess() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = this.restTemplate.withBasicAuth("user", getPassword()) 				.getForEntity("/error", Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertThat(body.get("error")).isEqualTo("None"); 		assertThat(body.get("status")).isEqualTo(999); 	}
private String getPassword() { 		return "password"; 	}
@Test 	public void testErrorPath() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = this.restTemplate.withBasicAuth("user", getPassword()) 				.getForEntity("/spring/error", 				Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertThat(body.get("error")).isEqualTo("None"); 		assertThat(body.get("status")).isEqualTo(999); 	}
private String getPassword() { 		return "password"; 	}
private String getPassword() { 		return "password"; 	}
@Before 	public void init() { 		this.authentication = new UsernamePasswordAuthenticationToken("user", "password"); 	}
@Test 	public void testHomeIsSecure() throws Exception { 		HttpHeaders headers = new HttpHeaders(); 		headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON)); 		ResponseEntity<String> entity = this.restTemplate.exchange("/", HttpMethod.GET, new HttpEntity<Void>(headers), String.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED); 	}
private String getPassword() { 		return "password"; 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http 				.requestMatcher(this.springBootSecurity.endpointIds(SpringBootSecurity.ALL_ENDPOINTS)) 				.authorizeRequests().anyRequest().authenticated() 					.and() 				.httpBasic(); 		}
@Test 	public void testManagementProtected() throws Exception { 		HttpHeaders headers = new HttpHeaders(); 		headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON)); 		ResponseEntity<String> entity = this.restTemplate 				.exchange("/application/beans", HttpMethod.GET, new HttpEntity<Void>(headers), String.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests() 					.requestMatchers(this.springBootSecurity.staticResources()).permitAll() 					.anyRequest().fullyAuthenticated().and().formLogin() 					.loginPage("/login").failureUrl("/login?error").permitAll().and() 					.logout().permitAll(); 		}
@Test 	public void unauthorizedResponseWithNoUser() throws Exception { 		this.mockMvc.perform(get("/") 				.accept(MediaType.APPLICATION_JSON)).andExpect(status().isUnauthorized()); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// secure endpoints 			RequestMatcher matcher = getRequestMatcher(); 			if (matcher != null) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				// Match all the requests for actuator endpoints ... 				http.requestMatcher(matcher); 				// ... but permitAll() for the non-sensitive ones 				configurePermittedRequests(http.authorizeRequests()); 				http.httpBasic().authenticationEntryPoint(entryPoint).and().cors(); 				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement() 						.sessionCreationPolicy(asSpringSecuritySessionCreationPolicy( 								this.management.getSecurity().getSessions())); 				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders()); 			} 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return endpoint.isSensitive(); 			}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return endpoint.isSensitive(); 			}
private Object bindBean(ConfigurationPropertyName name, Bindable<?> target, 			BindHandler handler, Context context) { 		if (containsNoDescendantOf(context.streamSources(), name) 				|| isUnbindableBean(name, target, context)) { 			return null; 		} 		BeanPropertyBinder propertyBinder = (propertyName, propertyTarget) -> bind( 				name.append(propertyName), propertyTarget, handler, context); 		Class<?> type = target.getType().resolve(); 		if (context.hasBoundBean(type)) { 			return null; 		} 		return context.withBean(type, () -> { 			Stream<?> boundBeans = BEAN_BINDERS.stream() 					.map((b) -> b.bind(name, target, context, propertyBinder)); 			return boundBeans.filter(Objects::nonNull).findFirst().orElse(null); 		}); 	}
public void addField(Field field) { 			if (this.field == null) { 				this.field = field; 			} 		}
public ResolvableType getType() { 			if (this.setter != null) { 				return ResolvableType.forMethodParameter(this.setter, 0); 			} 			return ResolvableType.forMethodReturnType(this.getter); 		}
private void addField(Field field) { 			BeanProperty property = this.properties.get(field.getName()); 			if (property != null) { 				property.addField(field); 			} 		}
public Class<?> getType() { 			return this.type; 		}
private Object bindBean(ConfigurationPropertyName name, Bindable<?> target, 			BindHandler handler, Context context) { 		boolean hasKnownBindableProperties = hasKnownBindableProperties(name, context); 		if (!hasKnownBindableProperties && isUnbindableBean(target)) { 			return null; 		} 		BeanPropertyBinder propertyBinder = (propertyName, propertyTarget) -> bind( 				name.append(propertyName), propertyTarget, handler, context); 		Class<?> type = target.getType().resolve(); 		if (context.hasBoundBean(type)) { 			return null; 		} 		return context.withBean(type, () -> { 			Stream<?> boundBeans = BEAN_BINDERS.stream().map( 					(b) -> b.bind(target, hasKnownBindableProperties, propertyBinder)); 			return boundBeans.filter(Objects::nonNull).findFirst().orElse(null); 		}); 	}
private MultiValueMap<String, ConfigurationProperty> getKnownIndexedChildren( 			ConfigurationPropertySource source, ConfigurationPropertyName root) { 		MultiValueMap<String, ConfigurationProperty> children = new LinkedMultiValueMap<>(); 		if (!(source instanceof IterableConfigurationPropertySource)) { 			return children; 		} 		for (ConfigurationPropertyName name : (IterableConfigurationPropertySource) source 				.filter(root::isAncestorOf)) { 			name = rollUp(name, root); 			if (name.getElement().isIndexed()) { 				String key = name.getElement().getValue(Form.UNIFORM); 				ConfigurationProperty value = source.getConfigurationProperty(name); 				children.add(key, value); 			} 		} 		return children; 	}
public void bindEntries(ConfigurationPropertySource source, 				Map<Object, Object> map) { 			if (source instanceof IterableConfigurationPropertySource) { 				for (ConfigurationPropertyName name : (IterableConfigurationPropertySource) source) { 					Bindable<?> valueBindable = getValueBindable(name); 					ConfigurationPropertyName entryName = getEntryName(source, name); 					Object key = getContext().getConversionService() 							.convert(getKeyName(entryName), this.keyType); 					Object value = this.elementBinder.bind(entryName, valueBindable); 					map.putIfAbsent(key, value); 				} 			} 		}
private void checkNoUnboundElements(ConfigurationPropertyName name, 			BindContext context) { 		Set<ConfigurationProperty> unbound = new TreeSet<>(); 		for (ConfigurationPropertySource source : context.getSources()) { 			if (source instanceof IterableConfigurationPropertySource) { 				collectUnbound(name, unbound, 						(IterableConfigurationPropertySource) source); 			} 		} 		if (!unbound.isEmpty()) { 			throw new UnboundConfigurationPropertiesException(unbound); 		} 	}
@Override 	public ConfigurationProperty getConfigurationProperty( 			ConfigurationPropertyName name) { 		Assert.notNull(name, "Name must not be null"); 		ConfigurationProperty result = getSource().getConfigurationProperty(name); 		if (result == null) { 			ConfigurationPropertyName aliasedName = getAliases().getNameForAlias(name); 			result = getSource().getConfigurationProperty(aliasedName); 		} 		return result; 	}
private ConfigurationPropertySource adapt(PropertySource<?> source) { 		return this.adapters.computeIfAbsent(source, this::createAdapter); 	}
@Override 	public ConfigurationProperty getConfigurationProperty( 			ConfigurationPropertyName name) { 		boolean filtered = getFilter().test(name); 		return (filtered ? getSource().getConfigurationProperty(name) : null); 	}
public void putAll(Map<?, ?> map) { 		Assert.notNull(map, "Map must not be null"); 		assertNotReadOnlySystemAttributesMap(map); 		map.forEach(this::put); 	}
@Override 	public ConfigurationProperty getConfigurationProperty( 			ConfigurationPropertyName name) { 		List<PropertyMapping> mappings = getMapper().map(getPropertySource(), name); 		return find(mappings, name); 	}
protected final ConfigurationProperty find(List<PropertyMapping> mappings, 			ConfigurationPropertyName name) { 		return mappings.stream().filter((m) -> m.isApplicable(name)).map(this::find) 				.filter(Objects::nonNull).findFirst().orElse(null); 	}
private ConfigurationProperty find(PropertyMapping mapping) { 		String propertySourceName = mapping.getPropertySourceName(); 		Object value = getPropertySource().getProperty(propertySourceName); 		if (value == null) { 			return null; 		} 		value = mapping.getValueExtractor().apply(value); 		ConfigurationPropertyName configurationPropertyName = mapping 				.getConfigurationPropertyName(); 		Origin origin = PropertySourceOrigin.get(this.propertySource, propertySourceName); 		return ConfigurationProperty.of(configurationPropertyName, value, origin); 	}
@Test 	public void bindToArrayWhenNonIterableShouldReturnPopulatedArray() throws Exception { 		MockConfigurationPropertySource source = new MockConfigurationPropertySource(); 		source.put("foo[1]", "2"); 		source.put("foo[0]", "1"); 		source.put("foo[2]", "3"); 		this.sources.add(source.nonIterable()); 		Integer[] result = this.binder.bind("foo", INTEGER_ARRAY).get(); 		assertThat(result).containsExactly(1, 2, 3); 	}
@Test 	public void bindToJavaBeanWhenNonIterableShouldReturnPopulatedBean() 			throws Exception { 		MockConfigurationPropertySource source = new MockConfigurationPropertySource( 				"foo.value", "bar"); 		this.sources.add(source.nonIterable()); 		JavaBean result = this.binder.bind("foo", Bindable.of(JavaBean.class)).get(); 		assertThat(result.getValue()).isEqualTo("bar"); 	}
@Test 	public void bindToCollectionWhenNonIterableShouldReturnPopulatedCollection() 			throws Exception { 		MockConfigurationPropertySource source = new MockConfigurationPropertySource(); 		source.put("foo[1]", "2"); 		source.put("foo[0]", "1"); 		source.put("foo[2]", "3"); 		this.sources.add(source.nonIterable()); 		List<Integer> result = this.binder.bind("foo", INTEGER_LIST).get(); 		assertThat(result).containsExactly(1, 2, 3); 	}
@Test 	public void bindToClassWhenNotIterableShouldNotBindNestedBasedOnInstance() 			throws Exception { 		// If we can't tell that binding will happen, we don't want to randomly invoke 		// getters on the class and cause side effects 		MockConfigurationPropertySource source = new MockConfigurationPropertySource(); 		source.put("foo.value-bean.int-value", "123"); 		source.put("foo.value-bean.string-value", "foo"); 		this.sources.add(source.nonIterable()); 		BindResult<ExampleNestedBeanWithoutSetterOrType> bean = this.binder.bind("foo", 				Bindable.of(ExampleNestedBeanWithoutSetterOrType.class)); 		assertThat(bean.isBound()).isFalse(); 	}
@Test 	public void bindToClassShouldNotInvokeExtraMethods() throws Exception { 		MockConfigurationPropertySource source = new MockConfigurationPropertySource( 				"foo.value", "123"); 		this.sources.add(source.nonIterable()); 		ExampleWithThrowingGetters bean = this.binder 				.bind("foo", Bindable.of(ExampleWithThrowingGetters.class)).get(); 		assertThat(bean.getValue()).isEqualTo(123); 	}
public String getFoo() { 				return "foo"; 			}
public ExampleValueBean getNested() { 			throw new RuntimeException(); 		}
public int getFoo() { 			return this.foo; 		}
public String getValue() { 			return String.valueOf(this.value); 		}
public String getValue() { 			return this.value; 		}
public int getValue() { 			return this.value; 		}
public int getValue() { 			return this.value; 		}
public String getValue() { 			return String.valueOf(this.value); 		}
public NestedImmutable getNested() { 			return this.nested; 		}
public String getValue() { 			return String.valueOf(this.value); 		}
@Test 	public void getConfigurationPropertyShouldConsiderAliases() throws Exception { 		MockConfigurationPropertySource source = new MockConfigurationPropertySource(); 		source.put("foo.bar", "bing"); 		source.put("foo.baz", "biff"); 		ConfigurationPropertySource aliased = source.nonIterable() 				.withAliases(new ConfigurationPropertyNameAliases("foo.bar", "foo.bar1")); 		assertThat(getValue(aliased, "foo.bar")).isEqualTo("bing"); 		assertThat(getValue(aliased, "foo.bar1")).isEqualTo("bing"); 	}
@Test 	public void getConfigurationPropertyWhenNotAliasesShouldReturnValue() 			throws Exception { 		MockConfigurationPropertySource source = new MockConfigurationPropertySource(); 		source.put("foo.bar", "bing"); 		source.put("foo.baz", "biff"); 		ConfigurationPropertySource aliased = source.nonIterable() 				.withAliases(new ConfigurationPropertyNameAliases("foo.bar", "foo.bar1")); 		assertThat(getValue(aliased, "foo.baz")).isEqualTo("biff"); 	}
@Test 	public void getValueShouldFilterNames() throws Exception { 		ConfigurationPropertySource source = createTestSource(); 		ConfigurationPropertySource filtered = source.filter(this::noBrackets); 		ConfigurationPropertyName name = ConfigurationPropertyName.of("a"); 		assertThat(source.getConfigurationProperty(name).getValue()).isEqualTo("1"); 		assertThat(filtered.getConfigurationProperty(name).getValue()).isEqualTo("1"); 		ConfigurationPropertyName bracketName = ConfigurationPropertyName.of("a[1]"); 		assertThat(source.getConfigurationProperty(bracketName).getValue()) 				.isEqualTo("2"); 		assertThat(filtered.getConfigurationProperty(bracketName)).isNull();  	}
protected final ConfigurationPropertySource createTestSource() { 		MockConfigurationPropertySource source = new MockConfigurationPropertySource(); 		source.put("a", "1"); 		source.put("a[1]", "2"); 		source.put("b", "3"); 		source.put("b[1]", "4"); 		source.put("c", "5"); 		return convertSource(source); 	}
@Override 	public Iterator<ConfigurationPropertyName> iterator() { 		return this.map.keySet().iterator(); 	}
@Override 	public Stream<ConfigurationPropertyName> stream() { 		return this.map.keySet().stream(); 	}
@Test 	public void getValueShouldUseDirectMapping() throws Exception { 		Map<String, Object> source = new LinkedHashMap<>(); 		source.put("key1", "value1"); 		source.put("key2", "value2"); 		source.put("key3", "value3"); 		PropertySource<?> propertySource = new MapPropertySource("test", source); 		TestPropertyMapper mapper = new TestPropertyMapper(); 		ConfigurationPropertyName name = ConfigurationPropertyName.of("my.key"); 		mapper.addFromConfigurationProperty(name, "key2"); 		PropertySourceConfigurationPropertySource adapter = new PropertySourceConfigurationPropertySource( 				propertySource, mapper); 		assertThat(adapter.getConfigurationProperty(name).getValue()).isEqualTo("value2"); 	}
@Test 	public void getValueShouldUseExtractor() throws Exception { 		Map<String, Object> source = new LinkedHashMap<>(); 		source.put("key", "value"); 		PropertySource<?> propertySource = new MapPropertySource("test", source); 		TestPropertyMapper mapper = new TestPropertyMapper(); 		ConfigurationPropertyName name = ConfigurationPropertyName.of("my.key"); 		mapper.addFromConfigurationProperty(name, "key", 				(value) -> value.toString().replace("ue", "let")); 		PropertySourceConfigurationPropertySource adapter = new PropertySourceConfigurationPropertySource( 				propertySource, mapper); 		assertThat(adapter.getConfigurationProperty(name).getValue()).isEqualTo("vallet"); 	}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnEnabledEndpoint("health") 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate, 				this.managementServerProperties.getSecurity().isEnabled()); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint 					.addStatusMapping(this.healthMvcEndpointProperties.getMapping()); 		} 		return healthMvcEndpoint; 	}
@Override 	public void setEnvironment(Environment environment) { 		this.securityPropertyResolver = new RelaxedPropertyResolver(environment, 				"management.security."); 	}
@Test 	public void testSecureByDefault() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(TestConfiguration.class); 		this.context.refresh(); 		MockHttpServletRequest request = new MockHttpServletRequest(); 		Health health = (Health) this.context.getBean(HealthMvcEndpoint.class) 				.invoke(request); 		assertThat(health.getStatus()).isEqualTo(Status.UP); 		assertThat(health.getDetails().get("foo")).isNull(); 	}
@Test 	public void up() { 		given(this.endpoint.invoke()).willReturn(new Health.Builder().up().build()); 		Object result = this.mvc.invoke(this.request); 		assertThat(result instanceof Health).isTrue(); 		assertThat(((Health) result).getStatus() == Status.UP).isTrue(); 	}
@SuppressWarnings("unchecked") 	@Test 	public void down() { 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		Object result = this.mvc.invoke(this.request); 		assertThat(result instanceof ResponseEntity).isTrue(); 		ResponseEntity<Health> response = (ResponseEntity<Health>) result; 		assertThat(response.getBody().getStatus() == Status.DOWN).isTrue(); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.SERVICE_UNAVAILABLE); 	}
@Test 	@SuppressWarnings("unchecked") 	public void customMapping() { 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().status("OK").build()); 		this.mvc.setStatusMapping( 				Collections.singletonMap("OK", HttpStatus.INTERNAL_SERVER_ERROR)); 		Object result = this.mvc.invoke(this.request); 		assertThat(result instanceof ResponseEntity).isTrue(); 		ResponseEntity<Health> response = (ResponseEntity<Health>) result; 		assertThat(response.getBody().getStatus().equals(new Status("OK"))).isTrue(); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 	}
@Test 	@SuppressWarnings("unchecked") 	public void customMappingWithRelaxedName() { 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().outOfService().build()); 		this.mvc.setStatusMapping(Collections.singletonMap("out-of-service", 				HttpStatus.INTERNAL_SERVER_ERROR)); 		Object result = this.mvc.invoke(this.request); 		assertThat(result instanceof ResponseEntity).isTrue(); 		ResponseEntity<Health> response = (ResponseEntity<Health>) result; 		assertThat(response.getBody().getStatus().equals(Status.OUT_OF_SERVICE)).isTrue(); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 	}
@Test 	public void healthIsCached() { 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(this.actuator); 		assertThat(result instanceof Health).isTrue(); 		Health health = (Health) result; 		assertThat(health.getStatus() == Status.UP).isTrue(); 		assertThat(health.getDetails()).hasSize(1); 		assertThat(health.getDetails().get("foo")).isEqualTo("bar"); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(this.request); // insecure now 		assertThat(result instanceof Health).isTrue(); 		health = (Health) result; 		// so the result is cached 		assertThat(health.getStatus() == Status.UP).isTrue(); 		// but the details are hidden 		assertThat(health.getDetails()).isEmpty(); 	}
@Test 	public void noCachingWhenTimeToLiveIsZero() { 		given(this.endpoint.getTimeToLive()).willReturn(0L); 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(this.request); 		assertThat(result instanceof Health).isTrue(); 		assertThat(((Health) result).getStatus() == Status.UP).isTrue(); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(this.request); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertThat(health.getStatus() == Status.DOWN).isTrue(); 	}
@Test 	public void newValueIsReturnedOnceTtlExpires() throws InterruptedException { 		given(this.endpoint.getTimeToLive()).willReturn(50L); 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(this.request); 		assertThat(result instanceof Health).isTrue(); 		assertThat(((Health) result).getStatus() == Status.UP).isTrue(); 		Thread.sleep(100); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(this.request); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertThat(health.getStatus() == Status.DOWN).isTrue(); 	}
private void sendFailureResponse(HttpServletRequest request, 			HttpServletResponse response) throws Exception { 		if (request.getUserPrincipal() != null) { 			String roles = StringUtils.collectionToDelimitedString(this.roles, " "); 			response.sendError(HttpStatus.FORBIDDEN.value(), 					"Access is denied. User must have one of the these roles: " + roles); 		} 		else { 			logUnauthorizedAttempt(); 			response.sendError(HttpStatus.UNAUTHORIZED.value(), 					"Full authentication is required to access this resource."); 		} 	}
@Test 	public void sensitiveEndpointIfNotAuthenticatedShouldNotAllowAccess() 			throws Exception { 		assertThat(this.securityInterceptor.preHandle(this.request, this.response, 				this.handlerMethod)).isFalse(); 		verify(this.response).sendError(HttpStatus.UNAUTHORIZED.value(), 				"Full authentication is required to access this resource."); 		assertThat(this.securityInterceptor.preHandle(this.request, this.response, 				this.handlerMethod)).isFalse(); 		assertThat(this.output.toString()) 				.containsOnlyOnce("Full authentication is required to access actuator " 						+ "endpoints. Consider adding Spring Security or set " 						+ "'management.security.enabled' to false"); 	}
@Override 	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, 			Object handler) throws Exception { 		if (CorsUtils.isPreFlightRequest(request) || !this.secure) { 			return true; 		} 		HandlerMethod handlerMethod = (HandlerMethod) handler; 		MvcEndpoint mvcEndpoint = (MvcEndpoint) handlerMethod.getBean(); 		if (!mvcEndpoint.isSensitive()) { 			return true; 		} 		for (String role : this.roles) { 			if (request.isUserInRole(role)) { 				return true; 			} 		} 		sendFailureResponse(request, response); 		return false; 	}
@Before 	public void setup() throws Exception { 		this.roles = Arrays.asList("SUPER_HERO"); 		this.securityInterceptor = new MvcEndpointSecurityInterceptor(true, this.roles); 		this.endpoint = new TestEndpoint("a"); 		this.mvcEndpoint = new TestMvcEndpoint(this.endpoint); 		this.handlerMethod = new HandlerMethod(this.mvcEndpoint, "invoke"); 		this.servletContext = new MockServletContext(); 		this.request = new MockHttpServletRequest(this.servletContext); 		this.response = mock(HttpServletResponse.class); 	}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Override 		public void init() { 			String rolesPropertyValue = getContext().getProperty(ROLES); 			if (rolesPropertyValue != null) { 				this.roles = StringUtils 						.commaDelimitedListToStringArray(rolesPropertyValue); 			} 		}
public String getName() { 			return this.name; 		}
@PostConstruct 		public void init() { 			FS commandFileSystem = createFileSystem( 					this.properties.getCommandPathPatterns(), 					this.properties.getDisabledCommands()); 			FS configurationFileSystem = createFileSystem( 					this.properties.getConfigPathPatterns(), new String[0]);  			PluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery( 					this.resourceLoader.getClassLoader(), this.beanFactory, 					this.properties.getDisabledPlugins());  			PluginContext context = new PluginContext(discovery, 					createPluginContextAttributes(), commandFileSystem, 					configurationFileSystem, this.resourceLoader.getClassLoader());  			context.refresh(); 			start(context); 		}
@Override 		public String getName() { 			return "spring"; 		}
protected void validateCrshShellConfig(Properties properties) { 			String finalAuth = properties.getProperty("crash.auth"); 			if (!this.defaultAuth && !this.type.equals(finalAuth)) { 				logger.warn(String.format( 						"Shell authentication fell back to method '%s' opposed to " 								+ "configured method '%s'. Please check your classpath.", 						finalAuth, this.type)); 			} 			// Make sure we keep track of final authentication method 			this.type = finalAuth; 		}
protected void validateCrshShellConfig(Properties properties) { 		getAuth().validateCrshShellConfig(properties); 	}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", String.valueOf(this.port)); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info(String.format( 						"%n%nUsing default password for shell access: %s%n%n", 						this.user.getPassword())); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", String.valueOf(this.port)); 				config.put("crash.ssh.auth_timeout", String.valueOf(this.authTimeout)); 				config.put("crash.ssh.idle_timeout", String.valueOf(this.idleTimeout)); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info(String.format( 						"%n%nUsing default password for shell access: %s%n%n", 						this.user.getPassword())); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", String.valueOf(this.port)); 				config.put("crash.ssh.auth_timeout", String.valueOf(this.authTimeout)); 				config.put("crash.ssh.idle_timeout", String.valueOf(this.idleTimeout)); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", String.valueOf(this.port)); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info(String.format( 						"%n%nUsing default password for shell access: %s%n%n", 						this.user.getPassword())); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", String.valueOf(this.port)); 				config.put("crash.ssh.auth_timeout", String.valueOf(this.authTimeout)); 				config.put("crash.ssh.idle_timeout", String.valueOf(this.idleTimeout)); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", String.valueOf(this.port)); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info(String.format( 						"%n%nUsing default password for shell access: %s%n%n", 						this.user.getPassword())); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", String.valueOf(this.port)); 				config.put("crash.ssh.auth_timeout", String.valueOf(this.authTimeout)); 				config.put("crash.ssh.idle_timeout", String.valueOf(this.idleTimeout)); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", String.valueOf(this.port)); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", String.valueOf(this.port)); 				config.put("crash.ssh.auth_timeout", String.valueOf(this.authTimeout)); 				config.put("crash.ssh.idle_timeout", String.valueOf(this.idleTimeout)); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", String.valueOf(this.port)); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info(String.format( 						"%n%nUsing default password for shell access: %s%n%n", 						this.user.getPassword())); 			} 		}
private boolean isSecure(Principal principal) { 		if (principal == null || principal.getClass().getName().contains("Anonymous")) { 			return false; 		} 		if (isSpringSecurityAuthentication(principal)) { 			Authentication authentication = (Authentication) principal; 			List<String> roles = Arrays.asList(StringUtils 					.trimArrayElements(StringUtils.commaDelimitedListToStringArray( 							this.roleResolver.getProperty("roles", "ROLE_ACTUATOR")))); 			for (GrantedAuthority authority : authentication.getAuthorities()) { 				String name = authority.getAuthority(); 				for (String role : roles) { 					if (role.equals(name) || ("ROLE_" + role).equals(name)) { 						return true; 					} 				} 			} 		} 		return false; 	}
@Bean 		public AuthenticationManager authenticationManager() { 			return new AuthenticationManager() {  				@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					if (authentication.getName().equals(USERNAME) 							&& authentication.getCredentials().equals(PASSWORD)) { 						authentication = new UsernamePasswordAuthenticationToken( 								authentication.getPrincipal(), 								authentication.getCredentials(), Collections 										.singleton(new SimpleGrantedAuthority("ACTUATOR"))); 					} 					else { 						throw new BadCredentialsException( 								"Invalid username and password"); 					} 					return authentication; 				} 			}; 		}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					if (authentication.getName().equals(USERNAME) 							&& authentication.getCredentials().equals(PASSWORD)) { 						authentication = new UsernamePasswordAuthenticationToken( 								authentication.getPrincipal(), 								authentication.getCredentials(), Collections 										.singleton(new SimpleGrantedAuthority("ACTUATOR"))); 					} 					else { 						throw new BadCredentialsException( 								"Invalid username and password"); 					} 					return authentication; 				}
@Test 	public void testWebConfigurationWithExtraRole() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(WebConfiguration.class); 		this.context.refresh(); 		UserDetails user = getUser(); 		ArrayList<GrantedAuthority> authorities = new ArrayList<GrantedAuthority>( 				user.getAuthorities()); 		assertThat(authorities).containsAll(AuthorityUtils 				.commaSeparatedStringToAuthorityList("ROLE_USER,ROLE_ACTUATOR")); 	}
@Test 	public void defaultJsonResponseIsNotIndented() throws Exception { 		TestSecurityContextHolder.getContext().setAuthentication( 				new TestingAuthenticationToken("user", "N/A", "ROLE_ACTUATOR")); 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(SecureConfiguration.class); 		MockMvc mockMvc = createSecureMockMvc(); 		mockMvc.perform(get("/mappings")).andExpect(content().string(startsWith("{\""))); 	}
@Test 	public void jsonExtensionProvided() throws Exception { 		TestSecurityContextHolder.getContext().setAuthentication( 				new TestingAuthenticationToken("user", "N/A", "ROLE_ACTUATOR")); 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(SecureConfiguration.class); 		MockMvc mockMvc = createSecureMockMvc(); 		mockMvc.perform(get("/beans.json")).andExpect(status().isOk()); 	}
private void assertIndentedJsonResponse(Class<?> configuration) throws Exception { 		TestSecurityContextHolder.getContext().setAuthentication( 				new TestingAuthenticationToken("user", "N/A", "ROLE_ACTUATOR")); 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(configuration); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.jackson.serialization.indent-output:true"); 		MockMvc mockMvc = createSecureMockMvc(); 		mockMvc.perform(get("/mappings")) 				.andExpect(content().string(startsWith("{" + LINE_SEPARATOR))); 	}
@Override 		public void init(AuthenticationManagerBuilder auth) throws Exception { 			auth.inMemoryAuthentication().withUser("admin").password("admin") 					.roles("ADMIN", "USER", "ACTUATOR").and().withUser("user").password("user") 					.roles("USER"); 		}
@Bean 	@ConditionalOnMissingBean 	public EndpointHandlerMapping endpointHandlerMapping() { 		Set<MvcEndpoint> endpoints = mvcEndpoints().getEndpoints(); 		CorsConfiguration corsConfiguration = getCorsConfiguration(this.corsProperties); 		EndpointHandlerMapping mapping = new EndpointHandlerMapping(endpoints, 				corsConfiguration); 		mapping.setPrefix(this.managementServerProperties.getContextPath()); 		MvcEndpointSecurityInterceptor securityInterceptor = new MvcEndpointSecurityInterceptor( 				this.managementServerProperties.getSecurity().isEnabled(), 				this.managementServerProperties.getSecurity().getRoles()); 		mapping.setSecurityInterceptor(securityInterceptor); 		for (EndpointHandlerMappingCustomizer customizer : this.mappingCustomizers) { 			customizer.customize(mapping); 		} 		return mapping; 	}
@Before 	public void defaultContextPath() { 		management.setContextPath(""); 		management.getSecurity().setEnabled(false); 		server.setContextPath(""); 	}
@Test 	public void onSamePort() throws Exception { 		EnvironmentTestUtils.addEnvironment(this.applicationContext, 				"management.security.enabled:false"); 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				BaseConfiguration.class, ServerPortConfig.class, 				EndpointWebMvcAutoConfiguration.class); 		this.applicationContext.refresh(); 		assertContent("/controller", ports.get().server, "controlleroutput"); 		assertContent("/endpoint", ports.get().server, "endpointoutput"); 		assertContent("/controller", ports.get().management, null); 		assertContent("/endpoint", ports.get().management, null); 		assertThat(hasHeader("/endpoint", ports.get().server, "X-Application-Context")) 				.isTrue(); 		assertThat(this.applicationContext.containsBean("applicationContextIdFilter")) 				.isTrue(); 	}
@Test 	public void specificPortsViaProperties() throws Exception { 		EnvironmentTestUtils.addEnvironment(this.applicationContext, 				"server.port:" + ports.get().server, 				"management.port:" + ports.get().management, 				"management.security.enabled:false"); 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				BaseConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ErrorMvcAutoConfiguration.class); 		this.applicationContext.refresh(); 		assertContent("/controller", ports.get().server, "controlleroutput"); 		assertContent("/endpoint", ports.get().server, null); 		assertContent("/controller", ports.get().management, null); 		assertContent("/endpoint", ports.get().management, "endpointoutput"); 	}
@Test 	public void contextPath() throws Exception { 		EnvironmentTestUtils.addEnvironment(this.applicationContext, 				"management.contextPath:/test", "management.security.enabled:false"); 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				ServerPortConfig.class, PropertyPlaceholderAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, JacksonAutoConfiguration.class, 				EmbeddedServletContainerAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				DispatcherServletAutoConfiguration.class, WebMvcAutoConfiguration.class, 				EndpointWebMvcAutoConfiguration.class); 		this.applicationContext.refresh(); 		assertContent("/controller", ports.get().server, "controlleroutput"); 		assertContent("/test/endpoint", ports.get().server, "endpointoutput"); 	}
public int getCount() { 				return this.count; 			}
@Bean 		public TomcatEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new TomcatEmbeddedServletContainerFactory(); 		}
@Bean 		public UndertowEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new UndertowEmbeddedServletContainerFactory(); 		}
@Bean 		public SpecificEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new SpecificEmbeddedServletContainerFactory(); 		}
@Bean 		public UndertowEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new UndertowEmbeddedServletContainerFactory(); 		}
@Bean 		public SpecificEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new SpecificEmbeddedServletContainerFactory(); 		}
@Bean 		public TomcatEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new TomcatEmbeddedServletContainerFactory(); 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			properties.getSecurity().setEnabled(false); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
public int getCount() { 			return this.count; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			properties.getSecurity().setEnabled(false); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			properties.getSecurity().setEnabled(false); 			return properties; 		}
@Bean 		public EndpointHandlerMapping endpointHandlerMapping( 				Collection<? extends MvcEndpoint> endpoints) { 			EndpointHandlerMapping mapping = new EndpointHandlerMapping(endpoints); 			mapping.setSecurityInterceptor( 					new MvcEndpointSecurityInterceptor(false, Collections.EMPTY_LIST)); 			return mapping; 		}
public void reset() { 			this.available = true; 			this.locked = false; 			this.heapDump = "HEAPDUMP"; 		}
@After 	public void reset() { 		this.endpoint.reset(); 	}
@Test 	public void defaultJsonResponseIsNotIndented() throws Exception { 		TestSecurityContextHolder.getContext().setAuthentication( 				new TestingAuthenticationToken("user", "N/A", "ROLE_ADMIN")); 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(SecureConfiguration.class); 		MockMvc mockMvc = createSecureMockMvc(); 		mockMvc.perform(get("/mappings")).andExpect(content().string(startsWith("{\""))); 	}
@Test 	public void jsonResponsesCanBeIndented() throws Exception { 		assertIndentedJsonResponse(SecureConfiguration.class); 	}
@Test 	public void jsonExtensionProvided() throws Exception { 		TestSecurityContextHolder.getContext().setAuthentication( 				new TestingAuthenticationToken("user", "N/A", "ROLE_ADMIN")); 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(SecureConfiguration.class); 		MockMvc mockMvc = createSecureMockMvc(); 		mockMvc.perform(get("/beans.json")).andExpect(status().isOk()); 	}
private void assertIndentedJsonResponse(Class<?> configuration) throws Exception { 		TestSecurityContextHolder.getContext().setAuthentication( 				new TestingAuthenticationToken("user", "N/A", "ROLE_ADMIN")); 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(configuration); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.jackson.serialization.indent-output:true"); 		MockMvc mockMvc = createSecureMockMvc(); 		mockMvc.perform(get("/mappings")) 				.andExpect(content().string(startsWith("{" + LINE_SEPARATOR))); 	}
private HandlerInterceptor[] addSecurityInterceptor(HandlerInterceptor[] existing) { 		List<HandlerInterceptor> interceptors = new ArrayList<HandlerInterceptor>(); 		interceptors.add(new CorsInterceptor(this.corsConfiguration)); 		interceptors.add(this.securityInterceptor); 		if (existing != null) { 			interceptors.addAll(Arrays.asList(existing)); 		} 		return interceptors.toArray(new HandlerInterceptor[interceptors.size()]); 	}
@Test 	public void getHandlerExecutionChainShouldHaveSecurityInterceptor() throws Exception { 		CloudFoundrySecurityInterceptor securityInterceptor = Mockito 				.mock(CloudFoundrySecurityInterceptor.class); 		TestMvcEndpoint endpoint = new TestMvcEndpoint(new TestEndpoint("a")); 		CloudFoundryEndpointHandlerMapping handlerMapping = new CloudFoundryEndpointHandlerMapping( 				Collections.singleton(endpoint), null, securityInterceptor); 		HandlerExecutionChain handlerExecutionChain = handlerMapping 				.getHandlerExecutionChain(endpoint, new MockHttpServletRequest()); 		HandlerInterceptor[] interceptors = handlerExecutionChain.getInterceptors(); 		assertThat(interceptors[1]).isEqualTo(securityInterceptor); 	}
public static void configureHeaders(HeadersConfigurer<?> configurer, 			SecurityProperties.Headers headers) throws Exception { 		if (headers.getHsts() != Headers.HSTS.NONE) { 			boolean includeSubDomains = headers.getHsts() == Headers.HSTS.ALL; 			HstsHeaderWriter writer = new HstsHeaderWriter(includeSubDomains); 			writer.setRequestMatcher(AnyRequestMatcher.INSTANCE); 			configurer.addHeaderWriter(writer); 		} 		if (!headers.isContentType()) { 			configurer.contentTypeOptions().disable(); 		} 		if (StringUtils.hasText(headers.getContentSecurityPolicy())) { 			String policyDirectives = headers.getContentSecurityPolicy(); 			ContentSecurityPolicyMode mode = headers.getContentSecurityPolicyMode(); 			if (mode == ContentSecurityPolicyMode.DEFAULT) { 				configurer.contentSecurityPolicy(policyDirectives); 			} 			else { 				configurer.contentSecurityPolicy(policyDirectives).reportOnly(); 			} 		} 		if (!headers.isXss()) { 			configurer.xssProtection().disable(); 		} 		if (!headers.isCache()) { 			configurer.cacheControl().disable(); 		} 		if (!headers.isFrame()) { 			configurer.frameOptions().disable(); 		} 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Test 	public void defaultHeaderConfiguration() throws Exception { 		this.context = SpringApplication.run(VanillaWebConfiguration.class, 				"--server.port=0"); 		MockMvc mockMvc = MockMvcBuilders 				.webAppContextSetup((WebApplicationContext) this.context) 				.addFilters((FilterChainProxy) this.context 						.getBean("springSecurityFilterChain", Filter.class)) 				.build(); 		mockMvc.perform(MockMvcRequestBuilders.get("/")) 				.andExpect(MockMvcResultMatchers.header().string("X-Content-Type-Options", 						is(notNullValue()))) 				.andExpect(MockMvcResultMatchers.header().string("X-XSS-Protection", 						is(notNullValue()))) 				.andExpect(MockMvcResultMatchers.header().string("Cache-Control", 						is(notNullValue()))) 				.andExpect(MockMvcResultMatchers.header().string("X-Frame-Options", 						is(notNullValue()))) 				.andExpect(MockMvcResultMatchers.header() 						.doesNotExist("Content-Security-Policy")); 	}
@Test 	public void contentSecurityPolicyConfiguration() throws Exception { 		this.context = SpringApplication.run(VanillaWebConfiguration.class, 				"--security.headers.content-security-policy=default-src 'self';"); 		MockMvc mockMvc = MockMvcBuilders 				.webAppContextSetup((WebApplicationContext) this.context) 				.addFilters((FilterChainProxy) this.context 						.getBean("springSecurityFilterChain", Filter.class)) 				.build(); 		mockMvc.perform(MockMvcRequestBuilders.get("/")) 				.andExpect(MockMvcResultMatchers.header() 						.string("Content-Security-Policy", is("default-src 'self';"))) 				.andExpect(MockMvcResultMatchers.header() 						.doesNotExist("Content-Security-Policy-Report-Only")); 	}
@Test 	public void contentSecurityPolicyReportOnlyConfiguration() throws Exception { 		this.context = SpringApplication.run(VanillaWebConfiguration.class, 				"--security.headers.content-security-policy=default-src 'self';", 				"--security.headers.content-security-policy-mode=report-only"); 		MockMvc mockMvc = MockMvcBuilders 				.webAppContextSetup((WebApplicationContext) this.context) 				.addFilters((FilterChainProxy) this.context 						.getBean("springSecurityFilterChain", Filter.class)) 				.build(); 		mockMvc.perform(MockMvcRequestBuilders.get("/")) 				.andExpect(MockMvcResultMatchers.header().string( 						"Content-Security-Policy-Report-Only", is("default-src 'self';"))) 				.andExpect(MockMvcResultMatchers.header() 						.doesNotExist("Content-Security-Policy")); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers(HttpMethod.POST, "/**").denyAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().denyAll(); 		}
public static void configureHeaders(HeadersConfigurer<?> configurer, 			SecurityProperties.Headers headers) throws Exception { 		if (headers.getHsts() != Headers.HSTS.NONE) { 			boolean includeSubDomains = headers.getHsts() == Headers.HSTS.ALL; 			HstsHeaderWriter writer = new HstsHeaderWriter(includeSubDomains); 			writer.setRequestMatcher(AnyRequestMatcher.INSTANCE); 			configurer.addHeaderWriter(writer); 		} 		if (!headers.isContentType()) { 			configurer.contentTypeOptions().disable(); 		} 		if (StringUtils.hasText(headers.getContentSecurityPolicy())) { 			if (headers.getContentSecurityPolicyMode() == Headers.ContentSecurityPolicyMode.DEFAULT) { 				configurer.contentSecurityPolicy(headers.getContentSecurityPolicy()); 			} 			else { 				assert headers.getContentSecurityPolicyMode() == Headers.ContentSecurityPolicyMode.REPORT_ONLY; 				configurer.contentSecurityPolicy(headers.getContentSecurityPolicy()).reportOnly(); 			} 		} 		if (!headers.isXss()) { 			configurer.xssProtection().disable(); 		} 		if (!headers.isCache()) { 			configurer.cacheControl().disable(); 		} 		if (!headers.isFrame()) { 			configurer.frameOptions().disable(); 		} 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Test 	public void defaultHeaderConfiguration() throws Exception { 		this.context = SpringApplication.run(VanillaWebConfiguration.class, 				"--server.port=0"); 		MockMvc mockMvc = MockMvcBuilders 				.webAppContextSetup((WebApplicationContext) this.context) 				.addFilters((FilterChainProxy) this.context 						.getBean("springSecurityFilterChain", Filter.class)) 				.build(); 		mockMvc.perform(MockMvcRequestBuilders.get("/")) 				.andExpect(MockMvcResultMatchers.header().string("X-Content-Type-Options", 						is(notNullValue()))) 				.andExpect(MockMvcResultMatchers.header().string("X-XSS-Protection", 						is(notNullValue()))) 				.andExpect(MockMvcResultMatchers.header().string("Cache-Control", 						is(notNullValue()))) 				.andExpect(MockMvcResultMatchers.header().string("X-Frame-Options", 						is(notNullValue()))) 				.andExpect(MockMvcResultMatchers.header().doesNotExist("Content-Security-Policy")); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers(HttpMethod.POST, "/**").denyAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().denyAll(); 		}
@Override 	protected void postProcessEndpoints(Set<NamedMvcEndpoint> endpoints) { 		super.postProcessEndpoints(endpoints); 		Iterator<NamedMvcEndpoint> iterator = endpoints.iterator(); 		HealthMvcEndpoint healthMvcEndpoint = null; 		while (iterator.hasNext()) { 			NamedMvcEndpoint endpoint = iterator.next(); 			if (endpoint instanceof HalJsonMvcEndpoint) { 				iterator.remove(); 			} 			else if (endpoint instanceof HealthMvcEndpoint) { 				iterator.remove(); 				healthMvcEndpoint = (HealthMvcEndpoint) endpoint; 			} 		} 		if (healthMvcEndpoint != null) { 			endpoints.add( 					new CloudFoundryHealthMvcEndpoint(healthMvcEndpoint.getDelegate())); 		} 	}
@Override 	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, 			Object o) throws Exception { 		if (CorsUtils.isPreFlightRequest(request)) { 			return true; 		} 		try { 			if (!StringUtils.hasText(this.applicationId)) { 				throw new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE, 						"Application id is not available"); 			} 			if (this.cloudFoundrySecurityService == null) { 				throw new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE, 						"Cloud controller URL is not available"); 			} 			HandlerMethod handlerMethod = (HandlerMethod) o; 			MvcEndpoint mvcEndpoint = (MvcEndpoint) handlerMethod.getBean(); 			check(request, mvcEndpoint); 		} 		catch (CloudFoundryAuthorizationException ex) { 			this.logger.error(ex); 			response.setContentType(MediaType.APPLICATION_JSON.toString()); 			response.getWriter() 					.write("{\"security_error\":\"" + ex.getMessage() + "\"}"); 			response.setStatus(ex.getStatusCode().value()); 			return false; 		} 		return true; 	}
@Test 	public void preHandleWhenTokenIsMissingShouldReturnFalse() throws Exception { 		boolean preHandle = this.interceptor.preHandle(this.request, this.response, 				this.handlerMethod); 		assertThat(preHandle).isFalse(); 		assertThat(this.response.getStatus()) 				.isEqualTo(Reason.MISSING_AUTHORIZATION.getStatus().value()); 		assertThat(this.response.getContentAsString()).contains("security_error"); 		assertThat(this.response.getContentType()) 				.isEqualTo(MediaType.APPLICATION_JSON.toString()); 	}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnEnabledEndpoint("health") 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate, 				isHealthSecure()); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint 					.addStatusMapping(this.healthMvcEndpointProperties.getMapping()); 		} 		return healthMvcEndpoint; 	}
private HandlerInterceptor[] addSecurityInterceptor(HandlerInterceptor[] existing) { 		List<HandlerInterceptor> interceptors = new ArrayList<HandlerInterceptor>(); 		interceptors.add(this.securityInterceptor); 		if (existing != null) { 			interceptors.addAll(Arrays.asList(existing)); 		} 		return interceptors.toArray(new HandlerInterceptor[interceptors.size()]); 	}
@Test 	public void cloudFoundryPlatformActive() throws Exception { 		CloudFoundryEndpointHandlerMapping handlerMapping = x(); 		assertThat(handlerMapping.getPrefix()).isEqualTo("/cloudfoundryapplication"); 	}
@Test 	public void getHandlerExecutionChainShouldHaveSecurityInterceptor() throws Exception { 		CloudFoundrySecurityInterceptor securityInterceptor = Mockito 				.mock(CloudFoundrySecurityInterceptor.class); 		TestMvcEndpoint endpoint = new TestMvcEndpoint(new TestEndpoint("a")); 		CloudFoundryEndpointHandlerMapping handlerMapping = new CloudFoundryEndpointHandlerMapping( 				Collections.singleton(endpoint), null, securityInterceptor); 		HandlerExecutionChain handlerExecutionChain = handlerMapping 				.getHandlerExecutionChain(endpoint, new MockHttpServletRequest()); 		HandlerInterceptor[] interceptors = handlerExecutionChain.getInterceptors(); 		assertThat(interceptors).contains(securityInterceptor); 	}
@Test 	public void getHandlerExecutionChainWhenEndpointHasPathShouldMapAgainstName() 			throws Exception { 		TestMvcEndpoint testMvcEndpoint = new TestMvcEndpoint(new TestEndpoint("a")); 		testMvcEndpoint.setPath("something-else"); 		CloudFoundryEndpointHandlerMapping handlerMapping = new CloudFoundryEndpointHandlerMapping( 				Collections.singleton(testMvcEndpoint), null, null); 		assertThat(handlerMapping.getPath(testMvcEndpoint)).isEqualTo("/a"); 	}
@Test 	public void doesNotRegisterHalJsonMvcEndpoint() throws Exception { 		CloudFoundryEndpointHandlerMapping handlerMapping = new CloudFoundryEndpointHandlerMapping( 				Collections.singleton(new TestHalJsonMvcEndpoint()), null, null); 		assertThat(handlerMapping.getEndpoints()).hasSize(0); 	}
@Test 	public void registersCloudFoundryDiscoveryEndpoint() throws Exception { 		StaticApplicationContext context = new StaticApplicationContext(); 		CloudFoundryEndpointHandlerMapping handlerMapping = new CloudFoundryEndpointHandlerMapping( 				Collections.<NamedMvcEndpoint>emptySet(), null, null); 		handlerMapping.setPrefix("/test"); 		handlerMapping.setApplicationContext(context); 		handlerMapping.afterPropertiesSet(); 		HandlerExecutionChain handler = handlerMapping 				.getHandler(new MockHttpServletRequest("GET", "/test")); 		HandlerMethod handlerMethod = (HandlerMethod) handler.getHandler(); 		assertThat(handlerMethod.getBean()) 				.isInstanceOf(CloudFoundryDiscoveryMvcEndpoint.class); 	}
private RequestMatcher getRequestMatcher() { 			if (this.management.getSecurity().isEnabled()) { 				return LazyEndpointPathRequestMatcher 						.getRequestMatcher(this.contextResolver); 			} 			return null; 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// secure endpoints 			RequestMatcher matcher = getRequestMatcher(); 			if (matcher != null) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				// Match all the requests for actuator endpoints ... 				http.requestMatcher(matcher); 				// ... but permitAll() for the non-sensitive ones 				configurePermittedRequests(http.authorizeRequests()); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement() 						.sessionCreationPolicy(asSpringSecuritySessionCreationPolicy( 								this.management.getSecurity().getSessions())); 				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders()); 			} 		}
private RequestMatcher getRequestMatcher() { 			if (this.management.getSecurity().isEnabled()) { 				return null; 			} 			return LazyEndpointPathRequestMatcher.getRequestMatcher(this.contextResolver); 		}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
private boolean isSecure(Principal principal) { 		if (principal == null || principal.getClass().getName().contains("Anonymous")) { 			return false; 		} 		if (isSpringSecurityAuthentication(principal)) { 			Authentication authentication = (Authentication) principal; 			List<String> roles = Arrays.asList(StringUtils.trimArrayElements(StringUtils 					.commaDelimitedListToStringArray(this.roleResolver.getProperty("roles")))); 			if (roles.isEmpty()) { 				roles = Collections.singletonList("ROLE_ADMIN"); 			} 			for (GrantedAuthority authority : authentication.getAuthorities()) { 				String name = authority.getAuthority(); 				for (String role : roles) { 					if (role.equals(name) || ("ROLE_" + role).equals(name)) { 						return true; 					} 				} 			} 		} 		return false; 	}
public String getContentType() { 			if (this.contentType == null) { 				this.contentType = deduceContentType(); 			} 			return this.contentType; 		}
@Override 	public Permission getPermission() throws IOException { 		if (this.permission == null) { 			this.permission = new FilePermission( 					this.jarFile.getRootJarFile().getFile().getPath(), READ_ACTION); 		} 		return this.permission; 	}
@Override 	public String getContentType() { 		return this.jarEntryName.getContentType(); 	}
@Bean 		@ConfigurationProperties("security.oauth2.client") 		@Primary 		public ClientCredentialsResourceDetails oauth2RemoteResource() { 			ClientCredentialsResourceDetails details = new ClientCredentialsResourceDetails(); 			return details; 		}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
private int countBeans(Class<?> type) { 		return countBeans(this.context, type); 	}
@Bean 		@ConfigurationProperties("security.oauth2.client") 		@Primary 		public ClientCredentialsResourceDetails oauth2RemoteResource() { 			ClientCredentialsResourceDetails details = new ClientCredentialsResourceDetails(); 			return details; 		}
@Bean 		@ConfigurationProperties("security.oauth2.client") 		@Primary 		public AuthorizationCodeResourceDetails oauth2RemoteResource() { 			AuthorizationCodeResourceDetails details = new AuthorizationCodeResourceDetails(); 			return details; 		}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
private EnumSet<DispatcherType> getDispatcherTypes( 			SecurityProperties securityProperties) { 		if (securityProperties.getFilterDispatcherTypes() == null) { 			return null; 		} 		Set<DispatcherType> dispatcherTypes = new HashSet<DispatcherType>(); 		for (String dispatcherType : securityProperties.getFilterDispatcherTypes()) { 			dispatcherTypes.add(DispatcherType.valueOf(dispatcherType)); 		} 		return EnumSet.copyOf(dispatcherTypes); 	}
@Bean 	@ConditionalOnBean(name = DEFAULT_FILTER_NAME) 	public DelegatingFilterProxyRegistrationBean securityFilterChainRegistration( 			SecurityProperties securityProperties) { 		DelegatingFilterProxyRegistrationBean registration = new DelegatingFilterProxyRegistrationBean( 				DEFAULT_FILTER_NAME); 		registration.setOrder(securityProperties.getFilterOrder()); 		registration.setDispatcherTypes(securityProperties.getFilterDispatcherTypes()); 		return registration; 	}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.userDetails = http.getSharedObject(UserDetailsService.class); 		}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return new TestingAuthenticationToken("foo", "bar"); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.authenticationManager = new AuthenticationManager() { 				@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				} 			}; 		}
@Autowired 		public void handlerMapping(MvcEndpoints endpoints, 				ListableBeanFactory beanFactory, EndpointHandlerMapping mapping) { 			// In a child context we definitely want to see the parent endpoints 			mapping.setDetectHandlerMethodsInAncestorContexts(true); 		}
@Override 		public void init(WebSecurity builder) throws Exception { 			if (this.server != null) { 				IgnoredRequestConfigurer ignoring = builder.ignoring(); 				// The ignores are not cumulative, so to prevent overwriting the defaults 				// we add them back. 				Set<String> ignored = new LinkedHashSet<String>( 						SpringBootWebSecurityConfiguration.getIgnored(this.security)); 				if (ignored.contains("none")) { 					ignored.remove("none"); 				} 				if (this.errorController != null) { 					ignored.add(normalizePath(this.errorController.getErrorPath())); 				} 				String[] paths = this.server.getPathsArray(ignored); 				RequestMatcher requestMatcher = this.management.getSecurity().isEnabled() 						? null 						: LazyEndpointPathRequestMatcher 								.getRequestMatcher(this.contextResolver); 				if (!ObjectUtils.isEmpty(paths)) { 					List<RequestMatcher> matchers = new ArrayList<RequestMatcher>(); 					for (String pattern : paths) { 						matchers.add(new AntPathRequestMatcher(pattern, null)); 					} 					if (requestMatcher != null) { 						matchers.add(requestMatcher); 					} 					requestMatcher = new OrRequestMatcher(matchers); 				} 				if (requestMatcher != null) { 					ignoring.requestMatchers(requestMatcher); 				} 			} 		}
private EndpointHandlerMapping getRequiredEndpointHandlerMapping() { 			EndpointHandlerMapping endpointHandlerMapping = null; 			ApplicationContext context = this.contextResolver.getApplicationContext(); 			if (context.getBeanNamesForType(EndpointHandlerMapping.class).length > 0) { 				endpointHandlerMapping = context.getBean(EndpointHandlerMapping.class); 			} 			if (endpointHandlerMapping == null) { 				// Maybe there are actually no endpoints (e.g. management.port=-1) 				endpointHandlerMapping = new EndpointHandlerMapping( 						Collections.<MvcEndpoint>emptySet()); 			} 			return endpointHandlerMapping; 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// secure endpoints 			RequestMatcher matcher = this.management.getSecurity().isEnabled() 					? LazyEndpointPathRequestMatcher 							.getRequestMatcher(this.contextResolver) 					: null; 			if (matcher != null) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				// Match all the requests for actuator endpoints ... 				http.requestMatcher(matcher); 				// ... but permitAll() for the non-sensitive ones 				configurePermittedRequests(http.authorizeRequests()); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions()); 				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders()); 			} 		}
private void configurePermittedRequests( 				ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry requests) { 			// Permit access to the non-sensitive endpoints 			requests.requestMatchers(new LazyEndpointPathRequestMatcher( 					this.contextResolver, EndpointPaths.NON_SENSITIVE)).permitAll(); 			// Restrict the rest to the configured role 			requests.anyRequest().hasRole(this.management.getSecurity().getRole()); 		}
@Override 		public boolean matches(HttpServletRequest request) { 			if (this.delegate == null) { 				this.delegate = createDelegate(); 			} 			return this.delegate.matches(request); 		}
private RequestMatcher createDelegate() { 			ServerProperties server = this.contextResolver.getApplicationContext() 					.getBean(ServerProperties.class); 			List<RequestMatcher> matchers = new ArrayList<RequestMatcher>(); 			EndpointHandlerMapping endpointHandlerMapping = getRequiredEndpointHandlerMapping(); 			for (String path : this.endpointPaths.getPaths(endpointHandlerMapping)) { 				matchers.add(new AntPathRequestMatcher(server.getPath(path))); 			} 			return (matchers.isEmpty() ? MATCH_NONE : new OrRequestMatcher(matchers)); 		}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
@Test 	public void onDifferentPortAndContext() throws Exception { 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				DifferentPortConfig.class, BaseConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class); 		management.setContextPath("/admin"); 		this.applicationContext.refresh(); 		assertContent("/controller", ports.get().server, "controlleroutput"); 		assertContent("/admin/endpoint", ports.get().management, "endpointoutput"); 		assertContent("/error", ports.get().management, startsWith("{")); 		this.applicationContext.close(); 		assertAllClosed(); 	}
@Test 	public void onDifferentPortAndMainContext() throws Exception { 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				DifferentPortConfig.class, BaseConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class); 		management.setContextPath("/admin"); 		server.setContextPath("/spring"); 		this.applicationContext.refresh(); 		assertContent("/spring/controller", ports.get().server, "controlleroutput"); 		assertContent("/admin/endpoint", ports.get().management, "endpointoutput"); 		assertContent("/error", ports.get().management, startsWith("{")); 		this.applicationContext.close(); 		assertAllClosed(); 	}
public int getCount() { 				return this.count; 			}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
public int getCount() { 			return this.count; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			return properties; 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				WebMvcAutoConfiguration.class, 				ManagementWebSecurityAutoConfiguration.class, 				JacksonAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		FilterChainProxy filterChainProxy = this.context.getBean(FilterChainProxy.class); 		// 1 for static resources, one for management endpoints and one for the rest 		assertThat(filterChainProxy.getFilterChains(), hasSize(3)); 		assertThat(filterChainProxy.getFilters("/beans"), hasSize(greaterThan(0))); 		assertThat(filterChainProxy.getFilters("/beans/"), hasSize(greaterThan(0))); 		assertThat(filterChainProxy.getFilters("/beans.foo"), hasSize(greaterThan(0))); 		assertThat(filterChainProxy.getFilters("/beans/foo/bar"), 				hasSize(greaterThan(0))); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(WebConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Just the management endpoints (one filter) and ignores now plus the backup 		// filter on app endpoints 		assertEquals(3, 				this.context.getBean(FilterChainProxy.class).getFilterChains().size()); 	}
@Test 	public void testCustomErrorPath() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = new TestRestTemplate("user", getPassword()) 				.getForEntity("http://localhost:" + this.port + "/oops", Map.class); 		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("None", body.get("error")); 		assertEquals(999, body.get("status")); 	}
public void configure(HttpSecurity http) throws Exception { 		OAuth2SsoProperties sso = this.beanFactory.getBean(OAuth2SsoProperties.class); 		// Delay the processing of the filter until we know the 		// SessionAuthenticationStrategy is available: 		http.apply(new OAuth2ClientAuthenticationConfigurer(oauth2SsoFilter(sso))); 		addAuthenticationEntryPoint(http, sso); 	}
@Test 	public void testTraceConfiguration() throws Exception { 		registerAndRefresh(AuditAutoConfiguration.class); 		assertNotNull(this.context.getBean(AuditEventRepository.class)); 		assertNotNull(this.context.getBean(AuthenticationAuditListener.class)); 		assertNotNull(this.context.getBean(AuthorizationAuditListener.class)); 	}
@Test 	public void ownAutoRepository() throws Exception { 		registerAndRefresh(CustomAuditEventRepositoryConfiguration.class, 				AuditAutoConfiguration.class); 		assertThat(this.context.getBean(AuditEventRepository.class), 				instanceOf(TestAuditEventRepository.class)); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 	public void onApplicationEvent(AbstractAuthenticationEvent event) { 		if (event instanceof AbstractAuthenticationFailureEvent) { 			onAuthenticationFailureEvent((AbstractAuthenticationFailureEvent) event); 		} 		else if (this.webListener != null && this.webListener.accepts(event)) { 			this.webListener.process(this, event); 		} 		else if (event instanceof AuthenticationSuccessEvent) { 			onAuthenticationEvent((AuthenticationSuccessEvent) event); 		} 	}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			// The ignores are not cumulative, so to prevent overwriting the defaults we 			// add them back. 			List<String> ignored = SpringBootWebSecurityConfiguration 					.getIgnored(this.security); 			if (!this.management.getSecurity().isEnabled()) { 				ignored.addAll(Arrays 						.asList(EndpointPaths.ALL.getPaths(this.endpointHandlerMapping))); 			} 			if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			if (this.server != null) { 				String[] paths = this.server.getPathsArray(ignored); 				if (!ObjectUtils.isEmpty(paths)) { 					ignoring.antMatchers(paths); 				} 			} 		}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
@Test 	public void testDisableIgnoredStaticApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ManagementWebSecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.ignored:none"); 		this.context.refresh(); 		// Just the application and management endpoints now 		assertEquals(2, 				this.context.getBean(FilterChainProxy.class).getFilterChains().size()); 	}
@Override 		public void init(WebSecurity builder) throws Exception { 			List<String> ignored = getIgnored(this.security); 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			String[] paths = this.server.getPathsArray(ignored); 			if (!ObjectUtils.isEmpty(paths)) { 				builder.ignoring().antMatchers(paths); 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 4 for static resources and one for the rest 		assertEquals(5, 				this.context.getBean(FilterChainProxy.class).getFilterChains().size()); 	}
@Test 	public void testDisableIgnoredStaticApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.ignored:none"); 		this.context.refresh(); 		// Just the application endpoints now 		assertEquals(1, 				this.context.getBean(FilterChainProxy.class).getFilterChains().size()); 	}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.userDetails = http.getSharedObject(UserDetailsService.class); 		}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return new TestingAuthenticationToken("foo", "bar"); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.authenticationManager = new AuthenticationManager() { 				@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				} 			}; 		}
@Test 	public void everythingIsSecuredByDefault() throws Exception { 		TestRestTemplate restTemplate = new TestRestTemplate(); 		ResponseEntity<Void> entity = restTemplate 				.getForEntity("http://localhost:" + this.port, Void.class); 		assertThat(entity.getStatusCode(), is(HttpStatus.FOUND)); 		assertThat(entity.getHeaders().getLocation(), 				is(equalTo(URI.create("http://localhost:" + this.port + "/login")))); 	}
@Test 	public void loginRedirectsToGithub() throws Exception { 		TestRestTemplate restTemplate = new TestRestTemplate(); 		ResponseEntity<Void> entity = restTemplate 				.getForEntity("http://localhost:" + this.port + "/login", Void.class); 		assertThat(entity.getStatusCode(), is(HttpStatus.FOUND)); 		assertThat(entity.getHeaders().getLocation().toString(), 				startsWith("https://github.com/login/oauth")); 	}
public static void configureHeaders(HeadersConfigurer<?> configurer, 			SecurityProperties.Headers headers) throws Exception { 		if (headers.getHsts() != Headers.HSTS.NONE) { 			boolean includeSubdomains = headers.getHsts() == Headers.HSTS.ALL; 			HstsHeaderWriter writer = new HstsHeaderWriter(includeSubdomains); 			writer.setRequestMatcher(AnyRequestMatcher.INSTANCE); 			configurer.addHeaderWriter(writer); 		} 		if (!headers.isContentType()) { 			configurer.contentTypeOptions().disable(); 		} 		if (!headers.isXss()) { 			configurer.xssProtection().disable(); 		} 		if (!headers.isCache()) { 			configurer.cacheControl().disable(); 		} 		if (!headers.isFrame()) { 			configurer.frameOptions().disable(); 		} 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers(HttpMethod.POST, "/**").denyAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().denyAll(); 		}
@Override 	public void setEnvironment(Environment environment) { 		this.propertyResolver = new RelaxedPropertyResolver(environment, 				"endpoints.health."); 		this.roleResolver = new RelaxedPropertyResolver(environment, 				"management.security."); 	}
private boolean isSecure(Principal principal) { 		if (principal == null || principal.getClass().getName().contains("Anonymous")) { 			return false; 		} 		if (!ClassUtils.isPresent("org.springframework.security.core.Authentication", 				null) || !(principal instanceof Authentication)) { 			return false; 		} 		String role = this.roleResolver.getProperty("role", "ROLE_ADMIN"); 		Authentication authentication = (Authentication) principal; 		for (GrantedAuthority authority : authentication.getAuthorities()) { 			String name = authority.getAuthority(); 			if (role.equals(name) || ("ROLE_" + role).equals(name)) { 				return true; 			} 		} 		return false; 	}
@Test 	@SuppressWarnings("unchecked") 	public void customMapping() { 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().status("OK").build()); 		this.mvc.setStatusMapping( 				Collections.singletonMap("OK", HttpStatus.INTERNAL_SERVER_ERROR)); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof ResponseEntity); 		ResponseEntity<Health> response = (ResponseEntity<Health>) result; 		assertTrue(response.getBody().getStatus().equals(new Status("OK"))); 		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode()); 	}
@Test 	@SuppressWarnings("unchecked") 	public void customMappingWithRelaxedName() { 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().outOfService().build()); 		this.mvc.setStatusMapping(Collections.singletonMap("out-of-service", 				HttpStatus.INTERNAL_SERVER_ERROR)); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof ResponseEntity); 		ResponseEntity<Health> response = (ResponseEntity<Health>) result; 		assertTrue(response.getBody().getStatus().equals(Status.OUT_OF_SERVICE)); 		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode()); 	}
@Test 	public void healthIsCached() { 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.isSensitive()).willReturn(true); 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(this.admin); 		assertTrue(result instanceof Health); 		Health health = (Health) result; 		assertTrue(health.getStatus() == Status.UP); 		assertThat(health.getDetails().size(), is(equalTo(1))); 		assertThat(health.getDetails().get("foo"), is(equalTo((Object) "bar"))); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); // insecure now 		assertTrue(result instanceof Health); 		health = (Health) result; 		// so the result is cached 		assertTrue(health.getStatus() == Status.UP); 		// but the details are hidden 		assertThat(health.getDetails().size(), is(equalTo(0))); 	}
@Test 	public void unsecureAnonymousAccessUnrestricted() { 		this.mvc = new HealthMvcEndpoint(this.endpoint, false); 		this.mvc.setEnvironment(this.environment); 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void unsensitiveAnonymousAccessRestricted() { 		this.environment.getPropertySources().addLast(NON_SENSITIVE); 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertNull(((Health) result).getDetails().get("foo")); 	}
@Test 	public void unsecureUnsensitiveAnonymousAccessUnrestricted() { 		this.mvc = new HealthMvcEndpoint(this.endpoint, false); 		this.mvc.setEnvironment(this.environment); 		this.environment.getPropertySources().addLast(NON_SENSITIVE); 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void noCachingWhenTimeToLiveIsZero() { 		given(this.endpoint.getTimeToLive()).willReturn(0L); 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertTrue(health.getStatus() == Status.DOWN); 	}
@Test 	public void newValueIsReturnedOnceTtlExpires() throws InterruptedException { 		given(this.endpoint.getTimeToLive()).willReturn(50L); 		given(this.endpoint.isSensitive()).willReturn(false); 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		Thread.sleep(100); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertTrue(health.getStatus() == Status.DOWN); 	}
private void assertIndentedJsonResponse(Class<?> configuration) throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(configuration); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.jackson.serialization.indent-output:true"); 		MockMvc mockMvc = createMockMvc(); 		mockMvc.perform(get("/beans")) 				.andExpect(content().string(startsWith("{" + LINE_SEPARATOR))); 	}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			// The ignores are not cumulative, so to prevent overwriting the defaults we 			// add them back. 			List<String> ignored = SpringBootWebSecurityConfiguration 					.getIgnored(this.security); 			if (!this.management.getSecurity().isEnabled()) { 				ignored.addAll(Arrays.asList(EndpointPaths.ALL 						.getPaths(this.endpointHandlerMapping))); 			} 			if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			if (this.server != null) { 				String[] paths = this.server.getPathsArray(ignored); 				ignoring.antMatchers(paths); 			} 		}
private RequestMatcher getRequestMatcher() { 			if (!this.management.getSecurity().isEnabled()) { 				return null; 			} 			String path = this.management.getContextPath(); 			if (StringUtils.hasText(path)) { 				AntPathRequestMatcher matcher = new AntPathRequestMatcher( 						this.server.getPath(path) + "/**"); 				return matcher; 			} 			// Match everything, including the sensitive and non-sensitive paths 			return new EndpointPathRequestMatcher(EndpointPaths.ALL); 		}
private void configurePermittedRequests( 				ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry requests) { 			// Permit access to the non-sensitive endpoints 			requests.requestMatchers( 					new EndpointPathRequestMatcher(EndpointPaths.NON_SENSITIVE)) 					.permitAll(); 			// Restrict the rest to the configured role 			requests.anyRequest().hasRole(this.management.getSecurity().getRole()); 		}
@Override 			public boolean matches(HttpServletRequest request) { 				if (this.delegate == null) { 					this.delegate = createDelegate(); 				} 				return this.delegate.matches(request); 			}
private RequestMatcher createDelegate() { 				ServerProperties server = ManagementWebSecurityConfigurerAdapter.this.server; 				List<RequestMatcher> matchers = new ArrayList<RequestMatcher>(); 				EndpointHandlerMapping endpointHandlerMapping = ManagementWebSecurityConfigurerAdapter.this 						.getRequiredEndpointHandlerMapping(); 				for (String path : this.endpointPaths.getPaths(endpointHandlerMapping)) { 					matchers.add(new AntPathRequestMatcher(server.getPath(path))); 				} 				return (matchers.isEmpty() ? AnyRequestMatcher.INSTANCE 						: new OrRequestMatcher(matchers)); 			}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			// The ignores are not cumulative, so to prevent overwriting the defaults we 			// add them back. 			List<String> ignored = SpringBootWebSecurityConfiguration 					.getIgnored(this.security); 			if (!this.management.getSecurity().isEnabled()) { 				ignored.addAll( 						Arrays.asList(EndpointPaths.get(this.endpointHandlerMapping))); 			} 			if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			if (this.server != null) { 				String[] paths = this.server.getPathsArray(ignored); 				ignoring.antMatchers(paths); 			} 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			String managementEnabled = context.getEnvironment() 					.getProperty("management.security.enabled", "true"); 			String basicEnabled = context.getEnvironment() 					.getProperty("security.basic.enabled", "true"); 			return new ConditionOutcome( 					"true".equalsIgnoreCase(managementEnabled) 							&& !"true".equalsIgnoreCase(basicEnabled), 					"Management security enabled and basic disabled"); 		}
protected final void deduceEndpointHandlerMappingIfMissing() { 			if (this.endpointHandlerMapping == null) { 				ApplicationContext context = (this.contextResolver == null ? null 						: this.contextResolver.getApplicationContext()); 				if (context != null && context 						.getBeanNamesForType(EndpointHandlerMapping.class).length > 0) { 					this.endpointHandlerMapping = context 							.getBean(EndpointHandlerMapping.class); 				} 				if (this.endpointHandlerMapping == null) { 					this.endpointHandlerMapping = new EndpointHandlerMapping( 							Collections.<MvcEndpoint> emptySet()); 				} 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// secure endpoints 			RequestMatcher matcher = getRequestMatcher(); 			if (matcher != null) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				// Match all the requests for actuator endpoints ... 				http.requestMatcher(matcher); 				// ... but permitAll() for the non-sensitive ones 				configurePermittedRequests(http.authorizeRequests()); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions()); 				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders()); 			} 		}
private RequestMatcher getRequestMatcher() { 			if (!this.management.getSecurity().isEnabled()) { 				return null; 			} 			String path = this.management.getContextPath(); 			if (StringUtils.hasText(path)) { 				AntPathRequestMatcher matcher = new AntPathRequestMatcher( 						this.server.getPath(path) + "/**"); 				return matcher; 			} 			// Match everything, including the sensitive and non-sensitive paths 			return new EndpointPathRequestMatcher( 					EndpointPaths.get(this.endpointHandlerMapping)); 		}
private RequestMatcher createDelegate() { 				ServerProperties server = ManagementWebSecurityConfigurerAdapter.this.server; 				List<RequestMatcher> matchers = new ArrayList<RequestMatcher>(); 				for (String path : this.paths) { 					matchers.add(new AntPathRequestMatcher(server.getPath(path))); 				} 				return (matchers.isEmpty() ? AnyRequestMatcher.INSTANCE 						: new OrRequestMatcher(matchers)); 			}
public static String[] get(EndpointHandlerMapping endpointHandlerMapping, 				boolean secure) { 			if (endpointHandlerMapping == null) { 				return NO_PATHS; 			} 			Set<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints(); 			Set<String> paths = new LinkedHashSet<String>(endpoints.size()); 			for (MvcEndpoint endpoint : endpoints) { 				if (endpoint.isSensitive() == secure) { 					String path = endpointHandlerMapping.getPath(endpoint.getPath()); 					paths.add(path); 					if (!path.equals("")) { 						if (secure) { 							// Ensure that nested paths are secured 							paths.add(path + "/**"); 							// Add Spring MVC-generated additional paths 							paths.add(path + ".*"); 						} 					} 					paths.add(path + "/"); 				} 			} 			return paths.toArray(new String[paths.size()]); 		}
private void assertIndentedJsonResponse(Class<?> configuration) throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(configuration); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.jackson.serialization.indent-output:true"); 		MockMvc mockMvc = createMockMvc(); 		mockMvc.perform(get("/beans")) 				.andExpect(content().string(startsWith("{" + LINE_SEPARATOR))); 	}
private MockMvc createMockMvc() { 		return doCreateMockMvc(); 	}
@PostConstruct 		public void init() { 			String prefix = "security.oauth2.client"; 			boolean defaultSecret = this.credentials.isDefaultSecret(); 			logger.info(String.format( 					"Initialized OAuth2 Client\n\n%s.clientId = %s\n%s.secret = %s\n\n", 					prefix, this.credentials.getClientId(), prefix, 					defaultSecret ? this.credentials.getClientSecret() : "****")); 		}
@Bean 		@ConfigurationProperties("security.oauth2.client") 		@Primary 		public ClientCredentialsResourceDetails oauth2RemoteResource() { 			ClientCredentialsResourceDetails details = new ClientCredentialsResourceDetails(); 			return details; 		}
@Bean 		@ConfigurationProperties("security.oauth2.client") 		@Primary 		public AuthorizationCodeResourceDetails oauth2RemoteResource() { 			AuthorizationCodeResourceDetails details = new AuthorizationCodeResourceDetails(); 			return details; 		}
@Bean 		@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 		public OAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(this.accessTokenRequest); 		}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public OAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		public OAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public OAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		public OAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 		@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 		public OAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(this.accessTokenRequest); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			PropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.client."); 			String clientId = resolver.getProperty("client-id"); 			return new ConditionOutcome(StringUtils.hasLength(clientId), 					"Non empty security.oauth2.client.client-id"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			String client = environment 					.resolvePlaceholders("${security.oauth2.client.clientId:}"); 			if (StringUtils.hasText(client)) { 				return ConditionOutcome.match("found client id"); 			} 			if (!resolver.getSubProperties("jwt").isEmpty()) { 				return ConditionOutcome.match("found JWT resource configuration"); 			} 			if (StringUtils.hasText(resolver.getProperty("user-info-uri"))) { 				return ConditionOutcome.match("found UserInfo " 						+ "URI resource configuration"); 			} 			if (ClassUtils.isPresent(AUTHORIZATION_ANNOTATION, null)) { 				if (AuthorizationServerEndpointsConfigurationBeanCondition 						.matches(context)) { 					return ConditionOutcome.match("found authorization " 							+ "server endpoints configuration"); 				} 			} 			return ConditionOutcome.noMatch("found neither client id nor " 					+ "JWT resource nor authorization server"); 		}
@Bean 			@ConditionalOnMissingBean(ResourceServerTokenServices.class) 			public ResourceServerTokenServices userInfoTokenServices() { 				UserInfoTokenServices services = new UserInfoTokenServices( 						this.sso.getUserInfoUri(), this.sso.getClientId()); 				services.setRestTemplate(this.restTemplate); 				services.setTokenType(this.sso.getTokenType()); 				return services; 			}
@Bean 			@ConditionalOnMissingBean({ ConnectionFactoryLocator.class, 					ResourceServerTokenServices.class }) 			public ResourceServerTokenServices userInfoTokenServices() { 				UserInfoTokenServices services = new UserInfoTokenServices( 						this.sso.getUserInfoUri(), this.sso.getClientId()); 				services.setTokenType(this.sso.getTokenType()); 				services.setRestTemplate(this.restTemplate); 				return services; 			}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment.resolvePlaceholders( 						"${OAUTH2_RESOURCE_PREFERTOKENINFO:true}").equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match("Token info endpoint " 						+ "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome.inverse(this.tokenInfoCondition.getMatchOutcome( 					context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome.inverse(this.jwtTokenCondition.getMatchOutcome( 					context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment.resolvePlaceholders( 						"${OAUTH2_RESOURCE_PREFERTOKENINFO:true}").equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match("Token info endpoint " 						+ "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome.inverse(this.tokenInfoCondition.getMatchOutcome( 					context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome.inverse(this.jwtTokenCondition.getMatchOutcome( 					context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment.resolvePlaceholders( 						"${OAUTH2_RESOURCE_PREFERTOKENINFO:true}").equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match("Token info endpoint " 						+ "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome.inverse(this.jwtTokenCondition.getMatchOutcome( 					context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment.resolvePlaceholders( 						"${OAUTH2_RESOURCE_PREFERTOKENINFO:true}").equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match("Token info endpoint " 						+ "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome.inverse(this.tokenInfoCondition.getMatchOutcome( 					context, metadata)); 		}
@Test 	public void testEnvironmentalOverrides() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		EnvironmentTestUtils.addEnvironment(this.context, 				"security.oauth2.client.clientId:myclientid", 				"security.oauth2.client.clientSecret:mysecret"); 		this.context.register(AuthorizationAndResourceServerConfiguration.class, 				MinimalSecureWebApplication.class); 		this.context.refresh(); 		ClientDetails config = this.context.getBean(ClientDetails.class); 		assertThat(config.getClientId(), equalTo("myclientid")); 		assertThat(config.getClientSecret(), equalTo("mysecret")); 		verifyAuthentication(config); 	}
@Test 	public void testDisablingAuthorizationServer() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(ResourceServerConfiguration.class, 				MinimalSecureWebApplication.class); 		EnvironmentTestUtils.addEnvironment(this.context, 				"security.oauth2.resource.jwt.keyValue:DEADBEEF"); 		this.context.refresh(); 		assertThat(countBeans(RESOURCE_SERVER_CONFIG), equalTo(1)); 		assertThat(countBeans(AUTHORIZATION_SERVER_CONFIG), equalTo(0)); 		assertThat(countBeans(UserApprovalHandler.class), equalTo(0)); 		assertThat(countBeans(DefaultTokenServices.class), equalTo(1)); 	}
@Test 	public void testAuthorizationServerOverride() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		EnvironmentTestUtils.addEnvironment(this.context, 				"security.oauth2.resourceId:resource-id"); 		this.context.register(AuthorizationAndResourceServerConfiguration.class, 				CustomAuthorizationServer.class, MinimalSecureWebApplication.class); 		this.context.refresh(); 		BaseClientDetails config = new BaseClientDetails(); 		config.setClientId("client"); 		config.setClientSecret("secret"); 		config.setResourceIds(Arrays.asList("resource-id")); 		config.setAuthorizedGrantTypes(Arrays.asList("password")); 		config.setAuthorities(AuthorityUtils.commaSeparatedStringToAuthorityList("USER")); 		config.setScope(Arrays.asList("read")); 		assertThat(countBeans(AUTHORIZATION_SERVER_CONFIG), equalTo(0)); 		assertThat(countBeans(RESOURCE_SERVER_CONFIG), equalTo(1)); 		verifyAuthentication(config); 	}
@Test 	public void useRemoteTokenServices() { 		EnvironmentTestUtils.addEnvironment(this.environment, 				"security.oauth2.resource.tokenInfoUri:http://example.com", 				"security.oauth2.resource.clientId=acme"); 		this.context = new SpringApplicationBuilder(ResourceConfiguration.class) 				.environment(this.environment).web(false).run(); 		RemoteTokenServices services = this.context.getBean(RemoteTokenServices.class); 		assertNotNull(services); 	}
@Test 	public void switchToUserInfo() { 		EnvironmentTestUtils.addEnvironment(this.environment, 				"security.oauth2.resource.userInfoUri:http://example.com"); 		this.context = new SpringApplicationBuilder(ResourceConfiguration.class) 				.environment(this.environment).web(false).run(); 		UserInfoTokenServices services = this.context 				.getBean(UserInfoTokenServices.class); 		assertNotNull(services); 	}
@Test 	public void userInfoNoClient() { 		EnvironmentTestUtils.addEnvironment(this.environment, 				"security.oauth2.client.clientId=acme", 				"security.oauth2.resource.userInfoUri:http://example.com", 				"server.port=-1", "debug=true"); 		this.context = new SpringApplicationBuilder(ResourceNoClientConfiguration.class) 				.environment(this.environment).web(true).run(); 		BeanDefinition bean = ((BeanDefinitionRegistry) this.context) 				.getBeanDefinition("scopedTarget.oauth2ClientContext"); 		assertEquals("request", bean.getScope()); 	}
@Test 	public void preferUserInfo() { 		EnvironmentTestUtils.addEnvironment(this.environment, 				"security.oauth2.resource.userInfoUri:http://example.com", 				"security.oauth2.resource.tokenInfoUri:http://example.com", 				"security.oauth2.resource.preferTokenInfo:false"); 		this.context = new SpringApplicationBuilder(ResourceConfiguration.class) 				.environment(this.environment).web(false).run(); 		UserInfoTokenServices services = this.context 				.getBean(UserInfoTokenServices.class); 		assertNotNull(services); 	}
@Test 	public void switchToJwt() { 		EnvironmentTestUtils.addEnvironment(this.environment, 				"security.oauth2.resource.jwt.keyValue=FOOBAR"); 		this.context = new SpringApplicationBuilder(ResourceConfiguration.class) 				.environment(this.environment).web(false).run(); 		DefaultTokenServices services = this.context.getBean(DefaultTokenServices.class); 		assertNotNull(services); 	}
@Test 	public void asymmetricJwt() { 		EnvironmentTestUtils.addEnvironment(this.environment, 				"security.oauth2.resource.jwt.keyValue=" + PUBLIC_KEY); 		this.context = new SpringApplicationBuilder(ResourceConfiguration.class) 				.environment(this.environment).web(false).run(); 		DefaultTokenServices services = this.context.getBean(DefaultTokenServices.class); 		assertNotNull(services); 	}
@Test 	public void springSocialUserInfo() { 		EnvironmentTestUtils.addEnvironment(this.environment, 				"security.oauth2.resource.userInfoUri:http://example.com", 				"spring.social.facebook.app-id=foo", 				"spring.social.facebook.app-secret=bar"); 		this.context = new SpringApplicationBuilder(SocialResourceConfiguration.class) 				.environment(this.environment).web(true).run(); 		ConnectionFactoryLocator connectionFactory = this.context 				.getBean(ConnectionFactoryLocator.class); 		assertNotNull(connectionFactory); 		SpringSocialTokenServices services = this.context 				.getBean(SpringSocialTokenServices.class); 		assertNotNull(services); 	}
@Bean 		public EmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return mock(EmbeddedServletContainerFactory.class); 		}
@Bean 		public MockEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new MockEmbeddedServletContainerFactory(); 		}
@Test 	public void oauth2Sample() throws Exception { 		String output = this.cli.run("oauth2.groovy"); 		assertTrue("Wrong output: " + output, 				output.contains("security.oauth2.client.clientId")); 		assertTrue("Wrong output: " + output, 				output.contains("security.oauth2.client.secret =")); 	}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnEnabledEndpoint("health") 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		Security security = this.managementServerProperties.getSecurity(); 		boolean secure = (security != null && security.isEnabled()); 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate, secure); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint.addStatusMapping(this.healthMvcEndpointProperties 					.getMapping()); 		} 		return healthMvcEndpoint; 	}
private boolean isUnrestricted() { 		Boolean sensitive = this.propertyResolver.getProperty("sensitive", Boolean.class); 		return !this.secure && !Boolean.TRUE.equals(sensitive); 	}
@Test 	public void unsecureAnonymousAccessUnrestricted() { 		this.mvc = new HealthMvcEndpoint(this.endpoint, false); 		this.mvc.setEnvironment(this.environment); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity( 				"http://localhost:" + this.port, Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testSecureHealth() throws Exception { 		ResponseEntity<String> entity = new TestRestTemplate().getForEntity( 				"http://localhost:" + this.port + "/health", String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertFalse("Wrong body: " + entity.getBody(), 				entity.getBody().contains("\"hello\":1")); 	}
@Bean 	public ClientHttpRequestFactory clientHttpRequestFactory() { 		List<ClientHttpRequestInterceptor> interceptors = Arrays 				.asList(getSecurityInterceptor()); 		return new InterceptingClientHttpRequestFactory( 				new SimpleClientHttpRequestFactory(), interceptors); 	}
@Test 	public void ignoresUnmappedUrl() throws Exception { 		loadContext("spring.developertools.remote.secret:supersecret"); 		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); 		this.request.setRequestURI("/restart"); 		this.request.addHeader(DEFAULT_SECRET_HEADER_NAME, "supersecret"); 		filter.doFilter(this.request, this.response, this.chain); 		assertRestartInvoked(false); 	}
@Test 	public void invokeRestartWithDefaultSetup() throws Exception { 		loadContext("spring.developertools.remote.secret:supersecret"); 		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); 		this.request.setRequestURI(DEFAULT_CONTEXT_PATH + "/restart"); 		this.request.addHeader(DEFAULT_SECRET_HEADER_NAME, "supersecret"); 		filter.doFilter(this.request, this.response, this.chain); 		assertRestartInvoked(true); 	}
@Test 	public void disableRestart() throws Exception { 		loadContext("spring.developertools.remote.secret:supersecret", 				"spring.developertools.remote.restart.enabled:false"); 		this.thrown.expect(NoSuchBeanDefinitionException.class); 		this.context.getBean("remoteRestartHanderMapper"); 	}
@Test 	public void invokeTunnelWithDefaultSetup() throws Exception { 		loadContext("spring.developertools.remote.secret:supersecret"); 		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); 		this.request.setRequestURI(DEFAULT_CONTEXT_PATH + "/debug"); 		this.request.addHeader(DEFAULT_SECRET_HEADER_NAME, "supersecret"); 		filter.doFilter(this.request, this.response, this.chain); 		assertTunnelInvoked(true); 	}
@Test 	public void disableRemoteDebug() throws Exception { 		loadContext("spring.developertools.remote.secret:supersecret", 				"spring.developertools.remote.debug.enabled:false"); 		this.thrown.expect(NoSuchBeanDefinitionException.class); 		this.context.getBean("remoteDebugHanderMapper"); 	}
@Test 	public void developerToolsHealthReturns200() throws Exception { 		loadContext("spring.developertools.remote.secret:supersecret"); 		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); 		this.request.setRequestURI(DEFAULT_CONTEXT_PATH); 		this.request.addHeader(DEFAULT_SECRET_HEADER_NAME, "supersecret"); 		this.response.setStatus(500); 		filter.doFilter(this.request, this.response, this.chain); 		assertThat(this.response.getStatus(), equalTo(200)); 	}
@Test 	public void warnIfNotHttps() throws Exception { 		configure("http://localhost", true); 		assertThat(this.output.toString(), containsString("is insecure")); 	}
@Test 	public void doesntWarnIfUsingHttps() throws Exception { 		configure("https://localhost", true); 		assertThat(this.output.toString(), not(containsString("is insecure"))); 	}
private void configure(String... pairs) { 		configure("http://localhost", true, pairs); 	}
@Bean 		public AccessDecisionManager shellAccessDecisionManager() { 			List<AccessDecisionVoter<?>> voters = new ArrayList<AccessDecisionVoter<?>>(); 			RoleVoter voter = new RoleVoter(); 			voter.setRolePrefix(""); 			voters.add(voter); 			return new UnanimousBased(voters); 		}
@Test 	public void testDefaultConfiguration() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(AuthorizationAndResourceServerConfiguration.class, 				MinimalSecureWebApplication.class); 		this.context.refresh();  		this.context.getBean(SpringSecurityOAuth2AuthorizationServerConfiguration.class); 		this.context.getBean(OAuth2ResourceServerConfiguration.class); 		this.context.getBean(OAuth2MethodSecurityConfiguration.class);  		ClientDetails config = this.context.getBean(BaseClientDetails.class); 		AuthorizationEndpoint endpoint = this.context 				.getBean(AuthorizationEndpoint.class); 		UserApprovalHandler handler = (UserApprovalHandler) ReflectionTestUtils.getField( 				endpoint, "userApprovalHandler"); 		ClientDetailsService clientDetailsService = this.context 				.getBean(ClientDetailsService.class); 		ClientDetails clientDetails = clientDetailsService.loadClientByClientId(config 				.getClientId());  		assertThat(AopUtils.isJdkDynamicProxy(clientDetailsService), is(true)); 		assertThat(AopUtils.getTargetClass(clientDetailsService).getName(), 				is(ClientDetailsService.class.getName()));  		assertThat(handler instanceof ApprovalStoreUserApprovalHandler, is(true));  		assertThat(clientDetails, equalTo(config));  		verifyAuthentication(config); 	}
@Test 	public void testDisablingResourceServer() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(AuthorizationServerConfiguration.class, 				MinimalSecureWebApplication.class); 		this.context.refresh();  		assertThat( 				this.context 						.getBeanNamesForType(OAuth2ResourceServerConfiguration.class).length, 				is(0));  		assertThat( 				this.context 						.getBeanNamesForType(SpringSecurityOAuth2AuthorizationServerConfiguration.class).length, 				is(1)); 	}
@Test 	public void testDisablingAuthorizationServer() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(ResourceServerConfiguration.class, 				MinimalSecureWebApplication.class); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.oauth2.resource.jwt.keyValue:DEADBEEF"); 		this.context.refresh();  		assertThat( 				this.context 						.getBeanNamesForType(OAuth2ResourceServerConfiguration.class).length, 				is(1));  		assertThat( 				this.context 						.getBeanNamesForType(SpringSecurityOAuth2AuthorizationServerConfiguration.class).length, 				is(0));  		assertThat(this.context.getBeanNamesForType(UserApprovalHandler.class).length, 				is(0)); 		assertThat(this.context.getBeanNamesForType(DefaultTokenServices.class).length, 				is(1)); 	}
@Test 	public void testResourceServerOverride() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(AuthorizationAndResourceServerConfiguration.class, 				CustomResourceServer.class, MinimalSecureWebApplication.class); 		this.context.refresh();  		ClientDetails config = this.context.getBean(ClientDetails.class);  		assertThat( 				this.context 						.getBeanNamesForType(SpringSecurityOAuth2AuthorizationServerConfiguration.class).length, 				is(1));  		assertThat(this.context.getBeanNamesForType(CustomResourceServer.class).length, 				is(1));  		assertThat( 				this.context 						.getBeanNamesForType(OAuth2ResourceServerConfiguration.class).length, 				is(1));  		verifyAuthentication(config);  	}
@Test 	public void testAuthorizationServerOverride() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.oauth2.resourceId:resource-id"); 		this.context.register(AuthorizationAndResourceServerConfiguration.class, 				CustomAuthorizationServer.class, MinimalSecureWebApplication.class); 		this.context.refresh();  		BaseClientDetails config = new BaseClientDetails(); 		config.setClientId("client"); 		config.setClientSecret("secret"); 		config.setResourceIds(Arrays.asList("resource-id")); 		config.setAuthorizedGrantTypes(Arrays.asList("password")); 		config.setAuthorities(AuthorityUtils.commaSeparatedStringToAuthorityList("USER")); 		config.setScope(Arrays.asList("read"));  		assertThat( 				this.context 						.getBeanNamesForType(SpringSecurityOAuth2AuthorizationServerConfiguration.class).length, 				is(0));  		assertThat( 				this.context 						.getBeanNamesForType(OAuth2ResourceServerConfiguration.class).length, 				is(1));  		verifyAuthentication(config); 	}
@Test 	public void testDefaultPrePostSecurityAnnotations() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(AuthorizationAndResourceServerConfiguration.class, 				MinimalSecureWebApplication.class); 		this.context.refresh();  		this.context.getBean(OAuth2MethodSecurityConfiguration.class);  		ClientDetails config = this.context.getBean(ClientDetails.class);  		DelegatingMethodSecurityMetadataSource source = this.context 				.getBean(DelegatingMethodSecurityMetadataSource.class); 		List<MethodSecurityMetadataSource> sources = source 				.getMethodSecurityMetadataSources();  		assertThat(sources.size(), is(1)); 		assertThat(sources.get(0).getClass().getName(), 				is(PrePostAnnotationSecurityMetadataSource.class.getName()));  		verifyAuthentication(config); 	}
@Test 	public void testClassicSecurityAnnotationOverride() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(SecuredEnabledConfiguration.class, 				MinimalSecureWebApplication.class); 		this.context.refresh();  		this.context.getBean(OAuth2MethodSecurityConfiguration.class);  		ClientDetails config = this.context.getBean(ClientDetails.class);  		DelegatingMethodSecurityMetadataSource source = this.context 				.getBean(DelegatingMethodSecurityMetadataSource.class); 		List<MethodSecurityMetadataSource> sources = source 				.getMethodSecurityMetadataSources();  		assertThat(sources.size(), is(1)); 		assertThat(sources.get(0).getClass().getName(), 				is(SecuredAnnotationSecurityMetadataSource.class.getName()));  		verifyAuthentication(config, HttpStatus.OK); 	}
@Test 	public void testJsr250SecurityAnnotationOverride() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(Jsr250EnabledConfiguration.class, 				MinimalSecureWebApplication.class); 		this.context.refresh();  		this.context.getBean(OAuth2MethodSecurityConfiguration.class);  		ClientDetails config = this.context.getBean(ClientDetails.class);  		DelegatingMethodSecurityMetadataSource source = this.context 				.getBean(DelegatingMethodSecurityMetadataSource.class); 		List<MethodSecurityMetadataSource> sources = source 				.getMethodSecurityMetadataSources();  		assertThat(sources.size(), is(1)); 		assertThat(sources.get(0).getClass().getName(), 				is(Jsr250MethodSecurityMetadataSource.class.getName()));  		verifyAuthentication(config, HttpStatus.OK); 	}
@Override 	public boolean matches(ClassNode classNode) { 		return AstUtils.hasAtLeastOneAnnotation(classNode, "EnableWebSecurity", "EnableGlobalMethodSecurity"); 	}
@Override 	public void applyDependencies(DependencyCustomizer dependencies) { 		dependencies 				.ifAnyMissingClasses( 						"org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity") 				.add("spring-boot-starter-security"); 	}
@Override 	public void applyImports(ImportCustomizer imports) { 		imports.addImports("org.springframework.security.core.Authentication", 				"org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity", 				"org.springframework.security.core.authority.AuthorityUtils") 				.addStarImports( 						"org.springframework.security.config.annotation.web.configuration", 						"org.springframework.security.authentication", 						"org.springframework.security.config.annotation.web", 						"org.springframework.security.config.annotation.web.builders"); 	}
@Override 	public boolean matches(ClassNode classNode) { 		return AstUtils.hasAtLeastOneAnnotation(classNode, 				"EnableAuthorizationServer", "EnableResourceServer", "EnableOAuth2Client", "EnableOAuth2Sso"); 	}
@Override 	public void applyImports(ImportCustomizer imports) throws CompilationFailedException { 		imports 			.addImports( 					"org.springframework.boot.autoconfigure.security.oauth2.client.EnableOAuth2Sso") 			.addStarImports( 					"org.springframework.security.oauth2.config.annotation.web.configuration", 					"org.springframework.security.access.prepost"); 	}
@Test 	public void oauth2Sample() throws Exception { 		String output = this.cli.run("oauth2.groovy"); 		assertTrue("Wrong output: " + output, output.contains("spring.oauth2.client.clientId")); 		assertTrue("Wrong output: " + output, output.contains("spring.oauth2.client.secret =")); 	}
@Override 	protected void registerHandlerMethod(Object handler, Method method, 			RequestMappingInfo mapping) { 		if (mapping == null) { 			return; 		} 		String[] patterns = getPatterns(handler, mapping); 		super.registerMapping(withNewPatterns(mapping, patterns), handler, method); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping); 			if (paths.length > 0 && this.management.getSecurity().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				paths = this.server.getPathsArray(paths); 				http.requestMatchers().antMatchers(paths); 				String[] endpointPaths = this.server.getPathsArray(getEndpointPaths( 						this.endpointHandlerMapping, false)); 				configureAuthorizeRequests(endpointPaths, http.authorizeRequests()); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions()); 				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders()); 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
private Health getHealth(Principal principal) { 		long accessTime = System.currentTimeMillis(); 		if (isCacheStale(accessTime)) { 			this.lastAccess = accessTime; 			this.cached = this.delegate.invoke(); 		} 		if (exposeHealthDetails(principal)) { 			return this.cached; 		} 		return Health.status(this.cached.getStatus()).build(); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Autowired 		public void init(AuthenticationManagerBuilder auth) throws Exception { 			auth.inMemoryAuthentication().withUser("dave").password("secret") 					.roles("USER"); 		}
@Bean 	@ConditionalOnMissingBean 	public HealthEndpoint healthEndpoint() { 		return new HealthEndpoint(this.healthAggregator, this.healthIndicators); 	}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnProperty(prefix = "endpoints.health", name = "enabled", matchIfMissing = true) 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		Security security = this.managementServerProperties.getSecurity(); 		boolean secure = (security == null || security.isEnabled()); 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate, secure); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint.addStatusMapping(this.healthMvcEndpointProperties 					.getMapping()); 		} 		return healthMvcEndpoint; 	}
private void configureAuthorizeRequests( 				String[] endpointPaths, 				ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry requests) { 			requests.antMatchers(endpointPaths).permitAll(); 			requests.anyRequest().hasRole(this.management.getSecurity().getRole()); 		}
@Override 	protected void registerHandlerMethod(Object handler, Method method, 			RequestMappingInfo mapping) { 		if (mapping == null) { 			return; 		} 		String[] patterns = getPatterns(handler, mapping); 		super.registerHandlerMethod(handler, method, withNewPatterns(mapping, patterns)); 	}
@RequestMapping 	@ResponseBody 	public Object invoke(Principal principal) { 		if (!this.delegate.isEnabled()) { 			// Shouldn't happen because the request mapping should not be registered 			return new ResponseEntity<Map<String, String>>(Collections.singletonMap( 					"message", "This endpoint is disabled"), HttpStatus.NOT_FOUND); 		} 		Health health = getHealth(principal); 		HttpStatus status = this.statusMapping.get(health.getStatus().getCode()); 		if (status != null) { 			return new ResponseEntity<Health>(health, status); 		} 		return health; 	}
private Health getHealth(Principal principal) { 		long accessTime = System.currentTimeMillis(); 		if (isCacheStale(accessTime) || isSecure(principal) || isUnrestricted()) { 			this.lastAccess = accessTime; 			this.cached = this.delegate.invoke(); 		} 		if (isSecure(principal) || isUnrestricted()) { 			return this.cached; 		} 		return Health.status(this.cached.getStatus()).build(); 	}
@Before 	public void init() { 		this.endpoint = mock(HealthEndpoint.class); 		given(this.endpoint.isEnabled()).willReturn(true); 		this.mvc = new HealthMvcEndpoint(this.endpoint); 		this.environment = new MockEnvironment(); 		this.mvc.setEnvironment(this.environment); 	}
@Test 	public void unsecureAnonymousAccessUnrestricted() { 		this.environment.getPropertySources().addLast(NON_SENSITIVE); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void unsecureIsNotCachedWhenAnonymousAccessIsUnrestricted() { 		this.environment.getPropertySources().addLast(NON_SENSITIVE); 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertTrue(health.getStatus() == Status.DOWN); 	}
@Test 	public void testCustomContextPath() throws Exception { 		ResponseEntity<String> entity = new TestRestTemplate("user", getPassword()) 				.getForEntity("http://localhost:" + this.port + "/admin/health", 						String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertTrue("Wrong body: " + entity.getBody(), 				entity.getBody().contains("\"status\":\"UP\"")); 		System.err.println(entity.getBody()); 		assertTrue("Wrong body: " + entity.getBody(), 				entity.getBody().contains("\"hello\":\"world\"")); 	}
@Bean 	@ConditionalOnMissingBean 	public HealthEndpoint healthEndpoint() { 		// The default sensitivity depends on whether all the endpoints by default are 		// secure or not. User can always override with endpoints.health.sensitive. 		boolean secure = this.management != null && this.management.getSecurity() != null 				&& this.management.getSecurity().isEnabled(); 		HealthEndpoint endpoint = new HealthEndpoint(this.healthAggregator, 				this.healthIndicators); 		endpoint.setSensitive(secure); 		return endpoint; 	}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnProperty(prefix = "endpoints.health", name = "enabled", matchIfMissing = true) 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint.addStatusMapping(this.healthMvcEndpointProperties 					.getMapping()); 		} 		return healthMvcEndpoint; 	}
@Bean 	public HandlerMapping handlerMapping(MvcEndpoints endpoints, 			ListableBeanFactory beanFactory) { 		Set<MvcEndpoint> set = new HashSet<MvcEndpoint>(endpoints.getEndpoints()); 		set.addAll(beanFactory.getBeansOfType(MvcEndpoint.class).values()); 		EndpointHandlerMapping mapping = new EndpointHandlerMapping(set); 		// In a child context we definitely want to see the parent endpoints 		mapping.setDetectHandlerMethodsInAncestorContexts(true); 		injectIntoSecurityFilter(beanFactory, mapping); 		if (this.mappingCustomizers != null) { 			for (EndpointHandlerMappingCustomizer customizer : this.mappingCustomizers) { 				customizer.customize(mapping); 			} 		} 		return mapping; 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping); 			if (paths.length > 0 && this.management.getSecurity().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				paths = this.server.getPathsArray(paths); 				http.requestMatchers().antMatchers(paths); 				String[] endpointPaths = this.server.getPathsArray(getEndpointPaths( 						this.endpointHandlerMapping, false)); 				ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry authorizeRequests = http 						.authorizeRequests(); 				authorizeRequests.antMatchers(endpointPaths).permitAll(); 				if (this.endpointHandlerMapping != null) { 					authorizeRequests.requestMatchers( 							new PrincipalHandlerRequestMatcher()).permitAll(); 				} 				authorizeRequests.anyRequest().hasRole( 						this.management.getSecurity().getRole()); 				http.httpBasic();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions());  				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
private static String[] getEndpointPaths( 			EndpointHandlerMapping endpointHandlerMapping, boolean secure) { 		if (endpointHandlerMapping == null) { 			return NO_PATHS; 		}  		Set<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints(); 		List<String> paths = new ArrayList<String>(endpoints.size()); 		for (MvcEndpoint endpoint : endpoints) { 			if (endpoint.isSensitive() == secure) { 				String path = endpointHandlerMapping.getPath(endpoint.getPath()); 				paths.add(path); 				// Add Spring MVC-generated additional paths 				paths.add(path + "/"); 				paths.add(path + ".*"); 			} 		} 		return paths.toArray(new String[paths.size()]); 	}
@Override 	protected void registerHandlerMethod(Object handler, Method method, 			RequestMappingInfo mapping) {  		if (mapping == null) { 			return; 		}  		Set<String> defaultPatterns = mapping.getPatternsCondition().getPatterns(); 		String[] patterns = new String[defaultPatterns.isEmpty() ? 1 : defaultPatterns 				.size()];  		String path = ""; 		Object bean = handler; 		if (bean instanceof String) { 			bean = getApplicationContext().getBean((String) handler); 		} 		if (bean instanceof MvcEndpoint) { 			MvcEndpoint endpoint = (MvcEndpoint) bean; 			path = endpoint.getPath(); 		}  		int i = 0; 		String prefix = StringUtils.hasText(this.prefix) ? this.prefix + path : path; 		if (defaultPatterns.isEmpty()) { 			patterns[0] = prefix; 		} 		else { 			for (String pattern : defaultPatterns) { 				patterns[i] = prefix + pattern; 				i++; 			} 		} 		PatternsRequestCondition patternsInfo = new PatternsRequestCondition(patterns);  		RequestMappingInfo modified = new RequestMappingInfo(patternsInfo, 				mapping.getMethodsCondition(), mapping.getParamsCondition(), 				mapping.getHeadersCondition(), mapping.getConsumesCondition(), 				mapping.getProducesCondition(), mapping.getCustomCondition());  		if (handlesPrincipal(method)) { 			this.principalHandlers.add(new HandlerMethod(handler, method)); 		}  		super.registerHandlerMethod(handler, method, modified); 	}
@Test 	public void testCustomContextPath() throws Exception { 		ResponseEntity<String> entity = new TestRestTemplate().getForEntity( 				"http://localhost:" + this.port + "/admin/health", String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertTrue("Wrong body: " + entity.getBody(), 				entity.getBody().contains("\"status\":\"UP\"")); 		System.err.println(entity.getBody()); 		assertTrue("Wrong body: " + entity.getBody(), 				entity.getBody().contains("\"hello\":\"world\"")); 	}
private static String[] getEndpointPaths( 			EndpointHandlerMapping endpointHandlerMapping, boolean secure) { 		if (endpointHandlerMapping == null) { 			return NO_PATHS; 		}  		Set<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints(); 		List<String> paths = new ArrayList<String>(endpoints.size()); 		for (MvcEndpoint endpoint : endpoints) { 			if (endpoint.isSensitive() == secure 					|| (!secure && endpoint instanceof AnonymouslyAccessibleMvcEndpoint)) { 				String path = endpointHandlerMapping.getPath(endpoint.getPath()); 				paths.add(path); 				// Add Spring MVC-generated additional paths 				paths.add(path + "/"); 				paths.add(path + ".*"); 			} 		} 		return paths.toArray(new String[paths.size()]); 	}
@Test 	public void testEventPublisherInjected() throws Exception { 		testAuthenticationManagerCreated(); 		final AtomicReference<ApplicationEvent> wrapper = new AtomicReference<ApplicationEvent>(); 		this.context.addApplicationListener(new ApplicationListener<ApplicationEvent>() { 			@Override 			public void onApplicationEvent(ApplicationEvent event) { 				wrapper.set(event); 			}; 		}); 		AuthenticationManager manager = this.context.getBean(AuthenticationManager.class); 		try { 			manager.authenticate(new UsernamePasswordAuthenticationToken("foo", "bar")); 			fail("Expected BadCredentialsException"); 		} 		catch (BadCredentialsException e) { 			// expected 		} 		assertTrue("Wrong event type: " + wrapper.get(), 				wrapper.get() instanceof AuthenticationFailureBadCredentialsEvent); 	}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return new TestingAuthenticationToken("foo", "bar"); 				}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return builder.getOrBuild().authenticate(authentication); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  			String[] paths = getSecureApplicationPaths();  			if (paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.httpBasic(); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests() 						.anyRequest() 						.hasAnyRole( 								this.security.getUser().getRole().toArray(new String[0])); 			}  		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = getIgnored(this.security); 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			String[] paths = this.server.getPathsArray(ignored); 			ignoring.antMatchers(paths); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  			String[] paths = getSecureApplicationPaths();  			if (paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.httpBasic(); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests() 						.anyRequest() 						.hasAnyRole( 								this.security.getUser().getRole().toArray(new String[0])); 			}  		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 5 for static resources and one for the rest 		List<SecurityFilterChain> filterChains = this.context.getBean( 				FilterChainProxy.class).getFilterChains(); 		assertEquals(5, filterChains.size()); 	}
@Test 	public void testDefaultIgnores() { 		assertTrue(SpringBootWebSecurityConfiguration 				.getIgnored(new SecurityProperties()).contains("/css/**")); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 6 for static resources, one for management endpoints and one for the rest 		assertEquals(9, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				FallbackWebSecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Just the management endpoints (one filter) and ignores now plus the backup 		// filter on app endpoints 		assertEquals(9, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  			String[] paths = getSecureApplicationPaths();  			if (paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.httpBasic(); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests() 						.anyRequest() 						.hasAnyRole( 								this.security.getUser().getRole().toArray(new String[0])); 			}  		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 5 for static resources and one for the rest 		List<SecurityFilterChain> filterChains = this.context.getBean( 				FilterChainProxy.class).getFilterChains(); 		assertEquals(6, filterChains.size()); 	}
@Override 		public void init() { 			String rolesPropertyValue = getContext().getProperty(ROLES); 			if (rolesPropertyValue != null) { 				this.roles = StringUtils 						.commaDelimitedListToStringArray(rolesPropertyValue); 			} 		}
public String getName() { 			return this.name; 		}
@PostConstruct 		public void init() { 			FS commandFileSystem = createFileSystem( 					this.properties.getCommandPathPatterns(), 					this.properties.getDisabledCommands()); 			FS configurationFileSystem = createFileSystem( 					this.properties.getConfigPathPatterns(), new String[0]);  			PluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery( 					this.resourceLoader.getClassLoader(), this.beanFactory, 					this.properties.getDisabledPlugins());  			PluginContext context = new PluginContext(discovery, 					createPluginContextAttributes(), commandFileSystem, 					configurationFileSystem, this.resourceLoader.getClassLoader());  			context.refresh(); 			start(context); 		}
@Override 		public String getName() { 			return "spring"; 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
public void setRoles(String[] roles) { 			// 'roles' can be null. This means no special to access right to connect to 			// shell is required. 			this.roles = roles; 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  			String[] paths = getSecureApplicationPaths();  			if (paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.httpBasic(); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests() 						.anyRequest() 						.hasAnyRole( 								this.security.getUser().getRole().toArray(new String[0])); 			}  		}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Ignores and the "matches-none" filter only 		assertEquals(1, this.context.getBeanNamesForType(FilterChainProxy.class).length); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				FallbackWebSecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Just the management endpoints (one filter) and ignores now plus the backup 		// filter on app endpoints 		assertEquals(8, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Bean 	@Lazy 	@Scope(proxyMode = ScopedProxyMode.INTERFACES) 	protected AuthenticationManager lazyAuthenticationManager() { 		AuthenticationManager manager = this.configurer.getAuthenticationManagerBuilder() 				.getOrBuild(); 		if (manager instanceof ProviderManager) { 			((ProviderManager) manager) 					.setAuthenticationEventPublisher(this.authenticationEventPublisher); 		} 		return manager; 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  			String[] paths = getSecureApplicationPaths(); 			configureAdditionalRules(http, paths);  		}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Ignores and permitAll() security on application endpoints 		assertEquals(1, this.context.getBeanNamesForType(FilterChainProxy.class).length); 	}
public static void main(String[] args) throws Exception { 		new SpringApplicationBuilder(SampleWebSecureApplication.class).run(args); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (!security.isEnableCsrf()) { 				// For testing 				http.csrf().disable(); 			} 			http.authorizeRequests().anyRequest().fullyAuthenticated().and().formLogin() 					.loginPage("/login").failureUrl("/login?error").permitAll(); 		}
@Test 	public void testHome() throws Exception { 		HttpHeaders headers = new HttpHeaders(); 		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML)); 		ResponseEntity<String> entity = new TestRestTemplate().exchange( 				"http://localhost:" + this.port, HttpMethod.GET, new HttpEntity<Void>( 						headers), String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertTrue("Wrong body (title doesn't match):\n" + entity.getBody(), 				entity.getBody().contains("<title>Login")); 	}
@Override 	public void customize(ConfigurableEmbeddedServletContainer container) { 		container.addErrorPages(new ErrorPage(this.properties.getServletPrefix() 				+ this.errorPath)); 	}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			// The ignores are not cumulative, so to prevent overwriting the defaults we 			// add them back. 			List<String> ignored = SpringBootWebSecurityConfiguration 					.getIgnored(this.security); 			ignored.addAll(Arrays.asList(getEndpointPaths(this.endpointHandlerMapping, 					false))); 			if (!this.management.getSecurity().isEnabled()) { 				ignored.addAll(Arrays.asList(getEndpointPaths( 						this.endpointHandlerMapping, true))); 			} 			if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			String[] paths = this.server.getPathsArray(ignored); 			ignoring.antMatchers(paths); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping, true); 			if (paths.length > 0 && this.management.getSecurity().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				paths = this.server.getPathsArray(paths); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.management.getSecurity().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions());  				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
@Bean 	@ConditionalOnMissingBean 	@ConditionalOnBean(DataSource.class) 	public JobExplorer jobExplorer(DataSource dataSource) throws Exception { 		JobExplorerFactoryBean factory = new JobExplorerFactoryBean(); 		factory.setDataSource(dataSource); 		factory.afterPropertiesSet(); 		return factory.getObject(); 	}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = getIgnored(this.security); 			String[] paths = this.server.getPathsArray(ignored); 			ignoring.antMatchers(paths); 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 4 for static resources and one for the rest 		List<SecurityFilterChain> filterChains = this.context.getBean( 				FilterChainProxy.class).getFilterChains(); 		assertEquals(5, filterChains.size()); 	}
@Test 	public void testDisableIgnoredStaticApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.ignored:none"); 		this.context.refresh(); 		// Just the application endpoints now 		assertEquals(1, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// No security at all not even ignores 		assertEquals(0, this.context.getBeanNamesForType(FilterChainProxy.class).length); 	}
@Test 	public void testAuthenticationManagerCreated() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testOverrideAuthenticationManager() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(TestConfiguration.class, SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertEquals(this.context.getBean(TestConfiguration.class).authenticationManager, 				this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testJpaCoexistsHappily() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(EntityConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class, 				DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class, 				SecurityAutoConfiguration.class, ServerPropertiesAutoConfiguration.class); 		// This can fail if security @Conditionals force early instantiation of the 		// HibernateJpaAutoConfiguration (e.g. the EntityManagerFactory is not found) 		this.context.refresh(); 		assertNotNull(this.context.getBean(JpaTransactionManager.class)); 	}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			// The ignores are not cumulative, so to prevent overwriting the defaults we 			// add them back. 			List<String> ignored = SpringBootWebSecurityConfiguration 					.getIgnored(this.security); 			ignored.addAll(Arrays.asList(getEndpointPaths(this.endpointHandlerMapping, 					false))); 			if (!this.management.getSecurity().isEnabled()) { 				ignored.addAll(Arrays.asList(getEndpointPaths( 						this.endpointHandlerMapping, true))); 			} 			if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			String[] paths = this.server.getPathsArray(ignored); 			ignoring.antMatchers(paths); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping, true); 			if (paths.length > 0 && this.management.getSecurity().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				paths = this.server.getPathsArray(paths); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.management.getSecurity().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions());  				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = getIgnored(this.security); 			String[] paths = this.server.getPathsArray(ignored); 			ignoring.antMatchers(paths); 		}
@Override 					public void customize(Connector connector) { 						ProtocolHandler handler = connector.getProtocolHandler(); 						if (handler instanceof AbstractHttp11Protocol) { 							AbstractHttp11Protocol protocol = (AbstractHttp11Protocol) handler; 							protocol.setMaxHttpHeaderSize(Tomcat.this.maxHttpHeaderSize); 						} 					}
@Override 					public void customize(Connector connector) { 						ProtocolHandler handler = connector.getProtocolHandler(); 						if (handler instanceof AbstractProtocol) { 							AbstractProtocol protocol = (AbstractProtocol) handler; 							protocol.setMaxThreads(Tomcat.this.maxThreads); 						} 					}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 4 for static resources and one for the rest 		List<SecurityFilterChain> filterChains = this.context.getBean( 				FilterChainProxy.class).getFilterChains(); 		assertEquals(5, filterChains.size()); 	}
@Test 	public void testDisableIgnoredStaticApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.ignored:none"); 		this.context.refresh(); 		// Just the application endpoints now 		assertEquals(1, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// No security at all not even ignores 		assertEquals(0, this.context.getBeanNamesForType(FilterChainProxy.class).length); 	}
@Test 	public void testAuthenticationManagerCreated() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testOverrideAuthenticationManager() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(TestConfiguration.class, SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertEquals(this.context.getBean(TestConfiguration.class).authenticationManager, 				this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testJpaCoexistsHappily() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.datasource.url:jdbc:hsqldb:mem:testsecdb"); 		this.context.register(EntityConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class, 				DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class, 				SecurityAutoConfiguration.class, ServerPropertiesAutoConfiguration.class); 		// This can fail if security @Conditionals force early instantiation of the 		// HibernateJpaAutoConfiguration (e.g. the EntityManagerFactory is not found) 		this.context.refresh(); 		assertNotNull(this.context.getBean(JpaTransactionManager.class)); 	}
public static void main(String[] args) throws Exception { 		new SpringApplicationBuilder(SampleMethodSecurityApplication.class) 				.run(args); 	}
@Override 		public void init(AuthenticationManagerBuilder auth) throws Exception { 			// @formatter:off 			auth.inMemoryAuthentication().withUser("admin").password("admin") 					.roles("ADMIN", "USER").and().withUser("user") 					.password("user").roles("USER"); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests().antMatchers("/login").permitAll() 					.anyRequest().fullyAuthenticated().and().formLogin() 					.loginPage("/login").failureUrl("/login?error").and() 					.logout() 					.logoutRequestMatcher(new AntPathRequestMatcher("/logout")) 					.and().exceptionHandling() 					.accessDeniedPage("/access?error"); 			// @formatter:on 		}
public static void main(String[] args) throws Exception { 		// Set user password to "password" for demo purposes only 		new SpringApplicationBuilder(SampleWebSecureApplication.class) 				.properties("security.user.password=password").run(args); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().fullyAuthenticated().and() 					.formLogin().loginPage("/login").failureUrl("/login?error") 					.permitAll(); 		}
@Override 		public void configure(AuthenticationManagerBuilder auth) throws Exception { 			if (auth.isConfigured()) { 				this.defaultAuth = auth; 				return; 			}  			User user = AuthenticationManagerConfiguration.this.security.getUser(); 			if (user.isDefaultPassword()) { 				logger.info("\n\nUsing default security password: " 						+ user.getPassword() + "\n\n"); 			}  			this.defaultAuth = new AuthenticationManagerBuilder( 					AuthenticationManagerConfiguration.this.objectPostProcessor);  			Set<String> roles = new LinkedHashSet<String>(user.getRole());  			AuthenticationManager parent = this.defaultAuth.inMemoryAuthentication() 					.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()])).and().and().build();  			auth.parentAuthenticationManager(parent); 		}
@Test 	public void testBindingIgnoredSingleValued() { 		this.binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.ignored", "/css/**"))); 		assertFalse(this.binder.getBindingResult().hasErrors()); 		assertEquals(1, this.security.getIgnored().size()); 	}
@Test 	public void testBindingIgnoredEmpty() { 		this.binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.ignored", ""))); 		assertFalse(this.binder.getBindingResult().hasErrors()); 		assertEquals(0, this.security.getIgnored().size()); 	}
@Test 	public void testBindingIgnoredDisable() { 		this.binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.ignored", "none"))); 		assertFalse(this.binder.getBindingResult().hasErrors()); 		assertEquals(1, this.security.getIgnored().size()); 	}
@Test 	public void testBindingIgnoredMultiValued() { 		this.binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.ignored", "/css/**,/images/**"))); 		assertFalse(this.binder.getBindingResult().hasErrors()); 		assertEquals(2, this.security.getIgnored().size()); 	}
@Test 	public void testBindingIgnoredMultiValuedList() { 		Map<String, String> map = new HashMap<String, String>(); 		map.put("security.ignored[0]", "/css/**"); 		map.put("security.ignored[1]", "/foo/**"); 		this.binder.bind(new MutablePropertyValues(map)); 		assertFalse(this.binder.getBindingResult().hasErrors()); 		assertEquals(2, this.security.getIgnored().size()); 		assertTrue(this.security.getIgnored().contains("/foo/**")); 	}
@Test 	public void testDefaultPasswordAutogeneratedIfUnresolovedPlaceholder() { 		this.binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.user.password", "${ADMIN_PASSWORD}"))); 		assertFalse(this.binder.getBindingResult().hasErrors()); 		assertTrue(this.security.getUser().isDefaultPassword()); 	}
@Test 	public void testDefaultPasswordAutogeneratedIfEmpty() { 		this.binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.user.password", ""))); 		assertFalse(this.binder.getBindingResult().hasErrors()); 		assertTrue(this.security.getUser().isDefaultPassword()); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				FallbackWebSecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Just the management endpoints (one filter) and ignores now 		assertEquals(7, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
public static void main(String[] args) throws Exception { 		// Set user password to "password" for demo purposes only 		new SpringApplicationBuilder(SampleSecureApplication.class).properties("security.user.password=password").run( 				args); 	}
@Override 	public final boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { 		String classOrMethodName = getClassOrMethodName(metadata); 		try { 			ConditionOutcome outcome = getMatchOutcome(context, metadata); 			logOutcome(classOrMethodName, outcome); 			recordEvaluation(context, classOrMethodName, outcome); 			return outcome.isMatch(); 		} 		catch (NoClassDefFoundError e) { 			throw new IllegalStateException( 					"Could not evaluate condition owing to internal class not found. " 							+ "This can happen if you are @ComponentScanning a springframework package " 							+ "(e.g. if you put a @ComponentScan in the default package by mistake)", 					e); 		} 	}
@Override 	public void init(AuthenticationManagerBuilder auth) throws Exception { 		auth.apply(this.configurer); 	}
@Override 		public void configure(AuthenticationManagerBuilder auth) throws Exception { 			if (auth.isConfigured()) { 				this.defaultAuth = auth; 				return; 			}  			User user = AuthenticationManagerConfiguration.this.security.getUser(); 			if (user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for application endpoints: " 						+ user.getPassword() + "\n\n"); 			}  			this.defaultAuth = new AuthenticationManagerBuilder( 					AuthenticationManagerConfiguration.this.objectPostProcessor);  			Set<String> roles = new LinkedHashSet<String>(user.getRole());  			AuthenticationManager parent = this.defaultAuth.inMemoryAuthentication() 					.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()])).and().and().build();  			auth.parentAuthenticationManager(parent); 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 4 for static resources and one for the rest 		List<SecurityFilterChain> filterChains = this.context.getBean( 				FilterChainProxy.class).getFilterChains(); 		assertEquals(5, filterChains.size()); 	}
private UserDetails getUser() { 		ProviderManager manager = this.context.getBean(ProviderManager.class); 		ProviderManager parent = (ProviderManager) ReflectionTestUtils.getField(manager, 				"parent"); 		DaoAuthenticationProvider provider = (DaoAuthenticationProvider) parent 				.getProviders().get(0); 		UserDetailsService service = (UserDetailsService) ReflectionTestUtils.getField( 				provider, "userDetailsService"); 		UserDetails user = service.loadUserByUsername("user"); 		return user; 	}
@Test 	public void testSecurityPropertiesNotAvailable() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(TestConfiguration.class, SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertEquals(this.context.getBean(TestConfiguration.class).authenticationManager, 				this.context.getBean(AuthenticationManager.class)); 	}
@Override 		public void configure(AuthenticationManagerBuilder auth) throws Exception { 			if (auth.isConfigured()) { 				return; 			}  			User user = AuthenticationManagerConfiguration.this.security.getUser(); 			if (user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for application endpoints: " 						+ user.getPassword() + "\n\n"); 			}  			AuthenticationManagerBuilder defaultAuth = new AuthenticationManagerBuilder( 					AuthenticationManagerConfiguration.this.objectPostProcessor);  			Set<String> roles = new LinkedHashSet<String>(user.getRole());  			AuthenticationManager parent = defaultAuth.inMemoryAuthentication() 					.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()])).and().and().build();  			auth.parentAuthenticationManager(parent); 		}
@Before 	public void init() { 		AuthenticationManager authenticationManager = context 				.getBean(AuthenticationManagerBuilder.class).getOrBuild(); 		authentication = authenticationManager 				.authenticate(new UsernamePasswordAuthenticationToken("user", "password")); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 6 for static resources, one for management endpoints and one for the rest 		assertEquals(8, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testWebConfigurationWithExtraRole() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(EndpointAutoConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, UserDetailsExposed.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		UserDetails user = getUser(); 		assertTrue(user.getAuthorities().containsAll( 				AuthorityUtils 						.commaSeparatedStringToAuthorityList("ROLE_USER,ROLE_ADMIN"))); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		debugRefresh(this.context); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 4 for static resources and one for the rest 		assertEquals(5, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
public static void main(String[] args) throws Exception { 		SpringApplication.run(SampleSecureApplication.class, "--debug"); 	}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
boolean isDefaultPassword() { 				return this.defaultPassword; 			}
public void setPassword(String password) { 				if (password.startsWith("${") && password.endsWith("}") 						|| !StringUtils.hasLength(password)) { 					return; 				} 				this.password = password; 				this.defaultPassword = false; 			}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
@Test 	public void testSimpleAuthenticationProvider() throws Exception { 		MockEnvironment env = new MockEnvironment(); 		env.setProperty("shell.auth", "simple"); 		env.setProperty("shell.auth.simple.user.name", "user"); 		env.setProperty("shell.auth.simple.user.password", "password"); 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setEnvironment(env); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityConfiguration.class); 		this.context.register(CrshAutoConfiguration.class); 		this.context.refresh();  		PluginLifeCycle lifeCycle = this.context.getBean(PluginLifeCycle.class); 		assertEquals(lifeCycle.getConfig().get("crash.auth"), "simple");  		AuthenticationPlugin<String> authenticationPlugin = null; 		String authentication = lifeCycle.getConfig().getProperty("crash.auth"); 		assertNotNull(authentication); 		for (AuthenticationPlugin plugin : lifeCycle.getContext().getPlugins( 				AuthenticationPlugin.class)) { 			if (authentication.equals(plugin.getName())) { 				authenticationPlugin = plugin; 				break; 			} 		} 		assertNotNull(authenticationPlugin); 		assertTrue(authenticationPlugin.authenticate("user", "password")); 		assertFalse(authenticationPlugin.authenticate(UUID.randomUUID().toString(), 				"password")); 	}
@Test 	public void testBindingSimple() { 		SimpleAuthenticationProperties props = new SimpleAuthenticationProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(props, "shell.auth.simple"); 		binder.setConversionService(new DefaultConversionService()); 		Map<String, String> map = new HashMap<String, String>(); 		map.put("shell.auth.simple.user.name", "username123"); 		map.put("shell.auth.simple.user.password", "password123"); 		binder.bind(new MutablePropertyValues(map)); 		assertFalse(binder.getBindingResult().hasErrors());  		Properties p = new Properties(); 		props.applyToCrshShellConfig(p);  		assertEquals("username123", p.get("crash.auth.simple.username")); 		assertEquals("password123", p.get("crash.auth.simple.password")); 	}
@Test 	public void testDefaultPasswordAutogeneratedIfUnresolovedPlaceholder() { 		SimpleAuthenticationProperties security = new SimpleAuthenticationProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"shell.auth.simple.user.password", "${ADMIN_PASSWORD}"))); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertTrue(security.getUser().isDefaultPassword()); 	}
@Test 	public void testDefaultPasswordAutogeneratedIfEmpty() { 		SimpleAuthenticationProperties security = new SimpleAuthenticationProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"shell.auth.simple.user.password", ""))); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertTrue(security.getUser().isDefaultPassword()); 	}
@Bean 		@ConditionalOnExpression("'${shell.auth:default_spring}' == 'default_spring'") 		@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 		public CrshShellAuthenticationProperties springAuthenticationProperties() { 			// In case no shell.auth property is provided fall back to Spring Security 			// based authentication and get role to access shell from 			// ManagementServerProperties. 			SpringAuthenticationProperties authenticationProperties = new SpringAuthenticationProperties(); 			if (this.management != null) { 				authenticationProperties.setRoles(new String[] { this.management 						.getSecurity().getRole() }); 			} 			return authenticationProperties; 		}
@Bean 	@ConditionalOnExpression("'${shell.auth:simple}' == 'spring'") 	@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 	public CrshShellAuthenticationProperties springAuthenticationProperties() { 		return new SpringAuthenticationProperties(); 	}
@Bean 		@ConditionalOnExpression("'${shell.auth:default_spring}' == 'default_spring'") 		@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 		public CrshShellAuthenticationProperties springAuthenticationProperties() { 			// In case no shell.auth property is provided fall back to Spring Security 			// based authentication and get role to access shell from 			// ManagementServerProperties. 			SpringAuthenticationProperties authenticationProperties = new SpringAuthenticationProperties(); 			if (this.management != null) { 				authenticationProperties.setRoles(new String[] { this.management 						.getSecurity().getRole() }); 			} 			return authenticationProperties; 		}
@Override 		public void init() { 			String rolesPropertyValue = getContext().getProperty(ROLES); 			if (rolesPropertyValue != null) { 				this.roles = StringUtils 						.commaDelimitedListToStringArray(rolesPropertyValue); 			} 		}
public String getName() { 			return this.name; 		}
@PostConstruct 		public void init() throws Exception { 			FS commandFileSystem = createFileSystem(this.properties 					.getCommandPathPatterns()); 			FS configurationFileSystem = createFileSystem(this.properties 					.getConfigPathPatterns());  			PluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery( 					this.resourceLoader.getClassLoader(), this.beanFactory, 					this.properties.getDisabledPlugins());  			PluginContext context = new PluginContext(discovery, 					createPluginContextAttributes(), commandFileSystem, 					configurationFileSystem, this.resourceLoader.getClassLoader());  			context.refresh(); 			start(context); 		}
@Override 		public String getName() { 			return "spring"; 		}
@Bean 		@ConditionalOnExpression("'${shell.auth:default_spring}' == 'default_spring'") 		@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 		public CrshShellAuthenticationProperties springAuthenticationProperties() { 			// In case no shell.auth property is provided fall back to Spring Security 			// based authentication and get role to access shell from SecurityProperties. 			SpringAuthenticationProperties authenticationProperties = new SpringAuthenticationProperties(); 			if (this.management != null) { 				authenticationProperties.setRoles(new String[] { this.management 						.getSecurity().getRole() }); 			} 			return authenticationProperties; 		}
@Bean 	@ConditionalOnExpression("'${shell.auth:simple}' == 'spring'") 	@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 	public CrshShellAuthenticationProperties springAuthenticationProperties() { 		return new SpringAuthenticationProperties(); 	}
@Bean 		@ConditionalOnExpression("'${shell.auth:default_spring}' == 'default_spring'") 		@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 		public CrshShellAuthenticationProperties springAuthenticationProperties() { 			// In case no shell.auth property is provided fall back to Spring Security 			// based authentication and get role to access shell from SecurityProperties. 			SpringAuthenticationProperties authenticationProperties = new SpringAuthenticationProperties(); 			if (this.management != null) { 				authenticationProperties.setRoles(new String[] { this.management 						.getSecurity().getRole() }); 			} 			return authenticationProperties; 		}
@Override 		public void init() { 			String rolesPropertyValue = getContext().getProperty(ROLES); 			if (rolesPropertyValue != null) { 				this.roles = StringUtils 						.commaDelimitedListToStringArray(rolesPropertyValue); 			} 		}
public String getName() { 			return this.name; 		}
@PostConstruct 		public void init() throws Exception { 			FS commandFileSystem = createFileSystem(this.properties 					.getCommandPathPatterns()); 			FS configurationFileSystem = createFileSystem(this.properties 					.getConfigPathPatterns());  			PluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery( 					this.resourceLoader.getClassLoader(), this.beanFactory, 					this.properties.getDisabledPlugins());  			PluginContext context = new PluginContext(discovery, 					createPluginContextAttributes(), commandFileSystem, 					configurationFileSystem, this.resourceLoader.getClassLoader());  			context.refresh(); 			start(context); 		}
@Override 		public String getName() { 			return "spring"; 		}
public static ManagementServerPort get(ApplicationContext beanFactory) {  			ServerProperties serverProperties; 			try { 				serverProperties = beanFactory.getBean(ServerProperties.class); 			} 			catch (NoSuchBeanDefinitionException ex) { 				serverProperties = new ServerProperties(); 			}  			ManagementServerProperties managementServerProperties; 			try { 				managementServerProperties = beanFactory 						.getBean(ManagementServerProperties.class); 			} 			catch (NoSuchBeanDefinitionException ex) { 				managementServerProperties = new ManagementServerProperties(); 			}  			if (DISABLED_PORT.equals(managementServerProperties.getPort())) { 				return DISABLE; 			} 			if (!(beanFactory instanceof WebApplicationContext)) { 				// Current context is no a a webapp 				return DIFFERENT; 			} 			return managementServerProperties.getPort() == null 					|| serverProperties.getPort() == null 					&& managementServerProperties.getPort().equals(8080) 					|| managementServerProperties.getPort().equals( 							serverProperties.getPort()) ? SAME : DIFFERENT; 		}
@Test 	public void securityDependencies() throws Exception { 		this.cli.run("secure.groovy"); 		assertThat(this.cli.getOutput(), containsString("Hello World")); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return SpringApplication.run( 										SampleActuatorApplication.class, 										"--management.security.enabled=false"); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@Override 							public ConfigurableApplicationContext call() throws Exception { 								return SpringApplication.run( 										SampleActuatorApplication.class, 										"--management.security.enabled=false"); 							}
@Override 	public void initialize(SpringApplication springApplication, String[] args) { 		if (System.getProperty("PID") == null) { 			System.setProperty("PID", getPid()); 		} 		LoggingSystem loggingSystem = LoggingSystem.get(springApplication.getClass() 				.getClassLoader()); 		loggingSystem.beforeInitialize(); 	}
@Override 	public void initialize(ConfigurableApplicationContext applicationContext) {  		ConfigurableEnvironment environment = applicationContext.getEnvironment();  		if (this.parseArgs && this.springBootLogging == null) { 			if (environment.containsProperty("debug")) { 				this.springBootLogging = LogLevel.DEBUG; 			} 			if (environment.containsProperty("trace")) { 				this.springBootLogging = LogLevel.TRACE; 			} 		}  		for (Map.Entry<String, String> mapping : ENVIRONMENT_SYSTEM_PROPERTY_MAPPING 				.entrySet()) { 			if (environment.containsProperty(mapping.getKey())) { 				System.setProperty(mapping.getValue(), 						environment.getProperty(mapping.getKey())); 			} 		}  		LoggingSystem system = LoggingSystem.get(applicationContext.getClassLoader());  		// User specified configuration 		if (environment.containsProperty("logging.config")) { 			String value = environment.getProperty("logging.config"); 			try { 				ResourceUtils.getURL(value).openStream().close(); 				system.initialize(value); 				return; 			} 			catch (Exception ex) { 				// Swallow exception and continue 			} 			this.logger.warn("Logging environment value '" + value 					+ "' cannot be opened and will be ignored"); 		}  		system.initialize(); 		if (this.springBootLogging != null) { 			initializeLogLevel(system, this.springBootLogging); 		} 	}
@Test 	public void parseDebugArg() throws Exception { 		TestUtils.addEnviroment(this.context, "debug"); 		this.initializer.initialize(this.context); 		this.logger.debug("testatdebug"); 		this.logger.trace("testattrace"); 		assertThat(this.outputCapture.toString(), containsString("testatdebug")); 		assertThat(this.outputCapture.toString(), not(containsString("testattrace"))); 	}
@Test 	public void parseTraceArg() throws Exception { 		TestUtils.addEnviroment(this.context, "trace"); 		this.initializer.initialize(this.context); 		this.logger.debug("testatdebug"); 		this.logger.trace("testattrace"); 		assertThat(this.outputCapture.toString(), containsString("testatdebug")); 		assertThat(this.outputCapture.toString(), containsString("testattrace")); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping, true); 			if (paths.length > 0 && this.security.getManagement().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.security.getManagement().getSessions());  				SecurityAutoConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping, true); 			if (paths.length > 0 && this.security.getManagement().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.security.getManagement().getSessions());  				SecurityAutoConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping, true); 			if (paths.length > 0 && this.security.getManagement().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.security.getManagement().getSessions());  				SecurityAutoConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = new ArrayList<String>(this.security.getIgnored()); 			if (!this.security.getManagement().isEnabled()) { 				ignored.addAll(Arrays.asList(getEndpointPaths( 						this.endpointHandlerMapping, true))); 			} 			if (ignored.isEmpty()) { 				ignored.addAll(DEFAULT_IGNORED); 			} 			else if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(this.errorController.getErrorPath()); 			} 			ignoring.antMatchers(ignored.toArray(new String[0])); 		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(getEndpointPaths(this.endpointHandlerMapping, false)); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping, true); 			if (paths.length > 0 && this.security.getManagement().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.security.getManagement().getSessions());  				SecurityAutoConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = new ArrayList<String>(this.security.getIgnored()); 			if (!this.security.getManagement().isEnabled()) { 				ignored.addAll(Arrays.asList(getEndpointPaths( 						this.endpointHandlerMapping, true))); 			} 			if (ignored.isEmpty()) { 				ignored.addAll(DEFAULT_IGNORED); 			} 			else if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(this.errorController.getErrorPath()); 			} 			ignoring.antMatchers(ignored.toArray(new String[0])); 		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(getEndpointPaths(this.endpointHandlerMapping, false)); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			String[] paths = getEndpointPaths(true); // secure endpoints 			if (paths.length > 0 && this.security.getManagement().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.security.getManagement().getSessions());  				SecurityAutoConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(getEndpointPaths(false)); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception {  			InMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder> builder = new AuthenticationManagerBuilder( 					ObjectPostProcessor.QUIESCENT_POSTPROCESSOR).inMemoryAuthentication(); 			User user = this.security.getUser();  			if (user.isDefaultPassword()) { 				logger.info("Using default password for application endpoints: " 						+ user.getPassword()); 			}  			Set<String> roles = new LinkedHashSet<String>(Arrays.asList(this.security 					.getManagement().getRole(), user.getRole()));  			builder.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()]));  			return builder.and().build();  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			String[] paths = getEndpointPaths(true); // secure endpoints 			if (paths.length > 0 && this.security.getManagement().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.security.getManagement().getSessions());  				SecurityAutoConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = new ArrayList<String>(this.security.getIgnored()); 			if (ignored.isEmpty()) { 				ignored.addAll(DEFAULT_IGNORED); 			} 			else if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(this.errorController.getErrorPath()); 			} 			ignoring.antMatchers(ignored.toArray(new String[0])); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
public SessionCreationPolicy getSessions() { 			return this.sessions; 		}
public void setSessions(SessionCreationPolicy sessions) { 			this.sessions = sessions; 		}
public SessionCreationPolicy getSessions() { 		return this.sessions; 	}
public void setSessions(SessionCreationPolicy sessions) { 		this.sessions = sessions; 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getEndpointPaths(true); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// No cookies for management endpoints by default 			http.csrf().disable(); 			http.sessionManagement().sessionCreationPolicy( 					this.security.getManagement().getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = new ArrayList<String>(this.security.getIgnored()); 			if (ignored.isEmpty()) { 				ignored.addAll(DEFAULT_IGNORED); 			} 			else if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(this.errorController.getErrorPath()); 			} 			ignoring.antMatchers(ignored.toArray(new String[0])); 		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(getEndpointPaths(false)); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception {  			InMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder> builder = new AuthenticationManagerBuilder( 					ObjectPostProcessor.QUIESCENT_POSTPROCESSOR).inMemoryAuthentication(); 			User user = this.security.getUser();  			if (user.isDefaultPassword()) { 				logger.info("Using default password for application endpoints: " 						+ user.getPassword()); 			}  			Set<String> roles = new LinkedHashSet<String>(Arrays.asList(this.security 					.getManagement().getRole(), user.getRole()));  			builder.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()]));  			return builder.and().build();  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = new ArrayList<String>(this.security.getIgnored()); 			if (ignored.isEmpty()) { 				ignored.addAll(DEFAULT_IGNORED); 			} 			else if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(this.errorController.getErrorPath()); 			} 			ignoring.antMatchers(ignored.toArray(new String[0])); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
public SessionCreationPolicy getSessions() { 			return this.sessions; 		}
public void setSessions(SessionCreationPolicy sessions) { 			this.sessions = sessions; 		}
public SessionCreationPolicy getSessions() { 		return this.sessions; 	}
public void setSessions(SessionCreationPolicy sessions) { 		this.sessions = sessions; 	}
@Test 	public void testDisableIgnoredStaticApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		TestUtils.addEnviroment(this.context, "security.ignored:none"); 		this.context.refresh(); 		// Just the application and\ management endpoints now 		assertEquals(2, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testBindingIgnoredMultiValuedList() { 		SecurityProperties security = new SecurityProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.setConversionService(new DefaultConversionService()); 		Map<String, String> map = new HashMap<String, String>(); 		map.put("security.ignored[0]", "/css/**"); 		map.put("security.ignored[1]", "/foo/**"); 		binder.bind(new MutablePropertyValues(map)); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertEquals(2, security.getIgnored().size()); 		assertTrue(security.getIgnored().contains("/foo/**")); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getEndpointPaths(true); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// No cookies for management endpoints by default 			http.csrf().disable(); 			http.sessionManagement().sessionCreationPolicy( 					this.security.getManagement().getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(this.security.getIgnoredPaths()); 			if (this.errorController != null) { 				ignoring.antMatchers(this.errorController.getErrorPath()); 			} 		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(getEndpointPaths(false)); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception {  			InMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder> builder = new AuthenticationManagerBuilder( 					ObjectPostProcessor.QUIESCENT_POSTPROCESSOR).inMemoryAuthentication(); 			User user = this.security.getUser();  			if (user.isDefaultPassword()) { 				logger.info("Using default password for application endpoints: " 						+ user.getPassword()); 			}  			Set<String> roles = new LinkedHashSet<String>(Arrays.asList(this.security 					.getManagement().getRole(), user.getRole()));  			builder.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()]));  			return builder.and().build();  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(this.security.getIgnoredPaths()); 			if (this.errorController != null) { 				ignoring.antMatchers(this.errorController.getErrorPath()); 			} 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
public SessionCreationPolicy getSessions() { 			return this.sessions; 		}
public void setSessions(SessionCreationPolicy sessions) { 			this.sessions = sessions; 		}
public SessionCreationPolicy getSessions() { 		return this.sessions; 	}
public void setSessions(SessionCreationPolicy sessions) { 		this.sessions = sessions; 	}
@Test 	public void testBindingIgnoredSingleValued() { 		SecurityProperties security = new SecurityProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.ignored", "/css/**"))); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertEquals(1, security.getIgnored().size()); 	}
@Test 	public void testBindingIgnoredMultiValued() { 		SecurityProperties security = new SecurityProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.setConversionService(new DefaultConversionService()); 		binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.ignored", "/css/**,/images/**"))); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertEquals(2, security.getIgnored().size()); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getEndpointPaths(true); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// No cookies for management endpoints by default 			http.csrf().disable(); 			http.sessionManagement().sessionCreationPolicy( 					this.security.getManagement().getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(getEndpointPaths(false)); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception {  			InMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder> builder = new AuthenticationManagerBuilder( 					ObjectPostProcessor.QUIESCENT_POSTPROCESSOR).inMemoryAuthentication(); 			User user = this.security.getUser();  			if (user.isDefaultPassword()) { 				logger.info("Using default password for application endpoints: " 						+ user.getPassword()); 			}  			Set<String> roles = new LinkedHashSet<String>(Arrays.asList(this.security 					.getManagement().getRole(), user.getRole()));  			builder.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()]));  			return builder.and().build();  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getEndpointPaths(true); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// No cookies for management endpoints by default 			http.csrf().disable(); 			http.sessionManagement().sessionCreationPolicy( 					this.security.getManagement().getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(this.security.getIgnored()); 			if (this.errorController != null) { 				ignoring.antMatchers(this.errorController.getErrorPath()); 			} 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
public SessionCreationPolicy getSessions() { 			return this.sessions; 		}
public void setSessions(SessionCreationPolicy sessions) { 			this.sessions = sessions; 		}
public SessionCreationPolicy getSessions() { 		return this.sessions; 	}
public void setSessions(SessionCreationPolicy sessions) { 		this.sessions = sessions; 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getEndpointPaths(true); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// No cookies for management endpoints by default 			http.csrf().disable(); 			http.sessionManagement().sessionCreationPolicy( 					this.security.getManagement().getSessions());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(getEndpointPaths(false)); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception {  			InMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder> builder = new AuthenticationManagerBuilder( 					ObjectPostProcessor.QUIESCENT_POSTPROCESSOR).inMemoryAuthentication(); 			User user = this.security.getUser();  			if (user.isDefaultPassword()) { 				logger.info("Using default password for application endpoints: " 						+ user.getPassword()); 			}  			Set<String> roles = new LinkedHashSet<String>(Arrays.asList(this.security 					.getManagement().getRole(), user.getRole()));  			builder.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()]));  			return builder.and().build();  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// Remove this when session creation is disabled by default 			http.csrf().disable(); 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(this.security.getIgnored()); 			if (this.errorController != null) { 				ignoring.antMatchers(this.errorController.getErrorPath()); 			} 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 		// 4 for static resources, one for management endpoints and one for the rest 		assertEquals(6, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (this.security.getBasic().isEnabled()) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.httpBasic().and().anonymous().disable(); 				ExpressionUrlAuthorizationConfigurer<HttpSecurity> authorizeUrls = http 						.authorizeUrls(); 				String[] paths = getEndpointPaths(true); 				if (paths.length > 0) { 					authorizeUrls.antMatchers(getEndpointPaths(true)).hasRole( 							this.management.getUser().getRole()); 				} 				paths = getSecureApplicationPaths(); 				if (paths.length > 0) { 					authorizeUrls.antMatchers(getSecureApplicationPaths()).hasRole( 							this.security.getBasic().getRole()); 				} 				authorizeUrls.and().httpBasic(); 			}  			// No cookies for service endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 		}
private String[] getSecureApplicationPaths() { 			List<String> list = new ArrayList<String>(); 			for (String path : this.security.getBasic().getPath()) { 				path = (path == null ? "" : path.trim()); 				if (path.equals("/**")) { 					return new String[] { path }; 				} 				if (!path.equals("")) { 					list.add(path); 				} 			} 			return list.toArray(new String[list.size()]); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			User user = this.management.getUser(); 			if (user.isDefaultPassword()) { 				logger.info("Using default password for management endpoints: " 						+ user.getPassword()); 			} 			List<String> roles = new ArrayList<String>(); 			roles.add("USER"); 			if (!"USER".equals(user.getRole())) { 				roles.add(user.getRole()); 			} 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()])).and().and().build(); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@BeforeClass 	public static void start() throws Exception { 		final String[] args = new String[] { "--server.port=" + port, 				"--management.port=" + managementPort, "--management.address=127.0.0.1" }; 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorUiApplication.class, args); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorUiApplication.class); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
private void start(final Class<?> configuration, final String... args) 			throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(configuration, args); 							} 						}); 		this.context = future.get(60, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		final String[] args = new String[] { "--server.port=" + port, 				"--management.port=" + managementPort }; 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorApplication.class, args); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		final String[] args = new String[] { "--server.port=" + port, 				"--management.port=" + managementPort, "--management.address=127.0.0.1" }; 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorApplication.class, args); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		final String[] args = new String[] { "--management.port=" + managementPort }; 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorApplication.class, args); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorApplication.class); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorApplication.class); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorApplication.class, 												"--security.basic.enabled=false"); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleJettyApplication.class); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleTraditionalApplication.class); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleWebStaticApplication.class); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleWebUiApplication.class); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleWebSocketsApplication.class); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (this.security.getBasic().isEnabled()) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.httpBasic().and().anonymous().disable(); 				ExpressionUrlAuthorizationConfigurer<HttpSecurity> authorizeUrls = http 						.authorizeUrls(); 				if (getEndpointPaths(true).length > 0) { 					authorizeUrls.antMatchers(getEndpointPaths(true)).hasRole( 							this.management.getUser().getRole()); 				} 				authorizeUrls.antMatchers(getSecureApplicationPaths()) 						.hasRole(this.security.getBasic().getRole()).and().httpBasic(); 			}  			// No cookies for service endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			User user = this.management.getUser(); 			if (user.isDefaultPassword()) { 				logger.info("Using default password for "); 			} 			List<String> roles = new ArrayList<String>(); 			roles.add("USER"); 			if (!"USER".equals(user.getRole())) { 				roles.add(user.getRole()); 			} 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()])).and().and().build(); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			User user = this.management.getUser(); 			if (user.isDefaultPassword()) { 				logger.info("Using default password for "); 			} 			List<String> roles = new ArrayList<String>(); 			roles.add("USER"); 			if (!"USER".equals(user.getRole())) { 				roles.add(user.getRole()); 			} 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()])).and().and().build(); 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testOverrideAuthenticationManager() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(TestConfiguration.class, SecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertEquals(this.context.getBean(TestConfiguration.class).authenticationManager, 				this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:" + port, Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:8080", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test(expected = ResourceAccessException.class) 	public void testMetricsNotAvailable() throws Exception { 		testHome(); // makes sure some requests have been made 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:" + managementPort + "/metrics", Map.class); 		assertEquals(HttpStatus.NOT_FOUND, entity.getStatusCode()); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:8080", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testMetrics() throws Exception { 		testHome(); // makes sure some requests have been made 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:8080/metrics", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertTrue("Wrong body: " + body, body.containsKey("counter.status.200.root")); 	}
@Test 	public void testEnv() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:8080/env", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertTrue("Wrong body: " + body, body.containsKey("systemProperties")); 	}
@Test 	public void testErrorPage() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:8080/foo", Map.class); 		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals(500, body.get("status")); 	}
@Test 	public void testBeans() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<List> entity = getRestTemplate("user", getPassword()) 				.getForEntity("http://localhost:8080/beans", List.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertEquals(1, entity.getBody().size()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = (Map<String, Object>) entity.getBody().get(0); 		assertTrue("Wrong body: " + body, 				((String) body.get("context")).startsWith("application")); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:8080", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testShutdown() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()) 				.postForEntity("http://localhost:8080/shutdown", null, Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertTrue("Wrong body: " + body, 				((String) body.get("message")).contains("Shutting down")); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(NonAutoConfigurationSampleTomcatApplication.class); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleTomcatApplication.class); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) == null) { 							return false; 						} 						return true; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) != null) { 							return true; 						} 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				if (DependencyCustomizer.this.contains(group, module)) { 					return false; 				} 				return DependencyCustomizer.this.canAdd(); 			}
protected boolean canAdd() { 		return true; 	}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 					} 					catch (Exception ex) { 						return true; 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) == null) { 							return false; 						} 						return true; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) != null) { 							return true; 						} 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				if (DependencyCustomizer.this.contains(group, module)) { 					return false; 				} 				return DependencyCustomizer.this.canAdd(); 			}
protected boolean canAdd() { 		return true; 	}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 					} 					catch (Exception ex) { 						return true; 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) != null) { 							return true; 						} 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				if (DependencyCustomizer.this.contains(group, module)) { 					return false; 				} 				return DependencyCustomizer.this.canAdd(); 			}
protected boolean canAdd() { 		return true; 	}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 					} 					catch (Exception ex) { 						return true; 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) == null) { 							return false; 						} 						return true; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				if (DependencyCustomizer.this.contains(group, module)) { 					return false; 				} 				return DependencyCustomizer.this.canAdd(); 			}
protected boolean canAdd() { 		return true; 	}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 					} 					catch (Exception ex) { 						return true; 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) == null) { 							return false; 						} 						return true; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) != null) { 							return true; 						} 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
protected boolean canAdd() { 		return true; 	}
public DependencyCustomizer add(String group, String module, String version) { 		return this.add(group, module, version, true); 	}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 					} 					catch (Exception ex) { 						return true; 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) == null) { 							return false; 						} 						return true; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) != null) { 							return true; 						} 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				if (DependencyCustomizer.this.contains(group, module)) { 					return false; 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(8081); 			return properties; 		}
@Bean 		public SpringTemplateEngine templateEngine() { 			SpringTemplateEngine engine = new SpringTemplateEngine(); 			for (ITemplateResolver templateResolver : this.templateResolvers) { 				engine.addTemplateResolver(templateResolver); 			} 			engine.addDialect(new LayoutDialect()); 			return engine; 		}
@Bean 		public SpringTemplateEngine templateEngine() { 			SpringTemplateEngine engine = new SpringTemplateEngine(); 			for (ITemplateResolver templateResolver : this.templateResolvers) { 				engine.addTemplateResolver(templateResolver); 			} 			return engine; 		}
@Bean 		@ConditionalOnMissingBean(name = "thymeleafViewResolver") 		public ThymeleafViewResolver thymeleafViewResolver() { 			ThymeleafViewResolver resolver = new ThymeleafViewResolver(); 			resolver.setTemplateEngine(this.templateEngine); 			resolver.setCharacterEncoding("UTF-8"); 			return resolver; 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser("user").password("password").roles("USER").and().and() 					.build(); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Override 		protected void configure(HttpConfiguration http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (this.security.getBasic().isEnabled()) {  				String[] paths = getSecurePaths();  				HttpConfiguration matcher = http.requestMatchers().antMatchers(paths); 				matcher.authenticationEntryPoint(entryPoint()).httpBasic() 						.authenticationEntryPoint(entryPoint()).and().anonymous() 						.disable(); 				matcher.authorizeUrls().anyRequest() 						.hasRole(this.security.getBasic().getRole());  			}  			// No cookies for service endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  		}
@Override 		public void configure(WebSecurityBuilder builder) throws Exception { 			builder.ignoring().antMatchers(this.security.getIgnored()) 					.antMatchers(this.endpoints.getOpenPaths()); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser("user").password("password").roles("USER").and().and() 					.build(); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Bean 		public EmbeddedServletContainerFactory factory() { 			return new EmbeddedServletContainerFactory() {  				@Override 				public EmbeddedServletContainer getEmbdeddedServletContainer( 						ServletContextInitializer... initializers) { 					ServletContext servletContext = new MockServletContext() { 						@Override 						public Dynamic addServlet(String servletName, Servlet servlet) { 							return Mockito.mock(Dynamic.class); 						}  						@Override 						public javax.servlet.FilterRegistration.Dynamic addFilter( 								String filterName, Filter filter) { 							// TODO: remove this when @ConditionalOnBean works 							return Mockito 									.mock(javax.servlet.FilterRegistration.Dynamic.class); 						} 					}; 					for (ServletContextInitializer initializer : initializers) { 						try { 							initializer.onStartup(servletContext); 						} catch (ServletException ex) { 							throw new IllegalStateException(ex); 						} 					} 					return new EmbeddedServletContainer() { 						@Override 						public void stop() throws EmbeddedServletContainerException { 						} 					}; 				} 			}; 		}
@Override 				public EmbeddedServletContainer getEmbdeddedServletContainer( 						ServletContextInitializer... initializers) { 					ServletContext servletContext = new MockServletContext() { 						@Override 						public Dynamic addServlet(String servletName, Servlet servlet) { 							return Mockito.mock(Dynamic.class); 						}  						@Override 						public javax.servlet.FilterRegistration.Dynamic addFilter( 								String filterName, Filter filter) { 							// TODO: remove this when @ConditionalOnBean works 							return Mockito 									.mock(javax.servlet.FilterRegistration.Dynamic.class); 						} 					}; 					for (ServletContextInitializer initializer : initializers) { 						try { 							initializer.onStartup(servletContext); 						} catch (ServletException ex) { 							throw new IllegalStateException(ex); 						} 					} 					return new EmbeddedServletContainer() { 						@Override 						public void stop() throws EmbeddedServletContainerException { 						} 					}; 				}
@Override 	public void applyImports(ImportCustomizer imports) { 		imports.addImports("javax.sql.DataSource", "javax.annotation.PostConstruct", 				"javax.annotation.PreDestroy", "groovy.util.logging.Log", 				"org.springframework.stereotype.Controller", 				"org.springframework.stereotype.Service", 				"org.springframework.stereotype.Component", 				"org.springframework.beans.factory.annotation.Autowired", 				"org.springframework.beans.factory.annotation.Value", 				"org.springframework.context.annotation.Import", 				"org.springframework.context.annotation.ImportResource", 				"org.springframework.context.annotation.Profile", 				"org.springframework.context.annotation.Scope", 				"org.springframework.context.annotation.Configuration", 				"org.springframework.context.annotation.ComponentScan", 				"org.springframework.context.annotation.Bean", 				"org.springframework.context.ApplicationContext", 				"org.springframework.context.MessageSource", 				"org.springframework.core.annotation.Order", 				"org.springframework.core.io.ResourceLoader", 				"org.springframework.bootstrap.CommandLineRunner", 				"org.springframework.bootstrap.context.annotation.EnableAutoConfiguration"); 		imports.addStarImports("org.springframework.stereotype"); 	}
@Test 	public void testMetrics() throws Exception { 		testHome(); // makes sure some requests have been made 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate().getForEntity( 				"http://localhost:" + managementPort + "/metrics", Map.class); 		assertEquals(HttpStatus.UNAUTHORIZED, entity.getStatusCode()); 	}
@Override 	public Object postProcessAfterInitialization(Object bean, String beanName) 			throws BeansException { 		ConfigurationProperties annotation = AnnotationUtils.findAnnotation( 				bean.getClass(), ConfigurationProperties.class); 		Object target = bean; 		if (annotation != null || bean instanceof ConfigurationPropertiesHolder) { 			if (bean instanceof ConfigurationPropertiesHolder) { 				target = ((ConfigurationPropertiesHolder) bean).getTarget(); 			} 			PropertiesConfigurationFactory<Object> factory = new PropertiesConfigurationFactory<Object>( 					target); 			factory.setPropertySources(this.propertySources); 			factory.setValidator(this.validator); 			// If no explicit conversion service is provided we add one so that (at least) 			// comma-separated arrays of convertibles can be bound automatically 			factory.setConversionService(this.conversionService == null ? this.defaultConversionService 					: this.conversionService); 			String targetName = null; 			if (annotation != null) { 				factory.setIgnoreInvalidFields(annotation.ignoreInvalidFields()); 				factory.setIgnoreUnknownFields(annotation.ignoreUnknownFields()); 				targetName = "".equals(annotation.value()) ? ("" 						.equals(annotation.name()) ? null : annotation.name()) 						: annotation.value(); 			} 			factory.setTargetName(targetName); 			try { 				target = factory.getObject(); // throwaway 			} catch (BeansException e) { 				throw e; 			} catch (Exception e) { 				throw new BeanCreationException(beanName, "Could not bind", e); 			} 		} 		return bean; 	}
@Bean 		@AssertMissingBean(TestProperties.class) 		public TestProperties testProperties() { 			TestProperties test = new TestProperties(); 			test.setName("bar"); 			return test; 		}
@ConditionalOnMissingBean(TestProperties.class) 		@Bean(name = "org.springframework.bootstrap.context.annotation.EnableConfigurationPropertiesTests$TestProperties") 		public TestProperties testProperties() { 			return new TestProperties(); 		}
public String getName() { 			return this.name; 		}
public String getName() { 			return this.name; 		}
public String getName() { 			return this.properties.getName(); 		}
public String getName() { 			return this.properties.getName(); 		}
@Override 		protected void configure(HttpConfiguration http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().antMatchers("/**").requiresSecure(); 			} 			if (this.security.getBasic().isEnabled()) { 				http.authenticationEntryPoint(entryPoint()) 						.antMatcher(this.security.getBasic().getPath()).httpBasic() 						.authenticationEntryPoint(entryPoint()).and().anonymous() 						.disable(); 				http.authorizeUrls().antMatchers("/**") 						.hasRole(this.security.getBasic().getRole()); 			} 			// No cookies for service endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 		}
@Override 		public void configure(WebSecurityConfiguration builder) throws Exception { 			builder.ignoring().antMatchers(this.endpoints.getHealth().getPath(), 					this.endpoints.getInfo().getPath(), 					this.endpoints.getError().getPath()); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser("user").password("password").roles("USER").and().and() 					.build(); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
public boolean isRequireSsl() { 		return this.requireSsl; 	}
@Override 	public void onApplicationEvent(ContextRefreshedEvent event) { 		if (event.getSource() != this.parent) { 			return; 		} 		if (this.configuration.getPort() != this.management.getPort()) { 			AnnotationConfigEmbeddedWebApplicationContext context = new AnnotationConfigEmbeddedWebApplicationContext(); 			context.setParent(this.parent); 			context.register(ManagementServerConfiguration.class, 					VarzConfiguration.class, HealthzConfiguration.class, 					ShutdownConfiguration.class); 			context.refresh(); 			this.context = context; 		} 	}
@Bean 	@ConditionalOnMissingBean(TraceRepository.class) 	protected TraceRepository traceRepository() { 		return this.traceRepository; 	}
@Test 	public void testHealthz() throws Exception { 		ResponseEntity<String> entity = getRestTemplate().getForEntity( 				"http://localhost:" + managementPort + "/healthz", String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertEquals("ok", entity.getBody()); 	}
@Override 	public void onApplicationEvent(ContextRefreshedEvent event) { 		if (event.getSource() != this.parent) { 			return; 		} 		if (this.configuration.getPort() != this.configuration.getManagementPort()) { 			AnnotationConfigEmbeddedWebApplicationContext context = new AnnotationConfigEmbeddedWebApplicationContext(); 			context.setParent(this.parent); 			context.register(ManagementContainerConfiguration.class, 					VarzAutoConfiguration.class, HealthzAutoConfiguration.class, 					ShutdownAutoConfiguration.class, TraceAutoConfiguration.class); 			context.refresh(); 			this.context = context; 		} 	}
@Bean 	public PropertySourcesBindingPostProcessor propertySourcesBinder() { 		PropertySources propertySources;  		if (this.configurer != null) { 			propertySources = extractPropertySources(this.configurer); 		} else { 			if (this.environment instanceof ConfigurableEnvironment) { 				propertySources = flattenPropertySources(((ConfigurableEnvironment) this.environment) 						.getPropertySources()); 			} else { 				// empty, so not very useful, but fulfils the contract 				propertySources = new MutablePropertySources(); 			} 		} 		PropertySourcesBindingPostProcessor processor = new PropertySourcesBindingPostProcessor(); 		LocalValidatorFactoryBean validator = new LocalValidatorFactoryBean(); 		validator.afterPropertiesSet(); 		processor.setValidator(validator); 		processor.setConversionService(this.conversionService); 		processor.setPropertySources(propertySources); 		return processor; 	}
@Override 	public void afterPropertiesSet() throws Exception {  		Assert.state(this.properties != null || this.propertySources != null, 				"Properties or propertySources should not be null");  		try { 			if (this.properties != null) { 				logger.trace("Properties:\n" + this.properties); 			} else { 				logger.trace("Property Sources: " + this.propertySources); 			} 			this.initialized = true;  			RelaxedDataBinder dataBinder; 			if (this.targetName != null) { 				dataBinder = new RelaxedDataBinder(this.configuration, this.targetName); 			} else { 				dataBinder = new RelaxedDataBinder(this.configuration); 			} 			if (this.validator != null) { 				dataBinder.setValidator(this.validator); 			} 			if (this.conversionService != null) { 				dataBinder.setConversionService(this.conversionService); 			} 			dataBinder.setIgnoreInvalidFields(this.ignoreInvalidFields); 			dataBinder.setIgnoreUnknownFields(this.ignoreUnknownFields); 			customizeBinder(dataBinder); 			PropertyValues pvs; 			if (this.properties != null) { 				pvs = new MutablePropertyValues(this.properties); 			} else { 				pvs = new PropertySourcesPropertyValues(this.propertySources); 			} 			dataBinder.bind(pvs);  			if (this.validator != null) { 				dataBinder.validate(); 				BindingResult errors = dataBinder.getBindingResult();  				if (errors.hasErrors()) { 					logger.error("Properties configuration failed validation"); 					for (ObjectError error : errors.getAllErrors()) { 						logger.error(this.messageSource != null ? this.messageSource 								.getMessage(error, Locale.getDefault()) 								+ " (" 								+ error 								+ ")" : error); 					} 					if (this.exceptionIfInvalid) { 						BindException summary = new BindException(errors); 						throw summary; 					} 				} 			} 		} catch (BindException e) { 			if (this.exceptionIfInvalid) { 				throw e; 			} 			logger.error( 					"Failed to load Properties validation bean. Your Properties may be invalid.", 					e); 		} 	}
@Override 	public Object postProcessAfterInitialization(Object bean, String beanName) 			throws BeansException { 		ConfigurationProperties annotation = AnnotationUtils.findAnnotation( 				bean.getClass(), ConfigurationProperties.class); 		if (annotation != null) { 			PropertiesConfigurationFactory<Object> factory = new PropertiesConfigurationFactory<Object>( 					bean); 			factory.setPropertySources(this.propertySources); 			factory.setValidator(this.validator); 			factory.setConversionService(this.conversionService); 			factory.setIgnoreInvalidFields(annotation.ignoreInvalidFields()); 			factory.setIgnoreUnknownFields(annotation.ignoreUnknownFields()); 			String targetName = "".equals(annotation.value()) ? ("".equals(annotation 					.name()) ? null : annotation.name()) : annotation.value(); 			factory.setTargetName(targetName); 			try { 				bean = factory.getObject(); 			} catch (BeansException e) { 				throw e; 			} catch (Exception e) { 				throw new BeanCreationException(beanName, "Could not bind", e); 			} 		} 		return bean; 	}
@Override 	public synchronized void stop() { 		try { 			this.server.stop(); 		} catch (InterruptedException ex) { 			Thread.currentThread().interrupt(); 			// No drama 		} catch (Exception ex) { 			throw new EmbeddedServletContainerException( 					"Unable to stop embedded Jetty servlet container", ex); 		} 	}
private BindingResult bind(Object target, String values, String namePrefix) 			throws Exception { 		Properties properties = PropertiesLoaderUtils 				.loadProperties(new ByteArrayResource(values.getBytes())); 		DataBinder binder = new RelaxedDataBinder(target, namePrefix); 		binder.setIgnoreUnknownFields(false); 		LocalValidatorFactoryBean validatorFactoryBean = new LocalValidatorFactoryBean(); 		validatorFactoryBean.afterPropertiesSet(); 		binder.setValidator(validatorFactoryBean); 		binder.setConversionService(this.conversionService); 		binder.bind(new MutablePropertyValues(properties)); 		binder.validate();  		return binder.getBindingResult(); 	}
@Bean 	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 		http.authorizeExchange((exchanges) -> { 			exchanges.matchers(EndpointRequest.to(HealthEndpoint.class)).permitAll(); 			exchanges.anyExchange().authenticated(); 		}); 		http.httpBasic(Customizer.withDefaults()); 		http.formLogin(Customizer.withDefaults()); 		return http.build(); 	}
@Bean 	SecurityFilterChain managementSecurityFilterChain(HttpSecurity http) throws Exception { 		http.authorizeRequests((requests) -> { 			requests.requestMatchers(EndpointRequest.to(HealthEndpoint.class)).permitAll(); 			requests.anyRequest().authenticated(); 		}); 		http.formLogin(Customizer.withDefaults()); 		http.httpBasic(Customizer.withDefaults()); 		return http.build(); 	}
@Test 	void outcomeShouldMatchDefaults() { 		this.contextRunner.run((context) -> assertThat(context).hasBean("health").doesNotHaveBean("spring") 				.doesNotHaveBean("test").doesNotHaveBean("shutdown")); 	}
@Test 	void outcomeWhenIncludeAllJmxButJmxDisabledShouldMatchDefaults() { 		this.contextRunner.withPropertyValues("management.endpoints.jmx.exposure.include=*") 				.run((context) -> assertThat(context).hasBean("health").doesNotHaveBean("spring") 						.doesNotHaveBean("test").doesNotHaveBean("shutdown")); 	}
@Test 	void outcomeWhenIncludeAllJmxAndJmxEnabledAndEnablingEndpointDisabledByDefaultShouldMatchAll() { 		this.contextRunner 				.withPropertyValues("management.endpoints.jmx.exposure.include=*", "spring.jmx.enabled=true", 						"management.endpoint.shutdown.enabled=true") 				.run((context) -> assertThat(context).hasBean("health").hasBean("test").hasBean("spring") 						.hasBean("shutdown")); 	}
@Test 	void webEndpointsAreDisabledByDefault() { 		this.contextRunner.run((context) -> { 			WebTestClient client = createClient(context); 			assertThat(isExposed(client, HttpMethod.GET, "beans")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "conditions")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "configprops")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "custommvc")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "customservlet")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "env")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "health")).isTrue(); 			assertThat(isExposed(client, HttpMethod.GET, "info")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "mappings")).isFalse(); 			assertThat(isExposed(client, HttpMethod.POST, "shutdown")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "threaddump")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "httptrace")).isFalse(); 		}); 	}
@Bean 	SecurityFilterChain configure(HttpSecurity http) throws Exception { 		http.authorizeRequests((requests) -> { 			requests.mvcMatchers("/actuator/beans").hasRole("BEANS"); 			requests.requestMatchers(EndpointRequest.to("health")).permitAll(); 			requests.requestMatchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)) 					.hasRole("ACTUATOR"); 			requests.requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll(); 			requests.antMatchers("/foo").permitAll(); 			requests.antMatchers("/**").hasRole("USER"); 		}); 		http.cors(Customizer.withDefaults()); 		http.httpBasic(); 		return http.build(); 	}
@Bean 	SecurityFilterChain configure(HttpSecurity http) throws Exception { 		// @formatter:off 		http.authorizeRequests() 				.requestMatchers(EndpointRequest.to("health")).permitAll() 				.requestMatchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)).hasRole("ACTUATOR") 				.antMatchers("/**").hasRole("USER") 				.and() 			.httpBasic(); 		return http.build(); 		// @formatter:on 	}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			http.authorizeExchange((exchanges) -> { 				exchanges.matchers(EndpointRequest.to("health")).permitAll(); 				exchanges.matchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)) 						.hasRole("ACTUATOR"); 				exchanges.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll(); 				exchanges.pathMatchers("/login").permitAll(); 				exchanges.anyExchange().authenticated(); 			}); 			http.httpBasic(); 			return http.build(); 		}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			http.authorizeExchange((exchanges) -> { 				exchanges.matchers(EndpointRequest.to("health")).permitAll(); 				exchanges.matchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)) 						.hasRole("ACTUATOR"); 				exchanges.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll(); 				exchanges.pathMatchers("/login").permitAll(); 				exchanges.anyExchange().authenticated(); 			}); 			http.httpBasic(Customizer.withDefaults()); 			return http.build(); 		}
private URI buildUrl(String path, String... params) { 		try { 			URIBuilder builder = new URIBuilder("/" + API_VERSION + path); 			int param = 0; 			while (param < params.length) { 				builder.addParameter(params[param++], params[param++]); 			} 			return builder.build(); 		} 		catch (URISyntaxException ex) { 			throw new IllegalStateException(ex); 		} 	}
private Response execute(HttpUriRequest request) { 		HttpHost host = this.clientConnection.getHttpHost(); 		CloseableHttpClient client = this.clientConnection.getHttpClient();  		try { 			CloseableHttpResponse response = client.execute(host, request); 			StatusLine statusLine = response.getStatusLine(); 			int statusCode = statusLine.getStatusCode(); 			HttpEntity entity = response.getEntity();  			if (statusCode >= 400 && statusCode < 500) { 				throw new DockerException(host.toHostString(), request.getURI(), statusCode, 						statusLine.getReasonPhrase(), getErrorsFromResponse(entity)); 			} 			if (statusCode == 500) { 				throw new DockerException(host.toHostString(), request.getURI(), statusCode, 						statusLine.getReasonPhrase(), null); 			} 			return new HttpClientResponse(response); 		} 		catch (IOException ioe) { 			throw new DockerException(host.toHostString(), request.getURI(), 500, ioe.getMessage(), null); 		} 	}
@Override 		public InputStream getContent() throws IOException { 			return this.response.getEntity().getContent(); 		}
@Override 		public InputStream getContent() throws UnsupportedOperationException { 			throw new UnsupportedOperationException(); 		}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.image(); 		}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.container(); 		}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.volume(); 		}
@BeforeEach 	void setup() { 		MockitoAnnotations.initMocks(this); 		this.dockerApi = new DockerApi(this.httpClient); 	}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.container(); 		}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.volume(); 		}
@Test 		void removeRemovesContainer() throws Exception { 			ContainerReference reference = ContainerReference.of("e90e34656806"); 			URI removeUri = new URI(CONTAINERS_URL + "/e90e34656806"); 			given(httpClient().delete(removeUri)).willReturn(emptyResponse()); 			this.api.remove(reference, false); 			verify(httpClient()).delete(removeUri); 		}
@Test 		void removeWhenForceIsTrueRemovesContainer() throws Exception { 			ContainerReference reference = ContainerReference.of("e90e34656806"); 			URI removeUri = new URI(CONTAINERS_URL + "/e90e34656806?force=1"); 			given(httpClient().delete(removeUri)).willReturn(emptyResponse()); 			this.api.remove(reference, true); 			verify(httpClient()).delete(removeUri); 		}
@BeforeEach 	void setup() { 		MockitoAnnotations.initMocks(this); 		this.dockerApi = new DockerApi(this.httpClient); 	}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.image(); 		}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.volume(); 		}
@Test 		void removeRemovesContainer() throws Exception { 			ImageReference reference = ImageReference 					.of("ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d"); 			URI removeUri = new URI(IMAGES_URL 					+ "/docker.io/library/ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d"); 			given(httpClient().delete(removeUri)).willReturn(emptyResponse()); 			this.api.remove(reference, false); 			verify(httpClient()).delete(removeUri); 		}
@Test 		void removeWhenForceIsTrueRemovesContainer() throws Exception { 			ImageReference reference = ImageReference 					.of("ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d"); 			URI removeUri = new URI(IMAGES_URL 					+ "/docker.io/library/ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d?force=1"); 			given(httpClient().delete(removeUri)).willReturn(emptyResponse()); 			this.api.remove(reference, true); 			verify(httpClient()).delete(removeUri); 		}
@BeforeEach 	void setup() { 		MockitoAnnotations.initMocks(this); 		this.dockerApi = new DockerApi(this.httpClient); 	}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.image(); 		}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.container(); 		}
@Test 	void createWhenUriIsNullThrowsException() { 		assertThatIllegalArgumentException() 				.isThrownBy(() -> new DockerException(this.HOST, null, 404, null, NO_ERRORS)) 				.withMessage("URI must not be null"); 	}
@Test 	void create() { 		DockerException exception = new DockerException(HOST, URI, 404, "missing", ERRORS); 		assertThat(exception.getMessage()).isEqualTo( 				"Docker API call to 'docker://localhost/example' failed with status code 404 \"missing\" [code: message]"); 		assertThat(exception.getStatusCode()).isEqualTo(404); 		assertThat(exception.getReasonPhrase()).isEqualTo("missing"); 		assertThat(exception.getErrors()).isSameAs(ERRORS); 	}
@Test 	void createWhenReasonPhraseIsNull() { 		DockerException exception = new DockerException(HOST, URI, 404, null, ERRORS); 		assertThat(exception.getMessage()).isEqualTo( 				"Docker API call to 'docker://localhost/example' failed with status code 404 [code: message]"); 		assertThat(exception.getStatusCode()).isEqualTo(404); 		assertThat(exception.getReasonPhrase()).isNull(); 		assertThat(exception.getErrors()).isSameAs(ERRORS); 	}
@Test 	void createWhenErrorsIsNull() { 		DockerException exception = new DockerException(HOST, URI, 404, "missing", null); 		assertThat(exception.getErrors()).isNull(); 	}
@Test 	void createWhenErrorsIsEmpty() { 		DockerException exception = new DockerException(HOST, URI, 404, "missing", NO_ERRORS); 		assertThat(exception.getMessage()) 				.isEqualTo("Docker API call to 'docker://localhost/example' failed with status code 404 \"missing\""); 		assertThat(exception.getStatusCode()).isEqualTo(404); 		assertThat(exception.getReasonPhrase()).isEqualTo("missing"); 		assertThat(exception.getErrors()).isSameAs(NO_ERRORS);  	}
@BeforeEach 	void setup() throws Exception { 		MockitoAnnotations.initMocks(this); 		given(this.client.execute(any(HttpHost.class), any(HttpRequest.class))).willReturn(this.response); 		given(this.response.getEntity()).willReturn(this.entity); 		given(this.response.getStatusLine()).willReturn(this.statusLine); 		this.http = new HttpClientHttp(new TestClientConnection(this.client)); 		this.uri = new URI("example"); 	}
@Test 	void getShouldExecuteHttpGet() throws Exception { 		given(this.entity.getContent()).willReturn(this.content); 		given(this.statusLine.getStatusCode()).willReturn(200); 		Response response = this.http.get(this.uri); 		verify(this.client).execute(this.hostCaptor.capture(), this.requestCaptor.capture()); 		HttpUriRequest request = this.requestCaptor.getValue(); 		assertThat(request).isInstanceOf(HttpGet.class); 		assertThat(request.getURI()).isEqualTo(this.uri); 		assertThat(request.getFirstHeader(HttpHeaders.CONTENT_TYPE)).isNull(); 		assertThat(response.getContent()).isSameAs(this.content); 	}
@Test 	void postShouldExecuteHttpPost() throws Exception { 		given(this.entity.getContent()).willReturn(this.content); 		given(this.statusLine.getStatusCode()).willReturn(200); 		Response response = this.http.post(this.uri); 		verify(this.client).execute(this.hostCaptor.capture(), this.requestCaptor.capture()); 		HttpUriRequest request = this.requestCaptor.getValue(); 		assertThat(request).isInstanceOf(HttpPost.class); 		assertThat(request.getURI()).isEqualTo(this.uri); 		assertThat(request.getFirstHeader(HttpHeaders.CONTENT_TYPE)).isNull(); 		assertThat(response.getContent()).isSameAs(this.content); 	}
@Test 	void postWithContentShouldExecuteHttpPost() throws Exception { 		given(this.entity.getContent()).willReturn(this.content); 		given(this.statusLine.getStatusCode()).willReturn(200); 		Response response = this.http.post(this.uri, APPLICATION_JSON, 				(out) -> StreamUtils.copy("test", StandardCharsets.UTF_8, out)); 		verify(this.client).execute(this.hostCaptor.capture(), this.requestCaptor.capture()); 		HttpUriRequest request = this.requestCaptor.getValue(); 		HttpEntity entity = ((HttpEntityEnclosingRequest) request).getEntity(); 		assertThat(request).isInstanceOf(HttpPost.class); 		assertThat(request.getURI()).isEqualTo(this.uri); 		assertThat(request.getFirstHeader(HttpHeaders.CONTENT_TYPE).getValue()).isEqualTo(APPLICATION_JSON); 		assertThat(entity.isRepeatable()).isFalse(); 		assertThat(entity.getContentLength()).isEqualTo(-1); 		assertThat(entity.isStreaming()).isTrue(); 		assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(entity::getContent); 		assertThat(writeToString(entity)).isEqualTo("test"); 		assertThat(response.getContent()).isSameAs(this.content); 	}
@Test 	void putWithContentShouldExecuteHttpPut() throws Exception { 		given(this.entity.getContent()).willReturn(this.content); 		given(this.statusLine.getStatusCode()).willReturn(200); 		Response response = this.http.put(this.uri, APPLICATION_JSON, 				(out) -> StreamUtils.copy("test", StandardCharsets.UTF_8, out)); 		verify(this.client).execute(this.hostCaptor.capture(), this.requestCaptor.capture()); 		HttpUriRequest request = this.requestCaptor.getValue(); 		HttpEntity entity = ((HttpEntityEnclosingRequest) request).getEntity(); 		assertThat(request).isInstanceOf(HttpPut.class); 		assertThat(request.getURI()).isEqualTo(this.uri); 		assertThat(request.getFirstHeader(HttpHeaders.CONTENT_TYPE).getValue()).isEqualTo(APPLICATION_JSON); 		assertThat(entity.isRepeatable()).isFalse(); 		assertThat(entity.getContentLength()).isEqualTo(-1); 		assertThat(entity.isStreaming()).isTrue(); 		assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(entity::getContent); 		assertThat(writeToString(entity)).isEqualTo("test"); 		assertThat(response.getContent()).isSameAs(this.content); 	}
@Test 	void deleteShouldExecuteHttpDelete() throws IOException { 		given(this.entity.getContent()).willReturn(this.content); 		given(this.statusLine.getStatusCode()).willReturn(200); 		Response response = this.http.delete(this.uri); 		verify(this.client).execute(this.hostCaptor.capture(), this.requestCaptor.capture()); 		HttpUriRequest request = this.requestCaptor.getValue(); 		assertThat(request).isInstanceOf(HttpDelete.class); 		assertThat(request.getURI()).isEqualTo(this.uri); 		assertThat(request.getFirstHeader(HttpHeaders.CONTENT_TYPE)).isNull(); 		assertThat(response.getContent()).isSameAs(this.content); 	}
@Test 	void executeWhenClientThrowsIOExceptionRethrowsAsDockerException() throws IOException { 		given(this.client.execute(any(HttpHost.class), any(HttpRequest.class))) 				.willThrow(new IOException("test IO exception")); 		assertThatExceptionOfType(DockerException.class).isThrownBy(() -> this.http.get(this.uri)) 				.satisfies((ex) -> assertThat(ex.getErrors()).isNull()).satisfies(DockerException::getStatusCode) 				.withMessageContaining("500") 				.satisfies((ex) -> assertThat(ex.getReasonPhrase()).contains("test IO exception")); 	}
public boolean determineEnabled() { 			if (CollectionUtils.isEmpty(RabbitProperties.this.parsedAddresses)) { 				return isEnabled(); 			} 			Address address = RabbitProperties.this.parsedAddresses.get(0); 			return address.determineSslEnabled(isEnabled()); 		}
@Override 	@SuppressWarnings("deprecation") 	protected Set<Class<?>> getDefaultIncludes() { 		if (ObjectUtils.isEmpty(this.annotation.controllers())) { 			return DEFAULT_INCLUDES_AND_CONTROLLER; 		} 		return DEFAULT_INCLUDES; 	}
@Override 	protected Set<Class<?>> getDefaultIncludes() { 		if (this.annotation.secure()) { 			if (ObjectUtils.isEmpty(this.annotation.controllers())) { 				return DEFAULT_INCLUDES_SECURITY_CONFIGURER_AND_CONTROLLER; 			} 			return DEFAULT_INCLUDES_AND_SECURITY_CONFIGURER; 		} 		if (ObjectUtils.isEmpty(this.annotation.controllers())) { 			return DEFAULT_INCLUDES_AND_CONTROLLER; 		} 		return DEFAULT_INCLUDES; 	}
@Test 	public void matchWhenHasNoControllers() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				WithNoControllers.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); 	}
@Test 	public void matchWhenHasController() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				WithController.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); 	}
@Test 	public void matchNotUsingDefaultFilters() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				NotUsingDefaultFilters.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isTrue(); 		assertThat(excludes(filter, ExampleWeb.class)).isTrue(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isTrue(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isTrue(); 	}
@Test 	public void matchWithExcludeFilter() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				WithExcludeFilter.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); 	}
@Bean 	@ConditionalOnMissingBean(WebDriver.class) 	@ConditionalOnBean(MockMvcHtmlUnitDriverBuilder.class) 	public HtmlUnitDriver htmlUnitDriver(MockMvcHtmlUnitDriverBuilder builder) { 		HtmlUnitDriver driver = builder.build(); 		if (ClassUtils.isPresent(SECURITY_CONTEXT_EXECUTOR, 				getClass().getClassLoader())) { 			driver.setExecutor(new DelegatingSecurityContextExecutor( 					Executors.newSingleThreadExecutor())); 		} 		return driver; 	}
@Bean 	@ConditionalOnMissingBean 	@ConditionalOnEnabledEndpoint 	@ConditionalOnBean(value = HealthEndpoint.class, search = SearchStrategy.CURRENT) 	public HealthWebEndpointExtension healthWebEndpointExtension(HealthEndpoint delegate, 			HealthWebEndpointExtensionProperties extensionProperties) { 		return new HealthWebEndpointExtension(delegate, 				createHealthStatusHttpMapper(extensionProperties)); 	}
@ReadOperation 	public WebEndpointResponse<Health> getHealth() { 		Health health = this.delegate.health(); 		Integer status = this.statusHttpMapper.mapStatus(health.getStatus()); 		return new WebEndpointResponse<>(health, status); 	}
@Test 	public void healthStatusMappingCanBeCustomized() { 		ApplicationContextRunner contextRunner = contextRunner() 				.withPropertyValues("endpoints.health.mapping.CUSTOM=500") 				.withUserConfiguration(HealthEndpointConfiguration.class); 		contextRunner.run((context) -> { 			HealthWebEndpointExtension extension = context 					.getBean(HealthWebEndpointExtension.class); 			@SuppressWarnings("unchecked") 			Map<String, Integer> statusMappings = ((HealthStatusHttpMapper) ReflectionTestUtils 					.getField(extension, "statusHttpMapper")).getStatusMapping(); 			assertThat(statusMappings).containsEntry("DOWN", 503); 			assertThat(statusMappings).containsEntry("OUT_OF_SERVICE", 503); 			assertThat(statusMappings).containsEntry("CUSTOM", 500); 		}); 	}
@Bean 		public HealthEndpoint healthEndpoint() { 			return new HealthEndpoint(() -> Health.up().build()); 		}
@Bean 		public HealthEndpoint healthEndpoint( 				Map<String, HealthIndicator> healthIndicators) { 			return new HealthEndpoint(new HealthIndicatorFactory().createHealthIndicator( 					new OrderedHealthAggregator(), healthIndicators)); 		}
@Bean 		public HealthWebEndpointExtension healthWebEndpointExtension( 				HealthEndpoint delegate) { 			return new HealthWebEndpointExtension(delegate, new HealthStatusHttpMapper()); 		}
@Bean 		public HealthEndpoint healthEndpoint( 				Map<String, HealthIndicator> healthIndicators) { 			return new HealthEndpoint(new HealthIndicatorFactory().createHealthIndicator( 					new OrderedHealthAggregator(), healthIndicators)); 		}
@Bean 		public HealthWebEndpointExtension healthWebEndpointExtension( 				HealthEndpoint delegate) { 			return new HealthWebEndpointExtension(delegate, new HealthStatusHttpMapper()); 		}
@Test 	public void testInsecureNestedPath() throws Exception { 		ResponseEntity<String> entity = this.restTemplate.getForEntity("/env", 				String.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK); 		ResponseEntity<String> user = this.restTemplate.getForEntity("/env/foo", 				String.class); 		assertThat(user.getStatusCode()).isEqualTo(HttpStatus.OK); 		assertThat(user.getBody()).contains("{\"foo\":"); 	}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnEnabledEndpoint("health") 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate, 				isHealthSecure()); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint 					.addStatusMapping(this.healthMvcEndpointProperties.getMapping()); 		} 		return healthMvcEndpoint; 	}
private <T extends ActiveMQConnectionFactory> T createNativeConnectionFactory( 			Class<T> factoryClass) throws Exception { 		Map<String, Object> params = new HashMap<String, Object>(); 		params.put(TransportConstants.HOST_PROP_NAME, this.properties.getHost()); 		params.put(TransportConstants.PORT_PROP_NAME, this.properties.getPort()); 		TransportConfiguration transportConfiguration = new TransportConfiguration( 				NettyConnectorFactory.class.getName(), params); 		Constructor<T> constructor = factoryClass.getConstructor(boolean.class, 				TransportConfiguration[].class); 		T connectionFactory = constructor.newInstance(false, 				new TransportConfiguration[] {transportConfiguration}); 		String user = this.properties.getUser(); 		if (StringUtils.hasText(user)) { 			connectionFactory.setUser(user); 			connectionFactory.setPassword(this.properties.getPassword()); 		} 		return connectionFactory; 	}
@Test 	public void nativeConnectionFactory() { 		load(EmptyConfiguration.class, "spring.artemis.mode:native"); 		JmsTemplate jmsTemplate = this.context.getBean(JmsTemplate.class); 		ActiveMQConnectionFactory connectionFactory = this.context 				.getBean(ActiveMQConnectionFactory.class); 		assertThat(connectionFactory).isEqualTo(jmsTemplate.getConnectionFactory()); 		assertNettyConnectionFactory(connectionFactory, "localhost", 61616); 		assertThat(connectionFactory.getUser()).isNull(); 		assertThat(connectionFactory.getPassword()).isNull(); 	}
@Bean 	public HornetQConnectionFactory jmsConnectionFactory(ListableBeanFactory beanFactory, 			HornetQProperties properties) { 		return new HornetQConnectionFactoryFactory(beanFactory, properties) 				.createConnectionFactory(HornetQSecuredConnectionFactory.class); 	}
private <T extends HornetQConnectionFactory> T createEmbeddedConnectionFactory( 			Class<T> factoryClass) throws Exception { 		try { 			TransportConfiguration transportConfiguration = new TransportConfiguration( 					InVMConnectorFactory.class.getName(), 					this.properties.getEmbedded().generateTransportParameters()); 			ServerLocator serviceLocator = HornetQClient 					.createServerLocatorWithoutHA(transportConfiguration); 			return factoryClass.getConstructor(HornetQProperties.class, ServerLocator.class) 					.newInstance(this.properties, serviceLocator); 		} 		catch (NoClassDefFoundError ex) { 			throw new IllegalStateException("Unable to create InVM " 					+ "HornetQ connection, ensure that hornet-jms-server.jar " 					+ "is in the classpath", ex); 		} 	}
private <T extends HornetQConnectionFactory> T createNativeConnectionFactory( 			Class<T> factoryClass) throws Exception { 		Map<String, Object> params = new HashMap<String, Object>(); 		params.put(TransportConstants.HOST_PROP_NAME, this.properties.getHost()); 		params.put(TransportConstants.PORT_PROP_NAME, this.properties.getPort()); 		TransportConfiguration transportConfiguration = new TransportConfiguration( 				NettyConnectorFactory.class.getName(), params); 		Constructor<T> constructor = factoryClass.getConstructor(HornetQProperties.class, 				boolean.class, TransportConfiguration[].class); 		return constructor.newInstance(this.properties, false, 				new TransportConfiguration[] { transportConfiguration }); 	}
@Primary 	@Bean(name = { "jmsConnectionFactory", "xaJmsConnectionFactory" }) 	public ConnectionFactory jmsConnectionFactory(ListableBeanFactory beanFactory, 			HornetQProperties properties, XAConnectionFactoryWrapper wrapper) 			throws Exception { 		return wrapper.wrapConnectionFactory( 				new HornetQConnectionFactoryFactory(beanFactory, properties) 						.createConnectionFactory( 								HornetQXASecuredConnectionFactory.class)); 	}
@Bean 	public HornetQConnectionFactory nonXaJmsConnectionFactory( 			ListableBeanFactory beanFactory, HornetQProperties properties) { 		return new HornetQConnectionFactoryFactory(beanFactory, properties) 				.createConnectionFactory(HornetQSecuredConnectionFactory.class); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertThat(this.context.getBean(AuthenticationManagerBuilder.class)).isNotNull(); 		// 5 for static resources and one for the rest 		assertThat(this.context.getBean(FilterChainProxy.class).getFilterChains()) 				.hasSize(6); 	}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.userDetails = http.getSharedObject(UserDetailsService.class); 		}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return new TestingAuthenticationToken("foo", "bar"); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.authenticationManager = new AuthenticationManager() { 				@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				} 			}; 		}
@Autowired 		public void handlerMapping(MvcEndpoints endpoints, 				ListableBeanFactory beanFactory, EndpointHandlerMapping mapping) { 			// In a child context we definitely want to see the parent endpoints 			mapping.setDetectHandlerMethodsInAncestorContexts(true); 		}
@Override 		public void init(WebSecurity builder) throws Exception { 			if (this.server != null) { 				IgnoredRequestConfigurer ignoring = builder.ignoring(); 				// The ignores are not cumulative, so to prevent overwriting the defaults 				// we add them back. 				Set<String> ignored = new LinkedHashSet<String>( 						SpringBootWebSecurityConfiguration.getIgnored(this.security)); 				if (ignored.contains("none")) { 					ignored.remove("none"); 				} 				if (this.errorController != null) { 					ignored.add(normalizePath(this.errorController.getErrorPath())); 				} 				String[] paths = this.server.getPathsArray(ignored); 				RequestMatcher requestMatcher = this.management.getSecurity().isEnabled() 						? null 						: LazyEndpointPathRequestMatcher 								.getRequestMatcher(this.contextResolver); 				if (!ObjectUtils.isEmpty(paths)) { 					List<RequestMatcher> matchers = new ArrayList<RequestMatcher>(); 					for (String pattern : paths) { 						matchers.add(new AntPathRequestMatcher(pattern, null)); 					} 					if (requestMatcher != null) { 						matchers.add(requestMatcher); 					} 					requestMatcher = new OrRequestMatcher(matchers); 				} 				if (requestMatcher != null) { 					ignoring.requestMatchers(requestMatcher); 				} 			} 		}
private EndpointHandlerMapping getRequiredEndpointHandlerMapping() { 			EndpointHandlerMapping endpointHandlerMapping = null; 			ApplicationContext context = this.contextResolver.getApplicationContext(); 			if (context.getBeanNamesForType(EndpointHandlerMapping.class).length > 0) { 				endpointHandlerMapping = context.getBean(EndpointHandlerMapping.class); 			} 			if (endpointHandlerMapping == null) { 				// Maybe there are actually no endpoints (e.g. management.port=-1) 				endpointHandlerMapping = new EndpointHandlerMapping( 						Collections.<MvcEndpoint>emptySet()); 			} 			return endpointHandlerMapping; 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// secure endpoints 			RequestMatcher matcher = this.management.getSecurity().isEnabled() 					? LazyEndpointPathRequestMatcher 							.getRequestMatcher(this.contextResolver) 					: null; 			if (matcher != null) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				// Match all the requests for actuator endpoints ... 				http.requestMatcher(matcher); 				// ... but permitAll() for the non-sensitive ones 				configurePermittedRequests(http.authorizeRequests()); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions()); 				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders()); 			} 		}
private void configurePermittedRequests( 				ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry requests) { 			// Permit access to the non-sensitive endpoints 			requests.requestMatchers(new LazyEndpointPathRequestMatcher( 					this.contextResolver, EndpointPaths.NON_SENSITIVE)).permitAll(); 			// Restrict the rest to the configured role 			requests.anyRequest().hasRole(this.management.getSecurity().getRole()); 		}
@Override 		public boolean matches(HttpServletRequest request) { 			if (this.delegate == null) { 				this.delegate = createDelegate(); 			} 			return this.delegate.matches(request); 		}
private RequestMatcher createDelegate() { 			ServerProperties server = this.contextResolver.getApplicationContext() 					.getBean(ServerProperties.class); 			List<RequestMatcher> matchers = new ArrayList<RequestMatcher>(); 			EndpointHandlerMapping endpointHandlerMapping = getRequiredEndpointHandlerMapping(); 			for (String path : this.endpointPaths.getPaths(endpointHandlerMapping)) { 				matchers.add(new AntPathRequestMatcher(server.getPath(path))); 			} 			return (matchers.isEmpty() ? MATCH_NONE : new OrRequestMatcher(matchers)); 		}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
@Test 	public void onDifferentPortAndContext() throws Exception { 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				DifferentPortConfig.class, BaseConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class); 		management.setContextPath("/admin"); 		this.applicationContext.refresh(); 		assertContent("/controller", ports.get().server, "controlleroutput"); 		assertContent("/admin/endpoint", ports.get().management, "endpointoutput"); 		assertContent("/error", ports.get().management, startsWith("{")); 		this.applicationContext.close(); 		assertAllClosed(); 	}
@Test 	public void onDifferentPortAndMainContext() throws Exception { 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				DifferentPortConfig.class, BaseConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class); 		management.setContextPath("/admin"); 		server.setContextPath("/spring"); 		this.applicationContext.refresh(); 		assertContent("/spring/controller", ports.get().server, "controlleroutput"); 		assertContent("/admin/endpoint", ports.get().management, "endpointoutput"); 		assertContent("/error", ports.get().management, startsWith("{")); 		this.applicationContext.close(); 		assertAllClosed(); 	}
public int getCount() { 				return this.count; 			}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
public int getCount() { 			return this.count; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			return properties; 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				WebMvcAutoConfiguration.class, 				ManagementWebSecurityAutoConfiguration.class, 				JacksonAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		FilterChainProxy filterChainProxy = this.context.getBean(FilterChainProxy.class); 		// 1 for static resources, one for management endpoints and one for the rest 		assertThat(filterChainProxy.getFilterChains(), hasSize(3)); 		assertThat(filterChainProxy.getFilters("/beans"), hasSize(greaterThan(0))); 		assertThat(filterChainProxy.getFilters("/beans/"), hasSize(greaterThan(0))); 		assertThat(filterChainProxy.getFilters("/beans.foo"), hasSize(greaterThan(0))); 		assertThat(filterChainProxy.getFilters("/beans/foo/bar"), 				hasSize(greaterThan(0))); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(WebConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Just the management endpoints (one filter) and ignores now plus the backup 		// filter on app endpoints 		assertEquals(3, 				this.context.getBean(FilterChainProxy.class).getFilterChains().size()); 	}
@Test 	public void testCustomErrorPath() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = new TestRestTemplate("user", getPassword()) 				.getForEntity("http://localhost:" + this.port + "/oops", Map.class); 		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("None", body.get("error")); 		assertEquals(999, body.get("status")); 	}
private RequestMatcher createDelegate() { 				ServerProperties server = ManagementWebSecurityConfigurerAdapter.this.server; 				List<RequestMatcher> matchers = new ArrayList<RequestMatcher>(); 				EndpointHandlerMapping endpointHandlerMapping = ManagementWebSecurityConfigurerAdapter.this 						.getRequiredEndpointHandlerMapping(); 				for (String path : this.endpointPaths.getPaths(endpointHandlerMapping)) { 					matchers.add(new AntPathRequestMatcher(server.getPath(path))); 				} 				return (matchers.isEmpty() ? MATCH_NONE : new OrRequestMatcher(matchers)); 			}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
@PostConstruct 		public void applyConfigurationProperties() { 			Integer timeout = this.serverProperties.getSession().getTimeout(); 			if (timeout != null) { 				this.sessionRepository.setDefaultMaxInactiveInterval(timeout); 			} 		}
@Deprecated 	public Integer getSessionTimeout() { 		return this.session.getTimeout(); 	}
@Deprecated 	public void setSessionTimeout(Integer sessionTimeout) { 		this.session.setTimeout(sessionTimeout); 	}
@Override 	public void customize(ConfigurableEmbeddedServletContainer container) { 		if (getPort() != null) { 			container.setPort(getPort()); 		} 		if (getAddress() != null) { 			container.setAddress(getAddress()); 		} 		if (getContextPath() != null) { 			container.setContextPath(getContextPath()); 		} 		if (getDisplayName() != null) { 			container.setDisplayName(getDisplayName()); 		} 		if (getSession().getTimeout() != null) { 			container.setSessionTimeout(getSession().getTimeout()); 		} 		if (getSsl() != null) { 			container.setSsl(getSsl()); 		} 		if (getJspServlet() != null) { 			container.setJspServlet(getJspServlet()); 		} 		if (getCompression() != null) { 			container.setCompression(getCompression()); 		} 		if (container instanceof TomcatEmbeddedServletContainerFactory) { 			getTomcat() 					.customizeTomcat((TomcatEmbeddedServletContainerFactory) container); 		} 		if (container instanceof UndertowEmbeddedServletContainerFactory) { 			getUndertow().customizeUndertow( 					(UndertowEmbeddedServletContainerFactory) container); 		} 		container.addInitializers(new SessionConfiguringInitializer(this.session)); 		container.addInitializers(new InitParameterConfiguringServletContextInitializer( 				getContextParameters())); 	}
@Override 				public void customize(Connector connector) { 					ProtocolHandler handler = connector.getProtocolHandler(); 					if (handler instanceof AbstractHttp11Protocol) { 						AbstractHttp11Protocol protocol = (AbstractHttp11Protocol) handler; 						protocol.setMaxHttpHeaderSize(Tomcat.this.maxHttpHeaderSize); 					} 				}
@Override 				public void customize(Connector connector) {  					ProtocolHandler handler = connector.getProtocolHandler(); 					if (handler instanceof AbstractProtocol) { 						AbstractProtocol protocol = (AbstractProtocol) handler; 						protocol.setMaxThreads(Tomcat.this.maxThreads); 					}  				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers("/css/**").permitAll().anyRequest() 					.fullyAuthenticated().and().formLogin().loginPage("/login") 					.failureUrl("/login?error").permitAll().and().logout().permitAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers("/css/**").permitAll().anyRequest() 					.fullyAuthenticated().and().formLogin().loginPage("/login") 					.failureUrl("/login?error").permitAll().and().logout().permitAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().fullyAuthenticated().and().formLogin() 					.loginPage("/login").failureUrl("/login?error").permitAll().and() 					.logout().permitAll(); 		}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnEnabledEndpoint("health") 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		Security security = this.managementServerProperties.getSecurity(); 		boolean secure = (security != null && security.isEnabled()); 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate, secure); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint.addStatusMapping(this.healthMvcEndpointProperties 					.getMapping()); 		} 		return healthMvcEndpoint; 	}
private boolean isUnrestricted() { 		Boolean sensitive = this.propertyResolver.getProperty("sensitive", Boolean.class); 		return !this.secure && !Boolean.TRUE.equals(sensitive); 	}
@Test 	public void unsecureAnonymousAccessUnrestricted() { 		this.mvc = new HealthMvcEndpoint(this.endpoint, false); 		this.mvc.setEnvironment(this.environment); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity( 				"http://localhost:" + this.port, Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testSecureHealth() throws Exception { 		ResponseEntity<String> entity = new TestRestTemplate().getForEntity( 				"http://localhost:" + this.port + "/health", String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertFalse("Wrong body: " + entity.getBody(), 				entity.getBody().contains("\"hello\":1")); 	}
private Health getHealth(Principal principal) { 		long accessTime = System.currentTimeMillis(); 		if (isCacheStale(accessTime)) { 			this.lastAccess = accessTime; 			this.cached = this.delegate.invoke(); 		} 		if (exposeHealthDetails(principal)) { 			return this.cached; 		} 		return Health.status(this.cached.getStatus()).build(); 	}
private static String[] getEndpointPaths( 			EndpointHandlerMapping endpointHandlerMapping, boolean secure) { 		if (endpointHandlerMapping == null) { 			return NO_PATHS; 		}  		Set<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints(); 		List<String> paths = new ArrayList<String>(endpoints.size()); 		for (MvcEndpoint endpoint : endpoints) { 			if (endpoint.isSensitive() == secure) { 				String path = endpointHandlerMapping.getPrefix() + endpoint.getPath(); 				paths.add(path); 				if (secure) { 					// Ensure the nested paths are secured 					paths.add(path + "/**"); 					// Add Spring MVC-generated additional paths 					paths.add(path + ".*"); 				} 			} 		} 		return paths.toArray(new String[paths.size()]); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		FilterChainProxy filterChainProxy = this.context.getBean(FilterChainProxy.class); 		// 6 for static resources, one for management endpoints and one for the rest 		assertThat(filterChainProxy.getFilterChains(), hasSize(8)); 		assertThat(filterChainProxy.getFilters("/beans"), hasSize(greaterThan(0))); 		assertThat(filterChainProxy.getFilters("/beans/"), hasSize(greaterThan(0))); 		assertThat(filterChainProxy.getFilters("/beans.foo"), hasSize(greaterThan(0))); 		assertThat(filterChainProxy.getFilters("/beans/foo/bar"), hasSize(greaterThan(0))); 	}
@Override 			public void configure(WebAppContext context) throws Exception { 				MimeTypes mimeTypes = context.getMimeTypes(); 				for (MimeMappings.Mapping mapping : getMimeMappings()) { 					mimeTypes.addMimeMapping(mapping.getExtension(), 							mapping.getMimeType()); 				} 			}
@Override 			public void configure(WebAppContext context) throws Exception { 				ErrorHandler errorHandler = context.getErrorHandler(); 				addJettyErrorPages(errorHandler, getErrorPages()); 			}
@Override 		public ServerConnector getConnector(Server server, 				SslContextFactory sslContextFactory, int port) { 			HttpConfiguration config = new HttpConfiguration(); 			config.addCustomizer(new SecureRequestCustomizer()); 			HttpConnectionFactory connectionFactory = new HttpConnectionFactory(config); 			SslConnectionFactory sslConnectionFactory = new SslConnectionFactory( 					sslContextFactory, HttpVersion.HTTP_1_1.asString()); 			ServerConnector serverConnector = new ServerConnector(server, 					sslConnectionFactory, connectionFactory); 			serverConnector.setPort(port); 			return serverConnector; 		}
@Override 		public AbstractConnector getConnector(Server server, 				SslContextFactory sslContextFactory, int port) { 			try { 				Class<?> connectorClass = Class 						.forName("org.eclipse.jetty.server.ssl.SslSocketConnector"); 				AbstractConnector connector = (AbstractConnector) connectorClass 						.getConstructor(SslContextFactory.class).newInstance( 								sslContextFactory); 				connector.getClass().getMethod("setPort", int.class) 						.invoke(connector, port); 				return connector; 			} 			catch (Exception ex) { 				throw new IllegalStateException(ex); 			} 		}
@Override 		public ServerConnector getConnector(Server server, 				SslContextFactory sslContextFactory, int port) { 			HttpConfiguration config = new HttpConfiguration(); 			config.addCustomizer(new SecureRequestCustomizer()); 			HttpConnectionFactory connectionFactory = new HttpConnectionFactory(config); 			SslConnectionFactory sslConnectionFactory = new SslConnectionFactory( 					sslContextFactory, HttpVersion.HTTP_1_1.asString()); 			ServerConnector serverConnector = new ServerConnector(server, 					sslConnectionFactory, connectionFactory); 			serverConnector.setPort(port); 			return serverConnector; 		}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnProperty(prefix = "endpoints.health", name = "enabled", matchIfMissing = true) 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate); 		boolean secure = this.managementServerProperties.getSecurity().isEnabled() 				&& ClassUtils.isPresent( 						"org.springframework.security.core.Authentication", null); 		delegate.setSensitive(secure); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint.addStatusMapping(this.healthMvcEndpointProperties 					.getMapping()); 		} 		return healthMvcEndpoint; 	}
private Health getHealth(Principal principal) { 		Health health = (useCachedValue(principal) ? this.cached : (Health) this.delegate 				.invoke()); 		// Not too worried about concurrent access here, the worst that can happen is the 		// odd extra call to delegate.invoke() 		this.cached = health; 		if (!secure(principal) && this.delegate.isSensitive()) { 			// If not secure we only expose the status 			health = Health.status(health.getStatus()).build(); 		} 		return health; 	}
private boolean useCachedValue(Principal principal) { 		long accessTime = System.currentTimeMillis(); 		if (cacheIsStale(accessTime) || secure(principal) || !this.delegate.isSensitive()) { 			this.lastAccess = accessTime; 			return false; 		} 		return this.cached != null; 	}
@Test 	public void secure() { 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		given(this.endpoint.isSensitive()).willReturn(false); 		Object result = this.mvc.invoke(this.user); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void secureNotCached() { 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.isSensitive()).willReturn(false); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(this.user); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(this.user); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertTrue(health.getStatus() == Status.DOWN); 	}
@Test 	public void unsecureCached() { 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.isSensitive()).willReturn(true); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(this.user); 		assertTrue(result instanceof Health); 		Health health = (Health) result; 		assertTrue(health.getStatus() == Status.UP); 		assertThat(health.getDetails().size(), is(equalTo(1))); 		assertThat(health.getDetails().get("foo"), is(equalTo((Object) "bar"))); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); // insecure now 		assertTrue(result instanceof Health); 		health = (Health) result; 		// so the result is cached 		assertTrue(health.getStatus() == Status.UP); 		// but the details are hidden 		assertThat(health.getDetails().size(), is(equalTo(0))); 	}
@Test 	public void unsecureAnonymousAccessUnrestricted() { 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		given(this.endpoint.isSensitive()).willReturn(false); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void unsecureIsNotCachedWhenAnonymousAccessIsUnrestricted() { 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.isSensitive()).willReturn(false); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertTrue(health.getStatus() == Status.DOWN); 	}
@Test 	public void newValueIsReturnedOnceTtlExpires() throws InterruptedException { 		given(this.endpoint.getTimeToLive()).willReturn(50L); 		given(this.endpoint.isSensitive()).willReturn(false); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		Thread.sleep(100); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertTrue(health.getStatus() == Status.DOWN); 	}
private void runSchemaScripts() { 		List<Resource> scripts = getScripts(this.properties.getSchema(), "schema"); 		if (!scripts.isEmpty()) { 			runScripts(scripts); 			try { 				this.applicationContext.publishEvent(new DataSourceInitializedEvent( 						this.dataSource)); 				// The listener might not be registered yet, so don't rely on it. 				if (!this.initialized) { 					runDataScripts(); 					this.initialized = true; 				} 			} 			catch (IllegalStateException ex) { 				logger.warn("Could not send event to complete DataSource initialization (" 						+ ex.getMessage() + ")"); 			} 		} 	}
@Test 	public void testLogin() throws Exception { 		HttpHeaders headers = getHeaders(); 		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML)); 		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); 		MultiValueMap<String, String> form = new LinkedMultiValueMap<String, String>(); 		form.set("username", "user"); 		form.set("password", "user"); 		ResponseEntity<String> entity = new TestRestTemplate().exchange( 				"http://localhost:" + this.port + "/login", HttpMethod.POST, 				new HttpEntity<MultiValueMap<String, String>>(form, headers), 				String.class); 		assertEquals(HttpStatus.FOUND, entity.getStatusCode()); 		assertTrue("Wrong location:\n" + entity.getHeaders(), 				entity.getHeaders().getLocation().toString().endsWith(port + "/")); 		assertNotNull("Missing cookie:\n" + entity.getHeaders(), 				entity.getHeaders().get("Set-Cookie")); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  			String[] paths = getSecureApplicationPaths();  			if (paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.httpBasic(); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests() 						.anyRequest() 						.hasAnyRole( 								this.security.getUser().getRole().toArray(new String[0])); 			}  		}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Ignores and the "matches-none" filter only 		assertEquals(1, this.context.getBeanNamesForType(FilterChainProxy.class).length); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				FallbackWebSecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Just the management endpoints (one filter) and ignores now plus the backup 		// filter on app endpoints 		assertEquals(8, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Bean 	@Lazy 	@Scope(proxyMode = ScopedProxyMode.INTERFACES) 	protected AuthenticationManager lazyAuthenticationManager() { 		AuthenticationManager manager = this.configurer.getAuthenticationManagerBuilder() 				.getOrBuild(); 		if (manager instanceof ProviderManager) { 			((ProviderManager) manager) 					.setAuthenticationEventPublisher(this.authenticationEventPublisher); 		} 		return manager; 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  			String[] paths = getSecureApplicationPaths(); 			configureAdditionalRules(http, paths);  		}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Ignores and permitAll() security on application endpoints 		assertEquals(1, this.context.getBeanNamesForType(FilterChainProxy.class).length); 	}
public static void main(String[] args) throws Exception { 		new SpringApplicationBuilder(SampleWebSecureApplication.class).run(args); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (!security.isEnableCsrf()) { 				// For testing 				http.csrf().disable(); 			} 			http.authorizeRequests().anyRequest().fullyAuthenticated().and().formLogin() 					.loginPage("/login").failureUrl("/login?error").permitAll(); 		}
@Test 	public void testHome() throws Exception { 		HttpHeaders headers = new HttpHeaders(); 		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML)); 		ResponseEntity<String> entity = new TestRestTemplate().exchange( 				"http://localhost:" + this.port, HttpMethod.GET, new HttpEntity<Void>( 						headers), String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertTrue("Wrong body (title doesn't match):\n" + entity.getBody(), 				entity.getBody().contains("<title>Login")); 	}
@Test 	public void testManagementAuthorizedAccess() throws Exception { 		ResponseEntity<String> entity = new TestRestTemplate("admin", "admin") 				.getForEntity("http://localhost:" + port + "/beans", String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 	}
public ConfigurableApplicationContext run(String... args) {  		StopWatch stopWatch = new StopWatch(); 		stopWatch.start(); 		ConfigurableApplicationContext context = null;  		System.setProperty("java.awt.headless", Boolean.toString(this.headless));  		Collection<SpringApplicationRunListener> runListeners = getRunListeners(args); 		for (SpringApplicationRunListener runListener : runListeners) { 			runListener.started(); 		}  		try { 			// Create and configure the environment 			ConfigurableEnvironment environment = getOrCreateEnvironment(); 			configureEnvironment(environment, args); 			for (SpringApplicationRunListener runListener : runListeners) { 				runListener.environmentPrepared(environment); 			}  			if (this.showBanner) { 				printBanner(); 			}  			// Create, load, refresh and run the ApplicationContext 			context = createApplicationContext(); 			if (this.registerShutdownHook) { 				try { 					context.registerShutdownHook(); 				} 				catch (AccessControlException e) { 					// Not allowed in some environments. 				} 			} 			context.setEnvironment(environment); 			postProcessApplicationContext(context); 			applyInitializers(context); 			for (SpringApplicationRunListener runListener : runListeners) { 				runListener.contextPrepared(context); 			} 			if (this.logStartupInfo) { 				logStartupInfo(context.getParent() == null); 			}  			// Load the sources 			Set<Object> sources = getSources(); 			Assert.notEmpty(sources, "Sources must not be empty"); 			load(context, sources.toArray(new Object[sources.size()])); 			for (SpringApplicationRunListener runListener : runListeners) { 				runListener.contextLoaded(context); 			}  			// Refresh the context 			refresh(context); 			afterRefresh(context, args); 			for (SpringApplicationRunListener runListener : runListeners) { 				runListener.finished(context, null); 			}  			stopWatch.stop(); 			if (this.logStartupInfo) { 				new StartupInfoLogger(this.mainApplicationClass).logStarted( 						getApplicationLog(), stopWatch); 			} 			return context; 		} 		catch (Exception ex) { 			for (SpringApplicationRunListener runListener : runListeners) { 				finishWithException(runListener, context, ex); 			} 			if (context != null) { 				context.close(); 			} 			ReflectionUtils.rethrowRuntimeException(ex); 			return context; 		} 		finally { 		} 	}
private StringBuilder getStartedMessage(StopWatch stopWatch) { 		StringBuilder message = new StringBuilder(); 		message.append("Started "); 		message.append(getApplicationName()); 		message.append(" in "); 		message.append(stopWatch.getTotalTimeSeconds()); 		message.append(" seconds (JVM running for "); 		try { 			message.append(ManagementFactory.getRuntimeMXBean().getUptime() / 1000.0); 		} 		catch (Throwable e) { 			message.append("?"); 		} 		message.append(")"); 		return message; 	}
@Override 			public Object call() throws Exception { 				return InetAddress.getLocalHost().getHostName(); 			}
@Override 			public Object call() throws Exception { 				return System.getProperty("PID"); 			}
@Override 			public Object call() throws Exception { 				return System.getProperty("user.name"); 			}
@Override 			public Object call() throws Exception { 				return source.getPackage().getImplementationVersion(); 			}
@Override 			public Object call() throws Exception { 				return System.getProperty("PID"); 			}
@Override 			public Object call() throws Exception { 				return System.getProperty("user.name"); 			}
@Override 			public Object call() throws Exception { 				return source.getPackage().getImplementationVersion(); 			}
@Override 			public Object call() throws Exception { 				return InetAddress.getLocalHost().getHostName(); 			}
@Override 			public Object call() throws Exception { 				return System.getProperty("user.name"); 			}
@Override 			public Object call() throws Exception { 				return source.getPackage().getImplementationVersion(); 			}
@Override 			public Object call() throws Exception { 				return InetAddress.getLocalHost().getHostName(); 			}
@Override 			public Object call() throws Exception { 				return System.getProperty("PID"); 			}
private String getPid() { 		try { 			String name = ManagementFactory.getRuntimeMXBean().getName(); 			if (name != null) { 				return name.split("@")[0]; 			} 		} 		catch (Throwable e) { 		} 		return "????"; 	}
@Override 	public void beforeInitialize() { 		super.beforeInitialize(); 		try { 			if (ClassUtils.isPresent("org.slf4j.bridge.SLF4JBridgeHandler", 					getClassLoader())) { 				try { 					SLF4JBridgeHandler.removeHandlersForRootLogger(); 				} 				catch (NoSuchMethodError ex) { 					// Method missing in older versions of SLF4J like in JBoss AS 7.1 					SLF4JBridgeHandler.uninstall(); 				} 				SLF4JBridgeHandler.install(); 			} 		} 		catch (Throwable e) { 			// Ignore. No java.util.logging bridge is installed. 		} 	}
@Bean 	@ConditionalOnMissingBean 	public EndpointHandlerMapping endpointHandlerMapping() { 		EndpointHandlerMapping mapping = new EndpointHandlerMapping(mvcEndpoints() 				.getEndpoints()); 		boolean disabled = ManagementServerPort.get(this.applicationContext) != ManagementServerPort.SAME; 		mapping.setDisabled(disabled); 		if (!disabled) { 			mapping.setPrefix(this.managementServerProperties.getContextPath()); 		} 		return mapping; 	}
private static String[] getEndpointPaths( 			EndpointHandlerMapping endpointHandlerMapping, boolean secure) { 		if (endpointHandlerMapping == null) { 			return NO_PATHS; 		}  		Set<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints(); 		List<String> paths = new ArrayList<String>(endpoints.size()); 		for (MvcEndpoint endpoint : endpoints) { 			if (endpoint.isSensitive() == secure) { 				paths.add(endpointHandlerMapping.getPrefix() + endpoint.getPath()); 			} 		} 		return paths.toArray(new String[paths.size()]); 	}
@BeforeClass 	public static void start() throws Exception { 		final String[] args = new String[] { "--server.port=" + port, 				"--management.port=" + managementPort, "--management.address=127.0.0.1", "--management.contextPath=/admin" }; 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return SpringApplication.run( 										SampleActuatorApplication.class, args); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@Test 	public void testHealth() throws Exception { 		ResponseEntity<String> entity = getRestTemplate().getForEntity( 				"http://localhost:" + managementPort + "/admin/health", String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertEquals("ok", entity.getBody()); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 6 for static resources, one for management endpoints and one for the rest 		assertEquals(8, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testWebConfigurationWithExtraRole() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(EndpointAutoConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, UserDetailsExposed.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		UserDetails user = getUser(); 		assertTrue(user.getAuthorities().containsAll( 				AuthorityUtils 						.commaSeparatedStringToAuthorityList("ROLE_USER,ROLE_ADMIN"))); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		debugRefresh(this.context); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 4 for static resources and one for the rest 		assertEquals(5, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
public static void main(String[] args) throws Exception { 		SpringApplication.run(SampleSecureApplication.class, "--debug"); 	}
private List<RemoteRepository> createRepositories( 			List<RepositoryConfiguration> repositoryConfigurations) { 		List<RemoteRepository> repositories = new ArrayList<RemoteRepository>( 				repositoryConfigurations.size()); 		for (RepositoryConfiguration repositoryConfiguration : repositoryConfigurations) { 			RemoteRepository.Builder builder = new RemoteRepository.Builder( 					repositoryConfiguration.getName(), "default", repositoryConfiguration 							.getUri().toASCIIString());  			if (!repositoryConfiguration.getSnapshotsEnabled()) { 				builder.setSnapshotPolicy(new RepositoryPolicy(false, 						RepositoryPolicy.UPDATE_POLICY_NEVER, 						RepositoryPolicy.CHECKSUM_POLICY_IGNORE)); 			} 			builder.setProxy(AetherGrapeEngine.defaultProxy(repositoryConfiguration 					.getUri().getScheme())); 			repositories.add(builder.build()); 		} 		return repositories; 	}
@Override 	public void addResolver(Map<String, Object> args) { 		String name = (String) args.get("name"); 		String root = (String) args.get("root"); 		RemoteRepository.Builder builder = new RemoteRepository.Builder(name, "default", 				root); 		String protocol = root.contains(":") ? root.substring(0, root.indexOf(":")) 				: "none"; 		builder.setProxy(AetherGrapeEngine.defaultProxy(protocol));  		this.repositories.add(builder.build()); 	}
@Bean 		@ConditionalOnExpression("'${shell.auth:default_spring}' == 'default_spring'") 		@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 		public CrshShellAuthenticationProperties springAuthenticationProperties() { 			// In case no shell.auth property is provided fall back to Spring Security 			// based authentication and get role to access shell from SecurityProperties. 			SpringAuthenticationProperties authenticationProperties = new SpringAuthenticationProperties(); 			if (this.management != null) { 				authenticationProperties.setRoles(new String[] { this.management 						.getSecurity().getRole() }); 			} 			return authenticationProperties; 		}
@Bean 	@ConditionalOnExpression("'${shell.auth:simple}' == 'spring'") 	@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 	public CrshShellAuthenticationProperties springAuthenticationProperties() { 		return new SpringAuthenticationProperties(); 	}
@Bean 		@ConditionalOnExpression("'${shell.auth:default_spring}' == 'default_spring'") 		@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 		public CrshShellAuthenticationProperties springAuthenticationProperties() { 			// In case no shell.auth property is provided fall back to Spring Security 			// based authentication and get role to access shell from SecurityProperties. 			SpringAuthenticationProperties authenticationProperties = new SpringAuthenticationProperties(); 			if (this.management != null) { 				authenticationProperties.setRoles(new String[] { this.management 						.getSecurity().getRole() }); 			} 			return authenticationProperties; 		}
@Override 		public void init() { 			String rolesPropertyValue = getContext().getProperty(ROLES); 			if (rolesPropertyValue != null) { 				this.roles = StringUtils 						.commaDelimitedListToStringArray(rolesPropertyValue); 			} 		}
public String getName() { 			return this.name; 		}
@PostConstruct 		public void init() throws Exception { 			FS commandFileSystem = createFileSystem(this.properties 					.getCommandPathPatterns()); 			FS configurationFileSystem = createFileSystem(this.properties 					.getConfigPathPatterns());  			PluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery( 					this.resourceLoader.getClassLoader(), this.beanFactory, 					this.properties.getDisabledPlugins());  			PluginContext context = new PluginContext(discovery, 					createPluginContextAttributes(), commandFileSystem, 					configurationFileSystem, this.resourceLoader.getClassLoader());  			context.refresh(); 			start(context); 		}
@Override 		public String getName() { 			return "spring"; 		}
public static ManagementServerPort get(ApplicationContext beanFactory) {  			ServerProperties serverProperties; 			try { 				serverProperties = beanFactory.getBean(ServerProperties.class); 			} 			catch (NoSuchBeanDefinitionException ex) { 				serverProperties = new ServerProperties(); 			}  			ManagementServerProperties managementServerProperties; 			try { 				managementServerProperties = beanFactory 						.getBean(ManagementServerProperties.class); 			} 			catch (NoSuchBeanDefinitionException ex) { 				managementServerProperties = new ManagementServerProperties(); 			}  			if (DISABLED_PORT.equals(managementServerProperties.getPort())) { 				return DISABLE; 			} 			if (!(beanFactory instanceof WebApplicationContext)) { 				// Current context is no a a webapp 				return DIFFERENT; 			} 			return managementServerProperties.getPort() == null 					|| serverProperties.getPort() == null 					&& managementServerProperties.getPort().equals(8080) 					|| managementServerProperties.getPort().equals( 							serverProperties.getPort()) ? SAME : DIFFERENT; 		}
@Test 	public void securityDependencies() throws Exception { 		this.cli.run("secure.groovy"); 		assertThat(this.cli.getOutput(), containsString("Hello World")); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return SpringApplication.run( 										SampleActuatorApplication.class, 										"--management.security.enabled=false"); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@Override 							public ConfigurableApplicationContext call() throws Exception { 								return SpringApplication.run( 										SampleActuatorApplication.class, 										"--management.security.enabled=false"); 							}
@Override 	public void initialize(SpringApplication springApplication, String[] args) { 		if (System.getProperty("PID") == null) { 			System.setProperty("PID", getPid()); 		} 		LoggingSystem loggingSystem = LoggingSystem.get(springApplication.getClass() 				.getClassLoader()); 		loggingSystem.beforeInitialize(); 	}
@Override 	public void initialize(ConfigurableApplicationContext applicationContext) {  		ConfigurableEnvironment environment = applicationContext.getEnvironment();  		if (this.parseArgs && this.springBootLogging == null) { 			if (environment.containsProperty("debug")) { 				this.springBootLogging = LogLevel.DEBUG; 			} 			if (environment.containsProperty("trace")) { 				this.springBootLogging = LogLevel.TRACE; 			} 		}  		for (Map.Entry<String, String> mapping : ENVIRONMENT_SYSTEM_PROPERTY_MAPPING 				.entrySet()) { 			if (environment.containsProperty(mapping.getKey())) { 				System.setProperty(mapping.getValue(), 						environment.getProperty(mapping.getKey())); 			} 		}  		LoggingSystem system = LoggingSystem.get(applicationContext.getClassLoader());  		// User specified configuration 		if (environment.containsProperty("logging.config")) { 			String value = environment.getProperty("logging.config"); 			try { 				ResourceUtils.getURL(value).openStream().close(); 				system.initialize(value); 				return; 			} 			catch (Exception ex) { 				// Swallow exception and continue 			} 			this.logger.warn("Logging environment value '" + value 					+ "' cannot be opened and will be ignored"); 		}  		system.initialize(); 		if (this.springBootLogging != null) { 			initializeLogLevel(system, this.springBootLogging); 		} 	}
@Test 	public void parseDebugArg() throws Exception { 		TestUtils.addEnviroment(this.context, "debug"); 		this.initializer.initialize(this.context); 		this.logger.debug("testatdebug"); 		this.logger.trace("testattrace"); 		assertThat(this.outputCapture.toString(), containsString("testatdebug")); 		assertThat(this.outputCapture.toString(), not(containsString("testattrace"))); 	}
@Test 	public void parseTraceArg() throws Exception { 		TestUtils.addEnviroment(this.context, "trace"); 		this.initializer.initialize(this.context); 		this.logger.debug("testatdebug"); 		this.logger.trace("testattrace"); 		assertThat(this.outputCapture.toString(), containsString("testatdebug")); 		assertThat(this.outputCapture.toString(), containsString("testattrace")); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (this.security.getBasic().isEnabled()) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.httpBasic().and().anonymous().disable(); 				ExpressionUrlAuthorizationConfigurer<HttpSecurity> authorizeUrls = http 						.authorizeUrls(); 				if (getEndpointPaths(true).length > 0) { 					authorizeUrls.antMatchers(getEndpointPaths(true)).hasRole( 							this.management.getUser().getRole()); 				} 				authorizeUrls.antMatchers(getSecureApplicationPaths()) 						.hasRole(this.security.getBasic().getRole()).and().httpBasic(); 			}  			// No cookies for service endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			User user = this.management.getUser(); 			if (user.isDefaultPassword()) { 				logger.info("Using default password for "); 			} 			List<String> roles = new ArrayList<String>(); 			roles.add("USER"); 			if (!"USER".equals(user.getRole())) { 				roles.add(user.getRole()); 			} 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()])).and().and().build(); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			User user = this.management.getUser(); 			if (user.isDefaultPassword()) { 				logger.info("Using default password for "); 			} 			List<String> roles = new ArrayList<String>(); 			roles.add("USER"); 			if (!"USER".equals(user.getRole())) { 				roles.add(user.getRole()); 			} 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()])).and().and().build(); 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testOverrideAuthenticationManager() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(TestConfiguration.class, SecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertEquals(this.context.getBean(TestConfiguration.class).authenticationManager, 				this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:" + port, Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:8080", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test(expected = ResourceAccessException.class) 	public void testMetricsNotAvailable() throws Exception { 		testHome(); // makes sure some requests have been made 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:" + managementPort + "/metrics", Map.class); 		assertEquals(HttpStatus.NOT_FOUND, entity.getStatusCode()); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:8080", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testMetrics() throws Exception { 		testHome(); // makes sure some requests have been made 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:8080/metrics", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertTrue("Wrong body: " + body, body.containsKey("counter.status.200.root")); 	}
@Test 	public void testEnv() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:8080/env", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertTrue("Wrong body: " + body, body.containsKey("systemProperties")); 	}
@Test 	public void testErrorPage() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:8080/foo", Map.class); 		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals(500, body.get("status")); 	}
@Test 	public void testBeans() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<List> entity = getRestTemplate("user", getPassword()) 				.getForEntity("http://localhost:8080/beans", List.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertEquals(1, entity.getBody().size()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = (Map<String, Object>) entity.getBody().get(0); 		assertTrue("Wrong body: " + body, 				((String) body.get("context")).startsWith("application")); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()).getForEntity( 				"http://localhost:8080", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testShutdown() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", getPassword()) 				.postForEntity("http://localhost:8080/shutdown", null, Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertTrue("Wrong body: " + body, 				((String) body.get("message")).contains("Shutting down")); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(NonAutoConfigurationSampleTomcatApplication.class); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleTomcatApplication.class); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser("user").password("password").roles("USER").and().and() 					.build(); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Override 		protected void configure(HttpConfiguration http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (this.security.getBasic().isEnabled()) {  				String[] paths = getSecurePaths();  				HttpConfiguration matcher = http.requestMatchers().antMatchers(paths); 				matcher.authenticationEntryPoint(entryPoint()).httpBasic() 						.authenticationEntryPoint(entryPoint()).and().anonymous() 						.disable(); 				matcher.authorizeUrls().anyRequest() 						.hasRole(this.security.getBasic().getRole());  			}  			// No cookies for service endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  		}
@Override 		public void configure(WebSecurityBuilder builder) throws Exception { 			builder.ignoring().antMatchers(this.security.getIgnored()) 					.antMatchers(this.endpoints.getOpenPaths()); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser("user").password("password").roles("USER").and().and() 					.build(); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Bean 		public EmbeddedServletContainerFactory factory() { 			return new EmbeddedServletContainerFactory() {  				@Override 				public EmbeddedServletContainer getEmbdeddedServletContainer( 						ServletContextInitializer... initializers) { 					ServletContext servletContext = new MockServletContext() { 						@Override 						public Dynamic addServlet(String servletName, Servlet servlet) { 							return Mockito.mock(Dynamic.class); 						}  						@Override 						public javax.servlet.FilterRegistration.Dynamic addFilter( 								String filterName, Filter filter) { 							// TODO: remove this when @ConditionalOnBean works 							return Mockito 									.mock(javax.servlet.FilterRegistration.Dynamic.class); 						} 					}; 					for (ServletContextInitializer initializer : initializers) { 						try { 							initializer.onStartup(servletContext); 						} catch (ServletException ex) { 							throw new IllegalStateException(ex); 						} 					} 					return new EmbeddedServletContainer() { 						@Override 						public void stop() throws EmbeddedServletContainerException { 						} 					}; 				} 			}; 		}
@Override 				public EmbeddedServletContainer getEmbdeddedServletContainer( 						ServletContextInitializer... initializers) { 					ServletContext servletContext = new MockServletContext() { 						@Override 						public Dynamic addServlet(String servletName, Servlet servlet) { 							return Mockito.mock(Dynamic.class); 						}  						@Override 						public javax.servlet.FilterRegistration.Dynamic addFilter( 								String filterName, Filter filter) { 							// TODO: remove this when @ConditionalOnBean works 							return Mockito 									.mock(javax.servlet.FilterRegistration.Dynamic.class); 						} 					}; 					for (ServletContextInitializer initializer : initializers) { 						try { 							initializer.onStartup(servletContext); 						} catch (ServletException ex) { 							throw new IllegalStateException(ex); 						} 					} 					return new EmbeddedServletContainer() { 						@Override 						public void stop() throws EmbeddedServletContainerException { 						} 					}; 				}
@Override 	public void applyImports(ImportCustomizer imports) { 		imports.addImports("javax.sql.DataSource", "javax.annotation.PostConstruct", 				"javax.annotation.PreDestroy", "groovy.util.logging.Log", 				"org.springframework.stereotype.Controller", 				"org.springframework.stereotype.Service", 				"org.springframework.stereotype.Component", 				"org.springframework.beans.factory.annotation.Autowired", 				"org.springframework.beans.factory.annotation.Value", 				"org.springframework.context.annotation.Import", 				"org.springframework.context.annotation.ImportResource", 				"org.springframework.context.annotation.Profile", 				"org.springframework.context.annotation.Scope", 				"org.springframework.context.annotation.Configuration", 				"org.springframework.context.annotation.ComponentScan", 				"org.springframework.context.annotation.Bean", 				"org.springframework.context.ApplicationContext", 				"org.springframework.context.MessageSource", 				"org.springframework.core.annotation.Order", 				"org.springframework.core.io.ResourceLoader", 				"org.springframework.bootstrap.CommandLineRunner", 				"org.springframework.bootstrap.context.annotation.EnableAutoConfiguration"); 		imports.addStarImports("org.springframework.stereotype"); 	}
@Test 	public void testMetrics() throws Exception { 		testHome(); // makes sure some requests have been made 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate().getForEntity( 				"http://localhost:" + managementPort + "/metrics", Map.class); 		assertEquals(HttpStatus.UNAUTHORIZED, entity.getStatusCode()); 	}
@Override 	public Object postProcessAfterInitialization(Object bean, String beanName) 			throws BeansException { 		ConfigurationProperties annotation = AnnotationUtils.findAnnotation( 				bean.getClass(), ConfigurationProperties.class); 		Object target = bean; 		if (annotation != null || bean instanceof ConfigurationPropertiesHolder) { 			if (bean instanceof ConfigurationPropertiesHolder) { 				target = ((ConfigurationPropertiesHolder) bean).getTarget(); 			} 			PropertiesConfigurationFactory<Object> factory = new PropertiesConfigurationFactory<Object>( 					target); 			factory.setPropertySources(this.propertySources); 			factory.setValidator(this.validator); 			// If no explicit conversion service is provided we add one so that (at least) 			// comma-separated arrays of convertibles can be bound automatically 			factory.setConversionService(this.conversionService == null ? this.defaultConversionService 					: this.conversionService); 			String targetName = null; 			if (annotation != null) { 				factory.setIgnoreInvalidFields(annotation.ignoreInvalidFields()); 				factory.setIgnoreUnknownFields(annotation.ignoreUnknownFields()); 				targetName = "".equals(annotation.value()) ? ("" 						.equals(annotation.name()) ? null : annotation.name()) 						: annotation.value(); 			} 			factory.setTargetName(targetName); 			try { 				target = factory.getObject(); // throwaway 			} catch (BeansException e) { 				throw e; 			} catch (Exception e) { 				throw new BeanCreationException(beanName, "Could not bind", e); 			} 		} 		return bean; 	}
@Bean 		@AssertMissingBean(TestProperties.class) 		public TestProperties testProperties() { 			TestProperties test = new TestProperties(); 			test.setName("bar"); 			return test; 		}
@ConditionalOnMissingBean(TestProperties.class) 		@Bean(name = "org.springframework.bootstrap.context.annotation.EnableConfigurationPropertiesTests$TestProperties") 		public TestProperties testProperties() { 			return new TestProperties(); 		}
public String getName() { 			return this.name; 		}
public String getName() { 			return this.name; 		}
public String getName() { 			return this.properties.getName(); 		}
public String getName() { 			return this.properties.getName(); 		}
@Test 	public void testManagementConfiguration() throws Exception { 		this.context = new AnnotationConfigApplicationContext(); 		this.context.register(MetricRepositoryConfiguration.class, 				TraceFilterConfiguration.class, ServerPropertiesConfiguration.class, 				ActuatorAutoConfiguration.ServerPropertiesConfiguration.class, 				ManagementAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(HealthEndpoint.class)); 	}
@Test 	public void testChildContextCreated() throws Exception { 		this.context = new AnnotationConfigApplicationContext(); 		TestUtils.addEnviroment(this.context, "server.port:7000", "management.port:7001"); 		this.context.register(ParentContext.class, MetricRepositoryConfiguration.class, 				TraceFilterConfiguration.class, ServerPropertiesConfiguration.class, 				ActuatorAutoConfiguration.ServerPropertiesConfiguration.class, 				ManagementAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class, NewEndpoint.class); 		this.context.refresh(); 		assertEquals(0, this.context.getBeanNamesForType(HealthEndpoint.class).length); 		assertEquals(0, this.context.getBeanNamesForType(NewEndpoint.class).length); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, EndpointsProperties.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testOverrideAuthenticationManager() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(TestConfiguration.class, SecurityAutoConfiguration.class, 				EndpointsProperties.class, PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertEquals(this.context.getBean(TestConfiguration.class).authenticationManager, 				this.context.getBean(AuthenticationManager.class)); 	}
@Override 	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {  		String checking = ConditionLogUtils.getPrefix(logger, metadata);  		String value = (String) metadata.getAnnotationAttributes( 				ConditionalOnExpression.class.getName()).get("value"); 		if (!value.startsWith("#{")) { 			// For convenience allow user to provide bare expression with no #{} wrapper 			value = "#{" + value + "}"; 		} 		if (logger.isDebugEnabled()) { 			StringBuilder builder = new StringBuilder(checking) 					.append("Evaluating expression"); 			if (metadata instanceof ClassMetadata) { 				builder.append(" on " + ((ClassMetadata) metadata).getClassName()); 			} 			builder.append(": " + value); 			logger.debug(builder.toString()); 		} 		// Explicitly allow environment placeholders inside the expression 		value = context.getEnvironment().resolvePlaceholders(value); 		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); 		BeanExpressionResolver resolver = beanFactory.getBeanExpressionResolver(); 		BeanExpressionContext expressionContext = (beanFactory != null) ? new BeanExpressionContext( 				beanFactory, null) : null; 		if (resolver == null) { 			resolver = new StandardBeanExpressionResolver(); 		} 		boolean result = (Boolean) resolver.evaluate(value, expressionContext); 		if (logger.isDebugEnabled()) { 			logger.debug(checking + "Finished matching and result is matches=" + result); 		} 		return result; 	}
static SQLDialect getDialect(DataSource dataSource) { 		try (Connection connection = (dataSource != null) ? dataSource.getConnection() : null) { 			return JDBCUtils.dialect(connection); 		} 		catch (SQLException ex) { 			logger.warn("Unable to determine dialect from datasource", ex); 		} 		return SQLDialect.DEFAULT; 	}
public ConfigurableApplicationContext run(String... args) { 		if (this.registerShutdownHook) { 			SpringApplication.shutdownHook.enableShutdowHookAddition(); 		} 		long startTime = System.nanoTime(); 		DefaultBootstrapContext bootstrapContext = createBootstrapContext(); 		ConfigurableApplicationContext context = null; 		configureHeadlessProperty(); 		SpringApplicationRunListeners listeners = getRunListeners(args); 		listeners.starting(bootstrapContext, this.mainApplicationClass); 		try { 			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); 			ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments); 			Banner printedBanner = printBanner(environment); 			context = createApplicationContext(); 			context.setApplicationStartup(this.applicationStartup); 			prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner); 			refreshContext(context); 			afterRefresh(context, applicationArguments); 			Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime); 			if (this.logStartupInfo) { 				new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup); 			} 			listeners.started(context, timeTakenToStartup); 			callRunners(context, applicationArguments); 		} 		catch (Throwable ex) { 			if (ex instanceof AbandonedRunException) { 				throw ex; 			} 			handleRunFailure(context, ex, listeners); 			throw new IllegalStateException(ex); 		} 		try { 			if (context.isRunning()) { 				Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime); 				listeners.ready(context, timeTakenToReady); 			} 		} 		catch (Throwable ex) { 			if (ex instanceof AbandonedRunException) { 				throw ex; 			} 			handleRunFailure(context, ex, null); 			throw new IllegalStateException(ex); 		} 		return context; 	}
public SpringApplication.Running run(String... args) { 			RunListener runListener = new RunListener(); 			SpringApplicationHook hook = new SingleUseSpringApplicationHook((springApplication) -> { 				springApplication.addPrimarySources(this.sources); 				return runListener; 			}); 			withHook(hook, () -> this.main.accept(args)); 			return runListener; 		}
public ConfigurableApplicationContext run(String... args) { 		if (this.registerShutdownHook) { 			SpringApplication.shutdownHook.enableShutdowHookAddition(); 		} 		long startTime = System.nanoTime(); 		DefaultBootstrapContext bootstrapContext = createBootstrapContext(); 		ConfigurableApplicationContext context = null; 		configureHeadlessProperty(); 		SpringApplicationRunListeners listeners = getRunListeners(args); 		listeners.starting(bootstrapContext, this.mainApplicationClass); 		try { 			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); 			ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments); 			Banner printedBanner = printBanner(environment); 			context = createApplicationContext(); 			context.setApplicationStartup(this.applicationStartup); 			prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner); 			refreshContext(context); 			afterRefresh(context, applicationArguments); 			Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime); 			if (this.logStartupInfo) { 				new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup); 			} 			listeners.started(context, timeTakenToStartup); 			callRunners(context, applicationArguments); 		} 		catch (Throwable ex) { 			if (ex instanceof AbandonedRunException) { 				throw ex; 			} 			handleRunFailure(context, ex, listeners); 			throw new IllegalStateException(ex); 		} 		try { 			if (context.isRunning()) { 				Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime); 				listeners.ready(context, timeTakenToReady); 			} 		} 		catch (Throwable ex) { 			if (ex instanceof AbandonedRunException) { 				throw ex; 			} 			handleRunFailure(context, ex, null); 			throw new IllegalStateException(ex); 		} 		return context; 	}
public ConfigurableApplicationContext getApplicationContext() { 			return this.applicationContext; 		}
@Override 			public ConfigurableApplicationContext getApplicationContext() { 				List<ConfigurableApplicationContext> rootContexts = this.contexts.stream() 					.filter((context) -> context.getParent() == null) 					.toList(); 				Assert.state(!rootContexts.isEmpty(), "No root application context located"); 				Assert.state(rootContexts.size() == 1, "No unique root application context located"); 				return rootContexts.get(0); 			}
private void addRuntimeShutdownHookIfNecessary() { 		if (this.shutdownHookAdditionEnabled && this.shutdownHookAdded.compareAndSet(false, true)) { 			addRuntimeShutdownHook(); 		} 	}
@Override 		public void run() { 			SpringApplicationShutdownHook.this.run(); 			SpringApplicationShutdownHook.this.reset(); 		}
@Override 	public void run() { 		Set<ConfigurableApplicationContext> contexts; 		Set<ConfigurableApplicationContext> closedContexts; 		Set<Runnable> actions; 		synchronized (SpringApplicationShutdownHook.class) { 			this.inProgress = true; 			contexts = new LinkedHashSet<>(this.contexts); 			closedContexts = new LinkedHashSet<>(this.closedContexts); 			actions = new LinkedHashSet<>(this.handlers.getActions()); 		} 		contexts.forEach(this::closeAndWait); 		closedContexts.forEach(this::closeAndWait); 		actions.forEach(Runnable::run); 	}
@Test 	void shutdownHookIsNotAddedUntilContextIsRegistered() { 		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook(); 		shutdownHook.enableShutdowHookAddition(); 		assertThat(shutdownHook.isRuntimeShutdownHookAdded()).isFalse(); 		ConfigurableApplicationContext context = new GenericApplicationContext(); 		shutdownHook.registerApplicationContext(context); 		assertThat(shutdownHook.isRuntimeShutdownHookAdded()).isTrue(); 	}
@Test 	void shutdownHookIsNotAddedUntilHandlerIsRegistered() { 		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook(); 		shutdownHook.enableShutdowHookAddition(); 		assertThat(shutdownHook.isRuntimeShutdownHookAdded()).isFalse(); 		shutdownHook.getHandlers().add(() -> { 		}); 		assertThat(shutdownHook.isRuntimeShutdownHookAdded()).isTrue(); 	}
@Override 		public void afterPropertiesSet() throws Exception { 			throw new IllegalArgumentException("test failure"); 		}
@Override 		public void afterPropertiesSet() throws Exception { 			this.context.close(); 			// Simulate System.exit by running the hook on a separate thread and waiting 			// for it to complete 			Thread thread = new Thread(this.shutdownHook); 			thread.start(); 			thread.join(15000); 			assertThat(thread.isAlive()).isFalse(); 		}
private void handleRunFailure(ConfigurableApplicationContext context, Throwable exception, 			SpringApplicationRunListeners listeners) { 		try { 			try { 				handleExitCode(context, exception); 				if (listeners != null) { 					listeners.failed(context, exception); 				} 			} 			finally { 				reportFailure(getExceptionReporters(context), exception); 				if (context != null) { 					context.close(); 					shutdownHook.deregisterFailedApplicationContext(context); 				} 			} 		} 		catch (Exception ex) { 			logger.warn("Unable to close ApplicationContext", ex); 		} 		ReflectionUtils.rethrowRuntimeException(exception); 	}
@Override 		public void afterPropertiesSet() throws Exception { 			throw new IllegalArgumentException("test failure"); 		}
@Override 			public void run() { 				SpringApplication application = new SpringApplication(FailingConfig.class); 				application.setWebApplicationType(WebApplicationType.NONE); 				application.run(); 			}
@Override 		public void registerShutdownHook() { 			this.applicationContext.registerShutdownHook(); 		}
@Test 	void run() { 		this.context = SpringApplication.run(ExampleWebConfig.class); 		assertThat(this.context).isNotNull(); 	}
@Test 	void registerShutdownHook() { 		SpringApplication application = new SpringApplication(ExampleConfig.class); 		application.setWebApplicationType(WebApplicationType.NONE); 		this.context = application.run(); 		assertThat(SpringApplicationShutdownHookInstance.get()).registeredApplicationContext(this.context); 	}
@Bean 		String someBean() { 			return "override"; 		}
@Bean 		String someBean() { 			return "test"; 		}
@PostConstruct 		void fail() { 			throw new RefreshFailureException(); 		}
@Bean 		CommandLineRunner runner() { 			return (args) -> { 				throw new IllegalStateException(); 			}; 		}
@Bean 		CommandLineRunner runner() { 			return (args) -> { 				throw new IllegalStateException(new ExitStatusException()); 			}; 		}
@Bean 		Object fail() { 			throw new RuntimeException("ExpectedError"); 		}
Integer getExitCode() { 			return this.exitCode; 		}
@Override 		public int getExitCode() { 			return 11; 		}
void addRuntimeShutdownHook() { 		try { 			Runtime.getRuntime().addShutdownHook(new Thread(this, "SpringApplicationShutdownHook")); 		} 		catch (AccessControlException ex) { 			// Not allowed in some environments 		} 	}
void registerApplicationContext(ConfigurableApplicationContext context) { 		addRuntimeShutdownHookIfNecessary(); 		synchronized (SpringApplicationShutdownHook.class) { 			assertNotInProgress(); 			context.addApplicationListener(this.contextCloseListener); 			this.contexts.add(context); 		} 	}
@Override 	public void apply(Project project) { 		Configuration optional = project.getConfigurations().create("optional"); 		optional.setCanBeConsumed(false); 		optional.setCanBeResolved(false); 		project.getPlugins().withType(JavaPlugin.class, (javaPlugin) -> { 			SourceSetContainer sourceSets = project.getConvention().getPlugin(JavaPluginConvention.class) 					.getSourceSets(); 			sourceSets.all((sourceSet) -> { 				project.getConfigurations().getByName(sourceSet.getCompileClasspathConfigurationName()) 						.extendsFrom(optional); 				project.getConfigurations().getByName(sourceSet.getRuntimeClasspathConfigurationName()) 						.extendsFrom(optional); 			}); 		}); 	}
private List<File> pluginClasspath() { 		return Arrays.asList(new File("bin/main"), new File("build/classes/java/main"), 				new File("build/resources/main"), new File(pathOfJarContaining(LaunchScript.class)), 				new File(pathOfJarContaining(ClassVisitor.class)), 				new File(pathOfJarContaining(DependencyManagementPlugin.class)), 				new File(pathOfJarContaining("org.jetbrains.kotlin.cli.common.PropertiesKt")), 				new File(pathOfJarContaining("org.jetbrains.kotlin.compilerRunner.KotlinLogger")), 				new File(pathOfJarContaining(KotlinPlugin.class)), new File(pathOfJarContaining(KotlinProject.class)), 				new File(pathOfJarContaining("org.jetbrains.kotlin.daemon.client.KotlinCompilerClient")), 				new File(pathOfJarContaining(KotlinGradleSubplugin.class)), 				new File(pathOfJarContaining(ArchiveEntry.class)), new File(pathOfJarContaining(BuildRequest.class)), 				new File(pathOfJarContaining(HttpClientConnectionManager.class)), 				new File(pathOfJarContaining(HttpRequest.class)), new File(pathOfJarContaining(Module.class)), 				new File(pathOfJarContaining(Versioned.class)), 				new File(pathOfJarContaining(ParameterNamesModule.class)), 				new File(pathOfJarContaining(JsonView.class)), new File(pathOfJarContaining(Platform.class))); 	}
@TaskAction 	void documentConfigurationProperties() throws IOException { 		Builder builder = DocumentOptions.builder(); 		builder.addSection("core") 				.withKeyPrefixes("debug", "trace", "logging", "spring.aop", "spring.application", 						"spring.autoconfigure", "spring.banner", "spring.beaninfo", "spring.codec", "spring.config", 						"spring.info", "spring.jmx", "spring.lifecycle", "spring.main", "spring.messages", "spring.pid", 						"spring.profiles", "spring.quartz", "spring.reactor", "spring.task", 						"spring.mandatory-file-encoding", "info", "spring.output.ansi.enabled") 				.addSection("mail").withKeyPrefixes("spring.mail", "spring.sendgrid").addSection("cache") 				.withKeyPrefixes("spring.cache").addSection("server").withKeyPrefixes("server").addSection("web") 				.withKeyPrefixes("spring.hateoas", "spring.http", "spring.servlet", "spring.jersey", "spring.mvc", 						"spring.netty", "spring.resources", "spring.session", "spring.web", "spring.webflux") 				.addSection("json").withKeyPrefixes("spring.jackson", "spring.gson").addSection("rsocket") 				.withKeyPrefixes("spring.rsocket").addSection("templating") 				.withKeyPrefixes("spring.freemarker", "spring.groovy", "spring.mustache", "spring.thymeleaf") 				.addOverride("spring.groovy.template.configuration", "See GroovyMarkupConfigurer") 				.addSection("security").withKeyPrefixes("spring.security").addSection("data-migration") 				.withKeyPrefixes("spring.flyway", "spring.liquibase", "spring.sql.init").addSection("data") 				.withKeyPrefixes("spring.couchbase", "spring.elasticsearch", "spring.h2", "spring.influx", 						"spring.ldap", "spring.mongodb", "spring.neo4j", "spring.redis", "spring.dao", "spring.data", 						"spring.datasource", "spring.jooq", "spring.jdbc", "spring.jpa", "spring.r2dbc") 				.addOverride("spring.datasource.oracleucp", 						"Oracle UCP specific settings bound to an instance of Oracle UCP's PoolDataSource") 				.addOverride("spring.datasource.dbcp2", 						"Commons DBCP2 specific settings bound to an instance of DBCP2's BasicDataSource") 				.addOverride("spring.datasource.tomcat", 						"Tomcat datasource specific settings bound to an instance of Tomcat JDBC's DataSource") 				.addOverride("spring.datasource.hikari", 						"Hikari specific settings bound to an instance of Hikari's HikariDataSource") 				.addSection("transaction").withKeyPrefixes("spring.jta", "spring.transaction").addSection("integration") 				.withKeyPrefixes("spring.activemq", "spring.artemis", "spring.batch", "spring.integration", 						"spring.jms", "spring.kafka", "spring.rabbitmq", "spring.hazelcast", "spring.webservices") 				.addSection("actuator").withKeyPrefixes("management").addSection("devtools") 				.withKeyPrefixes("spring.devtools").addSection("testing").withKeyPrefixes("spring.test"); 		DocumentOptions options = builder.build(); 		new ConfigurationMetadataDocumentWriter().writeDocument(this.outputDir.toPath(), options, 				this.configurationPropertyMetadata); 	}
private JarFile createJarFileFromDirectoryEntry(JarEntry entry) throws IOException { 		AsciiBytes name = entry.getAsciiBytesName(); 		JarEntryFilter filter = (candidate) -> { 			if (candidate.startsWith(name) && !candidate.equals(name)) { 				return candidate.substring(name.length()); 			} 			return null; 		}; 		return new JarFile(this.rootFile, this.pathFromRoot + "!/" + entry.getName().substring(0, name.length() - 1), 				this.data, filter, JarFileType.NESTED_DIRECTORY, this.manifestSupplier); 	}
@Override 	public void close() throws IOException { 		if (this.closed) { 			return; 		} 		this.closed = true; 		if (this.type == JarFileType.DIRECT) { 			this.rootFile.close(); 		} 	}
@Override 	public InputStream getInputStream() throws IOException { 		if (this.jarFile == null) { 			throw FILE_NOT_FOUND_EXCEPTION; 		} 		if (this.jarEntryName.isEmpty() && this.jarFile.getType() == JarFile.JarFileType.DIRECT) { 			throw new IOException("no entry name specified"); 		} 		connect(); 		InputStream inputStream = (this.jarEntryName.isEmpty() ? this.jarFile.getInputStream() 				: this.jarFile.getInputStream(this.jarEntry)); 		if (inputStream == null) { 			throwFileNotFound(this.jarEntryName, this.jarFile); 		} 		return inputStream; 	}
@Override 	public long getContentLengthLong() { 		if (this.jarFile == null) { 			return -1; 		} 		try { 			if (this.jarEntryName.isEmpty()) { 				return this.jarFile.size(); 			} 			java.util.jar.JarEntry entry = getJarEntry(); 			return (entry != null) ? (int) entry.getSize() : -1; 		} 		catch (IOException ex) { 			return -1; 		} 	}
String getContentType() { 			if (this.contentType == null) { 				this.contentType = deduceContentType(); 			} 			return this.contentType; 		}
@Override 	public Permission getPermission() throws IOException { 		if (this.jarFile == null) { 			throw FILE_NOT_FOUND_EXCEPTION; 		} 		if (this.permission == null) { 			this.permission = this.jarFile.getPermission(); 		} 		return this.permission; 	}
@Override 	public long getLastModified() { 		if (this.jarFile == null || this.jarEntryName.isEmpty()) { 			return 0; 		} 		try { 			java.util.jar.JarEntry entry = getJarEntry(); 			return (entry != null) ? entry.getTime() : 0; 		} 		catch (IOException ex) { 			return 0; 		} 	}
static JarURLConnection get(URL url, JarFile jarFile) throws IOException { 		StringSequence spec = new StringSequence(url.getFile()); 		int index = indexOfRootSpec(spec, jarFile.getPathFromRoot()); 		if (index == -1) { 			return (Boolean.TRUE.equals(useFastExceptions.get()) ? NOT_FOUND_CONNECTION 					: new JarURLConnection(url, null, EMPTY_JAR_ENTRY_NAME)); 		} 		int separator; 		while ((separator = spec.indexOf(SEPARATOR, index)) > 0) { 			JarEntryName entryName = JarEntryName.get(spec.subSequence(index, separator)); 			JarEntry jarEntry = jarFile.getJarEntry(entryName.toCharSequence()); 			if (jarEntry == null) { 				return JarURLConnection.notFound(jarFile, entryName); 			} 			jarFile = jarFile.getNestedJarFile(jarEntry); 			index = separator + SEPARATOR.length(); 		} 		JarEntryName jarEntryName = JarEntryName.get(spec, index); 		if (Boolean.TRUE.equals(useFastExceptions.get()) && !jarEntryName.isEmpty() 				&& !jarFile.containsEntry(jarEntryName.toString())) { 			return NOT_FOUND_CONNECTION; 		} 		return new JarURLConnection(url, new JarFileWrapper(jarFile), jarEntryName); 	}
@Override 	public String getContentType() { 		return (this.jarEntryName != null) ? this.jarEntryName.getContentType() : null; 	}
@Test 	void whenJarHasAPlusInItsPathConnectionJarFileMatchesOriginalJarFile(@TempDir File tempDir) throws Exception { 		File testJar = new File(tempDir, "t+e+s+t.jar"); 		TestJarCreator.createTestJar(testJar); 		URL url = new URL(null, "jar:" + testJar.toURI().toURL() + "!/nested.jar!/3.dat", this.handler); 		JarURLConnection connection = (JarURLConnection) url.openConnection(); 		JarFile jarFile = JarFileWrapper.unwrap(connection.getJarFile()); 		try { 			assertThat(jarFile.getRootJarFile().getFile()).isEqualTo(testJar); 		} 		finally { 			jarFile.close(); 		} 	}
@Test 	void whenJarHasASpaceInItsPathConnectionJarFileMatchesOriginalJarFile(@TempDir File tempDir) throws Exception { 		File testJar = new File(tempDir, "t e s t.jar"); 		TestJarCreator.createTestJar(testJar); 		URL url = new URL(null, "jar:" + testJar.toURI().toURL() + "!/nested.jar!/3.dat", this.handler); 		JarURLConnection connection = (JarURLConnection) url.openConnection(); 		JarFile jarFile = JarFileWrapper.unwrap(connection.getJarFile()); 		try { 			assertThat(jarFile.getRootJarFile().getFile()).isEqualTo(testJar); 		} 		finally { 			jarFile.close(); 		} 	}
@Test 	void getUrl() throws Exception { 		URL url = this.jarFile.getUrl(); 		assertThat(url.toString()).isEqualTo("jar:" + this.rootJarFile.toURI() + "!/"); 		JarURLConnection jarURLConnection = (JarURLConnection) url.openConnection(); 		assertThat(JarFileWrapper.unwrap(jarURLConnection.getJarFile())).isSameAs(this.jarFile); 		assertThat(jarURLConnection.getJarEntry()).isNull(); 		assertThat(jarURLConnection.getContentLength()).isGreaterThan(1); 		assertThat(JarFileWrapper.unwrap((java.util.jar.JarFile) jarURLConnection.getContent())).isSameAs(this.jarFile); 		assertThat(jarURLConnection.getContentType()).isEqualTo("x-java/jar"); 		assertThat(jarURLConnection.getJarFileURL().toURI()).isEqualTo(this.rootJarFile.toURI()); 	}
@Test 	void createEntryUrl() throws Exception { 		URL url = new URL(this.jarFile.getUrl(), "1.dat"); 		assertThat(url.toString()).isEqualTo("jar:" + this.rootJarFile.toURI() + "!/1.dat"); 		JarURLConnection jarURLConnection = (JarURLConnection) url.openConnection(); 		assertThat(JarFileWrapper.unwrap(jarURLConnection.getJarFile())).isSameAs(this.jarFile); 		assertThat(jarURLConnection.getJarEntry()).isSameAs(this.jarFile.getJarEntry("1.dat")); 		assertThat(jarURLConnection.getContentLength()).isEqualTo(1); 		assertThat(jarURLConnection.getContent()).isInstanceOf(InputStream.class); 		assertThat(jarURLConnection.getContentType()).isEqualTo("content/unknown"); 		assertThat(jarURLConnection.getPermission()).isInstanceOf(FilePermission.class); 		FilePermission permission = (FilePermission) jarURLConnection.getPermission(); 		assertThat(permission.getActions()).isEqualTo("read"); 		assertThat(permission.getName()).isEqualTo(this.rootJarFile.getPath()); 	}
@Test 	void getNestedJarFile() throws Exception { 		try (JarFile nestedJarFile = this.jarFile.getNestedJarFile(this.jarFile.getEntry("nested.jar"))) { 			assertThat(nestedJarFile.getComment()).isEqualTo("nested"); 			Enumeration<java.util.jar.JarEntry> entries = nestedJarFile.entries(); 			assertThat(entries.nextElement().getName()).isEqualTo("META-INF/"); 			assertThat(entries.nextElement().getName()).isEqualTo("META-INF/MANIFEST.MF"); 			assertThat(entries.nextElement().getName()).isEqualTo("3.dat"); 			assertThat(entries.nextElement().getName()).isEqualTo("4.dat"); 			assertThat(entries.nextElement().getName()).isEqualTo("\u00E4.dat"); 			assertThat(entries.hasMoreElements()).isFalse();  			InputStream inputStream = nestedJarFile.getInputStream(nestedJarFile.getEntry("3.dat")); 			assertThat(inputStream.read()).isEqualTo(3); 			assertThat(inputStream.read()).isEqualTo(-1);  			URL url = nestedJarFile.getUrl(); 			assertThat(url.toString()).isEqualTo("jar:" + this.rootJarFile.toURI() + "!/nested.jar!/"); 			JarURLConnection conn = (JarURLConnection) url.openConnection(); 			assertThat(JarFileWrapper.unwrap(conn.getJarFile())).isSameAs(nestedJarFile); 			assertThat(conn.getJarFileURL().toString()).isEqualTo("jar:" + this.rootJarFile.toURI() + "!/nested.jar"); 			assertThat(conn.getInputStream()).isNotNull(); 			JarInputStream jarInputStream = new JarInputStream(conn.getInputStream()); 			assertThat(jarInputStream.getNextJarEntry().getName()).isEqualTo("3.dat"); 			assertThat(jarInputStream.getNextJarEntry().getName()).isEqualTo("4.dat"); 			assertThat(jarInputStream.getNextJarEntry().getName()).isEqualTo("\u00E4.dat"); 			jarInputStream.close(); 			assertThat(conn.getPermission()).isInstanceOf(FilePermission.class); 			FilePermission permission = (FilePermission) conn.getPermission(); 			assertThat(permission.getActions()).isEqualTo("read"); 			assertThat(permission.getName()).isEqualTo(this.rootJarFile.getPath()); 		} 	}
@Test 	void getNestedJarDirectory() throws Exception { 		try (JarFile nestedJarFile = this.jarFile.getNestedJarFile(this.jarFile.getEntry("d/"))) { 			Enumeration<java.util.jar.JarEntry> entries = nestedJarFile.entries(); 			assertThat(entries.nextElement().getName()).isEqualTo("9.dat"); 			assertThat(entries.hasMoreElements()).isFalse();  			try (InputStream inputStream = nestedJarFile.getInputStream(nestedJarFile.getEntry("9.dat"))) { 				assertThat(inputStream.read()).isEqualTo(9); 				assertThat(inputStream.read()).isEqualTo(-1); 			}  			URL url = nestedJarFile.getUrl(); 			assertThat(url.toString()).isEqualTo("jar:" + this.rootJarFile.toURI() + "!/d!/"); 			JarURLConnection connection = (JarURLConnection) url.openConnection(); 			assertThat(JarFileWrapper.unwrap(connection.getJarFile())).isSameAs(nestedJarFile); 		} 	}
@Test 	void connectionToRootUsingAbsoluteUrl() throws Exception { 		URL url = new URL("jar:" + this.rootJarFile.toURI().toURL() + "!/"); 		Object content = JarURLConnection.get(url, this.jarFile).getContent(); 		assertThat(JarFileWrapper.unwrap((java.util.jar.JarFile) content)).isSameAs(this.jarFile); 	}
@Test 	void connectionToRootUsingRelativeUrl() throws Exception { 		URL url = new URL("jar:file:" + getRelativePath() + "!/"); 		Object content = JarURLConnection.get(url, this.jarFile).getContent(); 		assertThat(JarFileWrapper.unwrap((java.util.jar.JarFile) content)).isSameAs(this.jarFile); 	}
@Test 	void openConnectionCanBeClosedWithoutClosingSourceJar() throws Exception { 		URL url = new URL("jar:" + this.rootJarFile.toURI().toURL() + "!/"); 		JarURLConnection connection = JarURLConnection.get(url, this.jarFile); 		java.util.jar.JarFile connectionJarFile = connection.getJarFile(); 		connectionJarFile.close(); 		assertThat(this.jarFile.isClosed()).isFalse(); 	}
@Override 		public ResourcePatternResolver getResourcePatternResolver(AbstractApplicationContext applicationContext, 				ResourceLoader resourceLoader) { 			if (applicationContext instanceof WebApplicationContext) { 				return getServletContextResourcePatternResolver(applicationContext, resourceLoader); 			} 			return super.getResourcePatternResolver(applicationContext, resourceLoader); 		}
ResourcePatternResolver getResourcePatternResolver(AbstractApplicationContext applicationContext, 				ResourceLoader resourceLoader) { 			ResourceLoader targetResourceLoader = (resourceLoader != null) ? resourceLoader 					: new ApplicationContextResourceLoader(applicationContext::getProtocolResolvers); 			return new PathMatchingResourcePatternResolver(targetResourceLoader); 		}
@Override 		public int getOrder() { 			return Ordered.HIGHEST_PRECEDENCE; 		}
@Override 	public int getOrder() { 		return this.order; 	}
@Override 		public boolean equals(Object obj) { 			if (this == obj) { 				return true; 			} 			if (obj == null || getClass() != obj.getClass()) { 				return false; 			} 			DocumentsCacheKey other = (DocumentsCacheKey) obj; 			return this.loader.equals(other.loader) && this.resource.equals(other.resource); 		}
@Override 		public int hashCode() { 			return this.loader.hashCode() * 31 + this.resource.hashCode(); 		}
@Override 		public String toString() { 			return this.propertySource.toString(); 		}
@Override 		public boolean equals(Object obj) { 			if (obj == this) { 				return true; 			} 			if (obj == null || obj.getClass() != getClass()) { 				return false; 			} 			return ((Profile) obj).name.equals(this.name); 		}
@Override 		public int hashCode() { 			return this.name.hashCode(); 		}
@Override 		public String toString() { 			return this.name; 		}
@RequestMapping("${server.error.path:${error.path:/error}}") 	@ResponseBody 	public Map<String, Object> invoke(ServletWebRequest request) { 		return this.errorAttributes.getErrorAttributes(request, false, false); 	}
@Test // gh-17938 	void errorPageAndErrorControllerAreUsed() { 		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new) 				.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class, 						ServletWebServerFactoryAutoConfiguration.class, ServletManagementContextAutoConfiguration.class, 						WebEndpointAutoConfiguration.class, EndpointAutoConfiguration.class, 						DispatcherServletAutoConfiguration.class, ErrorMvcAutoConfiguration.class)) 				.withUserConfiguration(FailingEndpoint.class) 				.withInitializer(new ServerPortInfoApplicationContextInitializer()).withPropertyValues("server.port=0", 						"management.server.port=0", "management.endpoints.web.exposure.include=*") 				.run((context) -> { 					String port = context.getEnvironment().getProperty("local.management.port"); 					WebClient client = WebClient.create("http://localhost:" + port); 					ClientResponse response = client.get().uri("actuator/fail").accept(MediaType.APPLICATION_JSON) 							.exchange().block(); 					assertThat(response.bodyToMono(String.class).block()) 							.contains("message\":\"An error occurred while processing the request"); 				}); 	}
private void load(Consumer<T> contextCustomizer, String endpointPath, 			BiConsumer<ApplicationContext, WebTestClient> consumer) { 		T applicationContext = this.applicationContextSupplier.get(); 		contextCustomizer.accept(applicationContext); 		Map<String, Object> properties = new HashMap<>(); 		properties.put("endpointPath", endpointPath); 		properties.put("server.error.include-details", "always"); 		applicationContext.getEnvironment().getPropertySources().addLast(new MapPropertySource("test", properties)); 		applicationContext.refresh(); 		try { 			InetSocketAddress address = new InetSocketAddress(getPort(applicationContext)); 			String url = "http://" + address.getHostString() + ":" + address.getPort() + endpointPath; 			consumer.accept(applicationContext, 					WebTestClient.bindToServer().baseUrl(url).responseTimeout(TIMEOUT).build()); 		} 		finally { 			applicationContext.close(); 		} 	}
@Bean 		MonoResponseEndpoint testEndpoint(EndpointDelegate endpointDelegate) { 			return new MonoResponseEndpoint(); 		}
@Bean 		QueryWithListEndpoint queryEndpoint() { 			return new QueryWithListEndpoint(); 		}
@Bean 		QueryEndpoint queryEndpoint() { 			return new QueryEndpoint(); 		}
@Bean 		ResourceWebEndpointResponseEndpoint resourceEndpoint() { 			return new ResourceWebEndpointResponseEndpoint(); 		}
@Bean 		public ResourceEndpoint resourceEndpoint() { 			return new ResourceEndpoint(); 		}
@Bean 		public TestEndpoint testEndpoint(EndpointDelegate endpointDelegate) { 			return new TestEndpoint(endpointDelegate); 		}
@WriteOperation 		Object write() { 			this.delegate.write(); 			return null; 		}
@WriteOperation 		void write() { 			this.delegate.write(); 		}
@ReadOperation 		WebEndpointResponse<Resource> read() { 			return new WebEndpointResponse<>(new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }), 200); 		}
@ReadOperation(produces = "text/plain") 		String read() { 			return "read"; 		}
@ReadOperation 		Resource read() { 			return new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }); 		}
@ReadOperation(produces = "text/plain") 		String read() { 			return "read"; 		}
@ReadOperation 		Resource read() { 			return new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }); 		}
@ReadOperation 		WebEndpointResponse<Resource> read() { 			return new WebEndpointResponse<>(new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }), 200); 		}
@Deprecated 	protected Map<String, Object> getErrorAttributes(ServerRequest request, boolean includeStackTrace) { 		return this.errorAttributes.getErrorAttributes(request, includeStackTrace, false); 	}
protected boolean isTraceEnabled(ServerRequest request) { 		return getBooleanParameter(request, "trace"); 	}
protected Mono<ServerResponse> renderErrorView(ServerRequest request) { 		boolean includeStackTrace = isIncludeStackTrace(request, MediaType.TEXT_HTML); 		boolean includeDetails = isIncludeDetails(request, MediaType.TEXT_HTML); 		Map<String, Object> error = getErrorAttributes(request, includeStackTrace, includeDetails); 		int errorStatus = getHttpStatus(error); 		ServerResponse.BodyBuilder responseBody = ServerResponse.status(errorStatus).contentType(TEXT_HTML_UTF8); 		return Flux.just(getData(errorStatus).toArray(new String[] {})) 				.flatMap((viewName) -> renderErrorView(viewName, responseBody, error)) 				.switchIfEmpty(this.errorProperties.getWhitelabel().isEnabled() 						? renderDefaultErrorView(responseBody, error) : Mono.error(getError(request))) 				.next(); 	}
protected Mono<ServerResponse> renderErrorResponse(ServerRequest request) { 		boolean includeStackTrace = isIncludeStackTrace(request, MediaType.ALL); 		boolean includeDetails = isIncludeDetails(request, MediaType.ALL); 		Map<String, Object> error = getErrorAttributes(request, includeStackTrace, includeDetails); 		return ServerResponse.status(getHttpStatus(error)).contentType(MediaType.APPLICATION_JSON) 				.body(BodyInserters.fromValue(error)); 	}
@Deprecated 	protected Map<String, Object> getErrorAttributes(HttpServletRequest request, boolean includeStackTrace) { 		return this.getErrorAttributes(request, includeStackTrace, false); 	}
protected boolean getTraceParameter(HttpServletRequest request) { 		return getBooleanParameter(request, "trace"); 	}
@RequestMapping(produces = MediaType.TEXT_HTML_VALUE) 	public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { 		HttpStatus status = getStatus(request); 		Map<String, Object> model = Collections.unmodifiableMap(getErrorAttributes(request, 				isIncludeStackTrace(request, MediaType.TEXT_HTML), isIncludeDetails(request, MediaType.TEXT_HTML))); 		response.setStatus(status.value()); 		ModelAndView modelAndView = resolveErrorView(request, response, status, model); 		return (modelAndView != null) ? modelAndView : new ModelAndView("error", model); 	}
@RequestMapping 	public ResponseEntity<Map<String, Object>> error(HttpServletRequest request) { 		HttpStatus status = getStatus(request); 		if (status == HttpStatus.NO_CONTENT) { 			return new ResponseEntity<>(status); 		} 		Map<String, Object> body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL), 				isIncludeDetails(request, MediaType.ALL)); 		return new ResponseEntity<>(body, status); 	}
@Test 	void jsonError(CapturedOutput output) { 		this.contextRunner.run((context) -> { 			WebTestClient client = getWebClient(context); 			client.get().uri("/").exchange().expectStatus().isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR).expectBody() 					.jsonPath("status").isEqualTo("500").jsonPath("error") 					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase()).jsonPath("path").isEqualTo(("/")) 					.jsonPath("message").isEmpty().jsonPath("exception").doesNotExist().jsonPath("trace").doesNotExist() 					.jsonPath("requestId").isEqualTo(this.logIdFilter.getLogId()); 			assertThat(output).contains("500 Server Error for HTTP GET \"/\"") 					.contains("java.lang.IllegalStateException: Expected!"); 		}); 	}
@Test 	void htmlError() { 		this.contextRunner.withPropertyValues("server.error.include-details=always").run((context) -> { 			WebTestClient client = getWebClient(context); 			String body = client.get().uri("/").accept(MediaType.TEXT_HTML).exchange().expectStatus() 					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR).expectHeader().contentType(TEXT_HTML_UTF8) 					.expectBody(String.class).returnResult().getResponseBody(); 			assertThat(body).contains("status: 500").contains("message: Expected!"); 		}); 	}
@Test 	void bindingResultError() { 		this.contextRunner.run((context) -> { 			WebTestClient client = getWebClient(context); 			client.post().uri("/bind").contentType(MediaType.APPLICATION_JSON).bodyValue("{}").exchange().expectStatus() 					.isBadRequest().expectBody().jsonPath("status").isEqualTo("400").jsonPath("error") 					.isEqualTo(HttpStatus.BAD_REQUEST.getReasonPhrase()).jsonPath("path").isEqualTo(("/bind")) 					.jsonPath("exception").doesNotExist().jsonPath("errors").doesNotExist().jsonPath("message") 					.isNotEmpty().jsonPath("requestId").isEqualTo(this.logIdFilter.getLogId()); 		}); 	}
@Test 	void defaultErrorView() { 		this.contextRunner 				.withPropertyValues("spring.mustache.prefix=classpath:/unknown/", 						"server.error.include-stacktrace=always", "server.error.include-details=always") 				.run((context) -> { 					WebTestClient client = getWebClient(context); 					String body = client.get().uri("/").accept(MediaType.TEXT_HTML).exchange().expectStatus() 							.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR).expectHeader().contentType(TEXT_HTML_UTF8) 							.expectBody(String.class).returnResult().getResponseBody(); 					assertThat(body).contains("Whitelabel Error Page").contains(this.logIdFilter.getLogId()) 							.contains("<div>Expected!</div>") 							.contains("<div style='white-space:pre-wrap;'>java.lang.IllegalStateException"); 				}); 	}
@Test 	void escapeHtmlInDefaultErrorView() { 		this.contextRunner 				.withPropertyValues("spring.mustache.prefix=classpath:/unknown/", "server.error.include-details=always") 				.run((context) -> { 					WebTestClient client = getWebClient(context); 					String body = client.get().uri("/html").accept(MediaType.TEXT_HTML).exchange().expectStatus() 							.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR).expectHeader().contentType(TEXT_HTML_UTF8) 							.expectBody(String.class).returnResult().getResponseBody(); 					assertThat(body).contains("Whitelabel Error Page").contains(this.logIdFilter.getLogId()) 							.doesNotContain("<script>").contains("&lt;script&gt;"); 				}); 	}
@Test 	void nonStandardErrorStatusCodeShouldNotFail() { 		ErrorAttributes errorAttributes = mock(ErrorAttributes.class); 		ResourceProperties resourceProperties = new ResourceProperties(); 		ErrorProperties errorProperties = new ErrorProperties(); 		ApplicationContext context = new AnnotationConfigReactiveWebApplicationContext(); 		given(errorAttributes.getErrorAttributes(any(), anyBoolean(), anyBoolean())).willReturn(getErrorAttributes()); 		DefaultErrorWebExceptionHandler exceptionHandler = new DefaultErrorWebExceptionHandler(errorAttributes, 				resourceProperties, errorProperties, context); 		setupViewResolver(exceptionHandler); 		ServerWebExchange exchange = MockServerWebExchange 				.from(MockServerHttpRequest.get("/some-other-path").accept(MediaType.TEXT_HTML)); 		exceptionHandler.handle(exchange, new RuntimeException()).block(); 	}
@Test 	@SuppressWarnings("rawtypes") 	void testRequestBodyValidationForMachineClient() { 		load("--server.error.include-exception=true"); 		RequestEntity request = RequestEntity.post(URI.create(createUrl("/bodyValidation"))) 				.accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON).body("{}"); 		ResponseEntity<Map> entity = new TestRestTemplate().exchange(request, Map.class); 		assertErrorAttributes(entity.getBody(), "400", "Bad Request", MethodArgumentNotValidException.class, 				"Validation failed", "/bodyValidation"); 		assertThat(entity.getBody().containsKey("errors")).isFalse(); 	}
private void assertErrorAttributes(Map<?, ?> content, String status, String error, Class<?> exception, 			String message, String path) { 		assertThat(content.get("status").toString()).as("Wrong status").isEqualTo(status); 		assertThat(content.get("error")).as("Wrong error").isEqualTo(error); 		if (exception != null) { 			assertThat(content.get("exception")).as("Wrong exception").isEqualTo(exception.getName()); 		} 		else { 			assertThat(content.containsKey("exception")).as("Exception attribute should not be set").isFalse(); 		} 		assertThat(content.get("message")).as("Wrong message").isEqualTo(message); 		assertThat(content.get("path")).as("Wrong path").isEqualTo(path); 	}
@Test 	void testBindingExceptionForMachineClient() throws Exception { 		// In a real server the response is carried over into the error dispatcher, but 		// in the mock a new one is created so we have to assert the status at this 		// intermediate point 		MvcResult result = this.mockMvc.perform(get("/bind")).andExpect(status().is4xxClientError()).andReturn(); 		MvcResult response = this.mockMvc.perform(new ErrorDispatcher(result, "/error")).andReturn(); 		// And the rendered status code is always wrong (but would be 400 in a real 		// system) 		String content = response.getResponse().getContentAsString(); 		assertThat(content).contains("Validation failed"); 	}
@Test 	void renderContainsViewWithExceptionDetails() { 		this.contextRunner.run((context) -> { 			View errorView = context.getBean("error", View.class); 			ErrorAttributes errorAttributes = context.getBean(ErrorAttributes.class); 			DispatcherServletWebRequest webRequest = createWebRequest(new IllegalStateException("Exception message"), 					false); 			errorView.render(errorAttributes.getErrorAttributes(webRequest, true, true), webRequest.getRequest(), 					webRequest.getResponse()); 			assertThat(webRequest.getResponse().getContentType()).isEqualTo("text/html;charset=UTF-8"); 			String responseString = ((MockHttpServletResponse) webRequest.getResponse()).getContentAsString(); 			assertThat(responseString).contains( 					"<p>This application has no explicit mapping for /error, so you are seeing this as a fallback.</p>") 					.contains("<div>Exception message</div>") 					.contains("<div style='white-space:pre-wrap;'>java.lang.IllegalStateException"); 		}); 	}
@Test 	void renderWhenAlreadyCommittedLogsMessage(CapturedOutput output) { 		this.contextRunner.run((context) -> { 			View errorView = context.getBean("error", View.class); 			ErrorAttributes errorAttributes = context.getBean(ErrorAttributes.class); 			DispatcherServletWebRequest webRequest = createWebRequest(new IllegalStateException("Exception message"), 					true); 			errorView.render(errorAttributes.getErrorAttributes(webRequest, true, true), webRequest.getRequest(), 					webRequest.getResponse()); 			assertThat(output).contains("Cannot render error page for request [/path] " 					+ "and exception [Exception message] as the response has " 					+ "already been committed. As a result, the response may have the wrong status code."); 		}); 	}
@Test 	void postProcessEnablesIncludeStackTraceProperty() throws Exception { 		SpringApplication application = new SpringApplication(TestConfiguration.class); 		application.setWebApplicationType(WebApplicationType.NONE); 		this.context = getContext(application::run); 		ConfigurableEnvironment environment = this.context.getEnvironment(); 		String includeStackTrace = environment.getProperty("server.error.include-stacktrace"); 		assertThat(includeStackTrace).isEqualTo(ErrorProperties.IncludeStacktrace.ALWAYS.toString()); 		String includeDetails = environment.getProperty("server.error.include-details"); 		assertThat(includeDetails).isEqualTo(ErrorProperties.IncludeDetails.ALWAYS.toString()); 	}
@Override 	@Deprecated 	public Map<String, Object> getErrorAttributes(ServerRequest request, boolean includeStackTrace) { 		return this.getErrorAttributes(request, includeStackTrace, false); 	}
@Override 	@Deprecated 	public Map<String, Object> getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) { 		return this.getErrorAttributes(webRequest, includeStackTrace, false); 	}
@Test 	void missingExceptionAttribute() { 		MockServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get("/test").build()); 		ServerRequest request = ServerRequest.create(exchange, this.readers); 		assertThatIllegalStateException() 				.isThrownBy(() -> this.errorAttributes.getErrorAttributes(request, false, false)) 				.withMessageContaining("Missing exception attribute in ServerWebExchange"); 	}
@Test 	void includeTimeStamp() { 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, NOT_FOUND), 				false, false); 		assertThat(attributes.get("timestamp")).isInstanceOf(Date.class); 	}
@Test 	void defaultStatusCode() { 		Error error = new OutOfMemoryError("Test error"); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), 				false, false); 		assertThat(attributes.get("error")).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase()); 		assertThat(attributes.get("status")).isEqualTo(500); 	}
@Test 	void annotatedResponseStatusCode() { 		Exception error = new CustomException(); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), 				false, false); 		assertThat(attributes.get("error")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase()); 		assertThat(attributes.get("message")).isEqualTo(""); 		assertThat(attributes.get("status")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.value()); 	}
@Test 	void annotatedResponseStatusCodeWithExceptionMessage() { 		Exception error = new CustomException("Test Message"); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), 				false, true); 		assertThat(attributes.get("error")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase()); 		assertThat(attributes.get("message")).isEqualTo("Test Message"); 		assertThat(attributes.get("status")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.value()); 	}
@Test 	void annotatedResponseStatusCodeWithCustomReasonPhrase() { 		Exception error = new Custom2Exception(); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), 				false, true); 		assertThat(attributes.get("error")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase()); 		assertThat(attributes.get("status")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.value()); 		assertThat(attributes.get("message")).isEqualTo("Nope!"); 	}
@Test 	void includeStatusCode() { 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, NOT_FOUND), 				false, false); 		assertThat(attributes.get("error")).isEqualTo(HttpStatus.NOT_FOUND.getReasonPhrase()); 		assertThat(attributes.get("status")).isEqualTo(404); 	}
@Test 	void getError() { 		Error error = new OutOfMemoryError("Test error"); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		ServerRequest serverRequest = buildServerRequest(request, error); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false, true); 		assertThat(this.errorAttributes.getError(serverRequest)).isSameAs(error); 		assertThat(attributes.get("exception")).isNull(); 		assertThat(attributes.get("message")).isEqualTo("Test error"); 	}
@Test 	void includeException() { 		RuntimeException error = new RuntimeException("Test"); 		this.errorAttributes = new DefaultErrorAttributes(true); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		ServerRequest serverRequest = buildServerRequest(request, error); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false, true); 		assertThat(this.errorAttributes.getError(serverRequest)).isSameAs(error); 		assertThat(attributes.get("exception")).isEqualTo(RuntimeException.class.getName()); 		assertThat(attributes.get("message")).isEqualTo("Test"); 	}
@Test 	void processResponseStatusException() { 		RuntimeException nested = new RuntimeException("Test"); 		ResponseStatusException error = new ResponseStatusException(HttpStatus.BAD_REQUEST, "invalid request", nested); 		this.errorAttributes = new DefaultErrorAttributes(true); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		ServerRequest serverRequest = buildServerRequest(request, error); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false, true); 		assertThat(attributes.get("status")).isEqualTo(400); 		assertThat(attributes.get("message")).isEqualTo("invalid request"); 		assertThat(attributes.get("exception")).isEqualTo(RuntimeException.class.getName()); 		assertThat(this.errorAttributes.getError(serverRequest)).isSameAs(error); 	}
@Test 	void processResponseStatusExceptionWithNoNestedCause() { 		ResponseStatusException error = new ResponseStatusException(HttpStatus.NOT_ACCEPTABLE, 				"could not process request"); 		this.errorAttributes = new DefaultErrorAttributes(true); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		ServerRequest serverRequest = buildServerRequest(request, error); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false, true); 		assertThat(attributes.get("status")).isEqualTo(406); 		assertThat(attributes.get("message")).isEqualTo("could not process request"); 		assertThat(attributes.get("exception")).isEqualTo(ResponseStatusException.class.getName()); 		assertThat(this.errorAttributes.getError(serverRequest)).isSameAs(error); 	}
@Test 	void notIncludeTrace() { 		RuntimeException ex = new RuntimeException("Test"); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, ex), false, 				false); 		assertThat(attributes.get("trace")).isNull(); 	}
@Test 	void includeTrace() { 		RuntimeException ex = new RuntimeException("Test"); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, ex), true, 				false); 		assertThat(attributes.get("trace").toString()).startsWith("java.lang"); 	}
@Test 	void includePath() { 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, NOT_FOUND), 				false, false); 		assertThat(attributes.get("path")).isEqualTo("/test"); 	}
@Test 	void includeLogPrefix() { 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		ServerRequest serverRequest = buildServerRequest(request, NOT_FOUND); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false, false); 		assertThat(attributes.get("requestId")).isEqualTo(serverRequest.exchange().getRequest().getId()); 	}
@Test 	void extractBindingResultErrors() throws Exception { 		Method method = getClass().getDeclaredMethod("method", String.class); 		MethodParameter stringParam = new MethodParameter(method, 0); 		BindingResult bindingResult = new MapBindingResult(Collections.singletonMap("a", "b"), "objectName"); 		bindingResult.addError(new ObjectError("c", "d")); 		Exception ex = new WebExchangeBindException(stringParam, bindingResult); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, ex), false, 				true); 		assertThat(attributes.get("message")).asString() 				.startsWith("Validation failed for argument at index 0 in method: " 						+ "int org.springframework.boot.web.reactive.error.DefaultErrorAttributesTests" 						+ ".method(java.lang.String), with 1 error(s)"); 		assertThat(attributes.get("errors")).isEqualTo(bindingResult.getAllErrors()); 	}
@Test 	void includeTimeStamp() { 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest, false, false); 		assertThat(attributes.get("timestamp")).isInstanceOf(Date.class); 	}
@Test 	void specificStatusCode() { 		this.request.setAttribute("javax.servlet.error.status_code", 404); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest, false, false); 		assertThat(attributes.get("error")).isEqualTo(HttpStatus.NOT_FOUND.getReasonPhrase()); 		assertThat(attributes.get("status")).isEqualTo(404); 	}
@Test 	void missingStatusCode() { 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest, false, false); 		assertThat(attributes.get("error")).isEqualTo("None"); 		assertThat(attributes.get("status")).isEqualTo(999); 	}
@Test 	void mvcError() { 		RuntimeException ex = new RuntimeException("Test"); 		ModelAndView modelAndView = this.errorAttributes.resolveException(this.request, null, null, ex); 		this.request.setAttribute("javax.servlet.error.exception", new RuntimeException("Ignored")); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest, false, true); 		assertThat(this.errorAttributes.getError(this.webRequest)).isSameAs(ex); 		assertThat(modelAndView).isNull(); 		assertThat(attributes.containsKey("exception")).isFalse(); 		assertThat(attributes.get("message")).isEqualTo("Test"); 	}
@Test 	void unwrapServletException() { 		RuntimeException ex = new RuntimeException("Test"); 		ServletException wrapped = new ServletException(new ServletException(ex)); 		this.request.setAttribute("javax.servlet.error.exception", wrapped); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest, false, true); 		assertThat(this.errorAttributes.getError(this.webRequest)).isSameAs(wrapped); 		assertThat(attributes.containsKey("exception")).isFalse(); 		assertThat(attributes.get("message")).isEqualTo("Test"); 	}
@Test 	void getError() { 		Error error = new OutOfMemoryError("Test error"); 		this.request.setAttribute("javax.servlet.error.exception", error); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest, false, true); 		assertThat(this.errorAttributes.getError(this.webRequest)).isSameAs(error); 		assertThat(attributes.containsKey("exception")).isFalse(); 		assertThat(attributes.get("message")).isEqualTo("Test error"); 	}
@Test 	void withExceptionAttribute() { 		DefaultErrorAttributes errorAttributes = new DefaultErrorAttributes(true); 		RuntimeException ex = new RuntimeException("Test"); 		this.request.setAttribute("javax.servlet.error.exception", ex); 		Map<String, Object> attributes = errorAttributes.getErrorAttributes(this.webRequest, false, true); 		assertThat(attributes.get("exception")).isEqualTo(RuntimeException.class.getName()); 		assertThat(attributes.get("message")).isEqualTo("Test"); 	}
@Test 	void path() { 		this.request.setAttribute("javax.servlet.error.request_uri", "path"); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest, false, false); 		assertThat(attributes.get("path")).isEqualTo("path"); 	}
@Test 	public void jarFileEntryWithEpochTimeOfZeroShouldNotFail() throws Exception { 		File file = this.temporaryFolder.newFile(); 		FileOutputStream fileOutputStream = new FileOutputStream(file); 		try (JarOutputStream jarOutputStream = new JarOutputStream(fileOutputStream)) { 			jarOutputStream.setComment("outer"); 			JarEntry entry = new JarEntry("1.dat"); 			entry.setLastModifiedTime(FileTime.from(Instant.EPOCH)); 			ReflectionTestUtils.setField(entry, "xdostime", 0); 			jarOutputStream.putNextEntry(entry); 			jarOutputStream.write(new byte[] { (byte) 1 }); 			jarOutputStream.closeEntry(); 		} 		try (JarFile jar = new JarFile(file)) { 			Enumeration<java.util.jar.JarEntry> entries = jar.entries(); 			JarEntry entry = entries.nextElement(); 			assertThat(entry.getLastModifiedTime().toInstant()).isEqualTo(Instant.EPOCH); 			assertThat(entry.getName()).isEqualTo("1.dat"); 		} 	}
@Test 	void nestedZip64ArchivesAreHandledGracefully() throws Exception { 		File file = new File(this.tempDir, "test.jar"); 		try (JarOutputStream output = new JarOutputStream(new FileOutputStream(file))) { 			JarEntry zip64JarEntry = new JarEntry("nested/zip64.jar"); 			output.putNextEntry(zip64JarEntry); 			byte[] zip64JarData = writeZip64Jar(); 			zip64JarEntry.setSize(zip64JarData.length); 			zip64JarEntry.setCompressedSize(zip64JarData.length); 			zip64JarEntry.setMethod(ZipEntry.STORED); 			CRC32 crc32 = new CRC32(); 			crc32.update(zip64JarData); 			zip64JarEntry.setCrc(crc32.getValue()); 			output.write(zip64JarData); 			output.closeEntry(); 		} 		try (JarFile jarFile = new JarFile(file)) { 			ZipEntry nestedEntry = jarFile.getEntry("nested/zip64.jar"); 			try (JarFile nestedJarFile = jarFile.getNestedJarFile(nestedEntry)) { 				Iterator<JarEntry> iterator = nestedJarFile.iterator(); 				for (int i = 0; i < 65537; i++) { 					assertThat(iterator.hasNext()).as(i + "nth file is present").isTrue(); 					iterator.next(); 				} 			} 		} 	}
@Override 	public Resource getResource(String path) throws IOException { 		URL url = new URL("jar:file:" + this.jarPath + "!" + (path.startsWith("/") ? path : "/" + path)); 		URLResource resource = new URLResource(url, path); 		if (StringUtils.hasText(path) && !"/".equals(path) && resource.getContentLength() < 0) { 			return null; 		} 		return resource; 	}
@Override 	@ResponseBody 	protected Publisher<ResponseEntity<Object>> links(ServerWebExchange exchange) { 		ServerHttpRequest request = exchange.getRequest(); 		return this.securityInterceptor.preHandle(exchange, "") 				.map((securityResponse) -> { 					if (!securityResponse.getStatus().equals(HttpStatus.OK)) { 						return new ResponseEntity<>(securityResponse.getStatus()); 					} 					AccessLevel accessLevel = exchange 							.getAttribute(AccessLevel.REQUEST_ATTRIBUTE); 					Map<String, Link> links = this.linksResolver 							.resolveLinks(getEndpoints(), request.getURI().toString()); 					return new ResponseEntity<>( 							Collections.singletonMap("_links", 									getAccessibleLinks(accessLevel, links)), 							HttpStatus.OK); 				}); 	}
private CloudFoundrySecurityInterceptor getSecurityInterceptor( 			WebClient.Builder restTemplateBuilder, Environment environment) { 		ReactiveCloudFoundrySecurityService cloudfoundrySecurityService = getCloudFoundrySecurityService( 				restTemplateBuilder, environment); 		ReactiveTokenValidator tokenValidator = new ReactiveTokenValidator( 				cloudfoundrySecurityService); 		return new CloudFoundrySecurityInterceptor(tokenValidator, 				cloudfoundrySecurityService, 				environment.getProperty("vcap.application.application_id")); 	}
@Override 	@ResponseBody 	protected Map<String, Map<String, Link>> links(HttpServletRequest request, 			HttpServletResponse response) { 		SecurityResponse securityResponse = this.securityInterceptor.preHandle(request, 				""); 		if (!securityResponse.getStatus().equals(HttpStatus.OK)) { 			sendFailureResponse(response, securityResponse); 		} 		AccessLevel accessLevel = (AccessLevel) request 				.getAttribute(AccessLevel.REQUEST_ATTRIBUTE); 		Map<String, Link> links = this.linksResolver.resolveLinks(getEndpoints(), 				request.getRequestURL().toString()); 		Map<String, Link> filteredLinks = new LinkedHashMap<>(); 		if (accessLevel == null) { 			return Collections.singletonMap("_links", filteredLinks); 		} 		filteredLinks = links.entrySet().stream() 				.filter((e) -> e.getKey().equals("self") 						|| accessLevel.isAccessAllowed(e.getKey())) 				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)); 		return Collections.singletonMap("_links", filteredLinks); 	}
private void sendFailureResponse(HttpServletResponse response, 			SecurityResponse securityResponse) { 		try { 			response.sendError(securityResponse.getStatus().value(), 					securityResponse.getMessage()); 		} 		catch (Exception ex) { 			this.logger.debug("Failed to send error response", ex); 		} 	}
@Bean 	@ConditionalOnMissingBean 	public ParameterValueMapper endpointOperationParameterMapper() { 		return new ConversionServiceParameterValueMapper(); 	}
private String getStaticNames() { 		if (this.properties.getStaticNames().isEmpty()) { 			return ""; 		} 		StringBuilder builder = new StringBuilder(); 		this.properties.getStaticNames() 				.forEach((name, value) -> builder.append("," + name + "=" + value)); 		return builder.toString(); 	}
@Bean 	public ExposeExcludePropertyEndpointFilter<ExposableJmxEndpoint> jmxIncludeExcludePropertyEndpointFilter() { 		Set<String> expose = this.properties.getExpose(); 		Set<String> exclude = this.properties.getExclude(); 		return new ExposeExcludePropertyEndpointFilter<>(ExposableJmxEndpoint.class, 				expose, exclude, "*"); 	}
@Override 	public List<String> getPaths() { 		return this.endpoints.stream().map(this::getPath).collect(Collectors.toList()); 	}
@Override 	public String getPath(String id) { 		Assert.notNull(id, "ID must not be null"); 		return this.endpoints.stream().filter((info) -> id.equals(info.getId())) 				.findFirst().map(this::getPath).orElse(null); 	}
@Bean 	public ExposeExcludePropertyEndpointFilter<ExposableWebEndpoint> webIncludeExcludePropertyEndpointFilter() { 		Set<String> expose = this.properties.getExpose(); 		Set<String> exclude = this.properties.getExclude(); 		return new ExposeExcludePropertyEndpointFilter<>(ExposableWebEndpoint.class, 				expose, exclude, "info", "health"); 	}
@Test 	public void matchIfDiscovererCloudFoundryShouldReturnFalse() { 		DiscoveredEndpoint<?> endpoint = mock(DiscoveredEndpoint.class); 		given(endpoint.wasDiscoveredBy(CloudFoundryWebEndpointDiscoverer.class)) 				.willReturn(true); 		assertThat(this.filter.match(endpoint)).isTrue(); 	}
@Test 	public void matchIfDiscovererNotCloudFoundryShouldReturnFalse() { 		DiscoveredEndpoint<?> endpoint = mock(DiscoveredEndpoint.class); 		given(endpoint.wasDiscoveredBy(CloudFoundryWebEndpointDiscoverer.class)) 				.willReturn(false); 		assertThat(this.filter.match(endpoint)).isFalse(); 	}
@Bean 		public CloudFoundrySecurityInterceptor interceptor() { 			return new CloudFoundrySecurityInterceptor(tokenValidator, securityService, 					"app-id"); 		}
@Bean 		public WebEndpointDiscoverer webEndpointDiscoverer( 				ApplicationContext applicationContext, 				EndpointMediaTypes endpointMediaTypes) { 			ParameterValueMapper parameterMapper = new ConversionServiceParameterValueMapper( 					DefaultConversionService.getSharedInstance()); 			return new WebEndpointDiscoverer(applicationContext, parameterMapper, 					endpointMediaTypes, EndpointPathResolver.useEndpointId(), 					Collections.emptyList(), Collections.emptyList()); 		}
@Test 	public void allEndpointsAvailableUnderCloudFoundryWithoutEnablingWebIncludes() { 		setupContextWithCloudEnabled(); 		this.context.register(TestConfiguration.class); 		this.context.refresh(); 		CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(); 		Collection<ExposableWebEndpoint> endpoints = handlerMapping.getEndpoints(); 		List<String> endpointIds = endpoints.stream().map(ExposableEndpoint::getId) 				.collect(Collectors.toList()); 		assertThat(endpointIds).contains("test"); 	}
@Test 	public void endpointPathCustomizationIsNotApplied() { 		setupContextWithCloudEnabled(); 		this.context.register(TestConfiguration.class); 		this.context.refresh(); 		CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(); 		Collection<ExposableWebEndpoint> endpoints = handlerMapping.getEndpoints(); 		ExposableWebEndpoint endpoint = endpoints.stream() 				.filter((candidate) -> "test".equals(candidate.getId())).findFirst() 				.get(); 		assertThat(endpoint.getOperations()).hasSize(1); 		WebOperation operation = endpoint.getOperations().iterator().next(); 		assertThat(operation.getRequestPredicate().getPath()).isEqualTo("test"); 	}
@Test 	public void healthEndpointInvokerShouldBeCloudFoundryWebExtension() { 		setupContextWithCloudEnabled(); 		this.context.refresh(); 		Collection<ExposableWebEndpoint> endpoints = getHandlerMapping().getEndpoints(); 		ExposableWebEndpoint endpoint = endpoints.iterator().next(); 		WebOperation webOperation = endpoint.getOperations().iterator().next(); 		Object invoker = ReflectionTestUtils.getField(webOperation, "invoker"); 		assertThat(ReflectionTestUtils.getField(invoker, "target")) 				.isInstanceOf(CloudFoundryReactiveHealthEndpointWebExtension.class); 	}
@Before 	public void setup() { 		MockitoAnnotations.initMocks(this); 		this.interceptor = new CloudFoundrySecurityInterceptor( 				this.tokenValidator, this.securityService, "my-app-id"); 	}
@Test 	public void preHandleWhenApplicationIdIsNullShouldReturnError() { 		this.interceptor = new CloudFoundrySecurityInterceptor( 				this.tokenValidator, this.securityService, null); 		MockServerWebExchange request = MockServerWebExchange 				.from(MockServerHttpRequest.get("/a") 						.header(HttpHeaders.AUTHORIZATION, "bearer " + mockAccessToken()) 						.build()); 		StepVerifier.create(this.interceptor.preHandle(request, "/a")) 				.consumeErrorWith((ex) -> assertThat( 						((CloudFoundryAuthorizationException) ex).getReason()) 								.isEqualTo(Reason.SERVICE_UNAVAILABLE)) 				.verify(); 	}
@Test 	public void preHandleWhenCloudFoundrySecurityServiceIsNullShouldReturnError() { 		this.interceptor = new CloudFoundrySecurityInterceptor( 				this.tokenValidator, null, "my-app-id"); 		MockServerWebExchange request = MockServerWebExchange.from(MockServerHttpRequest 				.get("/a").header(HttpHeaders.AUTHORIZATION, mockAccessToken()).build()); 		StepVerifier.create(this.interceptor.preHandle(request, "/a")) 				.consumeErrorWith((ex) -> assertThat( 						((CloudFoundryAuthorizationException) ex).getReason()) 								.isEqualTo(Reason.SERVICE_UNAVAILABLE)) 				.verify(); 	}
@Test 	public void cloudFoundryPlatformActive() { 		CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(); 		EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils 				.getField(handlerMapping, "endpointMapping"); 		assertThat(endpointMapping.getPath()).isEqualTo("/cloudfoundryapplication"); 		CorsConfiguration corsConfiguration = (CorsConfiguration) ReflectionTestUtils 				.getField(handlerMapping, "corsConfiguration"); 		assertThat(corsConfiguration.getAllowedOrigins()).contains("*"); 		assertThat(corsConfiguration.getAllowedMethods()).containsAll( 				Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name())); 		assertThat(corsConfiguration.getAllowedHeaders()).containsAll( 				Arrays.asList("Authorization", "X-Cf-App-Instance", "Content-Type")); 	}
@Test 	public void allEndpointsAvailableUnderCloudFoundryWithoutExposeAllOnWeb() { 		this.context.register(TestConfiguration.class); 		this.context.refresh(); 		CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(); 		Collection<ExposableWebEndpoint> endpoints = handlerMapping.getEndpoints(); 		assertThat(endpoints.stream() 				.filter((candidate) -> "test".equals(candidate.getId())).findFirst()) 						.isNotEmpty(); 	}
@Test 	public void endpointPathCustomizationIsNotApplied() { 		TestPropertyValues.of("management.endpoints.web.path-mapping.test=custom") 				.applyTo(this.context); 		this.context.register(TestConfiguration.class); 		this.context.refresh(); 		CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(); 		Collection<ExposableWebEndpoint> endpoints = handlerMapping.getEndpoints(); 		ExposableWebEndpoint endpoint = endpoints.stream() 				.filter((candidate) -> "test".equals(candidate.getId())).findFirst() 				.get(); 		Collection<WebOperation> operations = endpoint.getOperations(); 		assertThat(operations).hasSize(1); 		assertThat(operations.iterator().next().getRequestPredicate().getPath()) 				.isEqualTo("test"); 	}
@Test 	public void healthEndpointInvokerShouldBeCloudFoundryWebExtension() { 		TestPropertyValues 				.of("VCAP_APPLICATION:---", "vcap.application.application_id:my-app-id", 						"vcap.application.cf_api:http://my-cloud-controller.com") 				.applyTo(this.context); 		this.context.refresh(); 		Collection<ExposableWebEndpoint> endpoints = this.context 				.getBean("cloudFoundryWebEndpointServletHandlerMapping", 						CloudFoundryWebEndpointServletHandlerMapping.class) 				.getEndpoints(); 		ExposableWebEndpoint endpoint = endpoints.iterator().next(); 		WebOperation webOperation = endpoint.getOperations().iterator().next(); 		Object invoker = ReflectionTestUtils.getField(webOperation, "invoker"); 		assertThat(ReflectionTestUtils.getField(invoker, "target")) 				.isInstanceOf(CloudFoundryHealthEndpointWebExtension.class); 	}
@Bean 		public WebEndpointDiscoverer webEndpointDiscoverer( 				ApplicationContext applicationContext, 				EndpointMediaTypes endpointMediaTypes) { 			ParameterValueMapper parameterMapper = new ConversionServiceParameterValueMapper( 					DefaultConversionService.getSharedInstance()); 			return new WebEndpointDiscoverer(applicationContext, parameterMapper, 					endpointMediaTypes, EndpointPathResolver.useEndpointId(), 					Collections.emptyList(), Collections.emptyList()); 		}
@Test 	public void createWhenEnvironmentIsNullShouldThrowException() { 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("Environment must not be null"); 		new ExposeExcludePropertyEndpointFilter<>(ExposableEndpoint.class, null, "foo"); 	}
@Test 	public void createWhenPrefixIsNullShouldThrowException() { 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("Prefix must not be empty"); 		new ExposeExcludePropertyEndpointFilter<>(ExposableEndpoint.class, 				new MockEnvironment(), null); 	}
@Test 	public void createWhenPrefixIsEmptyShouldThrowException() { 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("Prefix must not be empty"); 		new ExposeExcludePropertyEndpointFilter<>(ExposableEndpoint.class, 				new MockEnvironment(), ""); 	}
@Test 	public void matchWhenDiscovererDoesNotMatchShouldMatch() { 		MockEnvironment environment = new MockEnvironment(); 		environment.setProperty("foo.expose", "bar"); 		environment.setProperty("foo.exclude", ""); 		this.filter = new ExposeExcludePropertyEndpointFilter<>( 				DifferentTestExposableWebEndpoint.class, environment, "foo"); 		assertThat(match("baz")).isTrue(); 	}
private void setupFilter(String expose, String exclude) { 		MockEnvironment environment = new MockEnvironment(); 		environment.setProperty("foo.expose", expose); 		environment.setProperty("foo.exclude", exclude); 		this.filter = new ExposeExcludePropertyEndpointFilter<>( 				TestExposableWebEndpoint.class, environment, "foo", "def"); 	}
@SuppressWarnings({ "rawtypes", "unchecked" }) 	private boolean match(String id) { 		ExposableEndpoint<?> endpoint = mock(TestExposableWebEndpoint.class); 		given(endpoint.getId()).willReturn(id); 		return ((EndpointFilter) this.filter).match(endpoint); 	}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultFalse foo() { 			return new FooEndpointEnabledByDefaultFalse(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultFalse foo() { 			return new FooEndpointEnabledByDefaultFalse(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultTrue foo() { 			return new FooEndpointEnabledByDefaultTrue(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultTrue foo() { 			return new FooEndpointEnabledByDefaultTrue(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultFalse foo() { 			return new FooEndpointEnabledByDefaultFalse(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultFalse foo() { 			return new FooEndpointEnabledByDefaultFalse(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointExtensionEnabledByDefaultFalse fooExt() { 			return new FooEndpointExtensionEnabledByDefaultFalse(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultTrue foo() { 			return new FooEndpointEnabledByDefaultTrue(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultTrue foo() { 			return new FooEndpointEnabledByDefaultTrue(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointExtensionEnabledByDefaultTrue fooExt() { 			return new FooEndpointExtensionEnabledByDefaultTrue(); 		}
@Test 	public void generateObjectNameWithUniqueNames() { 		this.properties.setUniqueNames(true); 		ExposableJmxEndpoint endpoint = endpoint("test"); 		String id = ObjectUtils.getIdentityHexString(endpoint); 		ObjectName objectName = generateObjectName(endpoint); 		assertThat(objectName.toString()).isEqualTo( 				"org.springframework.boot:type=Endpoint,name=Test,identity=" + id); 	}
private ExposableJmxEndpoint endpoint(String id) { 		ExposableJmxEndpoint endpoint = mock(ExposableJmxEndpoint.class); 		given(endpoint.getId()).willReturn(id); 		return endpoint; 	}
private DefaultEndpointPathProvider createProvider(String contextPath) { 		Collection<ExposableWebEndpoint> endpoints = new ArrayList<>(); 		endpoints.add(mockEndpoint("foo")); 		endpoints.add(mockEndpoint("bar")); 		WebEndpointProperties properties = new WebEndpointProperties(); 		properties.setBasePath(contextPath); 		return new DefaultEndpointPathProvider(properties, endpoints); 	}
@Override 	public MBeanInfo getMBeanInfo() { 		return this.info; 	}
@Override 	public Object invoke(String actionName, Object[] params, String[] signature) 			throws MBeanException, ReflectionException { 		JmxOperation operation = this.operations.get(actionName); 		if (operation == null) { 			String message = "Endpoint with id '" + this.endpoint.getId() 					+ "' has no operation named " + actionName; 			throw new ReflectionException(new IllegalArgumentException(message), message); 		} 		return invoke(operation, params); 	}
@Override 	public Object getAttribute(String attribute) 			throws AttributeNotFoundException, MBeanException, ReflectionException { 		throw new AttributeNotFoundException("EndpointMBeans do not support attributes"); 	}
@Override 	public void setAttribute(Attribute attribute) throws AttributeNotFoundException, 			InvalidAttributeValueException, MBeanException, ReflectionException { 		throw new AttributeNotFoundException("EndpointMBeans do not support attributes"); 	}
private Resource createResource(EndpointMapping endpointMapping, 			WebOperation operation) { 		WebOperationRequestPredicate requestPredicate = operation.getRequestPredicate(); 		Builder resourceBuilder = Resource.builder() 				.path(endpointMapping.createSubPath(requestPredicate.getPath())); 		resourceBuilder.addMethod(requestPredicate.getHttpMethod().name()) 				.consumes(toStringArray(requestPredicate.getConsumes())) 				.produces(toStringArray(requestPredicate.getProduces())) 				.handledBy(new OperationInflector(operation, 						!requestPredicate.getConsumes().isEmpty())); 		return resourceBuilder.build(); 	}
@Override 		public Response apply(ContainerRequestContext data) { 			Map<String, Object> arguments = new HashMap<>(); 			if (this.readBody) { 				arguments.putAll(extractBodyArguments(data)); 			} 			arguments.putAll(extractPathParameters(data)); 			arguments.putAll(extractQueryParameters(data)); 			try { 				Object response = this.operation.invoke(arguments); 				return convertToJaxRsResponse(response, data.getRequest().getMethod()); 			} 			catch (MissingParametersException | ParameterMappingException ex) { 				return Response.status(Status.BAD_REQUEST).build(); 			} 		}
@Override 		public Object apply(Object body) { 			if (body instanceof Mono) { 				return ((Mono<?>) body).block(); 			} 			return body; 		}
@Override 		public Object apply(Object body) { 			if (body instanceof org.springframework.core.io.Resource) { 				try { 					return ((org.springframework.core.io.Resource) body).getInputStream(); 				} 				catch (IOException ex) { 					throw new IllegalStateException(); 				} 			} 			return body; 		}
@Override 	protected void initHandlerMethods() { 		for (ExposableWebEndpoint endpoint : this.endpoints) { 			for (WebOperation operation : endpoint.getOperations()) { 				registerMappingForOperation(endpoint, operation); 			} 		} 		if (StringUtils.hasText(this.endpointMapping.getPath())) { 			registerLinksMapping(); 		} 	}
private void registerLinksMapping() { 		PatternsRequestCondition patterns = new PatternsRequestCondition( 				pathPatternParser.parse(this.endpointMapping.getPath())); 		RequestMethodsRequestCondition methods = new RequestMethodsRequestCondition( 				RequestMethod.GET); 		ProducesRequestCondition produces = new ProducesRequestCondition( 				this.endpointMediaTypes.getProduced().toArray( 						new String[this.endpointMediaTypes.getProduced().size()])); 		RequestMappingInfo mapping = new RequestMappingInfo(patterns, methods, null, null, 				null, produces, null); 		registerMapping(mapping, this, this.linksMethod); 	}
public Collection<ExposableWebEndpoint> getEndpoints() { 		return this.endpoints; 	}
private void invoke(Map<String, Object> arguments, MonoSink<Object> sink) { 			try { 				Object result = this.invoker.invoke(arguments); 				sink.success(result); 			} 			catch (Exception ex) { 				sink.error(ex); 			} 		}
public Collection<ExposableWebEndpoint> getEndpoints() { 		return this.endpoints; 	}
@Override 	protected void initHandlerMethods() { 		for (ExposableWebEndpoint endpoint : this.endpoints) { 			for (WebOperation operation : endpoint.getOperations()) { 				registerMappingForOperation(endpoint, operation); 			} 		} 		if (StringUtils.hasText(this.endpointMapping.getPath())) { 			registerLinksMapping(); 		} 	}
@Test 	public void resolvedLinksContainsALinkForEachEndpointOperation() { 		List<WebOperation> operations = new ArrayList<>(); 		operations.add(operationWithPath("/alpha", "alpha")); 		operations.add(operationWithPath("/alpha/{name}", "alpha-name")); 		ExposableWebEndpoint endpoint = mock(ExposableWebEndpoint.class); 		given(endpoint.getId()).willReturn("alpha"); 		given(endpoint.isEnableByDefault()).willReturn(true); 		given(endpoint.getOperations()).willReturn(operations); 		String requestUrl = "https://api.example.com/actuator"; 		Map<String, Link> links = this.linksResolver 				.resolveLinks(Collections.singletonList(endpoint), requestUrl); 		assertThat(links).hasSize(3); 		assertThat(links).hasEntrySatisfying("self", 				linkWithHref("https://api.example.com/actuator")); 		assertThat(links).hasEntrySatisfying("alpha", 				linkWithHref("https://api.example.com/actuator/alpha")); 		assertThat(links).hasEntrySatisfying("alpha-name", 				linkWithHref("https://api.example.com/actuator/alpha/{name}")); 	}
private WebOperation operationWithPath(String path, String id) { 		WebOperationRequestPredicate predicate = new WebOperationRequestPredicate(path, 				WebEndpointHttpMethod.GET, Collections.emptyList(), 				Collections.emptyList()); 		WebOperation operation = mock(WebOperation.class); 		given(operation.getId()).willReturn(id); 		given(operation.getType()).willReturn(OperationType.READ); 		given(operation.getRequestPredicate()).willReturn(predicate); 		return operation; 	}
private void customize(ResourceConfig config) { 			List<String> mediaTypes = Arrays.asList(MediaType.APPLICATION_JSON, 					ActuatorMediaType.V2_JSON); 			EndpointMediaTypes endpointMediaTypes = new EndpointMediaTypes(mediaTypes, 					mediaTypes); 			WebEndpointDiscoverer discoverer = new WebEndpointDiscoverer( 					this.applicationContext, new ConversionServiceParameterValueMapper(), 					endpointMediaTypes, EndpointPathResolver.useEndpointId(), 					Collections.emptyList(), Collections.emptyList()); 			Collection<Resource> resources = new JerseyEndpointResourceFactory() 					.createEndpointResources(new EndpointMapping("/actuator"), 							discoverer.getEndpoints(), endpointMediaTypes); 			config.registerResources(new HashSet<>(resources)); 		}
@Bean 		public WebFluxEndpointHandlerMapping webEndpointReactiveHandlerMapping() { 			List<String> mediaTypes = Arrays.asList(MediaType.APPLICATION_JSON_VALUE, 					ActuatorMediaType.V2_JSON); 			EndpointMediaTypes endpointMediaTypes = new EndpointMediaTypes(mediaTypes, 					mediaTypes); 			WebEndpointDiscoverer discoverer = new WebEndpointDiscoverer( 					this.applicationContext, new ConversionServiceParameterValueMapper(), 					endpointMediaTypes, EndpointPathResolver.useEndpointId(), 					Collections.emptyList(), Collections.emptyList()); 			return new WebFluxEndpointHandlerMapping(new EndpointMapping("/actuator"), 					discoverer.getEndpoints(), endpointMediaTypes, 					new CorsConfiguration()); 		}
@Bean 		public WebMvcEndpointHandlerMapping webEndpointServletHandlerMapping() { 			List<String> mediaTypes = Arrays.asList(MediaType.APPLICATION_JSON_VALUE, 					ActuatorMediaType.V2_JSON); 			EndpointMediaTypes endpointMediaTypes = new EndpointMediaTypes(mediaTypes, 					mediaTypes); 			WebEndpointDiscoverer discoverer = new WebEndpointDiscoverer( 					this.applicationContext, new ConversionServiceParameterValueMapper(), 					endpointMediaTypes, EndpointPathResolver.useEndpointId(), 					Collections.emptyList(), Collections.emptyList()); 			return new WebMvcEndpointHandlerMapping(new EndpointMapping("/actuator"), 					discoverer.getEndpoints(), endpointMediaTypes, 					new CorsConfiguration()); 		}
@Test 	public void homeIsSecure() { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = restTemplate().getForEntity("/", Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertThat(body.get("error")).isEqualTo("Unauthorized"); 		assertThat(entity.getHeaders()).doesNotContainKey("Set-Cookie"); 	}
@Test 	public void testInsecureApplicationPath() { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = restTemplate().getForEntity("/foo", Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertThat((String) body.get("message")) 				.contains("Expected exception in controller"); 	}
@Test 	public void testInsecureStaticResources() { 		ResponseEntity<String> entity = restTemplate() 				.getForEntity("/css/bootstrap.min.css", String.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK); 		assertThat(entity.getBody()).contains("body"); 	}
@Override 		public void destroy() throws Exception { 			if (dataSourceRequiresShutdown()) { 				try (Connection connection = this.dataSource.getConnection()) { 					try (Statement statement = connection.createStatement()) { 						statement.execute("SHUTDOWN"); 					} 				} 			} 		}
@Override 	public void writeLoaderClasses(String loaderJarResourceName) throws IOException { 		URL loaderJar = getClass().getClassLoader().getResource(loaderJarResourceName); 		try (JarInputStream inputStream = new JarInputStream( 				new BufferedInputStream(loaderJar.openStream()))) { 			JarEntry entry; 			while ((entry = inputStream.getNextJarEntry()) != null) { 				if (entry.getName().endsWith(".class")) { 					writeEntry(new JarArchiveEntry(entry), 							new InputStreamEntryWriter(inputStream, false)); 				} 			} 		} 	}
@Override 	public Manifest getManifest() throws IOException { 		Manifest manifest = (this.manifest == null ? null : this.manifest.get()); 		if (manifest == null) { 			if (this.type == JarFileType.NESTED_DIRECTORY) { 				try (JarFile rootJarFile = new JarFile(this.getRootJarFile())) { 					manifest = rootJarFile.getManifest(); 				} 			} 			else { 				try (InputStream inputStream = getInputStream(MANIFEST_NAME, 						ResourceAccess.ONCE)) { 					if (inputStream == null) { 						return null; 					} 					manifest = new Manifest(inputStream); 				} 			} 			this.manifest = new SoftReference<>(manifest); 		} 		return manifest; 	}
@SuppressWarnings("resource") 	private boolean checkForDevtools() { 		try { 			URL[] urls = getClassPathUrls(); 			try (URLClassLoader classLoader = new URLClassLoader(urls)) { 				return (classLoader.findResource(RESTARTER_CLASS_LOCATION) != null); 			} 		} 		catch (Exception ex) { 			return false; 		} 	}
@Override 	public Map<String, Object> invoke() {  		if (this.context == null) { 			return Collections.<String, Object>singletonMap("message", 					"No context to shutdown."); 		}  		try { 			return Collections.<String, Object>singletonMap("message", 					"Shutting down, bye..."); 		} 		finally {  			Thread thread = new Thread(new Runnable() { 				@Override 				public void run() { 					try { 						Thread.sleep(500L); 					} 					catch (InterruptedException ex) { 						// Swallow exception and continue 					} 					ShutdownEndpoint.this.context.close(); 				} 			}); 			thread.setContextClassLoader(getClass().getClassLoader()); 			thread.start(); 		} 	}
@Test 	public void invoke() throws Exception { 		Config config = this.context.getBean(Config.class); 		ClassLoader previousTccl = Thread.currentThread().getContextClassLoader(); 		Map<String, Object> result; 		Thread.currentThread().setContextClassLoader( 				new URLClassLoader(new URL[0], getClass().getClassLoader())); 		try { 			result = getEndpointBean().invoke(); 		} 		finally { 			Thread.currentThread().setContextClassLoader(previousTccl); 		} 		assertThat((String) result.get("message"), startsWith("Shutting down")); 		assertTrue(this.context.isActive()); 		assertTrue(config.latch.await(10, TimeUnit.SECONDS)); 		assertThat(config.threadContextClassLoader, is(getClass().getClassLoader())); 	}
@Bean 		public ApplicationListener<ContextClosedEvent> listener() { 			return new ApplicationListener<ContextClosedEvent>() { 				@Override 				public void onApplicationEvent(ContextClosedEvent event) { 					Config.this.threadContextClassLoader = Thread.currentThread() 							.getContextClassLoader(); 					Config.this.latch.countDown(); 				} 			};  		}
@Override 				public void onApplicationEvent(ContextClosedEvent event) { 					Config.this.threadContextClassLoader = Thread.currentThread() 							.getContextClassLoader(); 					Config.this.latch.countDown(); 				}
@Override 	public Map<String, Object> invoke() {  		if (this.context == null) { 			return Collections.<String, Object>singletonMap("message", 					"No context to shutdown."); 		}  		try { 			return Collections.<String, Object>singletonMap("message", 					"Shutting down, bye..."); 		} 		finally {  			Thread thread = new Thread(new Runnable() { 				@Override 				public void run() { 					try { 						Thread.sleep(500L); 					} 					catch (InterruptedException ex) { 						// Swallow exception and continue 					} 					ShutdownEndpoint.this.context.close(); 				} 			}); 			thread.setContextClassLoader(getClass().getClassLoader()); 			thread.start(); 		} 	}
@Test 	public void invoke() throws Exception { 		Config config = this.context.getBean(Config.class); 		ClassLoader previousTccl = Thread.currentThread().getContextClassLoader(); 		Map<String, Object> result; 		Thread.currentThread().setContextClassLoader( 				new URLClassLoader(new URL[0], getClass().getClassLoader())); 		try { 			result = getEndpointBean().invoke(); 		} 		finally { 			Thread.currentThread().setContextClassLoader(previousTccl); 		} 		assertThat((String) result.get("message"), startsWith("Shutting down")); 		assertTrue(this.context.isActive()); 		assertTrue(config.latch.await(10, TimeUnit.SECONDS)); 		assertThat(config.threadContextClassLoader, is(getClass().getClassLoader())); 	}
@Bean 		public ApplicationListener<ContextClosedEvent> listener() { 			return new ApplicationListener<ContextClosedEvent>() { 				@Override 				public void onApplicationEvent(ContextClosedEvent event) { 					Config.this.threadContextClassLoader = Thread.currentThread() 							.getContextClassLoader(); 					Config.this.latch.countDown(); 				} 			};  		}
@Override 				public void onApplicationEvent(ContextClosedEvent event) { 					Config.this.threadContextClassLoader = Thread.currentThread() 							.getContextClassLoader(); 					Config.this.latch.countDown(); 				}
private Template createTemplate(Resource resource) throws IOException { 		Reader reader = getReader(resource); 		try { 			return this.compiler.compile(reader); 		} 		finally { 			reader.close(); 		} 	}
private ConfigurableApplicationContext doRun(SpringApplicationRunListeners listeners, 			String... args) { 		ConfigurableApplicationContext context; 		// Create and configure the environment 		ConfigurableEnvironment environment = getOrCreateEnvironment(); 		configureEnvironment(environment, args); 		listeners.environmentPrepared(environment); 		if (isWebEnvironment(environment) && !this.webEnvironment) { 			environment = convertToStandardEnvironment(environment); 		}  		if (this.showBanner) { 			printBanner(environment); 		}  		// Create, load, refresh and run the ApplicationContext 		context = createApplicationContext(); 		context.setEnvironment(environment); 		postProcessApplicationContext(context); 		applyInitializers(context); 		listeners.contextPrepared(context); 		if (this.logStartupInfo) { 			logStartupInfo(context.getParent() == null); 		}  		// Add boot specific singleton beans 		ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); 		context.getBeanFactory().registerSingleton("springApplicationArguments", 				applicationArguments);  		// Load the sources 		Set<Object> sources = getSources(); 		Assert.notEmpty(sources, "Sources must not be empty"); 		load(context, sources.toArray(new Object[sources.size()])); 		listeners.contextLoaded(context);  		// Refresh the context 		refresh(context); 		if (this.registerShutdownHook) { 			try { 				context.registerShutdownHook(); 			} 			catch (AccessControlException ex) { 				// Not allowed in some environments. 			} 		} 		afterRefresh(context, applicationArguments); 		listeners.finished(context, null); 		return context; 	}
private String[] getArgs(String... args) { 		List<String> list = new ArrayList<String>(Arrays.asList( 				"--spring.main.webEnvironment=false", "--spring.main.showBanner=false", 				"--spring.main.registerShutdownHook=false")); 		if (args.length > 0) { 			list.add("--spring.main.sources=" 					+ StringUtils.arrayToCommaDelimitedString(args)); 		} 		return list.toArray(new String[list.size()]); 	}
@Override 		public void close() { 			this.applicationContext.close(); 		}
@Override 			public void onApplicationEvent(ApplicationEvent event) { 				events.add(event); 			}
@Override 			public void onApplicationEvent(ApplicationEvent event) { 				events.add(event); 			}
@Override 		public void registerShutdownHook() { 			this.applicationContext.registerShutdownHook(); 		}
@Override 			public void onApplicationEvent(ApplicationEvent event) { 				events.add((event)); 			}
@Override 			public void onApplicationEvent(ApplicationEvent event) { 				events.add((event)); 			}
@Test 	public void registerShutdownHook() throws Exception { 		SpringApplication application = new SpringApplication(ExampleConfig.class); 		application.setApplicationContextClass(SpyApplicationContext.class); 		this.context = application.run(); 		SpyApplicationContext applicationContext = (SpyApplicationContext) this.context; 		verify(applicationContext.getApplicationContext()).registerShutdownHook(); 	}
@Override 		public void close() { 			super.close(); 			this.applicationContext.close(); 		}
private Process runCliProcess(String... args) throws IOException { 		List<String> command = new ArrayList<String>(); 		command.add(findLaunchScript().getAbsolutePath()); 		command.addAll(Arrays.asList(args)); 		ProcessBuilder processBuilder = new ProcessBuilder(command) 				.directory(this.workingDirectory); 		processBuilder.environment().remove("JAVA_OPTS"); 		return processBuilder.start(); 	}
private Process runCliProcess(String... args) throws IOException { 		List<String> command = new ArrayList<String>(); 		command.add(findLaunchScript().getAbsolutePath()); 		command.addAll(Arrays.asList(args)); 		ProcessBuilder processBuilder = new ProcessBuilder(command) 				.directory(this.workingDirectory); 		processBuilder.environment().remove("JAVA_OPTS"); 		return processBuilder.start(); 	}
@Override 	public boolean supportsEventType(Class<? extends ApplicationEvent> eventType) { 		return isAssignableFrom(eventType, EVENT_TYPES); 	}
@Override 	public boolean supportsSourceType(Class<?> sourceType) { 		return isAssignableFrom(sourceType, SOURCE_TYPES); 	}
@Override 	public void onApplicationEvent(ApplicationEvent event) { 		if (event instanceof ApplicationEnvironmentPreparedEvent) { 			ApplicationEnvironmentPreparedEvent available = (ApplicationEnvironmentPreparedEvent) event; 			initialize(available.getEnvironment(), available.getSpringApplication() 					.getClassLoader()); 		} 		else if (event instanceof ApplicationStartedEvent) { 			if (System.getProperty(PID_KEY) == null) { 				System.setProperty(PID_KEY, new ApplicationPid().toString()); 			} 			LoggingSystem loggingSystem = LoggingSystem.get(ClassUtils 					.getDefaultClassLoader()); 			loggingSystem.beforeInitialize(); 		} 		else { 			LoggingSystem loggingSystem = LoggingSystem.get(ClassUtils 					.getDefaultClassLoader()); 			loggingSystem.cleanUp(); 		} 	}
@Override 	public void beforeInitialize() { 		super.beforeInitialize(); 		configureJdkLoggingBridgeHandler(); 	}
private void configureJdkLoggingBridgeHandler() { 		try { 			if (bridgeHandlerIsAvailable()) { 				removeJdkLoggingBridgeHandler(); 				SLF4JBridgeHandler.install(); 			} 		} 		catch (Throwable ex) { 			// Ignore. No java.util.logging bridge is installed. 		} 	}
@After 	public void clear() { 		this.loggingSystem.cleanUp(); 		System.clearProperty("LOG_FILE"); 		System.clearProperty("LOG_PATH"); 		System.clearProperty("PID"); 	}
@After 	public void clear() { 		this.loggingSystem.cleanUp(); 		System.clearProperty("LOG_FILE"); 		System.clearProperty("LOG_PATH"); 		System.clearProperty("PID"); 	}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return null; 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			throw new NoClassDefFoundError(); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return failureAnalyzer.analyze(failure); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			throw new NoClassDefFoundError(); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return failureAnalyzer.analyze(failure); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return null; 		}
@BeforeEach 	void configureMock() { 		failureAnalyzer = mock(FailureAnalyzer.class); 	}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return null; 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			throw new NoClassDefFoundError(); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return failureAnalyzer.analyze(failure); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			throw new NoClassDefFoundError(); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return failureAnalyzer.analyze(failure); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return null; 		}
public Bindable<T> withExistingValue(T existingValue) { 		Assert.isTrue( 				existingValue == null || this.type.isArray() || this.boxedType.resolve().isInstance(existingValue), 				() -> "ExistingValue must be an instance of " + this.type); 		Supplier<T> value = (existingValue != null) ? () -> existingValue : null; 		return new Bindable<>(this.type, this.boxedType, value, this.annotations, this.bindRestrictions); 	}
@Override 	public Constructor<?> getBindConstructor(Bindable<?> bindable, boolean isNestedConstructorBinding) { 		Constructors constructors = Constructors.getConstructors(bindable.getType().resolve(), 				isNestedConstructorBinding); 		if (constructors.getBind() != null && constructors.isDeducedBindConstructor()) { 			if (bindable.getValue() != null && bindable.getValue().get() != null) { 				return null; 			} 		} 		return constructors.getBind(); 	}
@Override 	public Constructor<?> getBindConstructor(Class<?> type, boolean isNestedConstructorBinding) { 		Constructors constructors = Constructors.getConstructors(type, isNestedConstructorBinding); 		return constructors.getBind(); 	}
@Test // gh-33710 	void loadWhenConstructorUsedInBeanMethodAndNotAsConstructorBinding() { 		load(ConstructorUsedInBeanMethodConfiguration.class, "test.two=bound-2"); 		ConstructorUsedDirectly bean = this.context.getBean(ConstructorUsedDirectly.class); 		assertThat(bean.getOne()).isEqualTo("bean-method-1"); 		assertThat(bean.getTwo()).isEqualTo("bound-2"); 	}
@PostConstruct 		void init() { 			assertThat(this.properties).isNotNull(); 		}
@Bean 		static PropertySourcesPlaceholderConfigurer configurer() { 			PropertySourcesPlaceholderConfigurer placeholderConfigurer = new PropertySourcesPlaceholderConfigurer(); 			Properties properties = new Properties(); 			properties.put("com.example.bar", "b"); 			placeholderConfigurer.setProperties(properties); 			return placeholderConfigurer; 		}
@Bean 		static PropertySourcesPlaceholderConfigurer configurer() { 			return new PropertySourcesPlaceholderConfigurer(); 		}
void setName(String name) { 			this.name = name; 		}
void setName(String name) { 				this.name = name; 			}
void setName(String name) { 			this.name = name; 		}
public void setName(String name) { 			// Must be public for XML 			this.name = name; 		}
void setName(String name) { 				this.name = name; 			}
Nested getNested() { 					return this.nested; 				}
public void setName(String name) { 			// Must be public for XML 			this.name = name; 		}
void setName(String name) { 			this.name = name; 		}
void setName(String name) { 			this.name = name; 		}
public void setName(String name) { 			// Must be public for XML 			this.name = name; 		}
void setName(String name) { 				this.name = name; 			}
@PostConstruct 		void init() { 			assertThat(this.bar).isNotNull(); 			this.initialized = true; 		}
String getName() { 			return this.name; 		}
String getName() { 			return this.name; 		}
String getName() { 			return this.name; 		}
void setFoo(String foo) { 			this.foo = foo; 			if (!foo.equals("bar")) { 				throw new IllegalArgumentException("Wrong value for foo"); 			} 		}
@Override 		public boolean supports(Class<?> type) { 			return type == WithCustomValidatorProperties.class; 		}
void setFoo(String foo) { 			this.foo = foo; 			if (!foo.equals("bar")) { 				throw new IllegalArgumentException("Wrong value for foo"); 			} 		}
void setFoo(String foo) { 			this.foo = foo; 		}
void setFoo(String foo) { 			this.foo = foo; 		}
void setFoo(String foo) { 			this.foo = foo; 		}
void setFoo(String foo) { 			this.foo = foo; 			if (!foo.equals("bar")) { 				throw new IllegalArgumentException("Wrong value for foo"); 			} 		}
@Override 		public boolean supports(Class<?> type) { 			return type == ValidatorProperties.class; 		}
@Override 		public Alien convert(String source) { 			String[] content = StringUtils.split(source, " "); 			return new Alien(content[0], content[1]); 		}
@Override 		public WithPublicObjectToObjectMethod convert(String source) { 			return new WithPublicObjectToObjectMethod(source); 		}
@Override 		public Person convert(String source) { 			String[] content = StringUtils.split(source, " "); 			return new Person(content[0], content[1]); 		}
@Override 		public WithPublicObjectToObjectMethod convert(String source) { 			return new WithPublicObjectToObjectMethod(source); 		}
String getName() { 			return this.properties.name; 		}
Nested getNested() { 					return this.nested; 				}
int getAge() { 			return this.age; 		}
String getName() { 			return this.properties.name; 		}
Nested getNested() { 					return this.nested; 				}
int getAge() { 			return this.age; 		}
Nested getNested() { 					return this.nested; 				}
Nested getNested() { 					return this.nested; 				}
int getAge() { 			return this.age; 		}
int getAge() { 				return this.age; 			}
int getAge() { 				return this.age; 			}
int getAge() { 				return this.age; 			}
int getAge() { 				return this.age; 			}
int getAge() { 				return this.age; 			}
int getAge() { 				return this.age; 			}
int getAge() { 				return this.age; 			}
Nested getNested() { 					return this.nested; 				}
Nested getNested() { 					return this.nested; 				}
int getAge() { 			return this.age; 		}
Nested getNested() { 					return this.nested; 				}
int getAge() { 			return this.age; 		}
void setAge(int age) { 				this.age = age; 			}
Nested getNested() { 					return this.nested; 				}
int getAge() { 			return this.age; 		}
void setAge(int age) { 				this.age = age + 5; 			}
Nested getNested() { 			return this.nested; 		}
Nested getNested() { 			return this.nested; 		}
Nested getNested() { 			return this.nested; 		}
Nested getNested() { 			return this.nested; 		}
Nested getNested() { 			return this.nested; 		}
List<MultiConstructorConfigurationProperties> getNested() { 			return this.nested; 		}
Nested getNested() { 			return this.nested; 		}
Nested getNested() { 			return this.nested; 		}
Nested getNested() { 			return this.nested; 		}
Nested getNested() { 			return this.nested; 		}
ConstructorUsedDirectly getNested() { 			return this.nested; 		}
String getName() { 			return this.properties.name; 		}
Nested getNested() { 					return this.nested; 				}
int getAge() { 			return this.age; 		}
@Override 		public Person convert(String source) { 			String[] content = StringUtils.split(source, " "); 			return new Person(content[0], content[1]); 		}
@Override 		public Alien convert(String source) { 			String[] content = StringUtils.split(source, " "); 			return new Alien(content[0], content[1]); 		}
@Bean 		@ConfigurationProperties("test") 		ConstructorUsedDirectly constructorUsedInBeanMethod() { 			return new ConstructorUsedDirectly("bean-method-1", "bean-method-2"); 		}
@Override 		public String toString() { 			StringBuilder sb = new StringBuilder("User-defined bean"); 			if (this.methodMetadata != null) { 				sb.append(String.format(" method '%s' in '%s'", this.methodMetadata.getMethodName(), 						ClassUtils.getShortName(this.methodMetadata.getDeclaringClassName()))); 			} 			if (this.nullBean) { 				sb.append(" ignored as the bean value is null"); 			} 			return sb.toString(); 		}
@Override 		public String toString() { 			return String.format("Bean method '%s' in '%s' not loaded because %s", this.methodMetadata.getMethodName(), 					ClassUtils.getShortName(this.methodMetadata.getDeclaringClassName()), 					this.conditionOutcome.getMessage()); 		}
private FatalBeanException createFailure(Class<?> config, String... environment) { 		try { 			TestPropertyValues.of(environment).applyTo(this.context); 			this.context.register(config); 			this.context.refresh(); 			return null; 		} 		catch (FatalBeanException ex) { 			return ex; 		} 	}
@Bean 		String string() { 			return null; 		}
@Bean 		String string() { 			return null; 		}
@Bean 		String string() { 			return null; 		}
@ConditionalOnProperty("spring.string.enabled") 		@Bean 		String string() { 			return "Test"; 		}
@Bean 		String string() { 			return "Test"; 		}
@ConditionalOnBean(Integer.class) 		@Bean(name = "test-string") 		String string() { 			return "Test"; 		}
private Exception createFailure(Class<?> configuration, boolean allowCircularReferences) { 		try { 			this.context.register(configuration); 			AbstractAutowireCapableBeanFactory beanFactory = (AbstractAutowireCapableBeanFactory) this.context 					.getBeanFactory(); 			beanFactory.setAllowCircularReferences(allowCircularReferences); 			this.context.refresh(); 			fail("Expected failure did not occur"); 			return null; 		} 		catch (Exception ex) { 			return ex; 		} 	}
@Bean 			BeanThree three(BeanOne one) { 				return new BeanThree(); 			}
@Bean 		BeanTwo two(BeanThree three) { 			return new BeanTwo(); 		}
@Bean 		BeanOne one(BeanTwo two) { 			return new BeanOne(); 		}
@Bean 		BeanOne one(BeanTwo two) { 			return new BeanOne(); 		}
@Bean 				BeanOne one(BeanTwo two) { 					return new BeanOne(); 				}
@Bean 			BeanTwo two(BeanThree three) { 				return new BeanTwo(); 			}
@Bean 				BeanOne one(BeanTwo two) { 					return new BeanOne(); 				}
@Bean 		BeanThree three(BeanOne one) { 			return new BeanThree(); 		}
@Test 	void analysisWithNullEnvironment() { 		InvalidConfigurationPropertyValueException failure = new InvalidConfigurationPropertyValueException( 				"test.property", "invalid", "This is not valid."); 		FailureAnalysis analysis = new InvalidConfigurationPropertyValueFailureAnalyzer(null).analyze(failure); 		assertThat(analysis).isNull(); 	}
private FailureAnalysis performAnalysis(InvalidConfigurationPropertyValueException failure) { 		InvalidConfigurationPropertyValueFailureAnalyzer analyzer = new InvalidConfigurationPropertyValueFailureAnalyzer( 				this.environment); 		return analyzer.analyze(failure); 	}
@Test 	void analyzeWhenEnvironmentIsNullShouldReturnNull() { 		MutuallyExclusiveConfigurationPropertiesException failure = new MutuallyExclusiveConfigurationPropertiesException( 				new HashSet<>(Arrays.asList("com.example.a", "com.example.b")), 				new HashSet<>(Arrays.asList("com.example.a", "com.example.b"))); 		FailureAnalysis failureAnalysis = new MutuallyExclusiveConfigurationPropertiesFailureAnalyzer(null) 				.analyze(failure); 		assertThat(failureAnalysis).isNull(); 	}
private FailureAnalysis performAnalysis(MutuallyExclusiveConfigurationPropertiesException failure) { 		MutuallyExclusiveConfigurationPropertiesFailureAnalyzer analyzer = new MutuallyExclusiveConfigurationPropertiesFailureAnalyzer( 				this.environment); 		return analyzer.analyze(failure); 	}
private BeanCreationException createFailure(Class<?> consumer) { 		this.context.register(DuplicateBeansProducer.class, consumer); 		this.context.setParent(new AnnotationConfigApplicationContext(ParentProducer.class)); 		try { 			this.context.refresh(); 		} 		catch (BeanCreationException ex) { 			return ex; 		} 		return null; 	}
private FailureAnalysis performAnalysis(Class<?> configuration) { 		BeanCreationException failure = createFailure(configuration); 		assertThat(failure).isNotNull(); 		DataSourceBeanCreationFailureAnalyzer failureAnalyzer = new DataSourceBeanCreationFailureAnalyzer( 				this.environment); 		return failureAnalyzer.analyze(failure); 	}
@Test 	void noAnalysisWithoutR2dbcAutoConfiguration() { 		new ApplicationContextRunner().run((context) -> { 			NoDslContextBeanFailureAnalyzer failureAnalyzer = new NoDslContextBeanFailureAnalyzer( 					context.getBeanFactory()); 			assertThat(failureAnalyzer.analyze(new NoSuchBeanDefinitionException(DSLContext.class))).isNull(); 		}); 	}
@Test 	void analysisWithR2dbcAutoConfiguration() { 		new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class)) 				.run((context) -> { 					NoDslContextBeanFailureAnalyzer failureAnalyzer = new NoDslContextBeanFailureAnalyzer( 							context.getBeanFactory()); 					assertThat(failureAnalyzer.analyze(new NoSuchBeanDefinitionException(DSLContext.class))) 							.isNotNull(); 				}); 	}
private FailureAnalysis performAnalysis(Class<?> configuration) { 		BeanCreationException failure = createFailure(configuration); 		assertThat(failure).isNotNull(); 		ConnectionFactoryBeanCreationFailureAnalyzer failureAnalyzer = new ConnectionFactoryBeanCreationFailureAnalyzer( 				this.environment); 		return failureAnalyzer.analyze(failure); 	}
private T instantiate(TypeSupplier typeSupplier) { 		try { 			Class<?> type = typeSupplier.get(); 			Assert.isAssignable(this.type, type); 			return instantiate(type); 		} 		catch (Throwable ex) { 			this.failureHandler.handleFailure(this.type, typeSupplier.getName(), ex); 			return null; 		} 	}
@SuppressWarnings("unchecked") 	private T instantiate(Class<?> type) throws Exception { 		Constructor<?>[] constructors = type.getDeclaredConstructors(); 		Arrays.sort(constructors, CONSTRUCTOR_COMPARATOR); 		for (Constructor<?> constructor : constructors) { 			Object[] args = getArgs(constructor.getParameterTypes()); 			if (args != null) { 				ReflectionUtils.makeAccessible(constructor); 				return (T) constructor.newInstance(args); 			} 		} 		throw new IllegalAccessException("Class [" + type.getName() + "] has no suitable constructor"); 	}
@Override 				public String getName() { 					return type.getName(); 				}
@Override 				public Class<?> get() throws ClassNotFoundException { 					return type; 				}
@Override 				public String getName() { 					return name; 				}
@Override 				public Class<?> get() throws ClassNotFoundException { 					return ClassUtils.forName(name, classLoader); 				}
@Test 	void analyzersAreLoadedAndCalled() { 		RuntimeException failure = new RuntimeException(); 		analyzeAndReport(failure, BasicFailureAnalyzer.class.getName(), BasicFailureAnalyzer.class.getName()); 		then(failureAnalyzer).should(times(2)).analyze(failure); 	}
@Test 	void environmentIsInjectedIntoEnvironmentAwareFailureAnalyzers() { 		RuntimeException failure = new RuntimeException(); 		analyzeAndReport(failure, BasicFailureAnalyzer.class.getName(), StandardAwareFailureAnalyzer.class.getName()); 		then(failureAnalyzer).should().setEnvironment(same(this.context.getEnvironment())); 	}
@Test 	void analyzerThatFailsDuringInitializationDoesNotPreventOtherAnalyzersFromBeingCalled() { 		RuntimeException failure = new RuntimeException(); 		analyzeAndReport(failure, BrokenInitializationFailureAnalyzer.class.getName(), 				BasicFailureAnalyzer.class.getName()); 		then(failureAnalyzer).should().analyze(failure); 	}
@Test 	void analyzerThatFailsDuringAnalysisDoesNotPreventOtherAnalyzersFromBeingCalled() { 		RuntimeException failure = new RuntimeException(); 		analyzeAndReport(failure, BrokenAnalysisFailureAnalyzer.class.getName(), BasicFailureAnalyzer.class.getName()); 		then(failureAnalyzer).should().analyze(failure); 	}
@Test 	void createWithNullContextSkipsAwareAnalyzers() { 		RuntimeException failure = new RuntimeException(); 		analyzeAndReport(failure, (AnnotationConfigApplicationContext) null, BasicFailureAnalyzer.class.getName(), 				BeanFactoryConstructorFailureAnalyzer.class.getName(), 				EnvironmentConstructorFailureAnalyzer.class.getName(), StandardAwareFailureAnalyzer.class.getName()); 		then(failureAnalyzer).should().analyze(failure); 	}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return null; 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			throw new NoClassDefFoundError(); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return failureAnalyzer.analyze(failure); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			throw new NoClassDefFoundError(); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return failureAnalyzer.analyze(failure); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return null; 		}
public ApiVersion getApiVersion() { 		return resolveArgument(ApiVersion.class); 	}
@Deprecated 	public SecurityContext getSecurityContext() { 		return resolveArgument(SecurityContext.class); 	}
private boolean isMissing(InvocationContext context, OperationParameter parameter) { 		if (!parameter.isMandatory()) { 			return false; 		} 		if (context.canResolve(parameter.getType())) { 			return false; 		} 		return context.getArguments().get(parameter.getName()) == null; 	}
private Object resolveArgument(OperationParameter parameter, InvocationContext context) { 		Object resolvedByType = context.resolveArgument(parameter.getType()); 		if (resolvedByType != null) { 			return resolvedByType; 		} 		Object value = context.getArguments().get(parameter.getName()); 		return this.parameterValueMapper.mapParameterValue(parameter, value); 	}
@Override 	public Object invoke(InvocationContext context) { 		if (hasInput(context)) { 			return this.invoker.invoke(context); 		} 		long accessTime = System.currentTimeMillis(); 		ApiVersion contextApiVersion = context.getApiVersion(); 		Principal principal = context.resolveArgument(Principal.class); 		CacheKey cacheKey = new CacheKey(contextApiVersion, principal); 		CachedResponse cached = this.cachedResponses.get(cacheKey); 		if (cached == null || cached.isStale(accessTime, this.timeToLive)) { 			Object response = this.invoker.invoke(context); 			cached = createCachedResponse(response, accessTime); 			this.cachedResponses.put(cacheKey, cached); 		} 		return cached.getResponse(); 	}
@Override 		public Response apply(ContainerRequestContext data) { 			Map<String, Object> arguments = new HashMap<>(); 			if (this.readBody) { 				arguments.putAll(extractBodyArguments(data)); 			} 			arguments.putAll(extractPathParameters(data)); 			arguments.putAll(extractQueryParameters(data)); 			try { 				JerseySecurityContext securityContext = new JerseySecurityContext(data.getSecurityContext()); 				InvocationContext invocationContext = new InvocationContext(securityContext, arguments, 						Arrays.asList(new ProducibleOperationArgumentResolver(data.getHeaders()))); 				Object response = this.operation.invoke(invocationContext); 				return convertToJaxRsResponse(response, data.getRequest().getMethod()); 			} 			catch (InvalidEndpointRequestException ex) { 				return Response.status(Status.BAD_REQUEST).build(); 			} 		}
private Response convertToJaxRsResponse(Object response, String httpMethod) { 			if (response == null) { 				boolean isGet = HttpMethod.GET.equals(httpMethod); 				Status status = isGet ? Status.NOT_FOUND : Status.NO_CONTENT; 				return Response.status(status).build(); 			} 			try { 				if (!(response instanceof WebEndpointResponse)) { 					return Response.status(Status.OK).entity(convertIfNecessary(response)).build(); 				} 				WebEndpointResponse<?> webEndpointResponse = (WebEndpointResponse<?>) response; 				return Response.status(webEndpointResponse.getStatus()) 						.header("Content-Type", webEndpointResponse.getContentType()) 						.entity(convertIfNecessary(webEndpointResponse.getBody())).build(); 			} 			catch (IOException ex) { 				return Response.status(Status.INTERNAL_SERVER_ERROR).build(); 			} 		}
@Override 		public Object apply(Object body) { 			if (body instanceof Mono) { 				return ((Mono<?>) body).block(); 			} 			return body; 		}
@Override 		public Object apply(Object body) { 			if (body instanceof org.springframework.core.io.Resource) { 				try { 					return ((org.springframework.core.io.Resource) body).getInputStream(); 				} 				catch (IOException ex) { 					throw new IllegalStateException(); 				} 			} 			return body; 		}
@Override 		public Mono<ResponseEntity<Object>> handle(ServerWebExchange exchange, Map<String, String> body) { 			Map<String, Object> arguments = getArguments(exchange, body); 			String matchAllRemainingPathSegmentsVariable = this.operation.getRequestPredicate() 					.getMatchAllRemainingPathSegmentsVariable(); 			if (matchAllRemainingPathSegmentsVariable != null) { 				arguments.put(matchAllRemainingPathSegmentsVariable, 						tokenizePathSegments((String) arguments.get(matchAllRemainingPathSegmentsVariable))); 			} 			return this.securityContextSupplier.get() 					.map((securityContext) -> new InvocationContext(securityContext, arguments, 							Arrays.asList(new ProducibleOperationArgumentResolver(exchange.getRequest().getHeaders())))) 					.flatMap((invocationContext) -> handleResult((Publisher<?>) this.invoker.invoke(invocationContext), 							exchange.getRequest().getMethod())); 		}
private ResponseEntity<Object> toResponseEntity(Object response) { 			if (!(response instanceof WebEndpointResponse)) { 				return new ResponseEntity<>(response, HttpStatus.OK); 			} 			WebEndpointResponse<?> webEndpointResponse = (WebEndpointResponse<?>) response; 			MediaType contentType = (webEndpointResponse.getContentType() != null) 					? new MediaType(webEndpointResponse.getContentType()) : null; 			return ResponseEntity.status(webEndpointResponse.getStatus()).contentType(contentType) 					.body(webEndpointResponse.getBody()); 		}
@Override 		public String toString() { 			return getBean().toString(); 		}
@Override 		public String toString() { 			return "Actuator web endpoint '" + this.operation.getId() + "'"; 		}
@Override 		public Object handle(HttpServletRequest request, @RequestBody(required = false) Map<String, String> body) { 			HttpHeaders headers = new ServletServerHttpRequest(request).getHeaders(); 			Map<String, Object> arguments = getArguments(request, body); 			try { 				ServletSecurityContext securityContext = new ServletSecurityContext(request); 				InvocationContext invocationContext = new InvocationContext(securityContext, arguments, 						Arrays.asList(new ProducibleOperationArgumentResolver(headers))); 				return handleResult(this.operation.invoke(invocationContext), HttpMethod.resolve(request.getMethod())); 			} 			catch (InvalidEndpointRequestException ex) { 				throw new BadOperationRequestException(ex.getReason()); 			} 		}
@ResponseBody 		Object handle(HttpServletRequest request, @RequestBody(required = false) Map<String, String> body) { 			return this.operation.handle(request, body); 		}
@Override 		public String toString() { 			return this.operation.toString(); 		}
@Override 		public String toString() { 			return getBean().toString(); 		}
private Object handleResult(Object result, HttpMethod httpMethod) { 			if (result == null) { 				return new ResponseEntity<>( 						(httpMethod != HttpMethod.GET) ? HttpStatus.NO_CONTENT : HttpStatus.NOT_FOUND); 			} 			if (!(result instanceof WebEndpointResponse)) { 				return result; 			} 			WebEndpointResponse<?> response = (WebEndpointResponse<?>) result; 			MediaType contentType = (response.getContentType() != null) ? new MediaType(response.getContentType()) 					: null; 			return ResponseEntity.status(response.getStatus()).contentType(contentType).body(response.getBody()); 		}
@Override 		public Object handle(HttpServletRequest request, @RequestBody(required = false) Map<String, String> body) { 			HttpHeaders headers = new ServletServerHttpRequest(request).getHeaders(); 			Map<String, Object> arguments = getArguments(request, body); 			try { 				ServletSecurityContext securityContext = new ServletSecurityContext(request); 				InvocationContext invocationContext = new InvocationContext(securityContext, arguments, 						Arrays.asList(new ProducibleOperationArgumentResolver(headers))); 				return handleResult(this.operation.invoke(invocationContext), HttpMethod.resolve(request.getMethod())); 			} 			catch (InvalidEndpointRequestException ex) { 				throw new BadOperationRequestException(ex.getReason()); 			} 		}
@Override 		public String toString() { 			return "Actuator web endpoint '" + this.operation.getId() + "'"; 		}
@Override 		public String toString() { 			return getBean().toString(); 		}
@Override 		public String toString() { 			return "Actuator web endpoint '" + this.operation.getId() + "'"; 		}
@Override 		public String toString() { 			return this.operation.toString(); 		}
@Test 	void targetInvokedWithDifferentApiVersion() { 		OperationInvoker target = mock(OperationInvoker.class); 		Object expectedV2 = new Object(); 		Object expectedV3 = new Object(); 		InvocationContext contextV2 = new InvocationContext(mock(SecurityContext.class), Collections.emptyMap(), 				Arrays.asList(new ApiVersionArgumentResolver(ApiVersion.V2))); 		InvocationContext contextV3 = new InvocationContext(mock(SecurityContext.class), Collections.emptyMap(), 				Arrays.asList(new ApiVersionArgumentResolver(ApiVersion.V3))); 		given(target.invoke(contextV2)).willReturn(expectedV2); 		given(target.invoke(contextV3)).willReturn(expectedV3); 		CachingOperationInvoker invoker = new CachingOperationInvoker(target, CACHE_TTL); 		Object response = invoker.invoke(contextV2); 		assertThat(response).isSameAs(expectedV2); 		verify(target, times(1)).invoke(contextV2); 		Object cachedResponse = invoker.invoke(contextV3); 		assertThat(cachedResponse).isNotSameAs(response); 		verify(target, times(1)).invoke(contextV3); 	}
@Override 		public Flux<String> invoke(InvocationContext context) throws MissingParametersException { 			return Flux.just("spring", "boot").hide().doFirst(invocations::incrementAndGet); 		}
@Override 		public Mono<String> invoke(InvocationContext context) throws MissingParametersException { 			return Mono.fromCallable(() -> { 				invocations.incrementAndGet(); 				return "test"; 			}); 		}
@Bean 		@ConditionalOnMissingBean(JerseyApplicationPath.class) 		JerseyApplicationPath jerseyApplicationPath(JerseyProperties properties, ResourceConfig config) { 			return new DefaultJerseyApplicationPath(properties.getApplicationPath(), config); 		}
@Override 		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource) throws IOException { 			return createConfigData(this, resource); 		}
@Override 		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource) throws IOException { 			return createConfigData(this, resource); 		}
@Override 		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource) throws IOException { 			throw new AssertionError("Unexpected call"); 		}
@Override 		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource) throws IOException { 			throw new AssertionError("Unexpected call"); 		}
@Override 		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource) throws IOException { 			throw new AssertionError("Unexpected call"); 		}
private Collection<ApplicationListener<?>> getListeners() { 		List<ApplicationListener<?>> listeners = new ArrayList<>(); 		listeners.add(new AnsiOutputApplicationListener()); 		listeners.add(new EnvironmentPostProcessorApplicationListener(ConfigDataEnvironmentPostProcessor.class)); 		listeners.add(new ClasspathLoggingApplicationListener()); 		listeners.add(new LoggingApplicationListener()); 		listeners.add(new RemoteUrlPropertyExtractor()); 		return listeners; 	}
@Override 	public void initialize(ConfigurableApplicationContext applicationContext) { 		new org.springframework.boot.context.config.ConfigFileApplicationListener() { 			public void apply() { 				addPropertySources(applicationContext.getEnvironment(), applicationContext); 				addPostProcessors(applicationContext); 			} 		}.apply(); 	}
private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, 			ApplicationArguments applicationArguments) { 		// Create and configure the environment 		ConfigurableEnvironment environment = getOrCreateEnvironment(); 		configureEnvironment(environment, applicationArguments.getSourceArgs()); 		ConfigurationPropertySources.attach(environment); 		listeners.environmentPrepared(environment); 		DefaultPropertiesPropertySource.moveToEnd(environment); 		configureAdditionalProfiles(environment); 		bindToSpringApplication(environment); 		if (!this.isCustomEnvironment) { 			environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, 					deduceEnvironmentClass()); 		} 		ConfigurationPropertySources.attach(environment); 		return environment; 	}
protected void configureProfiles(ConfigurableEnvironment environment, String[] args) { 	}
public void setAdditionalProfiles(String... profiles) { 		this.additionalProfiles = Collections.unmodifiableSet(new LinkedHashSet<>(Arrays.asList(profiles))); 	}
@Deprecated 	@Override 	public void onApplicationEvent(ApplicationPreparedEvent event) { 		if (this.switchableLogger) { 			((DeferredLog) this.logger).switchTo(CloudFoundryVcapEnvironmentPostProcessor.class); 		} 	}
private Properties getPropertiesFromApplication(Environment environment, JsonParser parser) { 		Properties properties = new Properties(); 		try { 			String property = environment.getProperty(VCAP_APPLICATION, "{}"); 			Map<String, Object> map = parser.parseMap(property); 			extractPropertiesFromApplication(properties, map); 		} 		catch (Exception ex) { 			this.logger.error("Could not parse VCAP_APPLICATION", ex); 		} 		return properties; 	}
private Properties getPropertiesFromServices(Environment environment, JsonParser parser) { 		Properties properties = new Properties(); 		try { 			String property = environment.getProperty(VCAP_SERVICES, "{}"); 			Map<String, Object> map = parser.parseMap(property); 			extractPropertiesFromServices(properties, map); 		} 		catch (Exception ex) { 			this.logger.error("Could not parse VCAP_SERVICES", ex); 		} 		return properties; 	}
@Override 	public int getOrder() { 		// Apply after EnvironmentPostProcessorApplicationListener 		return EnvironmentPostProcessorApplicationListener.DEFAULT_ORDER + 1; 	}
@Override 	public void onApplicationEvent(ApplicationEvent event) { 		throw new IllegalStateException( 				"ConfigFileApplicationListener is deprected and can only be used as an EnvironmentPostProcessor"); 	}
@Override 		public int getOrder() { 			return Ordered.HIGHEST_PRECEDENCE; 		}
@Override 	public int getOrder() { 		return this.order; 	}
private void reorderSources(ConfigurableEnvironment environment) { 			DefaultPropertiesPropertySource.moveToEnd(environment); 		}
void load() { 			FilteredPropertySource.apply(this.environment, DefaultPropertiesPropertySource.NAME, LOAD_FILTERED_PROPERTY, 					this::loadWithFilteredProperties); 		}
private void addLoadedPropertySource(MutablePropertySources destination, String lastAdded, 				PropertySource<?> source) { 			if (lastAdded == null) { 				if (destination.contains(DefaultPropertiesPropertySource.NAME)) { 					destination.addBefore(DefaultPropertiesPropertySource.NAME, source); 				} 				else { 					destination.addLast(source); 				} 			} 			else { 				destination.addAfter(lastAdded, source); 			} 		}
@Override 		public boolean equals(Object obj) { 			if (this == obj) { 				return true; 			} 			if (obj == null || getClass() != obj.getClass()) { 				return false; 			} 			DocumentsCacheKey other = (DocumentsCacheKey) obj; 			return this.loader.equals(other.loader) && this.resource.equals(other.resource); 		}
@Override 		public int hashCode() { 			return this.loader.hashCode() * 31 + this.resource.hashCode(); 		}
@Override 		public String toString() { 			return this.propertySource.toString(); 		}
@Override 		public boolean equals(Object obj) { 			if (obj == this) { 				return true; 			} 			if (obj == null || obj.getClass() != getClass()) { 				return false; 			} 			return ((Profile) obj).name.equals(this.name); 		}
@Override 		public int hashCode() { 			return this.name.hashCode(); 		}
@Override 		public String toString() { 			return this.name; 		}
@Override 	public Object getProperty(String name) { 		if (!name.startsWith(PREFIX)) { 			return null; 		} 		logger.trace(LogMessage.format("Generating random property for '%s'", name)); 		return getRandomValue(name.substring(PREFIX.length())); 	}
public static void addToEnvironment(ConfigurableEnvironment environment) { 		addToEnvironment(environment, logger); 	}
@Test 	void addProfilesOrder() { 		SpringApplication application = new SpringApplication(ExampleConfig.class); 		application.setWebApplicationType(WebApplicationType.NONE); 		application.setAdditionalProfiles("foo"); 		ConfigurableEnvironment environment = new StandardEnvironment(); 		application.setEnvironment(environment); 		this.context = application.run("--spring.profiles.active=bar,spam"); 		// Since Boot 2.4 additional should always be last 		assertThat(environment.getActiveProfiles()).containsExactly("bar", "spam", "foo"); 	}
@Override 			public void run() { 				SpringApplication application = new SpringApplication(FailingConfig.class); 				application.setWebApplicationType(WebApplicationType.NONE); 				application.run(); 			}
@Override 		public void registerShutdownHook() { 			this.applicationContext.registerShutdownHook(); 		}
@Test 	void run() { 		this.context = SpringApplication.run(ExampleWebConfig.class); 		assertThat(this.context).isNotNull(); 	}
@Test 	void registerShutdownHook() { 		SpringApplication application = new SpringApplication(ExampleConfig.class); 		application.setApplicationContextFactory(ApplicationContextFactory.ofContextClass(SpyApplicationContext.class)); 		this.context = application.run(); 		SpyApplicationContext applicationContext = (SpyApplicationContext) this.context; 		verify(applicationContext.getApplicationContext()).registerShutdownHook(); 	}
@Bean 		String someBean() { 			return "override"; 		}
@Bean 		String someBean() { 			return "test"; 		}
@PostConstruct 		void fail() { 			throw new RefreshFailureException(); 		}
@Bean 		CommandLineRunner runner() { 			return (args) -> { 				throw new IllegalStateException(); 			}; 		}
@Bean 		CommandLineRunner runner() { 			return (args) -> { 				throw new IllegalStateException(new ExitStatusException()); 			}; 		}
@Bean 		Object fail() { 			throw new RuntimeException("ExpectedError"); 		}
Integer getExitCode() { 			return this.exitCode; 		}
@Override 		public int getExitCode() { 			return 11; 		}
@AfterEach 	void cleanUp() { 		if (this.context != null) { 			this.context.close(); 		} 		System.clearProperty("the.property"); 		System.clearProperty("spring.config.location"); 		this.logger.setLevel(this.existingLogLevel); 	}
@Test 	void moreSpecificLocationTakesPrecedenceOverRoot() { 		// checking order of default locations 		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, "spring.config.name=specific"); 		this.initializer.postProcessEnvironment(this.environment, this.application); 		String property = this.environment.getProperty("my.property"); 		assertThat(property).isEqualTo("specific"); 	}
@Test 	void randomValue() { 		// dont need 		this.initializer.postProcessEnvironment(this.environment, this.application); 		String property = this.environment.getProperty("random.value"); 		assertThat(property).isNotNull(); 	}
@Test 	void loadDefaultYamlDocument() { 		// makes sense 		this.environment.setDefaultProfiles("thedefault"); 		this.initializer.setSearchNames("testprofilesdocument"); 		this.initializer.postProcessEnvironment(this.environment, this.application); 		String property = this.environment.getProperty("my.property"); 		assertThat(property).isEqualTo("fromdefaultprofile"); 	}
@Test 	void includedProfilesFromDefaultPropertiesShouldNotTakePrecedence() { 		// required? 		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, 				"spring.profiles.active=morespecific"); 		this.environment.getPropertySources().addLast( 				new MapPropertySource("defaultProperties", Collections.singletonMap("spring.profiles.include", "dev"))); 		this.initializer.postProcessEnvironment(this.environment, this.application); 		assertThat(this.environment.getActiveProfiles()).containsExactly("dev", "morespecific", "yetmorespecific"); 	}
@Test 	void profilesAddedToEnvironmentAndViaPropertyDuplicateEnvironmentWins(CapturedOutput output) { 		// ? 		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, "spring.profiles.active=other,dev"); 		this.environment.addActiveProfile("other"); 		this.initializer.postProcessEnvironment(this.environment, this.application); 		assertThat(this.environment.getActiveProfiles()).contains("dev", "other"); 		assertThat(this.environment.getProperty("my.property")).isEqualTo("fromdevpropertiesfile"); 		validateProfilePreference(output, null, "other", "dev"); 	}
private void validateProfilePreference(CapturedOutput output, String... profiles) { 		String log = output.toString(); 		// First make sure that each profile got processed only once 		for (String profile : profiles) { 			String reason = "Wrong number of occurrences for profile '" + profile + "' --> " + log; 			assertThat(StringUtils.countOccurrencesOf(log, createLogForProfile(profile))).as(reason).isEqualTo(1); 		} 		// Make sure the order of loading is the right one 		for (String profile : profiles) { 			String line = createLogForProfile(profile); 			int index = log.indexOf(line); 			assertThat(index).as("Loading profile '" + profile + "' not found in '" + log + "'").isNotEqualTo(-1); 			log = log.substring(index + line.length()); 		} 	}
@Test 	void absoluteResourceDefaultsToFile() { 		// ? 		String location = new File("src/test/resources/specificlocation.properties").getAbsolutePath().replace("\\", 				"/"); 		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, 				"spring.config.location=" + location); 		this.initializer.postProcessEnvironment(this.environment, this.application); 		assertThat(this.environment).has( 				matchingPropertySource("applicationConfig: [file:" + location.replace(File.separatorChar, '/') + "]")); 	}
@Override 			public boolean matches(ConfigurableEnvironment value) { 				return value.acceptsProfiles(Profiles.of(profile)); 			}
@Override 			public boolean matches(ConfigurableEnvironment value) { 				return value.getPropertySources().contains(sourceName); 			}
@Bean 		ConfigurableWebBindingInitializer customConfigurableWebBindingInitializer() { 			return new CustomWebBindingInitializer(); 		}
@Test 	void validatorWithConfigurerShouldUseSpringValidator() { 		this.contextRunner.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class)) 				.withUserConfiguration(MvcValidator.class).run((context) -> { 					assertThat(context).getBeanNames(javax.validation.Validator.class).containsOnly("defaultValidator"); 					assertThat(context).getBeanNames(Validator.class).containsOnly("defaultValidator", "mvcValidator"); 					Validator expectedValidator = context.getBean(MvcValidator.class).validator; 					assertThat(context.getBean("mvcValidator")).isSameAs(expectedValidator); 					assertThat(context.getBean(RequestMappingHandlerAdapter.class).getWebBindingInitializer()) 							.hasFieldOrPropertyWithValue("validator", expectedValidator); 				}); 	}
@Override 		public void addResourceHandlers(ResourceHandlerRegistry registry) { 			registry.addResourceHandler("/**").addResourceLocations("classpath:/foo/"); 		}
@Override 		public void addResourceHandlers(ResourceHandlerRegistry registry) { 			registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/foo/"); 		}
@Test 	void customConfigurableWebBindingInitializer() { 		this.contextRunner.withUserConfiguration(CustomConfigurableWebBindingInitializer.class).run( 				(context) -> assertThat(context.getBean(RequestMappingHandlerAdapter.class).getWebBindingInitializer()) 						.isInstanceOf(CustomWebBindingInitializer.class)); 	}
@Override 	protected FailureAnalysis analyze(Throwable rootFailure, NoSuchBeanDefinitionException cause, String description) { 		if (cause.getNumberOfBeansFound() != 0) { 			return null; 		} 		List<AutoConfigurationResult> autoConfigurationResults = getAutoConfigurationResults(cause); 		List<UserConfigurationResult> userConfigurationResults = getUserConfigurationResults(cause); 		StringBuilder message = new StringBuilder(); 		message.append(String.format("%s required %s that could not be found.%n", 				(description != null) ? description : "A component", getBeanDescription(cause))); 		InjectionPoint injectionPoint = findInjectionPoint(rootFailure); 		if (injectionPoint != null) { 			Annotation[] injectionAnnotations = injectionPoint.getAnnotations(); 			if (injectionAnnotations.length > 0) { 				message.append(String.format("%nThe injection point has the following annotations:%n")); 				for (Annotation injectionAnnotation : injectionAnnotations) { 					message.append(String.format("\t- %s%n", injectionAnnotation)); 				} 			} 		} 		if (!autoConfigurationResults.isEmpty() || !userConfigurationResults.isEmpty()) { 			message.append(String.format("%nThe following candidates were found but could not be injected:%n")); 			for (AutoConfigurationResult result : autoConfigurationResults) { 				message.append(String.format("\t- %s%n", result)); 			} 			for (UserConfigurationResult result : userConfigurationResults) { 				message.append(String.format("\t- %s%n", result)); 			} 		} 		String action = String.format("Consider %s %s in your configuration.", 				(!autoConfigurationResults.isEmpty() || !userConfigurationResults.isEmpty()) 						? "revisiting the entries above or defining" : "defining", 				getBeanDescription(cause)); 		if (injectionPoint != null && injectionPoint.getMember() instanceof Constructor) { 			Constructor<?> constructor = (Constructor<?>) injectionPoint.getMember(); 			Class<?> declaringClass = constructor.getDeclaringClass(); 			MergedAnnotation<ConfigurationProperties> configurationProperties = MergedAnnotations.from(declaringClass) 					.get(ConfigurationProperties.class); 			if (configurationProperties.isPresent()) { 				action = String.format( 						"%s%nConsider adding @%s to %s if you intended to use constructor-based " 								+ "configuration property binding.", 						action, ConstructorBinding.class.getSimpleName(), constructor.getName()); 			} 		} 		return new FailureAnalysis(message.toString(), action, cause); 	}
@Override 		public String toString() { 			StringBuilder sb = new StringBuilder("User-defined bean"); 			if (this.methodMetadata != null) { 				sb.append(String.format(" method '%s' in '%s'", this.methodMetadata.getMethodName(), 						ClassUtils.getShortName(this.methodMetadata.getDeclaringClassName()))); 			} 			if (this.nullBean) { 				sb.append(" ignored as the bean value is null"); 			} 			return sb.toString(); 		}
@Override 		public String toString() { 			return String.format("Bean method '%s' in '%s' not loaded because %s", this.methodMetadata.getMethodName(), 					ClassUtils.getShortName(this.methodMetadata.getDeclaringClassName()), 					this.conditionOutcome.getMessage()); 		}
private void assertActionMissingType(FailureAnalysis analysis, Class<?> type) { 		assertThat(analysis.getAction()).startsWith(String.format( 				"Consider revisiting the entries above or defining a bean of type '%s' in your configuration.", 				type.getName())); 		assertThat(analysis.getAction()).doesNotContain("@ConstructorBinding"); 	}
@Bean 		String string() { 			return null; 		}
@Bean 		String string() { 			return null; 		}
@Bean 		String string() { 			return null; 		}
@ConditionalOnProperty("spring.string.enabled") 		@Bean 		String string() { 			return "Test"; 		}
@Bean 		String string() { 			return "Test"; 		}
@ConditionalOnBean(Integer.class) 		@Bean(name = "test-string") 		String string() { 			return "Test"; 		}
private ContextConfigurationProperties describeConfigurationProperties(ApplicationContext context, 			ObjectMapper mapper) { 		Map<String, ConfigurationPropertiesBean> beans = ConfigurationPropertiesBean.getAll(context); 		Map<String, ConfigurationPropertiesBeanDescriptor> descriptors = new HashMap<>(); 		beans.forEach((beanName, bean) -> { 			String prefix = bean.getAnnotation().prefix(); 			descriptors.put(beanName, new ConfigurationPropertiesBeanDescriptor(prefix, 					sanitize(prefix, safeSerialize(mapper, bean.getInstance(), prefix)))); 		}); 		return new ContextConfigurationProperties(descriptors, 				(context.getParent() != null) ? context.getParent().getId() : null); 	}
@Override 		public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { 			this.applicationContext = applicationContext; 		}
@Override 	public void afterPropertiesSet() throws Exception { 		// We can't use constructor injection of the application context because 		// it causes eager factory bean initialization 		this.registry = (BeanDefinitionRegistry) this.applicationContext.getAutowireCapableBeanFactory(); 		this.binder = ConfigurationPropertiesBinder.get(this.applicationContext); 	}
@Override 	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { 		ConfigurationPropertiesBean configurationPropertiesBean = ConfigurationPropertiesBean 				.get(this.applicationContext, bean, beanName); 		if (configurationPropertiesBean != null && !hasBoundValueObject(beanName)) { 			try { 				this.binder.bind(configurationPropertiesBean.asBindTarget()); 			} 			catch (Exception ex) { 				throw new ConfigurationPropertiesBindException(configurationPropertiesBean, ex); 			} 		} 		return bean; 	}
@Override 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { 		// Spring Cloud Function may call this with a null importingClassMetadata 		if (importingClassMetadata == null) { 			EnableConfigurationPropertiesRegistrar.registerInfrastructureBeans(registry); 			return; 		} 		new EnableConfigurationPropertiesRegistrar().registerBeanDefinitions(importingClassMetadata, registry); 	}
@Override 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { 		Set<String> packagesToScan = getPackagesToScan(importingClassMetadata); 		scan(registry, packagesToScan); 	}
private Set<String> getPackagesToScan(AnnotationMetadata metadata) { 		AnnotationAttributes attributes = AnnotationAttributes 				.fromMap(metadata.getAnnotationAttributes(ConfigurationPropertiesScan.class.getName())); 		String[] basePackages = attributes.getStringArray("basePackages"); 		Class<?>[] basePackageClasses = attributes.getClassArray("basePackageClasses"); 		Set<String> packagesToScan = new LinkedHashSet<>(Arrays.asList(basePackages)); 		for (Class<?> basePackageClass : basePackageClasses) { 			packagesToScan.add(ClassUtils.getPackageName(basePackageClass)); 		} 		if (packagesToScan.isEmpty()) { 			packagesToScan.add(ClassUtils.getPackageName(metadata.getClassName())); 		} 		packagesToScan.removeIf((candidate) -> !StringUtils.hasText(candidate)); 		return packagesToScan; 	}
PropertySources getPropertySources() { 		PropertySourcesPlaceholderConfigurer configurer = getSinglePropertySourcesPlaceholderConfigurer(); 		if (configurer != null) { 			return configurer.getAppliedPropertySources(); 		} 		MutablePropertySources sources = extractEnvironmentPropertySources(); 		Assert.state(sources != null, 				"Unable to obtain PropertySources from PropertySourcesPlaceholderConfigurer or Environment"); 		return sources; 	}
@Test 	void registerBeanDefintionsShouldScanForConfigurationProperties() throws IOException { 		this.registrar.registerBeanDefinitions(getAnnotationMetadata(ConfigurationPropertiesScanConfiguration.class), 				this.beanFactory); 		BeanDefinition bingDefinition = this.beanFactory.getBeanDefinition( 				"bing-org.springframework.boot.context.properties.scan.valid.ConfigurationPropertiesScanConfiguration$BingProperties"); 		BeanDefinition fooDefinition = this.beanFactory.getBeanDefinition( 				"foo-org.springframework.boot.context.properties.scan.valid.ConfigurationPropertiesScanConfiguration$FooProperties"); 		BeanDefinition barDefinition = this.beanFactory.getBeanDefinition( 				"bar-org.springframework.boot.context.properties.scan.valid.ConfigurationPropertiesScanConfiguration$BarProperties"); 		assertThat(bingDefinition).isExactlyInstanceOf(GenericBeanDefinition.class); 		assertThat(fooDefinition).isExactlyInstanceOf(GenericBeanDefinition.class); 		assertThat(barDefinition).isExactlyInstanceOf(ConfigurationPropertiesValueObjectBeanDefinition.class); 	}
@Test 	void scanWhenBasePackagesAndBasePackcageClassesProvidedShouldUseThat() throws IOException { 		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); 		beanFactory.setAllowBeanDefinitionOverriding(false); 		this.registrar.registerBeanDefinitions( 				getAnnotationMetadata(ConfigurationPropertiesScanConfiguration.DifferentPackageConfiguration.class), 				beanFactory); 		assertThat(beanFactory.containsBeanDefinition( 				"foo-org.springframework.boot.context.properties.scan.valid.ConfigurationPropertiesScanConfiguration$FooProperties")) 						.isFalse(); 		BeanDefinition aDefinition = beanFactory.getBeanDefinition( 				"a-org.springframework.boot.context.properties.scan.valid.a.AScanConfiguration$AProperties"); 		BeanDefinition bFirstDefinition = beanFactory.getBeanDefinition( 				"b.first-org.springframework.boot.context.properties.scan.valid.b.BScanConfiguration$BFirstProperties"); 		BeanDefinition bSecondDefinition = beanFactory.getBeanDefinition( 				"b.second-org.springframework.boot.context.properties.scan.valid.b.BScanConfiguration$BSecondProperties"); 		assertThat(aDefinition).isExactlyInstanceOf(GenericBeanDefinition.class); 		// Constructor injection 		assertThat(bFirstDefinition).isExactlyInstanceOf(ConfigurationPropertiesValueObjectBeanDefinition.class); 		// Post-processing injection 		assertThat(bSecondDefinition).isExactlyInstanceOf(GenericBeanDefinition.class); 	}
@Test 	void loadWhenBindingWithoutAndAnnotationShouldFail() { 		assertThatIllegalStateException().isThrownBy(() -> load(WithoutAndAnnotationConfiguration.class, "name:foo")) 				.withMessageContaining("No ConfigurationProperties annotation found"); 	}
@PostConstruct 		void init() { 			assertThat(this.properties).isNotNull(); 		}
@Bean 		static PropertySourcesPlaceholderConfigurer configurer() { 			PropertySourcesPlaceholderConfigurer placeholderConfigurer = new PropertySourcesPlaceholderConfigurer(); 			Properties properties = new Properties(); 			properties.put("com.example.bar", "b"); 			placeholderConfigurer.setProperties(properties); 			return placeholderConfigurer; 		}
@Bean 		static PropertySourcesPlaceholderConfigurer configurer() { 			return new PropertySourcesPlaceholderConfigurer(); 		}
void setName(String name) { 			this.name = name; 		}
void setName(String name) { 				this.name = name; 			}
void setName(String name) { 			this.name = name; 		}
public void setName(String name) { 			// Must be public for XML 			this.name = name; 		}
void setName(String name) { 				this.name = name; 			}
public void setName(String name) { 			// Must be public for XML 			this.name = name; 		}
void setName(String name) { 			this.name = name; 		}
void setName(String name) { 			this.name = name; 		}
public void setName(String name) { 			// Must be public for XML 			this.name = name; 		}
void setName(String name) { 				this.name = name; 			}
@PostConstruct 		void init() { 			assertThat(this.bar).isNotNull(); 			this.initialized = true; 		}
void setFoo(String foo) { 			this.foo = foo; 			if (!foo.equals("bar")) { 				throw new IllegalArgumentException("Wrong value for foo"); 			} 		}
@Override 		public boolean supports(Class<?> type) { 			return type == WithCustomValidatorProperties.class; 		}
void setFoo(String foo) { 			this.foo = foo; 			if (!foo.equals("bar")) { 				throw new IllegalArgumentException("Wrong value for foo"); 			} 		}
void setFoo(String foo) { 			this.foo = foo; 		}
void setFoo(String foo) { 			this.foo = foo; 		}
void setFoo(String foo) { 			this.foo = foo; 		}
void setFoo(String foo) { 			this.foo = foo; 			if (!foo.equals("bar")) { 				throw new IllegalArgumentException("Wrong value for foo"); 			} 		}
@Override 		public boolean supports(Class<?> type) { 			return type == ValidatorProperties.class; 		}
private void inject(Field field, Object target, String beanName) { 		try { 			field.setAccessible(true); 			Assert.state(ReflectionUtils.getField(field, target) == null, 					() -> "The field " + field + " cannot have an existing value"); 			Object bean = this.beanFactory.getBean(beanName, field.getType()); 			if (bean instanceof ScopedObject) { 				bean = ((ScopedObject) bean).getTargetObject(); 			} 			ReflectionUtils.setField(field, target, bean); 		} 		catch (Throwable ex) { 			throw new BeanCreationException("Could not inject field: " + field, ex); 		} 	}
@Override 		public int getOrder() { 			return Ordered.HIGHEST_PRECEDENCE; 		}
public static void register(BeanDefinitionRegistry registry) { 			if (!registry.containsBeanDefinition(BEAN_NAME)) { 				RootBeanDefinition definition = new RootBeanDefinition(SpyPostProcessor.class); 				definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); 				ConstructorArgumentValues constructorArguments = definition.getConstructorArgumentValues(); 				constructorArguments.addIndexedArgumentValue(0, 						new RuntimeBeanReference(MockitoPostProcessor.BEAN_NAME)); 				registry.registerBeanDefinition(BEAN_NAME, definition); 			} 		}
@Override 	public int getOrder() { 		return Ordered.LOWEST_PRECEDENCE - 10; 	}
@Override 		public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException { 			return this.mockitoPostProcessor.createSpyIfNecessary(bean, getOriginalBeanNameIfScopedTarget(beanName)); 		}
@Override 		public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { 			if (bean instanceof FactoryBean || bean instanceof ScopedObject) { 				return bean; 			} 			return this.mockitoPostProcessor.createSpyIfNecessary(bean, getOriginalBeanNameIfScopedTarget(beanName)); 		}
public static void register(BeanDefinitionRegistry registry) { 		register(registry, null); 	}
@Bean 		Jackson2ObjectMapperBuilderCustomizer customDateFormat() { 			return (builder) -> builder.dateFormat(new MyDateFormat()); 		}
@Bean 		@Primary 		ObjectMapper objectMapper() { 			ObjectMapper mapper = new ObjectMapper(); 			mapper.registerModule(jacksonModule()); 			return mapper; 		}
@Bean 		Module jacksonModule() { 			SimpleModule module = new SimpleModule(); 			module.addSerializer(Foo.class, new JsonSerializer<Foo>() {  				@Override 				public void serialize(Foo value, JsonGenerator jgen, SerializerProvider provider) throws IOException { 					jgen.writeStartObject(); 					jgen.writeStringField("foo", "bar"); 					jgen.writeEndObject(); 				} 			}); 			return module; 		}
@Bean 		CustomModule jacksonModule() { 			return new CustomModule(); 		}
@Bean 		@Primary 		ObjectMapper objectMapper() { 			return mock(ObjectMapper.class); 		}
@Test 	void customDateFormat() { 		this.contextRunner.withPropertyValues("spring.jackson.date-format:yyyyMMddHHmmss").run((context) -> { 			ObjectMapper mapper = context.getBean(ObjectMapper.class); 			DateFormat dateFormat = mapper.getDateFormat(); 			assertThat(dateFormat).isInstanceOf(SimpleDateFormat.class); 			assertThat(((SimpleDateFormat) dateFormat).toPattern()).isEqualTo("yyyyMMddHHmmss"); 		}); 	}
private boolean canBindAtCreationTime(Class<?> type) { 			List<Constructor<?>> constructors = determineConstructors(type); 			boolean autowiredPresent = constructors.stream().anyMatch( 					(c) -> AnnotationUtils.findAnnotation(c, Autowired.class) != null); 			if (autowiredPresent) { 				return false; 			} 			return (constructors.size() == 1 					&& constructors.get(0).getParameterCount() > 0); 		}
@SuppressWarnings("unchecked") 	private void customize(MeterRegistry registry) { 		LambdaSafe 				.callbacks(MeterRegistryCustomizer.class, asOrderedList(this.customizers), 						registry) 				.withLogger(MeterRegistryConfigurer.class) 				.invoke((customizer) -> customizer.customize(registry)); 	}
private void addFilters(MeterRegistry registry) { 		this.filters.orderedStream().forEach(registry.config()::meterFilter); 	}
private void addBinders(MeterRegistry registry) { 		this.binders.orderedStream().forEach((binder) -> binder.bindTo(registry)); 	}
private MeterRegistryConfigurer getConfigurer() { 		if (this.configurer == null) { 			this.configurer = new MeterRegistryConfigurer(this.meterRegistryCustomizers, 					this.meterFilters, this.meterBinders, 					this.metricsProperties.getObject().isUseGlobalRegistry()); 		} 		return this.configurer; 	}
@Test 	public void configureWhenCompositeShouldApplyCustomizer() { 		this.customizers.add(this.mockCustomizer); 		MeterRegistryConfigurer configurer = new MeterRegistryConfigurer( 				createObjectProvider(this.customizers), 				createObjectProvider(this.filters), createObjectProvider(this.binders), 				false); 		CompositeMeterRegistry composite = new CompositeMeterRegistry(); 		configurer.configure(composite); 		verify(this.mockCustomizer).customize(composite); 	}
@Test 	public void configureShouldApplyCustomizer() { 		this.customizers.add(this.mockCustomizer); 		MeterRegistryConfigurer configurer = new MeterRegistryConfigurer( 				createObjectProvider(this.customizers), 				createObjectProvider(this.filters), createObjectProvider(this.binders), 				false); 		configurer.configure(this.mockRegistry); 		verify(this.mockCustomizer).customize(this.mockRegistry); 	}
@Test 	public void configureShouldApplyFilter() { 		this.filters.add(this.mockFilter); 		MeterRegistryConfigurer configurer = new MeterRegistryConfigurer( 				createObjectProvider(this.customizers), 				createObjectProvider(this.filters), createObjectProvider(this.binders), 				false); 		configurer.configure(this.mockRegistry); 		verify(this.mockConfig).meterFilter(this.mockFilter); 	}
@Test 	public void configureShouldApplyBinder() { 		this.binders.add(this.mockBinder); 		MeterRegistryConfigurer configurer = new MeterRegistryConfigurer( 				createObjectProvider(this.customizers), 				createObjectProvider(this.filters), createObjectProvider(this.binders), 				false); 		configurer.configure(this.mockRegistry); 		verify(this.mockBinder).bindTo(this.mockRegistry); 	}
@Test 	public void configureShouldBeCalledInOrderCustomizerFilterBinder() { 		this.customizers.add(this.mockCustomizer); 		this.filters.add(this.mockFilter); 		this.binders.add(this.mockBinder); 		MeterRegistryConfigurer configurer = new MeterRegistryConfigurer( 				createObjectProvider(this.customizers), 				createObjectProvider(this.filters), createObjectProvider(this.binders), 				false); 		configurer.configure(this.mockRegistry); 		InOrder ordered = inOrder(this.mockBinder, this.mockConfig, this.mockCustomizer); 		ordered.verify(this.mockCustomizer).customize(this.mockRegistry); 		ordered.verify(this.mockConfig).meterFilter(this.mockFilter); 		ordered.verify(this.mockBinder).bindTo(this.mockRegistry); 	}
@Test 	public void configureWhenAddToGlobalRegistryShouldAddToGlobalRegistry() { 		MeterRegistryConfigurer configurer = new MeterRegistryConfigurer( 				createObjectProvider(this.customizers), 				createObjectProvider(this.filters), createObjectProvider(this.binders), 				true); 		try { 			configurer.configure(this.mockRegistry); 			assertThat(Metrics.globalRegistry.getRegistries()) 					.contains(this.mockRegistry); 		} 		finally { 			Metrics.removeRegistry(this.mockRegistry); 		} 	}
@Test 	public void configureWhenNotAddToGlobalRegistryShouldAddToGlobalRegistry() { 		MeterRegistryConfigurer configurer = new MeterRegistryConfigurer( 				createObjectProvider(this.customizers), 				createObjectProvider(this.filters), createObjectProvider(this.binders), 				false); 		configurer.configure(this.mockRegistry); 		assertThat(Metrics.globalRegistry.getRegistries()) 				.doesNotContain(this.mockRegistry); 	}
@Override 	protected FailureAnalysis analyze(Throwable rootFailure, 			NoSuchBeanDefinitionException cause, String description) { 		if (cause.getNumberOfBeansFound() != 0) { 			return null; 		} 		List<AutoConfigurationResult> autoConfigurationResults = getAutoConfigurationResults( 				cause); 		List<UserConfigurationResult> userConfigurationResults = getUserConfigurationResults( 				cause); 		StringBuilder message = new StringBuilder(); 		message.append(String.format("%s required %s that could not be found.%n", 				(description != null ? description : "A component"), 				getBeanDescription(cause))); 		if (!autoConfigurationResults.isEmpty()) { 			for (AutoConfigurationResult result : autoConfigurationResults) { 				message.append(String.format("\t- %s%n", result)); 			} 		} 		if (!userConfigurationResults.isEmpty()) { 			for (UserConfigurationResult result : userConfigurationResults) { 				message.append(String.format("\t- %s%n", result)); 			} 		} 		String action = String.format("Consider %s %s in your configuration.", 				(!autoConfigurationResults.isEmpty() 						|| !userConfigurationResults.isEmpty() 								? "revisiting the entries above or defining" 								: "defining"), 				getBeanDescription(cause)); 		return new FailureAnalysis(message.toString(), action, cause); 	}
@Override 		public String toString() { 			StringBuilder sb = new StringBuilder("User-defined bean"); 			if (this.methodMetadata != null) { 				sb.append(String.format(" method '%s' in '%s'", 						this.methodMetadata.getMethodName(), ClassUtils.getShortName( 								this.methodMetadata.getDeclaringClassName()))); 			} 			if (this.nullBean) { 				sb.append(" ignored as the bean value is null"); 			} 			return sb.toString(); 		}
private void assertActionMissingType(FailureAnalysis analysis, Class<?> type) { 		assertThat(analysis.getAction()).startsWith(String.format( 				"Consider revisiting the entries above or defining a bean of type '%s' " 						+ "in your configuration.", 				type.getName())); 	}
private void assertActionMissingName(FailureAnalysis analysis, String name) { 		assertThat(analysis.getAction()).startsWith(String.format( 				"Consider revisiting the entries above or defining a bean named '%s' " 						+ "in your configuration.", 				name)); 	}
@Bean 		public String string() { 			return null; 		}
@Bean 		public String string() { 			return null; 		}
@Bean 		public String string() { 			return null; 		}
@Override 			public void setResourceLoader(ResourceLoader resourceLoader) { 				this.resourceLoader = resourceLoader; 			}
@Override 		public void configureMessageConverters(List<HttpMessageConverter<?>> converters) { 			this.messageConvertersProvider.ifAvailable((customConverters) -> converters 					.addAll(customConverters.getConverters())); 		}
@Override 		public void setResourceLoader(ResourceLoader resourceLoader) { 			this.resourceLoader = resourceLoader; 		}
private Iterable<String> getBeanNames(ListableBeanFactory beanFactory) { 		Set<String> names = new HashSet<>(); 		names.addAll(Arrays.asList(BeanFactoryUtils.beanNamesForTypeIncludingAncestors( 				beanFactory, this.beanClass, true, false))); 		if (this.factoryBeanClass != null) { 			for (String factoryBeanName : BeanFactoryUtils 					.beanNamesForTypeIncludingAncestors(beanFactory, 							this.factoryBeanClass, true, false)) { 				names.add(BeanFactoryUtils.transformedBeanName(factoryBeanName)); 			} 		} 		return names; 	}
@EventListener 		public void onClassPathChanged(ClassPathChangedEvent event) { 			if (event.isRestartRequired()) { 				Restarter.getInstance().restart( 						new FileWatchingFailureHandler(fileSystemWatcherFactory())); 			} 		}
@EventListener 		public void onClassPathChanged(ClassPathChangedEvent event) { 			if (!event.isRestartRequired()) { 				optionalLiveReloadServer().triggerReload(); 			} 		}
@PostConstruct 		public void validateMBeans() { 			HikariDataSource hikariDataSource = unwrapHikariDataSource(); 			if (hikariDataSource != null && hikariDataSource.isRegisterMbeans()) { 				this.mBeanExporter.ifUnique((exporter) -> 						exporter.addExcludedBean("dataSource")); 			} 		}
private void beforeTestMethod(TestContext testContext) throws Exception { 			ManualRestDocumentation restDocumentation = findManualRestDocumentation( 					testContext); 			if (restDocumentation != null) { 				restDocumentation.beforeTest(testContext.getTestClass(), 						testContext.getTestMethod().getName()); 			} 		}
private void afterTestMethod(TestContext testContext) { 			ManualRestDocumentation restDocumentation = findManualRestDocumentation( 					testContext); 			if (restDocumentation != null) { 				restDocumentation.afterTest(); 			} 		}
@Override 	public void beforeTestMethod(TestContext testContext) throws Exception { 		if (restDocsIsPresent()) { 			new DocumentationHandler().beforeTestMethod(testContext); 		} 	}
@Override 	public void afterTestMethod(TestContext testContext) throws Exception { 		if (restDocsIsPresent()) { 			new DocumentationHandler().afterTestMethod(testContext); 		} 	}
@EventListener 		public void onContextRefreshed(ContextRefreshedEvent event) { 			this.liveReloadServer.triggerReload(); 		}
@EventListener 		public void onClassPathChanged(ClassPathChangedEvent event) { 			if (event.isRestartRequired()) { 				Restarter.getInstance().restart( 						new FileWatchingFailureHandler(fileSystemWatcherFactory())); 			} 		}
@EventListener 		public void onClassPathChanged(ClassPathChangedEvent event) { 			if (!event.isRestartRequired()) { 				this.liveReloadServer.triggerReload(); 			} 		}
@EventListener 		public void onClassPathChanged(ClassPathChangedEvent event) { 			if (!event.isRestartRequired()) { 				this.liveReloadServer.triggerReload(); 			} 		}
@Bean 		public Validator customValidator() { 			return mock(Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		Validator customValidator() { 			return new CustomValidatorBean(); 		}
@Bean 		public OptionalValidatorFactoryBean customValidator() { 			return new OptionalValidatorFactoryBean(); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		Validator customValidator() { 			return new CustomValidatorBean(); 		}
@Bean 		public OptionalValidatorFactoryBean customValidator() { 			return new OptionalValidatorFactoryBean(); 		}
@Bean 		public Validator customValidator() { 			return mock(Validator.class); 		}
@Bean 		Validator customValidator() { 			return new CustomValidatorBean(); 		}
@Bean 		public OptionalValidatorFactoryBean customValidator() { 			return new OptionalValidatorFactoryBean(); 		}
@Bean 		public Validator customValidator() { 			return mock(Validator.class); 		}
@Bean 		Validator customValidator() { 			return new CustomValidatorBean(); 		}
@Bean 		public Validator customValidator() { 			return mock(Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		Validator customValidator() { 			return new CustomValidatorBean(); 		}
@Bean 		public OptionalValidatorFactoryBean customValidator() { 			return new OptionalValidatorFactoryBean(); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		Validator customValidator() { 			return new CustomValidatorBean(); 		}
@Bean 		public OptionalValidatorFactoryBean customValidator() { 			return new OptionalValidatorFactoryBean(); 		}
@Bean 		public Validator customValidator() { 			return mock(Validator.class); 		}
@Bean 		Validator customValidator() { 			return new CustomValidatorBean(); 		}
@Bean 		public OptionalValidatorFactoryBean customValidator() { 			return new OptionalValidatorFactoryBean(); 		}
@Bean 		public Validator customValidator() { 			return mock(Validator.class); 		}
@Bean 		Validator customValidator() { 			return new CustomValidatorBean(); 		}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			ConditionMessage.Builder message = ConditionMessage 					.forCondition("EmbeddedDataSource"); 			if (anyMatches(context, metadata, this.pooledCondition)) { 				return ConditionOutcome 						.noMatch(message.foundExactly("supported pooled data source")); 			} 			EmbeddedDatabaseType type = EmbeddedDatabaseConnection 					.get(context.getClassLoader()).getType(); 			if (type == null) { 				return ConditionOutcome 						.noMatch(message.didNotFind("embedded database").atAll()); 			} 			return ConditionOutcome.match(message.found("embedded database").items(type)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			ConditionMessage.Builder message = ConditionMessage 					.forCondition("DataSourceAvailable"); 			if (hasBean(context, DataSource.class) 					|| hasBean(context, XADataSource.class)) { 				return ConditionOutcome 						.match(message.foundExactly("existing data source bean")); 			} 			if (anyMatches(context, metadata, this.pooledCondition, 					this.embeddedCondition)) { 				return ConditionOutcome.match(message 						.foundExactly("existing auto-configured data source bean")); 			} 			return ConditionOutcome 					.noMatch(message.didNotFind("any existing data source bean").atAll()); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			ConditionMessage.Builder message = ConditionMessage 					.forCondition("PooledDataSource"); 			if (getDataSourceClassLoader(context) != null) { 				return ConditionOutcome 						.match(message.foundExactly("supported DataSource")); 			} 			return ConditionOutcome 					.noMatch(message.didNotFind("supported DataSource").atAll()); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			ConditionMessage.Builder message = ConditionMessage 					.forCondition("DataSourceAvailable"); 			if (hasBean(context, DataSource.class) 					|| hasBean(context, XADataSource.class)) { 				return ConditionOutcome 						.match(message.foundExactly("existing data source bean")); 			} 			if (anyMatches(context, metadata, this.pooledCondition, 					this.embeddedCondition)) { 				return ConditionOutcome.match(message 						.foundExactly("existing auto-configured data source bean")); 			} 			return ConditionOutcome 					.noMatch(message.didNotFind("any existing data source bean").atAll()); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			ConditionMessage.Builder message = ConditionMessage 					.forCondition("PooledDataSource"); 			if (getDataSourceClassLoader(context) != null) { 				return ConditionOutcome 						.match(message.foundExactly("supported DataSource")); 			} 			return ConditionOutcome 					.noMatch(message.didNotFind("supported DataSource").atAll()); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			ConditionMessage.Builder message = ConditionMessage 					.forCondition("EmbeddedDataSource"); 			if (anyMatches(context, metadata, this.pooledCondition)) { 				return ConditionOutcome 						.noMatch(message.foundExactly("supported pooled data source")); 			} 			EmbeddedDatabaseType type = EmbeddedDatabaseConnection 					.get(context.getClassLoader()).getType(); 			if (type == null) { 				return ConditionOutcome 						.noMatch(message.didNotFind("embedded database").atAll()); 			} 			return ConditionOutcome.match(message.found("embedded database").items(type)); 		}
@Bean 	@ConditionalOnMissingBean 	public EndpointHandlerMapping endpointHandlerMapping() { 		Set<MvcEndpoint> endpoints = mvcEndpoints().getEndpoints(); 		CorsConfiguration corsConfiguration = getCorsConfiguration(this.corsProperties); 		EndpointHandlerMapping mapping = new EndpointHandlerMapping(endpoints, 				corsConfiguration); 		mapping.setPrefix(this.managementServerProperties.getContextPath()); 		for (EndpointHandlerMappingCustomizer customizer : this.mappingCustomizers) { 			customizer.customize(mapping); 		} 		return mapping; 	}
@Bean 		@ConditionalOnBean(DispatcherServlet.class) 		@ConditionalOnMissingBean 		public DefaultErrorViewResolver conventionErrorViewResolver() { 			return new DefaultErrorViewResolver(this.applicationContext, 					this.resourceProperties); 		}
public Map<String, Expression> getExpressions() { 			return Collections.unmodifiableMap(this.expressions); 		}
private Map<String, Expression> getExpressions() { 			if (this.expressions == null) { 				synchronized (this) { 					ExpressionCollector expressionCollector = new ExpressionCollector(); 					this.helper.replacePlaceholders(this.template, expressionCollector); 					this.expressions = expressionCollector.getExpressions(); 				} 			} 			return this.expressions; 		}
private void parseMockBeanAnnotation(MockBean annotation, AnnotatedElement element) { 		Set<ResolvableType> typesToMock = getOrDeduceTypes(element, annotation.value()); 		Assert.state(!typesToMock.isEmpty(), 				"Unable to deduce type to mock from " + element); 		if (StringUtils.hasLength(annotation.name())) { 			Assert.state(typesToMock.size() == 1, 					"The name attribute can only be used when mocking a single class"); 		} 		for (ResolvableType typeToMock : typesToMock) { 			MockDefinition definition = new MockDefinition(element, annotation.name(), 					typeToMock,	annotation.extraInterfaces(), annotation.answer(), 					annotation.serializable(), annotation.reset()); 			addDefinition(definition, "mock"); 		} 	}
private void parseSpyBeanAnnotation(SpyBean annotation, AnnotatedElement element) { 		Set<ResolvableType> typesToSpy = getOrDeduceTypes(element, annotation.value()); 		Assert.state(!typesToSpy.isEmpty(), 				"Unable to deduce type to spy from " + element); 		if (StringUtils.hasLength(annotation.name())) { 			Assert.state(typesToSpy.size() == 1, 					"The name attribute can only be used when spying a single class"); 		} 		for (ResolvableType typeToSpy : typesToSpy) { 			SpyDefinition definition = new SpyDefinition(element, annotation.name(), 					typeToSpy, annotation.reset(), annotation.proxyTargetAware()); 			addDefinition(definition, "spy"); 		} 	}
private RootBeanDefinition createBeanDefinition(MockDefinition mockDefinition) { 		RootBeanDefinition definition = new RootBeanDefinition( 				mockDefinition.getTypeToMock().resolve()); 		definition.setTargetType(mockDefinition.getTypeToMock()); 		definition.setFactoryBeanName(BEAN_NAME); 		definition.setFactoryMethodName("createMock"); 		definition.getConstructorArgumentValues().addIndexedArgumentValue(0, 				mockDefinition); 		AnnotatedElement element = mockDefinition.getElement(); 		if (element instanceof Field) { 			definition.setQualifiedElement(element); 		} 		return definition; 	}
private String getBeanName(ConfigurableListableBeanFactory beanFactory, 			BeanDefinitionRegistry registry, MockDefinition mockDefinition, 			RootBeanDefinition beanDefinition) { 		if (StringUtils.hasLength(mockDefinition.getName())) { 			return mockDefinition.getName(); 		} 		String[] existingBeans = findCandidateBeans(beanFactory, mockDefinition); 		if (ObjectUtils.isEmpty(existingBeans)) { 			return this.beanNameGenerator.generateBeanName(beanDefinition, registry); 		} 		if (existingBeans.length == 1) { 			return existingBeans[0]; 		} 		throw new IllegalStateException( 				"Unable to register mock bean " + mockDefinition.getTypeToMock() 						+ " expected a single matching bean to replace but found " 						+ new TreeSet<String>(Arrays.asList(existingBeans))); 	}
private Object createSpyIfNecessary(Object bean, String beanName) { 			return this.mockitoPostProcessor.createSpyIfNecessary(bean, beanName); 		}
@Override 		public int getOrder() { 			return Ordered.HIGHEST_PRECEDENCE; 		}
public static void register(BeanDefinitionRegistry registry) { 			if (!registry.containsBeanDefinition(BEAN_NAME)) { 				RootBeanDefinition definition = new RootBeanDefinition( 						SpyPostProcessor.class); 				definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); 				ConstructorArgumentValues constructorArguments = definition 						.getConstructorArgumentValues(); 				constructorArguments.addIndexedArgumentValue(0, 						new RuntimeBeanReference(MockitoPostProcessor.BEAN_NAME)); 				registry.registerBeanDefinition(BEAN_NAME, definition); 			} 		}
@Override 	public int getOrder() { 		return Ordered.LOWEST_PRECEDENCE - 10; 	}
protected Object createSpyIfNecessary(Object bean, String beanName) 			throws BeansException { 		SpyDefinition definition = this.spies.get(beanName); 		if (definition != null) { 			bean = definition.createSpy(beanName, bean); 		} 		return bean; 	}
public static void register(BeanDefinitionRegistry registry) { 		register(registry, null); 	}
@Test 	public void parseMockBeanAttributes() throws Exception { 		this.parser.parse(MockBeanAttributes.class); 		assertThat(getDefinitions()).hasSize(1); 		MockDefinition definition = getMockDefinition(0); 		assertThat(definition.getElement()).isEqualTo(MockBeanAttributes.class); 		assertThat(definition.getName()).isEqualTo("Name"); 		assertThat(definition.getTypeToMock().resolve()).isEqualTo(ExampleService.class); 		assertThat(definition.getExtraInterfaces()) 				.containsExactly(ExampleExtraInterface.class); 		assertThat(definition.getAnswer()).isEqualTo(Answers.RETURNS_SMART_NULLS); 		assertThat(definition.isSerializable()).isEqualTo(true); 		assertThat(definition.getReset()).isEqualTo(MockReset.NONE); 	}
@Test 	public void parseMockBeanOnClassAndField() throws Exception { 		this.parser.parse(MockBeanOnClassAndField.class); 		assertThat(getDefinitions()).hasSize(2); 		MockDefinition classDefinition = getMockDefinition(0); 		assertThat(classDefinition.getElement()) 				.isEqualTo(MockBeanOnClassAndField.class); 		assertThat(classDefinition.getTypeToMock().resolve()) 				.isEqualTo(ExampleService.class); 		MockDefinition fieldDefinition = getMockDefinition(1); 		assertThat(fieldDefinition.getElement()).isEqualTo( 				ReflectionUtils.findField(MockBeanOnClassAndField.class, "caller")); 		assertThat(fieldDefinition.getTypeToMock().resolve()) 				.isEqualTo(ExampleServiceCaller.class); 	}
@Test 	public void parseSpyBeanAttributes() throws Exception { 		this.parser.parse(SpyBeanAttributes.class); 		assertThat(getDefinitions()).hasSize(1); 		SpyDefinition definition = getSpyDefinition(0); 		assertThat(definition.getElement()).isEqualTo(SpyBeanAttributes.class); 		assertThat(definition.getName()).isEqualTo("Name"); 		assertThat(definition.getTypeToSpy().resolve()) 				.isEqualTo(RealExampleService.class); 		assertThat(definition.getReset()).isEqualTo(MockReset.NONE); 	}
@Test 	public void parseSpyBeanOnClassAndField() throws Exception { 		this.parser.parse(SpyBeanOnClassAndField.class); 		assertThat(getDefinitions()).hasSize(2); 		SpyDefinition classDefinition = getSpyDefinition(0); 		assertThat(classDefinition.getElement()) 				.isEqualTo(SpyBeanOnClassAndField.class); 		assertThat(classDefinition.getTypeToSpy().resolve()) 				.isEqualTo(RealExampleService.class); 		SpyDefinition fieldDefinition = getSpyDefinition(1); 		assertThat(fieldDefinition.getElement()).isEqualTo( 				ReflectionUtils.findField(SpyBeanOnClassAndField.class, "caller")); 	}
@Test 	public void classToMockMustNotBeNull() throws Exception { 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("TypeToMock must not be null"); 		new MockDefinition(null, null, null, null, null, false, null); 	}
@Test 	public void createWithDefaults() throws Exception { 		MockDefinition definition = new MockDefinition(null, null, EXAMPLE_SERVICE_TYPE, 				null, null, false, null); 		assertThat(definition.getElement()).isNull(); 		assertThat(definition.getName()).isNull(); 		assertThat(definition.getTypeToMock()).isEqualTo(EXAMPLE_SERVICE_TYPE); 		assertThat(definition.getExtraInterfaces()).isEmpty(); 		assertThat(definition.getAnswer()).isEqualTo(Answers.RETURNS_DEFAULTS); 		assertThat(definition.isSerializable()).isFalse(); 		assertThat(definition.getReset()).isEqualTo(MockReset.AFTER); 	}
@Test 	public void createExplicit() throws Exception { 		MockDefinition definition = new MockDefinition(getClass(), "name", 				EXAMPLE_SERVICE_TYPE, 				new Class<?>[] { ExampleExtraInterface.class }, 				Answers.RETURNS_SMART_NULLS, true, MockReset.BEFORE); 		assertThat(definition.getElement()).isEqualTo(getClass()); 		assertThat(definition.getName()).isEqualTo("name"); 		assertThat(definition.getTypeToMock()).isEqualTo(EXAMPLE_SERVICE_TYPE); 		assertThat(definition.getExtraInterfaces()) 				.containsExactly(ExampleExtraInterface.class); 		assertThat(definition.getAnswer()).isEqualTo(Answers.RETURNS_SMART_NULLS); 		assertThat(definition.isSerializable()).isTrue(); 		assertThat(definition.getReset()).isEqualTo(MockReset.BEFORE); 		assertThat(definition.isProxyTargetAware()).isFalse(); 	}
@Test 	public void createMock() throws Exception { 		MockDefinition definition = new MockDefinition(null, "name", 				EXAMPLE_SERVICE_TYPE, 				new Class<?>[] { ExampleExtraInterface.class }, 				Answers.RETURNS_SMART_NULLS, true, MockReset.BEFORE); 		ExampleService mock = definition.createMock(); 		MockCreationSettings<?> settings = new MockUtil().getMockSettings(mock); 		assertThat(mock).isInstanceOf(ExampleService.class); 		assertThat(mock).isInstanceOf(ExampleExtraInterface.class); 		assertThat(settings.getMockName().toString()).isEqualTo("name"); 		assertThat(settings.getDefaultAnswer()) 				.isEqualTo(Answers.RETURNS_SMART_NULLS.get()); 		assertThat(settings.isSerializable()).isTrue(); 		assertThat(MockReset.get(mock)).isEqualTo(MockReset.BEFORE); 	}
@Test 	public void hashCodeAndEquals() { 		MockDefinition d1 = createTestMockDefinition(ExampleService.class); 		MockDefinition d2 = createTestMockDefinition(ExampleServiceCaller.class); 		MockitoContextCustomizer c1 = new MockitoContextCustomizer(NO_DEFINITIONS); 		MockitoContextCustomizer c2 = new MockitoContextCustomizer( 				new LinkedHashSet<MockDefinition>(Arrays.asList(d1, d2))); 		MockitoContextCustomizer c3 = new MockitoContextCustomizer( 				new LinkedHashSet<MockDefinition>(Arrays.asList(d2, d1))); 		assertThat(c2.hashCode()).isEqualTo(c3.hashCode()); 		assertThat(c1).isEqualTo(c1).isNotEqualTo(c2); 		assertThat(c2).isEqualTo(c2).isEqualTo(c3).isNotEqualTo(c1); 	}
@Test 	public void cannotMockMultipleBeans() { 		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); 		MockitoPostProcessor.register(context); 		context.register(MultipleBeans.class); 		this.thrown.expect(IllegalStateException.class); 		this.thrown.expectMessage( 				"Unable to register mock bean " + ExampleService.class.getName() 						+ " expected a single matching bean to replace " 						+ "but found [example1, example2]"); 		context.refresh(); 	}
@Test 	public void classToSpyMustNotBeNull() throws Exception { 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("TypeToSpy must not be null"); 		new SpyDefinition(null, null, null, null, true); 	}
@Test 	public void createWithDefaults() throws Exception { 		SpyDefinition definition = new SpyDefinition(null, null, REAL_SERVICE_TYPE, null, true); 		assertThat(definition.getElement()).isNull(); 		assertThat(definition.getName()).isNull(); 		assertThat(definition.getTypeToSpy()).isEqualTo(REAL_SERVICE_TYPE); 		assertThat(definition.getReset()).isEqualTo(MockReset.AFTER); 		assertThat(definition.isProxyTargetAware()).isTrue(); 	}
@Test 	public void createExplicit() throws Exception { 		SpyDefinition definition = new SpyDefinition(getClass(), "name", 				REAL_SERVICE_TYPE, MockReset.BEFORE, false); 		assertThat(definition.getElement()).isEqualTo(getClass()); 		assertThat(definition.getName()).isEqualTo("name"); 		assertThat(definition.getTypeToSpy()).isEqualTo(REAL_SERVICE_TYPE); 		assertThat(definition.getReset()).isEqualTo(MockReset.BEFORE); 		assertThat(definition.isProxyTargetAware()).isFalse(); 	}
@Test 	public void createSpy() throws Exception { 		SpyDefinition definition = new SpyDefinition(null, "name", REAL_SERVICE_TYPE, 				MockReset.BEFORE, true); 		RealExampleService spy = definition.createSpy(new RealExampleService("hello")); 		MockCreationSettings<?> settings = new MockUtil().getMockSettings(spy); 		assertThat(spy).isInstanceOf(ExampleService.class); 		assertThat(settings.getMockName().toString()).isEqualTo("name"); 		assertThat(settings.getDefaultAnswer()) 				.isEqualTo(Answers.CALLS_REAL_METHODS.get()); 		assertThat(MockReset.get(spy)).isEqualTo(MockReset.BEFORE); 	}
@Test 	public void createSpyWhenNullInstanceShouldThrowException() throws Exception { 		SpyDefinition definition = new SpyDefinition(null, "name", REAL_SERVICE_TYPE, 				MockReset.BEFORE, true); 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("Instance must not be null"); 		definition.createSpy(null); 	}
@Test 	public void createSpyWhenWrongInstanceShouldThrowException() throws Exception { 		SpyDefinition definition = new SpyDefinition(null, "name", REAL_SERVICE_TYPE, 				MockReset.BEFORE, true); 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("must be an instance of"); 		definition.createSpy(new ExampleServiceCaller(null)); 	}
@Test 	public void createSpyTwice() throws Exception { 		SpyDefinition definition = new SpyDefinition(null, "name", REAL_SERVICE_TYPE, 				MockReset.BEFORE, true); 		Object instance = new RealExampleService("hello"); 		instance = definition.createSpy(instance); 		instance = definition.createSpy(instance); 	}
private void parseMockBeanAnnotation(MockBean annotation, AnnotatedElement element) { 		Set<ResolvableType> typesToMock = getOrDeduceTypes(element, annotation.value()); 		Assert.state(!typesToMock.isEmpty(), 				"Unable to deduce type to mock from " + element); 		if (StringUtils.hasLength(annotation.name())) { 			Assert.state(typesToMock.size() == 1, 					"The name attribute can only be used when mocking a single class"); 		} 		for (ResolvableType typeToMock : typesToMock) { 			MockDefinition definition = new MockDefinition(annotation.name(), typeToMock, 					annotation.extraInterfaces(), annotation.answer(), 					annotation.serializable(), annotation.reset()); 			addDefinition(element, definition, "mock"); 		} 	}
private void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory, 			BeanDefinitionRegistry registry) { 		beanFactory.registerSingleton(MockitoBeans.class.getName(), this.mockitoBeans); 		DefinitionsParser parser = new DefinitionsParser(this.definitions); 		for (Class<?> configurationClass : getConfigurationClasses(beanFactory)) { 			parser.parse(configurationClass); 		} 		Set<Definition> definitions = parser.getDefinitions(); 		for (Definition definition : definitions) { 			Field field = parser.getField(definition); 			register(beanFactory, registry, definition, field); 		} 	}
private void registerMock(ConfigurableListableBeanFactory beanFactory, 			BeanDefinitionRegistry registry, MockDefinition definition, Field field) { 		RootBeanDefinition beanDefinition = createBeanDefinition(definition); 		String beanName = getBeanName(beanFactory, registry, definition, beanDefinition); 		beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(1, 				beanName); 		if (registry.containsBeanDefinition(beanName)) { 			registry.removeBeanDefinition(beanName); 		} 		registry.registerBeanDefinition(beanName, beanDefinition); 		Object mock = createMock(definition, beanName); 		beanFactory.registerSingleton(beanName, mock); 		this.mockitoBeans.add(mock); 		this.beanNameRegistry.put(definition, beanName); 		if (field != null) { 			this.fieldRegistry.put(field, new RegisteredField(definition, beanName)); 		} 	}
private Object createSpyIfNecessary(Object bean, String beanName) { 			return this.mockitoPostProcessor.createSpyIfNecessary(bean, beanName); 		}
@Override 		public int getOrder() { 			return Ordered.HIGHEST_PRECEDENCE; 		}
public static void register(BeanDefinitionRegistry registry) { 			if (!registry.containsBeanDefinition(BEAN_NAME)) { 				RootBeanDefinition definition = new RootBeanDefinition( 						SpyPostProcessor.class); 				definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); 				ConstructorArgumentValues constructorArguments = definition 						.getConstructorArgumentValues(); 				constructorArguments.addIndexedArgumentValue(0, 						new RuntimeBeanReference(MockitoPostProcessor.BEAN_NAME)); 				registry.registerBeanDefinition(BEAN_NAME, definition); 			} 		}
@Override 	public int getOrder() { 		return Ordered.LOWEST_PRECEDENCE - 10; 	}
protected Object createSpyIfNecessary(Object bean, String beanName) 			throws BeansException { 		SpyDefinition definition = this.spies.get(beanName); 		if (definition != null) { 			bean = definition.createSpy(beanName, bean); 		} 		return bean; 	}
public static void register(BeanDefinitionRegistry registry) { 		register(registry, null); 	}
private void resetMocks(ConfigurableApplicationContext applicationContext, 			MockReset reset) { 		ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory(); 		String[] names = beanFactory.getBeanDefinitionNames(); 		Set<String> instantiatedSingletons = new HashSet<String>( 				Arrays.asList(beanFactory.getSingletonNames())); 		for (String name : names) { 			BeanDefinition definition = beanFactory.getBeanDefinition(name); 			if (definition.isSingleton() && instantiatedSingletons.contains(name)) { 				Object bean = beanFactory.getBean(name); 				if (reset.equals(MockReset.get(bean))) { 					Mockito.reset(bean); 				} 			} 		} 		try { 			MockitoBeans mockedBeans = beanFactory.getBean(MockitoBeans.class); 			for (Object mockedBean : mockedBeans) { 				if (reset.equals(MockReset.get(mockedBean))) { 					Mockito.reset(mockedBean); 				} 			} 		} 		catch (NoSuchBeanDefinitionException ex) { 			// Continue 		} 		if (applicationContext.getParent() != null) { 			resetMocks(applicationContext.getParent(), reset); 		} 	}
@Test 	public void verifyShouldUseProxyTarget() throws Exception { 		given(this.dateService.getDate()).willReturn(1L); 		Long d1 = this.dateService.getDate(); 		assertThat(d1).isEqualTo(1L); 		given(this.dateService.getDate()).willReturn(2L); 		Long d2 = this.dateService.getDate(); 		assertThat(d2).isEqualTo(2L); 		verify(this.dateService, times(2)).getDate(); 	}
@Test 	public void createWithDefaults() throws Exception { 		MockDefinition definition = new MockDefinition(null, EXAMPLE_SERVICE_TYPE, null, 				null, false, null); 		assertThat(definition.getName()).isNull(); 		assertThat(definition.getTypeToMock()).isEqualTo(EXAMPLE_SERVICE_TYPE); 		assertThat(definition.getExtraInterfaces()).isEmpty(); 		assertThat(definition.getAnswer()).isEqualTo(Answers.RETURNS_DEFAULTS); 		assertThat(definition.isSerializable()).isFalse(); 		assertThat(definition.getReset()).isEqualTo(MockReset.AFTER); 	}
@Test 	public void createExplicit() throws Exception { 		MockDefinition definition = new MockDefinition("name", EXAMPLE_SERVICE_TYPE, 				new Class<?>[] { ExampleExtraInterface.class }, 				Answers.RETURNS_SMART_NULLS, true, MockReset.BEFORE); 		assertThat(definition.getName()).isEqualTo("name"); 		assertThat(definition.getTypeToMock()).isEqualTo(EXAMPLE_SERVICE_TYPE); 		assertThat(definition.getExtraInterfaces()) 				.containsExactly(ExampleExtraInterface.class); 		assertThat(definition.getAnswer()).isEqualTo(Answers.RETURNS_SMART_NULLS); 		assertThat(definition.isSerializable()).isTrue(); 		assertThat(definition.getReset()).isEqualTo(MockReset.BEFORE); 		assertThat(definition.isProxyTargetAware()).isFalse(); 	}
@Test 	public void createMock() throws Exception { 		MockDefinition definition = new MockDefinition("name", EXAMPLE_SERVICE_TYPE, 				new Class<?>[] { ExampleExtraInterface.class }, 				Answers.RETURNS_SMART_NULLS, true, MockReset.BEFORE); 		ExampleService mock = definition.createMock(); 		MockCreationSettings<?> settings = new MockUtil().getMockSettings(mock); 		assertThat(mock).isInstanceOf(ExampleService.class); 		assertThat(mock).isInstanceOf(ExampleExtraInterface.class); 		assertThat(settings.getMockName().toString()).isEqualTo("name"); 		assertThat(settings.getDefaultAnswer()) 				.isEqualTo(Answers.RETURNS_SMART_NULLS.get()); 		assertThat(settings.isSerializable()).isTrue(); 		assertThat(MockReset.get(mock)).isEqualTo(MockReset.BEFORE); 	}
public JsonContent<T> write(T value) throws IOException { 		verify(); 		Assert.notNull(value, "Value must not be null"); 		String json = writeObject(value, this.type); 		return new JsonContent<T>(this.resourceLoadClass, this.type, json); 	}
public T parseObject(byte[] jsonBytes) throws IOException { 		verify(); 		return parse(jsonBytes).getObject(); 	}
public ObjectContent<T> parse(byte[] jsonBytes) throws IOException { 		verify(); 		Assert.notNull(jsonBytes, "JsonBytes must not be null"); 		return read(new ByteArrayResource(jsonBytes)); 	}
public T parseObject(String jsonString) throws IOException { 		verify(); 		return parse(jsonString).getObject(); 	}
public ObjectContent<T> parse(String jsonString) throws IOException { 		verify(); 		Assert.notNull(jsonString, "JsonString must not be null"); 		return read(new StringReader(jsonString)); 	}
public T readObject(String resourcePath) throws IOException { 		verify(); 		return read(resourcePath).getObject(); 	}
public ObjectContent<T> read(String resourcePath) throws IOException { 		verify(); 		Assert.notNull(resourcePath, "ResourcePath must not be null"); 		return read(new ClassPathResource(resourcePath, this.resourceLoadClass)); 	}
public T readObject(File file) throws IOException { 		verify(); 		return read(file).getObject(); 	}
public ObjectContent<T> read(File file) throws IOException { 		verify(); 		Assert.notNull(file, "File must not be null"); 		return read(new FileSystemResource(file)); 	}
public T readObject(InputStream inputStream) throws IOException { 		verify(); 		return read(inputStream).getObject(); 	}
public ObjectContent<T> read(InputStream inputStream) throws IOException { 		verify(); 		Assert.notNull(inputStream, "InputStream must not be null"); 		return read(new InputStreamResource(inputStream)); 	}
public T readObject(Resource resource) throws IOException { 		verify(); 		return read(resource).getObject(); 	}
public ObjectContent<T> read(Resource resource) throws IOException { 		verify(); 		Assert.notNull(resource, "Resource must not be null"); 		InputStream inputStream = resource.getInputStream(); 		T object = readObject(inputStream, this.type); 		closeQuietly(inputStream); 		return new ObjectContent<T>(this.type, object); 	}
public T readObject(Reader reader) throws IOException { 		verify(); 		return read(reader).getObject(); 	}
public ObjectContent<T> read(Reader reader) throws IOException { 		verify(); 		Assert.notNull(reader, "Reader must not be null"); 		T object = readObject(reader, this.type); 		closeQuietly(reader); 		return new ObjectContent<T>(this.type, object); 	}
public JsonContent<Object> from(CharSequence source) { 		verify(); 		return getJsonContent(this.loader.getJson(source)); 	}
public JsonContent<Object> from(String path, Class<?> resourceLoadClass) { 		verify(); 		return getJsonContent(this.loader.getJson(path, resourceLoadClass)); 	}
public JsonContent<Object> from(byte[] source) { 		verify(); 		return getJsonContent(this.loader.getJson(source)); 	}
public JsonContent<Object> from(File source) { 		verify(); 		return getJsonContent(this.loader.getJson(source)); 	}
public JsonContent<Object> from(InputStream source) { 		verify(); 		return getJsonContent(this.loader.getJson(source)); 	}
public JsonContent<Object> from(Resource source) { 		verify(); 		return getJsonContent(this.loader.getJson(source)); 	}
@Bean 		@Primary 		@ConditionalOnMissingBean(ObjectMapper.class) 		public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { 			return builder.createXmlMapper(false).build(); 		}
@Override 			public void customize(Jackson2ObjectMapperBuilder builder) {  				if (this.jacksonProperties.getDefaultPropertyInclusion() != null) { 					builder.serializationInclusion( 							this.jacksonProperties.getDefaultPropertyInclusion()); 				} 				if (this.jacksonProperties.getTimeZone() != null) { 					builder.timeZone(this.jacksonProperties.getTimeZone()); 				} 				configureFeatures(builder, this.jacksonProperties.getDeserialization()); 				configureFeatures(builder, this.jacksonProperties.getSerialization()); 				configureFeatures(builder, this.jacksonProperties.getMapper()); 				configureFeatures(builder, this.jacksonProperties.getParser()); 				configureFeatures(builder, this.jacksonProperties.getGenerator()); 				configureDateFormat(builder); 				configurePropertyNamingStrategy(builder); 				configureModules(builder); 				configureLocale(builder); 			}
private void configureDateFormat(Jackson2ObjectMapperBuilder builder) { 				// We support a fully qualified class name extending DateFormat or a date 				// pattern string value 				String dateFormat = this.jacksonProperties.getDateFormat(); 				if (dateFormat != null) { 					try { 						Class<?> dateFormatClass = ClassUtils.forName(dateFormat, null); 						builder.dateFormat( 								(DateFormat) BeanUtils.instantiateClass(dateFormatClass)); 					} 					catch (ClassNotFoundException ex) { 						SimpleDateFormat simpleDateFormat = new SimpleDateFormat( 								dateFormat); 						// Since Jackson 2.6.3 we always need to set a TimeZone (see 						// gh-4170). If none in our properties fallback to the Jackson's 						// default 						TimeZone timeZone = this.jacksonProperties.getTimeZone(); 						if (timeZone == null) { 							timeZone = new ObjectMapper().getSerializationConfig() 									.getTimeZone(); 						} 						simpleDateFormat.setTimeZone(timeZone); 						builder.dateFormat(simpleDateFormat); 					} 				} 			}
private void configureModules(Jackson2ObjectMapperBuilder builder) { 				Collection<Module> moduleBeans = getBeans(this.applicationContext, 						Module.class); 				builder.modulesToInstall( 						moduleBeans.toArray(new Module[moduleBeans.size()])); 			}
private void configureLocale(Jackson2ObjectMapperBuilder builder) { 				Locale locale = this.jacksonProperties.getLocale(); 				if (locale != null) { 					builder.locale(locale); 				} 			}
@Bean 		public Jackson2ObjectMapperBuilderCustomizer customDateFormat() { 			return new Jackson2ObjectMapperBuilderCustomizer() { 				@Override 				public void customize( 						Jackson2ObjectMapperBuilder jackson2ObjectMapperBuilder) { 					jackson2ObjectMapperBuilder.dateFormat(new MyDateFormat()); 				} 			}; 		}
@Bean 		@Primary 		public ObjectMapper objectMapper() { 			ObjectMapper mapper = new ObjectMapper(); 			mapper.registerModule(jacksonModule()); 			return mapper; 		}
@Bean 		public Module jacksonModule() { 			SimpleModule module = new SimpleModule(); 			module.addSerializer(Foo.class, new JsonSerializer<Foo>() {  				@Override 				public void serialize(Foo value, JsonGenerator jgen, 						SerializerProvider provider) 								throws IOException, JsonProcessingException { 					jgen.writeStartObject(); 					jgen.writeStringField("foo", "bar"); 					jgen.writeEndObject(); 				} 			}); 			return module; 		}
@Bean 		public CustomModule jacksonModule() { 			return new CustomModule(); 		}
@Bean 		@Primary 		public ObjectMapper objectMapper() { 			return mock(ObjectMapper.class); 		}
@Test 	public void customDateFormat() throws Exception { 		this.context.register(JacksonAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.jackson.date-format:yyyyMMddHHmmss"); 		this.context.refresh(); 		ObjectMapper mapper = this.context.getBean(ObjectMapper.class); 		DateFormat dateFormat = mapper.getDateFormat(); 		assertThat(dateFormat).isInstanceOf(SimpleDateFormat.class); 		assertThat(((SimpleDateFormat) dateFormat).toPattern()) 				.isEqualTo("yyyyMMddHHmmss"); 	}
@Bean 		public Jackson2ObjectMapperBuilderCustomizer customDateFormat() { 			return new Jackson2ObjectMapperBuilderCustomizer() { 				@Override 				public void customize( 						Jackson2ObjectMapperBuilder jackson2ObjectMapperBuilder) { 					jackson2ObjectMapperBuilder.dateFormat(new MyDateFormat()); 				} 			}; 		}
@Override 	protected Map<String, Object> getVendorProperties() { 		Map<String, Object> vendorProperties = new LinkedHashMap<String, Object>(); 		vendorProperties.putAll(getProperties().getHibernateProperties(getDataSource())); 		return vendorProperties; 	}
@Bean 	@ConditionalOnMissingBean 	public JpaVendorAdapter jpaVendorAdapter() { 		AbstractJpaVendorAdapter adapter = createJpaVendorAdapter(); 		adapter.setShowSql(this.properties.isShowSql()); 		adapter.setDatabase(this.properties.getDatabase()); 		adapter.setDatabasePlatform(this.properties.getDatabasePlatform()); 		adapter.setGenerateDdl(this.properties.isGenerateDdl()); 		return adapter; 	}
@Bean 		@ConditionalOnProperty(prefix = "shell", name = "auth", havingValue = "jaas") 		@ConditionalOnMissingBean(CrshShellAuthenticationProperties.class) 		public JaasAuthenticationProperties jaasAuthenticationProperties() { 			return new JaasAuthenticationProperties(); 		}
@Bean 		@ConditionalOnProperty(prefix = "shell", name = "auth", havingValue = "key") 		@ConditionalOnMissingBean(CrshShellAuthenticationProperties.class) 		public KeyAuthenticationProperties keyAuthenticationProperties() { 			return new KeyAuthenticationProperties(); 		}
@Bean 		@ConditionalOnProperty(prefix = "shell", name = "auth", havingValue = "simple", matchIfMissing = true) 		@ConditionalOnMissingBean(CrshShellAuthenticationProperties.class) 		public SimpleAuthenticationProperties simpleAuthenticationProperties() { 			return new SimpleAuthenticationProperties(); 		}
@Override 		public void init() { 			String rolesPropertyValue = getContext().getProperty(ROLES); 			if (rolesPropertyValue != null) { 				this.roles = StringUtils 						.commaDelimitedListToStringArray(rolesPropertyValue); 			} 		}
public String getName() { 			return this.name; 		}
@PostConstruct 		public void init() { 			FS commandFileSystem = createFileSystem( 					this.properties.getCommandPathPatterns(), 					this.properties.getDisabledCommands()); 			FS configurationFileSystem = createFileSystem( 					this.properties.getConfigPathPatterns(), new String[0]);  			PluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery( 					this.resourceLoader.getClassLoader(), this.beanFactory, 					this.properties.getDisabledPlugins());  			PluginContext context = new PluginContext(discovery, 					createPluginContextAttributes(), commandFileSystem, 					configurationFileSystem, this.resourceLoader.getClassLoader());  			context.refresh(); 			start(context); 		}
@Override 		public String getName() { 			return "spring"; 		}
@Bean 	@ConditionalOnMissingBean 	public HealthEndpoint healthEndpoint() { 		return new HealthEndpoint( 				this.healthAggregator == null ? new OrderedHealthAggregator() 						: this.healthAggregator, 				this.healthIndicators == null 						? Collections.<String, HealthIndicator>emptyMap() 						: this.healthIndicators); 	}
@Bean 	@ConditionalOnMissingBean 	public InfoEndpoint infoEndpoint() throws Exception { 		return new InfoEndpoint(this.infoContributors == null 				? Collections.<InfoContributor>emptyList() : this.infoContributors); 	}
@Bean 	@ConditionalOnMissingBean 	public TraceEndpoint traceEndpoint() { 		return new TraceEndpoint(this.traceRepository == null 				? new InMemoryTraceRepository() : this.traceRepository); 	}
private RequestMatcher getRequestMatcher() { 			if (this.management.getSecurity().isEnabled()) { 				return LazyEndpointPathRequestMatcher 						.getRequestMatcher(this.contextResolver); 			} 			return null; 		}
private RequestMatcher getRequestMatcher() { 			if (this.management.getSecurity().isEnabled()) { 				return null; 			} 			return LazyEndpointPathRequestMatcher.getRequestMatcher(this.contextResolver); 		}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
@Bean 	@ConditionalOnMissingBean(name = "metricWritersMetricExporter") 	public SchedulingConfigurer metricWritersMetricExporter() { 		Map<String, GaugeWriter> writers = new HashMap<String, GaugeWriter>(); 		MetricReader reader = this.endpointReader; 		if (reader == null && !CollectionUtils.isEmpty(this.readers)) { 			reader = new CompositeMetricReader( 					this.readers.toArray(new MetricReader[this.readers.size()])); 		} 		if (reader == null && CollectionUtils.isEmpty(this.exporters)) { 			return new NoOpSchedulingConfigurer(); 		} 		MetricExporters exporters = new MetricExporters(this.properties); 		if (reader != null) { 			if (!CollectionUtils.isEmpty(this.writers)) { 				writers.putAll(this.writers); 			} 			exporters.setReader(reader); 			exporters.setWriters(writers); 		} 		exporters.setExporters(this.exporters == null 				? Collections.<String, Exporter>emptyMap() : this.exporters); 		return exporters; 	}
@Bean 	public MetricReaderPublicMetrics metricReaderPublicMetrics() { 		return new MetricReaderPublicMetrics( 				new CompositeMetricReader(this.metricReaders == null ? new MetricReader[0] 						: this.metricReaders 								.toArray(new MetricReader[this.metricReaders.size()]))); 	}
@Bean 		@ConditionalOnMissingBean 		public HttpMessageConverters messageConverters() { 			return new HttpMessageConverters(this.converters == null 					? Collections.<HttpMessageConverter<?>>emptyList() : this.converters); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			if (anyMatches(context, metadata, this.pooledCondition)) { 				return ConditionOutcome.noMatch("supported DataSource class found"); 			} 			EmbeddedDatabaseType type = EmbeddedDatabaseConnection 					.get(context.getClassLoader()).getType(); 			if (type == null) { 				return ConditionOutcome.noMatch("no embedded database detected"); 			} 			return ConditionOutcome.match("embedded database " + type + " detected"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			if (hasBean(context, DataSource.class) 					|| hasBean(context, XADataSource.class)) { 				return ConditionOutcome 						.match("existing bean configured database detected"); 			} 			if (anyMatches(context, metadata, this.pooledCondition, 					this.embeddedCondition)) { 				return ConditionOutcome.match("existing auto database detected"); 			} 			return ConditionOutcome.noMatch("no existing bean configured database"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			if (getDataSourceClassLoader(context) != null) { 				return ConditionOutcome.match("supported DataSource class found"); 			} 			return ConditionOutcome.noMatch("missing supported DataSource"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			if (hasBean(context, DataSource.class) 					|| hasBean(context, XADataSource.class)) { 				return ConditionOutcome 						.match("existing bean configured database detected"); 			} 			if (anyMatches(context, metadata, this.pooledCondition, 					this.embeddedCondition)) { 				return ConditionOutcome.match("existing auto database detected"); 			} 			return ConditionOutcome.noMatch("no existing bean configured database"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			if (getDataSourceClassLoader(context) != null) { 				return ConditionOutcome.match("supported DataSource class found"); 			} 			return ConditionOutcome.noMatch("missing supported DataSource"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			if (anyMatches(context, metadata, this.pooledCondition)) { 				return ConditionOutcome.noMatch("supported DataSource class found"); 			} 			EmbeddedDatabaseType type = EmbeddedDatabaseConnection 					.get(context.getClassLoader()).getType(); 			if (type == null) { 				return ConditionOutcome.noMatch("no embedded database detected"); 			} 			return ConditionOutcome.match("embedded database " + type + " detected"); 		}
@Bean 		@ConditionalOnMissingBean(PlatformTransactionManager.class) 		public DataSourceTransactionManager transactionManager() { 			return new DataSourceTransactionManager(this.dataSource); 		}
@Bean 		public IRuntimeConfig embeddedMongoRuntimeConfig() { 			Logger logger = LoggerFactory 					.getLogger(getClass().getPackage().getName() + ".EmbeddedMongo"); 			ProcessOutput processOutput = new ProcessOutput( 					Processors.logTo(logger, Slf4jLevel.INFO), 					Processors.logTo(logger, Slf4jLevel.ERROR), Processors.named( 							"[console>]", Processors.logTo(logger, Slf4jLevel.DEBUG))); 			return new RuntimeConfigBuilder().defaultsWithLogger(Command.MongoD, logger) 					.processOutput(processOutput).artifactStore(getArtifactStore(logger)) 					.build(); 		}
private ArtifactStoreBuilder getArtifactStore(Logger logger) { 			return new ExtractedArtifactStoreBuilder().defaults(Command.MongoD) 					.download(new DownloadConfigBuilder() 							.defaultsForCommand(Command.MongoD) 							.progressListener(new Slf4jProgressListener(logger)).build()); 		}
@Bean(name = "userInfoRestTemplate") 		public OAuth2RestTemplate userInfoRestTemplate() { 			OAuth2RestTemplate template = getTemplate( 					this.details == null ? DEFAULT_RESOURCE_DETAILS : this.details); 			template.getInterceptors().add(new AcceptJsonRequestInterceptor()); 			AuthorizationCodeAccessTokenProvider accessTokenProvider = new AuthorizationCodeAccessTokenProvider(); 			accessTokenProvider.setTokenRequestEnhancer(new AcceptJsonRequestEnhancer()); 			template.setAccessTokenProvider(accessTokenProvider); 			if (!CollectionUtils.isEmpty(this.customizers)) { 				AnnotationAwareOrderComparator.sort(this.customizers); 				for (UserInfoRestTemplateCustomizer customizer : this.customizers) { 					customizer.customize(template); 				} 			} 			return template; 		}
@Bean 			@ConditionalOnMissingBean(ResourceServerTokenServices.class) 			public UserInfoTokenServices userInfoTokenServices() { 				UserInfoTokenServices services = new UserInfoTokenServices( 						this.sso.getUserInfoUri(), this.sso.getClientId()); 				services.setRestTemplate(this.restTemplate); 				services.setTokenType(this.sso.getTokenType()); 				if (this.authoritiesExtractor != null) { 					services.setAuthoritiesExtractor(this.authoritiesExtractor); 				} 				return services; 			}
@Bean 			@ConditionalOnMissingBean({ ConnectionFactoryLocator.class, 					ResourceServerTokenServices.class }) 			public UserInfoTokenServices userInfoTokenServices() { 				UserInfoTokenServices services = new UserInfoTokenServices( 						this.sso.getUserInfoUri(), this.sso.getClientId()); 				services.setTokenType(this.sso.getTokenType()); 				services.setRestTemplate(this.restTemplate); 				if (this.authoritiesExtractor != null) { 					services.setAuthoritiesExtractor(this.authoritiesExtractor); 				} 				return services; 			}
@Bean 		public JwtAccessTokenConverter jwtTokenEnhancer() { 			JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); 			String keyValue = this.resource.getJwt().getKeyValue(); 			if (!StringUtils.hasText(keyValue)) { 				try { 					keyValue = getKeyFromServer(); 				} 				catch (ResourceAccessException ex) { 					logger.warn("Failed to fetch token key (you may need to refresh " 							+ "when the auth server is back)"); 				} 			} 			if (StringUtils.hasText(keyValue) && !keyValue.startsWith("-----BEGIN")) { 				converter.setSigningKey(keyValue); 			} 			if (keyValue != null) { 				converter.setVerifierKey(keyValue); 			} 			if (!CollectionUtils.isEmpty(this.configurers)) { 				AnnotationAwareOrderComparator.sort(this.configurers); 				for (JwtAccessTokenConverterConfigurer configurer : this.configurers) { 					configurer.configure(converter); 				} 			} 			return converter; 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.tokenInfoCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.jwtTokenCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment 						.resolvePlaceholders("${OAUTH2_RESOURCE_PREFERTOKENINFO:true}") 						.equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match( 						"Token info endpoint " + "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.tokenInfoCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.jwtTokenCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment 						.resolvePlaceholders("${OAUTH2_RESOURCE_PREFERTOKENINFO:true}") 						.equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match( 						"Token info endpoint " + "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.jwtTokenCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment 						.resolvePlaceholders("${OAUTH2_RESOURCE_PREFERTOKENINFO:true}") 						.equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match( 						"Token info endpoint " + "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.tokenInfoCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public UserIdSource getUserIdSource() { 			return new SecurityContextUserIdSource(); 		}
@Override 		public String getUserId() { 			SecurityContext context = SecurityContextHolder.getContext(); 			Authentication authentication = context.getAuthentication(); 			Assert.state(authentication != null, 					"Unable to get a " + "ConnectionRepository: no user signed in"); 			return authentication.getName(); 		}
@Override 		public UserIdSource getUserIdSource() { 			return new UserIdSource() { 				@Override 				public String getUserId() { 					return "anonymous"; 				} 			}; 		}
@Override 				public String getUserId() { 					return "anonymous"; 				}
@Bean 		public SpringTemplateEngine templateEngine() { 			SpringTemplateEngine engine = new SpringTemplateEngine(); 			for (ITemplateResolver templateResolver : this.templateResolvers) { 				engine.addTemplateResolver(templateResolver); 			} 			if (!CollectionUtils.isEmpty(this.dialects)) { 				for (IDialect dialect : this.dialects) { 					engine.addDialect(dialect); 				} 			} 			return engine; 		}
@Bean 	@ConditionalOnMissingBean 	public HttpMessageConverters messageConverters() { 		return new HttpMessageConverters(this.converters == null 				? Collections.<HttpMessageConverter<?>>emptyList() : this.converters); 	}
@Bean 			public LiteDeviceDelegatingViewResolver deviceDelegatingViewResolver() { 				if (logger.isDebugEnabled()) { 					logger.debug("LiteDeviceDelegatingViewResolver delegates to " 							+ "InternalResourceViewResolver"); 				} 				return getConfiguredViewResolver(this.viewResolver, 						this.viewResolver.getOrder()); 			}
@Bean 			public LiteDeviceDelegatingViewResolver deviceDelegatingViewResolver() { 				if (logger.isDebugEnabled()) { 					logger.debug("LiteDeviceDelegatingViewResolver delegates to " 							+ "ThymeleafViewResolver"); 				} 				return getConfiguredViewResolver(this.viewResolver, 						this.viewResolver.getOrder()); 			}
@Bean 	@ConditionalOnMissingBean(DeviceResolverHandlerInterceptor.class) 	public DeviceResolverHandlerInterceptor deviceResolverHandlerInterceptor() { 		return new DeviceResolverHandlerInterceptor(); 	}
@Bean 	public DeviceHandlerMethodArgumentResolver deviceHandlerMethodArgumentResolver() { 		return new DeviceHandlerMethodArgumentResolver(); 	}
@Override 		public void addArgumentResolvers( 				List<HandlerMethodArgumentResolver> argumentResolvers) { 			argumentResolvers.add(this.deviceHandlerMethodArgumentResolver); 		}
@Bean 	@ConditionalOnMissingBean(SitePreferenceHandlerInterceptor.class) 	public SitePreferenceHandlerInterceptor sitePreferenceHandlerInterceptor() { 		return new SitePreferenceHandlerInterceptor(); 	}
@Bean 	public SitePreferenceHandlerMethodArgumentResolver sitePreferenceHandlerMethodArgumentResolver() { 		return new SitePreferenceHandlerMethodArgumentResolver(); 	}
@Override 		public void addArgumentResolvers( 				List<HandlerMethodArgumentResolver> argumentResolvers) { 			argumentResolvers.add(this.sitePreferenceHandlerMethodArgumentResolver); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Bean 			@ConditionalOnMissingBean(ResourceServerTokenServices.class) 			public UserInfoTokenServices userInfoTokenServices() { 				UserInfoTokenServices services = new UserInfoTokenServices( 						this.sso.getUserInfoUri(), this.sso.getClientId()); 				services.setRestTemplate(this.restTemplate); 				services.setTokenType(this.sso.getTokenType()); 				if (this.authoritiesExtractor != null) { 					services.setAuthoritiesExtractor(this.authoritiesExtractor); 				} 				return services; 			}
@Bean 			@ConditionalOnMissingBean({ ConnectionFactoryLocator.class, 					ResourceServerTokenServices.class }) 			public UserInfoTokenServices userInfoTokenServices() { 				UserInfoTokenServices services = new UserInfoTokenServices( 						this.sso.getUserInfoUri(), this.sso.getClientId()); 				services.setTokenType(this.sso.getTokenType()); 				services.setRestTemplate(this.restTemplate); 				if (this.authoritiesExtractor != null) { 					services.setAuthoritiesExtractor(this.authoritiesExtractor); 				} 				return services; 			}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.tokenInfoCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.jwtTokenCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment 						.resolvePlaceholders("${OAUTH2_RESOURCE_PREFERTOKENINFO:true}") 						.equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match( 						"Token info endpoint " + "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.tokenInfoCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.jwtTokenCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment 						.resolvePlaceholders("${OAUTH2_RESOURCE_PREFERTOKENINFO:true}") 						.equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match( 						"Token info endpoint " + "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.jwtTokenCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment 						.resolvePlaceholders("${OAUTH2_RESOURCE_PREFERTOKENINFO:true}") 						.equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match( 						"Token info endpoint " + "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.tokenInfoCondition.getMatchOutcome(context, metadata)); 		}
@FlywayDataSource 		@Bean 		public DataSource flywayDataSource() { 			return DataSourceBuilder.create().url("jdbc:hsqldb:mem:flywaytest") 					.username("sa").build(); 		}
@Test 	public void flywayDataSource() throws Exception { 		registerAndRefresh(FlywayDataSourceConfiguration.class, 				EmbeddedDataSourceConfiguration.class, FlywayAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		Flyway flyway = this.context.getBean(Flyway.class); 		assertThat(flyway.getDataSource()).isNotNull(); 	}
@Test 	public void defaultJtaPlatform() throws Exception { 		this.context.register(JtaAutoConfiguration.class); 		setupTestConfiguration(); 		this.context.refresh(); 		Map<String, Object> jpaPropertyMap = this.context 				.getBean(LocalContainerEntityManagerFactoryBean.class) 				.getJpaPropertyMap(); 		assertThat(jpaPropertyMap.get("hibernate.transaction.jta.platform")) 				.isInstanceOf(SpringJtaPlatform.class); 	}
@Test 	public void testCustomJtaPlatform() throws Exception { 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.jpa.properties.hibernate.transaction.jta.platform:" 						+ TestJtaPlatform.class.getName()); 		this.context.register(JtaAutoConfiguration.class); 		setupTestConfiguration(); 		this.context.refresh(); 		Map<String, Object> jpaPropertyMap = this.context 				.getBean(LocalContainerEntityManagerFactoryBean.class) 				.getJpaPropertyMap(); 		assertThat((String) jpaPropertyMap.get("hibernate.transaction.jta.platform")) 				.isEqualTo(TestJtaPlatform.class.getName()); 	}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.userDetails = http.getSharedObject(UserDetailsService.class); 		}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return new TestingAuthenticationToken("foo", "bar"); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.authenticationManager = new AuthenticationManager() { 				@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				} 			}; 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers(HttpMethod.POST, "/**").denyAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().denyAll(); 		}
@Bean 		public EmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return mock(EmbeddedServletContainerFactory.class); 		}
@Bean 		public MockEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new MockEmbeddedServletContainerFactory(); 		}
private List<MessageConverter> getCustomizedConverters() { 		List<MessageConverter> customizedConverters = new ArrayList<MessageConverter>(); 		WebSocketMessagingAutoConfiguration.WebSocketMessageConverterConfiguration configuration = new WebSocketMessagingAutoConfiguration.WebSocketMessageConverterConfiguration( 				new ObjectMapper()); 		configuration.configureMessageConverters(customizedConverters); 		return customizedConverters; 	}
@Override 			public void handleFrame(StompHeaders headers, Object payload) { 				latch.countDown(); 			}
@Override 					public void handleFrame(StompHeaders headers, Object payload) { 						result.set(payload); 						latch.countDown(); 					}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new JettyEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new UndertowEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			JettyEmbeddedServletContainerFactory factory = new JettyEmbeddedServletContainerFactory( 					0); 			factory.setContextPath(this.env.getProperty("context")); 			return factory; 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new TomcatEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new UndertowEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			JettyEmbeddedServletContainerFactory factory = new JettyEmbeddedServletContainerFactory( 					0); 			factory.setContextPath(this.env.getProperty("context")); 			return factory; 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new TomcatEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new JettyEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			JettyEmbeddedServletContainerFactory factory = new JettyEmbeddedServletContainerFactory( 					0); 			factory.setContextPath(this.env.getProperty("context")); 			return factory; 		}
@Bean 		public DispatcherServlet dispatcherServlet() { 			DispatcherServlet dispatcherServlet = new DispatcherServlet(); 			// Can configure dispatcher servlet here as would usually do via init-params 			return dispatcherServlet; 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new TomcatEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new JettyEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new UndertowEmbeddedServletContainerFactory(0); 		}
@Bean 		public DispatcherServlet dispatcherServlet() { 			return new DispatcherServlet(); 			// Alternatively you can use ServletContextInitializer beans including 			// ServletRegistration and FilterRegistration. Read the 			// EmbeddedWebApplicationContext javadoc for details 		}
private void handleRunFailure(ConfigurableApplicationContext context, 			SpringApplicationRunListeners listeners, Throwable exception) { 		try { 			try { 				handleExitCode(context, exception); 				listeners.finished(context, exception); 			} 			finally { 				reportFailure(exception, context); 				if (context != null) { 					context.close(); 				} 			} 		} 		catch (Exception ex) { 			logger.warn("Unable to close ApplicationContext", ex); 		} 		ReflectionUtils.rethrowRuntimeException(exception); 	}
@Override 		public void render(Map<String, ?> model, HttpServletRequest request, 				HttpServletResponse response) throws Exception { 			if (response.getContentType() == null) { 				response.setContentType(getContentType()); 			} 			Map<String, Object> map = new HashMap<String, Object>(model); 			map.put("path", request.getContextPath()); 			PlaceholderResolver resolver = new ExpressionResolver(this.expressions, map); 			String result = this.helper.replacePlaceholders(this.template, resolver); 			response.getWriter().append(result); 		}
@Override 		public String resolvePlaceholder(String name) { 			this.expressions.put(name, this.parser.parseExpression(name)); 			return null; 		}
@Bean 	@ConditionalOnMissingBean 	public HealthEndpoint healthEndpoint() { 		return new HealthEndpoint(this.healthIndicators); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 6 for static resources, one for management endpoints and one for the rest 		assertEquals(8, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testWebConfigurationWithExtraRole() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(EndpointAutoConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, UserDetailsExposed.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		UserDetails user = getUser(); 		assertTrue(user.getAuthorities().containsAll( 				AuthorityUtils 						.commaSeparatedStringToAuthorityList("ROLE_USER,ROLE_ADMIN"))); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		debugRefresh(this.context); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 4 for static resources and one for the rest 		assertEquals(5, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
public static void main(String[] args) throws Exception { 		SpringApplication.run(SampleSecureApplication.class, "--debug"); 	}
@RequestMapping("/") 	public String welcome(Map<String,Object> model) { 		model.put("time", new Date()); 		model.put("message", message ); 		return "welcome"; 	}
@Bean 	@ConditionalOnMissingBean 	public GraphQlSource graphQlSource(ResourcePatternResolver resourcePatternResolver, GraphQlProperties properties, 			ObjectProvider<DataFetcherExceptionResolver> exceptionResolversProvider, 			ObjectProvider<Instrumentation> instrumentationsProvider, 			ObjectProvider<RuntimeWiringConfigurer> wiringConfigurers, 			ObjectProvider<GraphQlSourceBuilderCustomizer> sourceCustomizers) {  		List<Resource> schemaResources = resolveSchemaResources(resourcePatternResolver, 				properties.getSchema().getLocations(), properties.getSchema().getFileExtensions()); 		GraphQlSource.Builder builder = GraphQlSource.builder() 				.schemaResources(schemaResources.toArray(new Resource[0])) 				.exceptionResolvers(exceptionResolversProvider.orderedStream().collect(Collectors.toList())) 				.instrumentation(instrumentationsProvider.orderedStream().collect(Collectors.toList())); 		if (!properties.getSchema().getIntrospection().isEnabled()) { 			builder.configureRuntimeWiring((wiring) -> wiring 					.fieldVisibility(NoIntrospectionGraphqlFieldVisibility.NO_INTROSPECTION_FIELD_VISIBILITY)); 		} 		wiringConfigurers.orderedStream().forEach(builder::configureRuntimeWiring); 		sourceCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder)); 		try { 			return builder.build(); 		} 		catch (MissingSchemaException exc) { 			throw new InvalidSchemaLocationsException(properties.getSchema().getLocations(), resourcePatternResolver, 					exc); 		} 	}
public String getPath() { 			return this.path; 		}
public String getPath() { 			return this.path; 		}
public void setPath(String path) { 			this.path = path; 		}
public void setPath(String path) { 			this.path = path; 		}
public boolean isEnabled() { 			return this.enabled; 		}
public void setEnabled(boolean enabled) { 			this.enabled = enabled; 		}
public String getPath() { 		return this.path; 	}
public void setPath(String path) { 		this.path = path; 	}
public boolean isEnabled() { 				return this.enabled; 			}
public boolean isEnabled() { 				return this.enabled; 			}
public void setEnabled(boolean enabled) { 				this.enabled = enabled; 			}
public void setEnabled(boolean enabled) { 				this.enabled = enabled; 			}
public String getPath() { 		return this.path; 	}
public void setPath(String path) { 		this.path = path; 	}
@Override 	protected Yaml createYaml() { 		LoaderOptions loaderOptions = new LoaderOptions(); 		loaderOptions.setAllowDuplicateKeys(false); 		loaderOptions.setMaxAliasesForCollections(Integer.MAX_VALUE); 		loaderOptions.setAllowRecursiveKeys(true); 		return createYaml(loaderOptions); 	}
@Override 		public void render(Map<String, ?> model, HttpServletRequest request, 				HttpServletResponse response) throws Exception { 			if (response.getContentType() == null) { 				response.setContentType(getContentType()); 			} 			Map<String, Object> map = new HashMap<String, Object>(model); 			map.put("path", request.getContextPath()); 			PlaceholderResolver resolver = new ExpressionResolver(this.expressions, map); 			String result = this.helper.replacePlaceholders(this.template, resolver); 			response.getWriter().append(result); 		}
@Override 		public String resolvePlaceholder(String name) { 			this.expressions.put(name, this.parser.parseExpression(name)); 			return null; 		}
private Health getHealth(Principal principal) { 		Health health = (useCachedValue(principal) ? this.cached : (Health) this.delegate 				.invoke()); 		// Not too worried about concurrent access here, the worst that can happen is the 		// odd extra call to delegate.invoke() 		this.cached = health; 		if (this.delegate.isRestrictAnonymousAccess() && !secure(principal)) { 			// If not secure we only expose the status 			health = Health.status(health.getStatus()).build(); 		} 		return health; 	}
private boolean useCachedValue(Principal principal) { 		long accessTime = System.currentTimeMillis(); 		if (cacheIsStale(accessTime) || secure(principal) 				|| !this.delegate.isRestrictAnonymousAccess()) { 			this.lastAccess = accessTime; 			return false; 		} 		return this.cached != null; 	}
@Test 	public void secure() { 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		given(this.endpoint.isRestrictAnonymousAccess()).willReturn(true); 		Object result = this.mvc.invoke(this.user); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void secureNotCached() { 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.isRestrictAnonymousAccess()).willReturn(true); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(this.user); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(this.user); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertTrue(health.getStatus() == Status.DOWN); 	}
@Test 	public void unsecureCached() { 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.isRestrictAnonymousAccess()).willReturn(true); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(this.user); 		assertTrue(result instanceof Health); 		Health health = (Health) result; 		assertTrue(health.getStatus() == Status.UP); 		assertThat(health.getDetails().size(), is(equalTo(1))); 		assertThat(health.getDetails().get("foo"), is(equalTo((Object) "bar"))); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); // insecure now 		assertTrue(result instanceof Health); 		health = (Health) result; 		// so the result is cached 		assertTrue(health.getStatus() == Status.UP); 		// but the details are hidden 		assertThat(health.getDetails().size(), is(equalTo(0))); 	}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			// The ignores are not cumulative, so to prevent overwriting the defaults we 			// add them back. 			List<String> ignored = SpringBootWebSecurityConfiguration 					.getIgnored(this.security); 			if (!this.management.getSecurity().isEnabled()) { 				ignored.addAll(Arrays.asList(getEndpointPaths( 						this.endpointHandlerMapping))); 			} 			if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			if (this.server != null) { 				String[] paths = this.server.getPathsArray(ignored); 				ignoring.antMatchers(paths); 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping); 			if (paths.length > 0 && this.management.getSecurity().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				paths = this.server.getPathsArray(paths); 				http.requestMatchers().antMatchers(paths); 				// @formatter:off 				http.authorizeRequests() 						.antMatchers(this.server.getPathsArray(getEndpointPaths(this.endpointHandlerMapping, false))).access("permitAll()") 						.anyRequest().hasRole(this.management.getSecurity().getRole()); 				// @formatter:on 				http.httpBasic();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions());  				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
private static String[] getEndpointPaths( 			EndpointHandlerMapping endpointHandlerMapping, boolean secure) { 		if (endpointHandlerMapping == null) { 			return NO_PATHS; 		}  		Set<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints(); 		List<String> paths = new ArrayList<String>(endpoints.size()); 		for (MvcEndpoint endpoint : endpoints) { 			if (endpoint.isSensitive() == secure) { 				String path = endpointHandlerMapping.getPath(endpoint.getPath()); 				paths.add(path); 				// Add Spring MVC-generated additional paths 				paths.add(path + "/"); 				paths.add(path + ".*"); 			} 		} 		return paths.toArray(new String[paths.size()]); 	}
@Override 	public void afterPropertiesSet() { 		super.afterPropertiesSet(); 		if (!this.disabled) { 			for (MvcEndpoint endpoint : this.endpoints.values()) { 				detectHandlerMethods(endpoint); 			} 		} 	}
public Set<? extends MvcEndpoint> getEndpoints() { 		return new HashSet<MvcEndpoint>(this.endpoints.values()); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 4 for static resources, one for management endpoints and one for the rest 		assertEquals(6, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				FallbackWebSecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Just the management endpoints (one filter) and ignores now plus the backup 		// filter on app endpoints 		assertEquals(6, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void up() { 		given(this.endpoint.invoke()).willReturn(new Health.Builder().up().build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 	}
@SuppressWarnings("unchecked") 	@Test 	public void down() { 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof ResponseEntity); 		ResponseEntity<Health> response = (ResponseEntity<Health>) result; 		assertTrue(response.getBody().getStatus() == Status.DOWN); 		assertEquals(HttpStatus.SERVICE_UNAVAILABLE, response.getStatusCode()); 	}
@SuppressWarnings("unchecked") 	@Test 	public void customMapping() { 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().status("OK").build()); 		this.mvc.setStatusMapping(Collections.singletonMap("OK", 				HttpStatus.INTERNAL_SERVER_ERROR)); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof ResponseEntity); 		ResponseEntity<Health> response = (ResponseEntity<Health>) result; 		assertTrue(response.getBody().getStatus().equals(new Status("OK"))); 		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode()); 	}
@Test 	public void testHealth() throws Exception { 		ResponseEntity<String> entity = new TestRestTemplate().getForEntity( 				"http://localhost:" + this.port + "/health", String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertTrue("Wrong body: " + entity.getBody(), 				entity.getBody().contains("\"status\":\"UP\"")); 		assertFalse("Wrong body: " + entity.getBody(), 				entity.getBody().contains("\"hello\":\"1\"")); 	}
void processAndApply() { 		ConfigDataImporter importer = new ConfigDataImporter(this.logFactory, this.notFoundAction, this.resolvers, 				this.loaders); 		registerBootstrapBinder(this.contributors, null, DENY_INACTIVE_BINDING); 		ConfigDataEnvironmentContributors contributors = processInitial(this.contributors, importer); 		ConfigDataActivationContext activationContext = createActivationContext( 				contributors.getBinder(null, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE)); 		contributors = processWithoutProfiles(contributors, importer, activationContext); 		activationContext = withProfiles(contributors, activationContext); 		contributors = processWithProfiles(contributors, importer, activationContext); 		applyToEnvironment(contributors, activationContext); 	}
private ConfigDataEnvironmentContributors processInitial(ConfigDataEnvironmentContributors contributors, 			ConfigDataImporter importer) { 		this.logger.trace("Processing initial config data environment contributors without activation context"); 		contributors = contributors.withProcessedImports(importer, null); 		registerBootstrapBinder(contributors, null, DENY_INACTIVE_BINDING); 		return contributors; 	}
private ConfigDataEnvironmentContributors processWithoutProfiles(ConfigDataEnvironmentContributors contributors, 			ConfigDataImporter importer, ConfigDataActivationContext activationContext) { 		this.logger.trace("Processing config data environment contributors with initial activation context"); 		contributors = contributors.withProcessedImports(importer, activationContext); 		registerBootstrapBinder(contributors, activationContext, DENY_INACTIVE_BINDING); 		return contributors; 	}
private ConfigDataEnvironmentContributors processWithProfiles(ConfigDataEnvironmentContributors contributors, 			ConfigDataImporter importer, ConfigDataActivationContext activationContext) { 		this.logger.trace("Processing config data environment contributors with profile activation context"); 		contributors = contributors.withProcessedImports(importer, activationContext); 		registerBootstrapBinder(contributors, activationContext, ALLOW_INACTIVE_BINDING); 		return contributors; 	}
@Test 	void bootstrapsApplicationContext() { 		try (ConfigurableApplicationContext context = this.application 				.run("--spring.config.import=classpath:application-bootstrap-registry-integration-tests.properties")) { 			LoaderHelper bean = context.getBean(TestConfigDataBootstrap.LoaderHelper.class); 			assertThat(bean).isNotNull(); 			assertThat(bean.getBound()).isEqualTo("igotbound"); 			assertThat(bean.getProfileBound()).isEqualTo("igotprofilebound"); 			assertThat(bean.getLocation().getResolverHelper().getLocation()) 					.isEqualTo(ConfigDataLocation.of("testbootstrap:test")); 		} 	}
@Override 			public void run() { 				SpringApplication application = new SpringApplication(FailingConfig.class); 				application.setWebApplicationType(WebApplicationType.NONE); 				application.run(); 			}
@Override 		public void registerShutdownHook() { 			this.applicationContext.registerShutdownHook(); 		}
@Test 	void run() { 		this.context = SpringApplication.run(ExampleWebConfig.class); 		assertThat(this.context).isNotNull(); 	}
@Test 	void shouldStopKeepAliveThreadIfContextIsClosed() { 		SpringApplication application = new SpringApplication(ExampleConfig.class); 		application.setWebApplicationType(WebApplicationType.NONE); 		application.setKeepAlive(true); 		this.context = application.run(); 		Set<Thread> threadsBeforeClose = getCurrentThreads(); 		assertThat(threadsBeforeClose).filteredOn((thread) -> thread.getName().equals("keep-alive")).isNotEmpty(); 		this.context.close(); 		Set<Thread> threadsAfterClose = getCurrentThreads(); 		Awaitility.await() 			.atMost(Duration.ofSeconds(30)) 			.untilAsserted( 					() -> assertThat(threadsAfterClose).filteredOn((thread) -> thread.getName().equals("keep-alive")) 						.isEmpty()); 	}
@Override 		public void onApplicationEvent(ApplicationEvent event) { 			this.events.add(event.getClass(), event); 		}
@Test 	void registerShutdownHook() { 		SpringApplication application = new SpringApplication(ExampleConfig.class); 		application.setWebApplicationType(WebApplicationType.NONE); 		this.context = application.run(); 		assertThat(SpringApplicationShutdownHookInstance.get()).registeredApplicationContext(this.context); 	}
@Bean 		String someBean() { 			return "override"; 		}
@Bean 		String someBean() { 			return "test"; 		}
@PostConstruct 		void fail() { 			throw new RefreshFailureException(); 		}
@Bean 		@Order 		CommandLineRunner runnerC() { 			return (args) -> this.runners.add("runnerC"); 		}
@Bean 		@Order(Ordered.LOWEST_PRECEDENCE - 1) 		ApplicationRunner runnerB() { 			return (args) -> this.runners.add("runnerB"); 		}
@Bean 		@Order(Ordered.HIGHEST_PRECEDENCE) 		CommandLineRunner runnerA() { 			return (args) -> this.runners.add("runnerA"); 		}
@Bean 		TestCommandLineRunner runnerC() { 			return new TestCommandLineRunner(Ordered.LOWEST_PRECEDENCE, "runnerB", "runnerA"); 		}
@Bean 		TestApplicationRunner runnerB() { 			return new TestApplicationRunner(Ordered.LOWEST_PRECEDENCE - 1, "runnerA"); 		}
@Bean 		TestCommandLineRunner runnerA() { 			return new TestCommandLineRunner(Ordered.HIGHEST_PRECEDENCE); 		}
@Bean 		CommandLineRunner runner() { 			return (args) -> { 				throw new IllegalStateException(); 			}; 		}
@Bean 		CommandLineRunner runner() { 			return (args) -> { 				throw new IllegalStateException(new ExitStatusException()); 			}; 		}
@Bean 		Object fail() { 			throw new RuntimeException("ExpectedError"); 		}
Integer getExitCode() { 			return this.exitCode; 		}
@Override 		public int getExitCode() { 			return 11; 		}
@Override 		@SuppressWarnings("unchecked") 		public void onApplicationEvent(ApplicationEvent event) { 			this.reference.set((E) event); 		}
static void main(String[] args) { 			SpringApplication application = new SpringApplication(ExampleConfig.class); 			application.setWebApplicationType(WebApplicationType.NONE); 			application.addListeners(new ApplicationListener<ApplicationEnvironmentPreparedEvent>() {  				@Override 				public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) { 					SpringApplicationBuilder builder = new SpringApplicationBuilder( 							InnerApplicationConfiguration.class); 					builder.web(WebApplicationType.NONE); 					builder.run().close(); 				}  			}); 			application.run(args); 		}
static void main(String[] args) { 			SpringApplication application = new SpringApplication(ExampleConfig.class); 			application.setWebApplicationType(WebApplicationType.NONE); 			application.run(args); 		}
public void build(BuildRequest request) throws DockerEngineException, IOException { 		Assert.notNull(request, "Request must not be null"); 		this.log.start(request); 		Image builderImage = getImage(request, ImageType.BUILDER); 		BuilderMetadata builderMetadata = BuilderMetadata.fromImage(builderImage); 		BuildOwner buildOwner = BuildOwner.fromEnv(builderImage.getConfig().getEnv()); 		request = determineRunImage(request, builderImage, builderMetadata.getStack()); 		EphemeralBuilder builder = new EphemeralBuilder(buildOwner, builderImage, request.getName(), builderMetadata, 				request.getCreator(), request.getEnv()); 		this.docker.image().load(builder.getArchive(), UpdateListener.none()); 		try { 			executeLifecycle(request, builder); 			if (request.isPublish()) { 				pushImage(request.getName()); 			} 		} 		finally { 			this.docker.image().remove(builder.getName(), true); 		} 	}
@BeforeEach 	void setup() throws Exception { 		this.image = Image.of(getContent("image.json")); 		this.targetImage = ImageReference.of("my-image:latest"); 		this.metadata = BuilderMetadata.fromImage(this.image); 		this.env = new HashMap<>(); 		this.env.put("spring", "boot"); 		this.env.put("empty", null); 	}
@Test 	void getNameHasRandomName() throws Exception { 		EphemeralBuilder b1 = new EphemeralBuilder(this.owner, this.image, this.targetImage, this.metadata, 				this.creator, this.env); 		EphemeralBuilder b2 = new EphemeralBuilder(this.owner, this.image, this.targetImage, this.metadata, 				this.creator, this.env); 		assertThat(b1.getName().toString()).startsWith("pack.local/builder/").endsWith(":latest"); 		assertThat(b1.getName().toString()).isNotEqualTo(b2.getName().toString()); 	}
@Test 	void getArchiveHasCreatedByConfig() throws Exception { 		EphemeralBuilder builder = new EphemeralBuilder(this.owner, this.image, this.targetImage, this.metadata, 				this.creator, this.env); 		ImageConfig config = builder.getArchive().getImageConfig(); 		BuilderMetadata ephemeralMetadata = BuilderMetadata.fromImageConfig(config); 		assertThat(ephemeralMetadata.getCreatedBy().getName()).isEqualTo("Spring Boot"); 		assertThat(ephemeralMetadata.getCreatedBy().getVersion()).isEqualTo("dev"); 	}
@Test 	void getArchiveHasTag() throws Exception { 		EphemeralBuilder builder = new EphemeralBuilder(this.owner, this.image, this.targetImage, this.metadata, 				this.creator, this.env); 		ImageReference tag = builder.getArchive().getTag(); 		assertThat(tag.toString()).startsWith("pack.local/builder/").endsWith(":latest"); 	}
@Test 	void getArchiveHasFixedCreateDate() throws Exception { 		EphemeralBuilder builder = new EphemeralBuilder(this.owner, this.image, this.targetImage, this.metadata, 				this.creator, this.env); 		Instant createInstant = builder.getArchive().getCreateDate(); 		OffsetDateTime createDateTime = OffsetDateTime.ofInstant(createInstant, ZoneId.of("UTC")); 		assertThat(createDateTime.getYear()).isEqualTo(1980); 		assertThat(createDateTime.getMonthValue()).isEqualTo(1); 		assertThat(createDateTime.getDayOfMonth()).isEqualTo(1); 		assertThat(createDateTime.getHour()).isEqualTo(0); 		assertThat(createDateTime.getMinute()).isEqualTo(0); 		assertThat(createDateTime.getSecond()).isEqualTo(1); 	}
@Test 	void getArchiveContainsEnvLayer() throws Exception { 		EphemeralBuilder builder = new EphemeralBuilder(this.owner, this.image, this.targetImage, this.metadata, 				this.creator, this.env); 		File directory = unpack(getLayer(builder.getArchive(), 0), "env"); 		assertThat(new File(directory, "platform/env/spring")).usingCharset(StandardCharsets.UTF_8).hasContent("boot"); 		assertThat(new File(directory, "platform/env/empty")).usingCharset(StandardCharsets.UTF_8).hasContent(""); 	}
@Test 	void whenARequestIsActiveAfterGracefulShutdownEndsThenStopWillComplete() 			throws InterruptedException, BrokenBarrierException { 		AbstractServletWebServerFactory factory = getFactory(); 		factory.setShutdown(Shutdown.GRACEFUL); 		BlockingServlet blockingServlet = new BlockingServlet(); 		this.webServer = factory 				.getWebServer((context) -> context.addServlet("blockingServlet", blockingServlet).addMapping("/")); 		this.webServer.start(); 		int port = this.webServer.getPort(); 		initiateGetRequest(port, "/"); 		blockingServlet.awaitQueue(); 		AtomicReference<GracefulShutdownResult> result = new AtomicReference<>(); 		this.webServer.shutDownGracefully(result::set); 		this.webServer.stop(); 		assertThat(Awaitility.await().atMost(Duration.ofSeconds(30)).until(result::get, Objects::nonNull)) 				.isEqualTo(GracefulShutdownResult.REQUESTS_ACTIVE); 		try { 			blockingServlet.admitOne(); 		} 		catch (RuntimeException ex) {  		} 	}
@Override 			public void service(ServletRequest request, ServletResponse response) throws IOException { 				HttpSession session = ((HttpServletRequest) request).getSession(true); 				long value = System.currentTimeMillis(); 				Object existing = session.getAttribute("boot"); 				session.setAttribute("boot", value); 				PrintWriter writer = response.getWriter(); 				writer.append(String.valueOf(existing)).append(":").append(String.valueOf(value)); 			}
@Override 			public void service(ServletRequest request, ServletResponse response) { 				throw new RuntimeException("Planned"); 			}
@Override 		public void init() throws ServletException { 			throw new FailingServletException(); 		}
@Override 		public void init() { 			this.initCount++; 		}
@Override 		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { 			Blocker blocker = new Blocker(); 			this.blockers.add(blocker); 			blocker.await(); 		}
@Override 		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { 			Blocker blocker = new Blocker(); 			this.blockers.add(blocker); 			AsyncContext async = req.startAsync(); 			new Thread(() -> { 				blocker.await(); 				async.complete(); 			}).start(); 		}
public void admitOne() throws InterruptedException { 			this.blockers.take().clear(); 		}
private void admitOne() throws InterruptedException { 			this.blockers.take().clear(); 		}
public void awaitQueue() throws InterruptedException { 			while (this.blockers.isEmpty()) { 				Thread.sleep(100); 			} 		}
private void awaitQueue() throws InterruptedException { 			while (this.blockers.isEmpty()) { 				Thread.sleep(100); 			} 		}
public void awaitQueue(int size) throws InterruptedException { 			while (this.blockers.size() < size) { 				Thread.sleep(100); 			} 		}
@Override 		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { 			Blocker blocker = new Blocker(); 			this.blockers.add(blocker); 			blocker.await(); 		}
@Override 		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { 			Blocker blocker = new Blocker(); 			this.blockers.add(blocker); 			AsyncContext async = req.startAsync(); 			new Thread(() -> { 				blocker.await(); 				async.complete(); 			}).start(); 		}
public void admitOne() throws InterruptedException { 			this.blockers.take().clear(); 		}
private void admitOne() throws InterruptedException { 			this.blockers.take().clear(); 		}
public void awaitQueue() throws InterruptedException { 			while (this.blockers.isEmpty()) { 				Thread.sleep(100); 			} 		}
private void awaitQueue() throws InterruptedException { 			while (this.blockers.isEmpty()) { 				Thread.sleep(100); 			} 		}
@Test 	void requestMappingIsInstrumented() { 		this.loopback.getForObject("/api/people", Set.class); 		waitAtMost(Duration.ofSeconds(5)).untilAsserted( 				() -> assertThat(this.registry.get("http.server.requests").timer().count()).isEqualTo(1));  	}
@Test 	void requestMappingIsInstrumented() { 		this.loopback.getForObject("/api/people", Set.class); 		waitAtMost(Duration.ofSeconds(5)).untilAsserted( 				() -> assertThat(this.registry.get("http.server.requests").timer().count()).isEqualTo(1));  	}
@Override 			protected TomcatWebServer getTomcatWebServer(Tomcat tomcat) { 				try { 					return super.getTomcatWebServer(tomcat); 				} 				finally { 					assertThat(tomcat.getServer().getState()).isEqualTo(LifecycleState.DESTROYED); 				} 			}
@Override 			protected TomcatWebServer getTomcatWebServer(Tomcat tomcat) { 				tomcat.enableNaming(); 				return super.getTomcatWebServer(tomcat); 			}
@Test 	void whenServerIsShuttingDownARequestOnAnIdleConnectionResultsInConnectionReset() throws Exception { 		AbstractServletWebServerFactory factory = getFactory(); 		factory.setShutdown(Shutdown.GRACEFUL); 		BlockingServlet blockingServlet = new BlockingServlet(); 		this.webServer = factory.getWebServer((context) -> { 			Dynamic registration = context.addServlet("blockingServlet", blockingServlet); 			registration.addMapping("/blocking"); 			registration.setAsyncSupported(true); 		}); 		HttpClient httpClient = HttpClients.createMinimal(); 		this.webServer.start(); 		int port = this.webServer.getPort(); 		Future<Object> keepAliveRequest = initiateGetRequest(httpClient, port, "/blocking"); 		blockingServlet.awaitQueue(); 		blockingServlet.admitOne(); 		assertThat(keepAliveRequest.get()).isInstanceOf(HttpResponse.class); 		Future<Object> request = initiateGetRequest(port, "/blocking"); 		blockingServlet.awaitQueue(); 		blockingServlet.setBlocking(false); 		this.webServer.shutDownGracefully((result) -> { 		}); 		Object idleConnectionRequestResult = Awaitility.await().until(() -> { 			Future<Object> idleConnectionRequest = initiateGetRequest(httpClient, port, "/blocking"); 			Object result = idleConnectionRequest.get(); 			return result; 		}, (result) -> result instanceof Exception); 		assertThat(idleConnectionRequestResult).isInstanceOfAny(SocketException.class, NoHttpResponseException.class); 		if (idleConnectionRequestResult instanceof SocketException) { 			assertThat((SocketException) idleConnectionRequestResult).hasMessage("Connection reset"); 		} 		blockingServlet.admitOne(); 		Object response = request.get(); 		assertThat(response).isInstanceOf(HttpResponse.class); 		this.webServer.stop(); 	}
@Override 			public void service(ServletRequest request, ServletResponse response) throws IOException { 				HttpSession session = ((HttpServletRequest) request).getSession(true); 				long value = System.currentTimeMillis(); 				Object existing = session.getAttribute("boot"); 				session.setAttribute("boot", value); 				PrintWriter writer = response.getWriter(); 				writer.append(String.valueOf(existing)).append(":").append(String.valueOf(value)); 			}
@Override 			public void service(ServletRequest request, ServletResponse response) { 				throw new RuntimeException("Planned"); 			}
@Override 		public void init() throws ServletException { 			throw new FailingServletException(); 		}
@Override 		public void init() { 			this.initCount++; 		}
@Override 		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { 			if (this.blocking) { 				CyclicBarrier barrier = new CyclicBarrier(2); 				this.barriers.add(barrier); 				try { 					barrier.await(); 				} 				catch (InterruptedException ex) { 					Thread.currentThread().interrupt(); 				} 				catch (BrokenBarrierException ex) { 					throw new ServletException(ex); 				} 			} 		}
@Override 		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { 			CyclicBarrier barrier = new CyclicBarrier(2); 			this.barriers.add(barrier); 			AsyncContext async = req.startAsync(); 			new Thread(() -> { 				try { 					barrier.await(); 				} 				catch (InterruptedException ex) { 					Thread.currentThread().interrupt(); 				} 				catch (BrokenBarrierException ex) {  				} 				async.complete(); 			}).start(); 		}
private void admitOne() { 			try { 				this.barriers.take().await(); 			} 			catch (InterruptedException ex) { 				Thread.currentThread().interrupt(); 			} 			catch (BrokenBarrierException ex) { 				throw new RuntimeException(ex); 			} 		}
@Override 		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { 			if (this.blocking) { 				CyclicBarrier barrier = new CyclicBarrier(2); 				this.barriers.add(barrier); 				try { 					barrier.await(); 				} 				catch (InterruptedException ex) { 					Thread.currentThread().interrupt(); 				} 				catch (BrokenBarrierException ex) { 					throw new ServletException(ex); 				} 			} 		}
public void admitOne() { 			try { 				CyclicBarrier barrier = this.barriers.take(); 				if (!barrier.isBroken()) { 					barrier.await(); 				} 			} 			catch (InterruptedException ex) { 				Thread.currentThread().interrupt(); 			} 			catch (BrokenBarrierException ex) { 				throw new RuntimeException(ex); 			} 		}
public boolean isDistributionComplete(ReleaseInfo releaseInfo) { 		RequestEntity<Void> allFilesRequest = getRequest(releaseInfo, 1); 		Object[] allFiles = waitAtMost(5, TimeUnit.MINUTES).with().pollDelay(20, TimeUnit.SECONDS).until(() -> { 			try { 				return this.restTemplate.exchange(allFilesRequest, Object[].class).getBody(); 			} 			catch (HttpClientErrorException ex) { 				if (ex.getStatusCode() != HttpStatus.NOT_FOUND) { 					throw ex; 				} 				return null; 			} 		}, Objects::nonNull); 		RequestEntity<Void> publishedFilesRequest = getRequest(releaseInfo, 0); 		try { 			waitAtMost(40, TimeUnit.MINUTES).with().pollDelay(20, TimeUnit.SECONDS).until(() -> { 				Object[] publishedFiles = this.restTemplate.exchange(publishedFilesRequest, Object[].class).getBody(); 				return allFiles.length == publishedFiles.length; 			}); 		} 		catch (ConditionTimeoutException ex) { 			return false; 		} 		return true; 	}
@Test 	void isDistributionComplete() throws Exception { 		this.server 				.expect(requestTo(String.format( 						"https://api.bintray.com/packages/%s/%s/%s/versions/%s/files?include_unpublished=%s", 						this.properties.getSubject(), this.properties.getRepo(), "example", "1.1.0.RELEASE", 1))) 				.andRespond(withStatus(HttpStatus.NOT_FOUND)); 		setupGetPackageFiles(1, "all-package-files.json"); 		setupGetPackageFiles(0, "published-files.json"); 		setupGetPackageFiles(0, "all-package-files.json"); 		assertThat(this.service.isDistributionComplete(getReleaseInfo())).isTrue(); 		this.server.verify(); 	}
@Test 	public void enableSchedulingWithNoTaskExecutorAutoConfiguresOne() { 		this.contextRunner 				.withPropertyValues( 						"spring.task.scheduling.thread-name-prefix=scheduling-test-") 				.withUserConfiguration(SchedulingConfiguration.class).run((context) -> { 					assertThat(context).hasSingleBean(TaskExecutor.class); 					TestBean bean = context.getBean(TestBean.class); 					assertThat(bean.latch.await(30, TimeUnit.SECONDS)).isTrue(); 					assertThat(bean.threadNames) 							.allMatch((name) -> name.contains("scheduling-test-")); 				}); 	}
@Test 	public void enableSchedulingWithNoTaskExecutorAppliesCustomizers() { 		this.contextRunner 				.withPropertyValues( 						"spring.task.scheduling.thread-name-prefix=scheduling-test-") 				.withUserConfiguration(SchedulingConfiguration.class, 						TaskSchedulerCustomizerConfiguration.class) 				.run((context) -> { 					assertThat(context).hasSingleBean(TaskExecutor.class); 					TestBean bean = context.getBean(TestBean.class); 					assertThat(bean.latch.await(30, TimeUnit.SECONDS)).isTrue(); 					assertThat(bean.threadNames) 							.allMatch((name) -> name.contains("customized-scheduler-")); 				}); 	}
@Test 	public void enableSchedulingWithExistingTaskSchedulerBacksOff() { 		this.contextRunner.withUserConfiguration(SchedulingConfiguration.class, 				TaskSchedulerConfiguration.class).run((context) -> { 					assertThat(context).hasSingleBean(TaskScheduler.class); 					assertThat(context.getBean(TaskScheduler.class)) 							.isInstanceOf(TestTaskScheduler.class); 					TestBean bean = context.getBean(TestBean.class); 					assertThat(bean.latch.await(30, TimeUnit.SECONDS)).isTrue(); 					assertThat(bean.threadNames).containsExactly("test-1"); 				}); 	}
@Test 	public void enableSchedulingWithExistingScheduledExecutorServiceBacksOff() { 		this.contextRunner.withUserConfiguration(SchedulingConfiguration.class, 				ScheduledExecutorServiceConfiguration.class).run((context) -> { 					assertThat(context).doesNotHaveBean(TaskScheduler.class); 					assertThat(context).hasSingleBean(ScheduledExecutorService.class); 					TestBean bean = context.getBean(TestBean.class); 					assertThat(bean.latch.await(30, TimeUnit.SECONDS)).isTrue(); 					assertThat(bean.threadNames) 							.allMatch((name) -> name.contains("pool-")); 				}); 	}
@Test 	public void enableSchedulingWithConfigurerBacksOff() { 		this.contextRunner.withUserConfiguration(SchedulingConfiguration.class, 				SchedulingConfigurerConfiguration.class).run((context) -> { 					assertThat(context).doesNotHaveBean(TaskScheduler.class); 					TestBean bean = context.getBean(TestBean.class); 					assertThat(bean.latch.await(30, TimeUnit.SECONDS)).isTrue(); 					assertThat(bean.threadNames).containsExactly("test-1"); 				}); 	}
@Scheduled(fixedRate = 60000) 		public void accumulate() { 			this.threadNames.add(Thread.currentThread().getName()); 			this.latch.countDown(); 		}
private Supplier<C> getContext(HttpServletRequest request) { 		if (this.context == null) { 			synchronized (this.contextLock) { 				if (this.context == null) { 					Supplier<C> createdContext = createContext(request); 					initialized(createdContext); 					this.context = createdContext; 				} 			} 		} 		return this.context; 	}
private Mono<Void> validateKeyIdAndSignature(Token token) { 		String keyId = token.getKeyId(); 		Map<String, String> localCachedTokenKeys = new HashMap<>(this.cachedTokenKeys); 		return Mono.just(localCachedTokenKeys) 				.filter((tokenKeys) -> tokenKeys.containsKey(keyId)) 				.switchIfEmpty(this.securityService.fetchTokenKeys() 						.doOnSuccess((fetchedTokenKeys) -> { 							this.cachedTokenKeys.clear(); 							this.cachedTokenKeys.putAll(fetchedTokenKeys); 						}).filter((tokenKeys) -> tokenKeys.containsKey(keyId)) 						.switchIfEmpty((Mono.error(new CloudFoundryAuthorizationException( 								Reason.INVALID_KEY_ID, 								"Key Id present in token header does not match"))))) 				.filter((tokenKeys) -> hasValidSignature(token, tokenKeys.get(keyId))) 				.switchIfEmpty(Mono.error(new CloudFoundryAuthorizationException( 						Reason.INVALID_SIGNATURE, "RSA Signature did not match content"))) 				.then(); 	}
@Test 	public void getRequestShouldReturnHeapDumpInResponseBody() throws Exception { 		client.get().uri("/application/heapdump").exchange().expectStatus().isOk() 				.expectHeader().contentType(MediaType.APPLICATION_OCTET_STREAM) 				.expectBody(String.class).isEqualTo("HEAPDUMP"); 		assertHeapDumpFileIsDeleted(); 	}
@Override 	protected Class<?> loadClass(String name, boolean resolve) 			throws ClassNotFoundException { 		Handler.setUseFastConnectionExceptions(true); 		try { 			try { 				definePackageIfNecessary(name); 			} 			catch (IllegalArgumentException ex) { 				// Tolerate race condition due to being parallel capable 				if (getPackage(name) == null) { 					// This should never happen as the IllegalArgumentException indicates 					// that the package has already been defined and, therefore, 					// getPackage(name) should not return null. 					throw new AssertionError("Package " + name + " has already been " 							+ "defined but it could not be found"); 				} 			} 			return super.loadClass(name, resolve); 		} 		finally { 			Handler.setUseFastConnectionExceptions(false); 		} 	}
private void definePackageIfNecessary(String className) { 		int lastDot = className.lastIndexOf('.'); 		if (lastDot >= 0) { 			String packageName = className.substring(0, lastDot); 			if (getPackage(packageName) == null) { 				try { 					definePackage(packageName); 				} 				catch (IllegalArgumentException ex) { 					// Tolerate race condition due to being parallel capable 					if (getPackage(packageName) == null) { 						// This should never happen as the IllegalArgumentException 						// indicates that the package has already been defined and, 						// therefore, getPackage(name) should not have returned null. 						throw new AssertionError( 								"Package " + packageName + " has already been defined " 										+ "but it could not be found"); 					} 				} 			} 		} 	}
@Test 	public void clientClose() throws Exception { 		WebSocketClient client = new WebSocketClient(); 		try { 			Socket socket = openSocket(client, new Socket()); 			socket.getSession().close(); 		} 		finally { 			client.stop(); 		} 		awaitClosedException(); 		assertThat(this.server.getClosedExceptions().size(), greaterThan(0)); 	}
public List<ConnectionClosedException> getClosedExceptions() { 			synchronized (this.monitor) { 				return new ArrayList<ConnectionClosedException>(this.closedExceptions); 			} 		}
@Override 			public void run() throws Exception { 				try { 					super.run(); 				} 				catch (ConnectionClosedException ex) { 					synchronized (MonitoredLiveReloadServer.this.monitor) { 						MonitoredLiveReloadServer.this.closedExceptions.add(ex); 					} 					throw ex; 				} 			}
private String getOutput() throws Exception { 		Future<String> future = Executors.newSingleThreadExecutor().submit( 				new Callable<String>() { 					@Override 					public String call() throws Exception { 						Resource[] resources = getResourcesWithContent(); 						while (resources.length == 0) { 							Thread.sleep(200); 							resources = getResourcesWithContent(); 						} 						StringBuilder builder = new StringBuilder(); 						for (Resource resource : resources) { 							builder.append(new String(StreamUtils 									.copyToByteArray(resource.getInputStream()))); 						} 						return builder.toString(); 					} 				}); 		return future.get(30, TimeUnit.SECONDS); 	}
@Override 					public String call() throws Exception { 						Resource[] resources = getResourcesWithContent(); 						while (resources.length == 0) { 							Thread.sleep(200); 							resources = getResourcesWithContent(); 						} 						StringBuilder builder = new StringBuilder(); 						for (Resource resource : resources) { 							builder.append(new String(StreamUtils 									.copyToByteArray(resource.getInputStream()))); 						} 						return builder.toString(); 					}
protected int run(Collection<String> args) throws IOException { 		ProcessBuilder builder = new ProcessBuilder(this.command); 		builder.command().addAll(args); 		builder.redirectErrorStream(true); 		boolean inheritedIO = inheritIO(builder); 		try { 			Process process = builder.start(); 			this.process = process; 			if (!inheritedIO) { 				redirectOutput(process); 			} 			SignalUtils.attachSignalHandler(new Runnable() { 				@Override 				public void run() { 					handleSigInt(); 				} 			}); 			try { 				return process.waitFor(); 			} 			catch (InterruptedException ex) { 				Thread.currentThread().interrupt(); 				return 1; 			} 		} 		finally { 			this.endTime = System.currentTimeMillis(); 			this.process = null; 		} 	}
@Override 			public void run() { 				try { 					String line = reader.readLine(); 					while (line != null) { 						System.out.println(line); 						line = reader.readLine(); 						System.out.flush(); 					} 					reader.close(); 				} 				catch (Exception ex) { 				} 			}
@Override 				public void run() { 					handleSigInt(); 				}
@Override 		public Iterator<ConditionAndOutcome> iterator() { 			return Collections.unmodifiableSet(this.outcomes).iterator(); 		}
@Test 	public void parent() throws Exception { 		this.beanFactory.setParentBeanFactory(new DefaultListableBeanFactory()); 		AutoConfigurationReport.get((ConfigurableListableBeanFactory) this.beanFactory.getParentBeanFactory()); 		assertThat(this.report, 				sameInstance(AutoConfigurationReport.get(this.beanFactory))); 		assertThat(this.report, not(nullValue())); 		assertThat(this.report.getParent(), not(nullValue())); 	}
@Test 	public void recordConditionEvaluations() throws Exception { 		given(this.outcome1.getMessage()).willReturn("Message 1"); 		given(this.outcome2.getMessage()).willReturn("Message 2"); 		given(this.outcome3.getMessage()).willReturn("Message 3");  		this.report.recordConditionEvaluation("a", this.condition1, this.outcome1); 		this.report.recordConditionEvaluation("a", this.condition2, this.outcome2); 		this.report.recordConditionEvaluation("b", this.condition3, this.outcome3);  		Map<String, ConditionAndOutcomes> map = this.report.getConditionAndOutcomesBySource(); 		assertThat(map.size(), equalTo(2)); 		Iterator<ConditionAndOutcome> iterator = map.get("a").iterator(); 		ConditionAndOutcome conditionAndOutcome = iterator.next(); 		assertThat(conditionAndOutcome.getCondition(), equalTo(this.condition1)); 		assertThat(conditionAndOutcome.getOutcome(), equalTo(this.outcome1)); 		conditionAndOutcome = iterator.next(); 		assertThat(conditionAndOutcome.getCondition(), equalTo(this.condition2)); 		assertThat(conditionAndOutcome.getOutcome(), equalTo(this.outcome2)); 		assertThat(iterator.hasNext(), equalTo(false)); 		iterator = map.get("b").iterator(); 		conditionAndOutcome = iterator.next(); 		assertThat(conditionAndOutcome.getCondition(), equalTo(this.condition3)); 		assertThat(conditionAndOutcome.getOutcome(), equalTo(this.outcome3)); 		assertThat(iterator.hasNext(), equalTo(false)); 	}
@Test 	@SuppressWarnings("resource") 	public void springBootConditionPopulatesReport() throws Exception { 		AutoConfigurationReport report = AutoConfigurationReport.get(new AnnotationConfigApplicationContext( 				Config.class).getBeanFactory()); 		assertThat(report.getConditionAndOutcomesBySource().size(), not(equalTo(0))); 	}
@Test 	public void emptyServerWhenPortIsZero() throws Exception { 		ConfigurableEmbeddedServletContainerFactory factory = getFactory(); 		factory.setPort(0); 		this.container = factory 				.getEmbeddedServletContainer(exampleServletRegistration()); 		this.container.start(); 		this.thrown.expect(IOException.class); 		getResponse("http://localhost:8080/hello"); 	}
@Test 	public void stopServlet() throws Exception { 		ConfigurableEmbeddedServletContainerFactory factory = getFactory(); 		this.container = factory 				.getEmbeddedServletContainer(exampleServletRegistration()); 		this.container.start(); 		this.container.stop(); 		this.thrown.expect(IOException.class); 		getResponse("http://localhost:8080/hello"); 	}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						servletContext.addServlet("test", servlet).setLoadOnStartup(1); 					}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						try { 							Thread.sleep(500); 							date[0] = new Date(); 						} 						catch (InterruptedException ex) { 							throw new ServletException(ex); 						} 					}
@Override 	public void customize(ConfigurableEmbeddedServletContainerFactory factory) { 		Integer port = getPort(); 		if (port != null) { 			factory.setPort(port); 		} 		if (getAddress() != null) { 			factory.setAddress(getAddress()); 		} 		if (getContextPath() != null) { 			factory.setContextPath(getContextPath()); 		} 		if (getSessionTimeout() != null) { 			factory.setSessionTimeout(getSessionTimeout()); 		} 		if (factory instanceof TomcatEmbeddedServletContainerFactory) { 			getTomcat().customizeTomcat((TomcatEmbeddedServletContainerFactory) factory); 		} 	}
@Override 	public void setPort(int port) { 		this.port = port; 	}
@Override 	public void start() throws EmbeddedServletContainerException { 		if (!this.autoStart) { 			return; 		} 		try { 			this.server.start(); 			Connector[] connectors = this.server.getConnectors(); 			for (Connector connector : connectors) { 				connector.start(); 				this.logger.info("Jetty started on port: " + connector.getLocalPort()); 			} 		} 		catch (Exception ex) { 			throw new EmbeddedServletContainerException( 					"Unable to start embedded Jetty servlet container", ex); 		} 	}
@Override 	public EmbeddedServletContainer getEmbeddedServletContainer( 			ServletContextInitializer... initializers) { 		WebAppContext context = new WebAppContext(); 		int port = getPort() >= 0 ? getPort() : 0; 		Server server = new Server(new InetSocketAddress(getAddress(), port));  		if (this.resourceLoader != null) { 			context.setClassLoader(this.resourceLoader.getClassLoader()); 		} 		String contextPath = getContextPath(); 		context.setContextPath(StringUtils.hasLength(contextPath) ? contextPath : "/"); 		configureDocumentRoot(context); 		if (isRegisterDefaultServlet()) { 			addDefaultServlet(context); 		} 		if (isRegisterJspServlet() 				&& ClassUtils.isPresent(getJspServletClassName(), getClass() 						.getClassLoader())) { 			addJspServlet(context); 		}  		ServletContextInitializer[] initializersToUse = mergeInitializers(initializers); 		Configuration[] configurations = getWebAppContextConfigurations(context, 				initializersToUse); 		context.setConfigurations(configurations); 		context.getSessionHandler().getSessionManager() 				.setMaxInactiveInterval(getSessionTimeout()); 		postProcessWebAppContext(context);  		server.setHandler(context); 		this.logger.info("Server initialized with port: " + port); 		return getJettyEmbeddedServletContainer(server); 	}
@Override 			public void configure(WebAppContext context) throws Exception { 				MimeTypes mimeTypes = context.getMimeTypes(); 				for (MimeMappings.Mapping mapping : getMimeMappings()) { 					mimeTypes.addMimeMapping(mapping.getExtension(), 							mapping.getMimeType()); 				} 			}
@Override 			public void configure(WebAppContext context) throws Exception { 				ErrorHandler errorHandler = context.getErrorHandler(); 				addJettyErrorPages(errorHandler, getErrorPages()); 			}
protected JettyEmbeddedServletContainer getJettyEmbeddedServletContainer(Server server) { 		return new JettyEmbeddedServletContainer(server, getPort() >= 0); 	}
@Override 	public void start() throws EmbeddedServletContainerException { 		Connector connector = this.tomcat.getConnector(); 		if (connector != null && this.autoStart) { 			try { 				connector.getProtocolHandler().start(); 				this.logger.info("Tomcat started on port: " + connector.getLocalPort()); 			} 			catch (Exception ex) { 				this.logger.error("Cannot start connector: ", ex); 				throw new EmbeddedServletContainerException( 						"Unable to start embdedded Tomcat connectors", ex); 			} 		} 	}
protected void customizeConnector(Connector connector) { 		int port = getPort() >= 0 ? getPort() : 0; 		connector.setPort(port); 		if (connector.getProtocolHandler() instanceof AbstractProtocol) { 			if (getAddress() != null) { 				((AbstractProtocol) connector.getProtocolHandler()) 						.setAddress(getAddress()); 			} 		} 		// If ApplicationContext is slow to start we want Tomcat not to bind to the socket 		// prematurely... 		connector.setProperty("bindOnInit", "false"); 		for (TomcatConnectorCustomizer customizer : this.tomcatConnectorCustomizers) { 			customizer.customize(connector); 		} 	}
protected TomcatEmbeddedServletContainer getTomcatEmbeddedServletContainer( 			Tomcat tomcat) { 		return new TomcatEmbeddedServletContainer(tomcat, getPort() >= 0); 	}
@Override 	public void increment(String metricName, int amount, Date timestamp) { 		Object lock = this.locks.putIfAbsent(metricName, new Object()); 		if (lock == null) { 			lock = this.locks.get(metricName); 		} 		synchronized (lock) { 			Measurement current = this.metrics.get(metricName); 			if (current != null) { 				Metric metric = current.getMetric(); 				this.metrics.replace(metricName, current, new Measurement(timestamp, 						metric.increment(amount))); 				return; 			} 			else { 				this.metrics.putIfAbsent(metricName, new Measurement(timestamp, 						new Metric(metricName, amount))); 			} 		} 	}
@Override 	public void applyDependencies(DependencyCustomizer dependencies) { 		dependencies 				.ifAnyMissingClasses("org.springframework.web.servlet.mvc.Controller") 				.add("org.springframework", "spring-webmvc", 						dependencies.getProperty("spring.version"));  		dependencies 				.ifAnyMissingClasses("org.apache.catalina.startup.Tomcat") 				.add("org.apache.tomcat.embed", "tomcat-embed-core", 						dependencies.getProperty("tomcat.version")) 				.add("org.apache.tomcat.embed", "tomcat-embed-logging-juli", 						dependencies.getProperty("tomcat.version"));  		dependencies.add("org.codehaus.groovy", "groovy-templates", 				dependencies.getProperty("groovy.version")); 	}
@Bean 		public SpringTemplateEngine templateEngine() { 			SpringTemplateEngine engine = new SpringTemplateEngine(); 			for (ITemplateResolver templateResolver : this.templateResolvers) { 				engine.addTemplateResolver(templateResolver); 			} 			for (IDialect dialect : this.dialects) { 				engine.addDialect(dialect); 			} 			return engine; 		}
@Bean 		public SpringTemplateEngine templateEngine() { 			SpringTemplateEngine engine = new SpringTemplateEngine(); 			for (ITemplateResolver templateResolver : this.templateResolvers) { 				engine.addTemplateResolver(templateResolver); 			} 			for (IDialect dialect : this.dialects) { 				engine.addDialect(dialect); 			} 			return engine; 		}
@Test 	void userDefinedMappingsSecureByDefault() throws Exception { 		WebClient webClient = this.webClientBuilder.baseUrl("http://localhost:" + this.port + "/").build(); 		ClientResponse response = webClient.get().header("Authorization", getBasicAuth()).exchange() 				.block(Duration.ofSeconds(30)); 		assertThat(response.statusCode()).isEqualTo(HttpStatus.OK); 		ResponseCookie sessionCookie = response.cookies().getFirst("SESSION"); 		String sessionId = response.bodyToMono(String.class).block(Duration.ofSeconds(30)); 		response = webClient.get().cookie("SESSION", sessionCookie.getValue()).exchange().block(Duration.ofSeconds(30)); 		assertThat(response.statusCode()).isEqualTo(HttpStatus.OK); 		assertThat(response.bodyToMono(String.class).block(Duration.ofSeconds(30))).isEqualTo(sessionId); 		Thread.sleep(5000); 		response = webClient.get().cookie("SESSION", sessionCookie.getValue()).exchange().block(Duration.ofSeconds(30)); 		assertThat(response.statusCode()).isEqualTo(HttpStatus.UNAUTHORIZED); 	}
private void configureSession(Context context) { 		long sessionTimeout = getSessionTimeoutInMinutes(); 		context.setSessionTimeout((int) sessionTimeout); 		Manager manager = context.getManager(); 		if (manager == null) { 			manager = new StandardManager(); 			context.setManager(manager); 		} 		if (isPersistSession()) { 			configurePersistSession(manager); 		} 		else { 			disablePersistSession(manager); 		} 	}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						servletContext.addServlet("test", servlet).setLoadOnStartup(1); 					}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						try { 							Thread.sleep(500); 							date[0] = new Date(); 						} 						catch (InterruptedException ex) { 							throw new ServletException(ex); 						} 					}
@Override 			public void service(ServletRequest request, ServletResponse response) 					throws ServletException, IOException { 				HttpSession session = ((HttpServletRequest) request).getSession(true); 				long value = System.currentTimeMillis(); 				Object existing = session.getAttribute("boot"); 				session.setAttribute("boot", value); 				PrintWriter writer = response.getWriter(); 				writer.append(String.valueOf(existing) + ":" + value); 			}
@Override 			public void service(ServletRequest request, ServletResponse response) 					throws ServletException, IOException { 				throw new RuntimeException("Planned"); 			}
@Override 			public void run() { 				TomcatEmbeddedServletContainerFactory factory = getFactory(); 				Connector connector = new Connector( 						"org.apache.coyote.http11.Http11NioProtocol"); 				connector.setPort(port); 				factory.addAdditionalTomcatConnectors(connector);  				try { 					TomcatEmbeddedServletContainerFactoryTests.this.container = factory 							.getEmbeddedServletContainer(); 					TomcatEmbeddedServletContainerFactoryTests.this.container.start(); 					fail(); 				} 				catch (IllegalStateException ex) { 					// Ignore 				} 			}
@Override 			public void run() { 				TomcatEmbeddedServletContainerFactory factory = getFactory(); 				factory.setPort(port);  				try { 					TomcatEmbeddedServletContainerFactoryTests.this.container = factory 							.getEmbeddedServletContainer(); 					TomcatEmbeddedServletContainerFactoryTests.this.container.start(); 					fail(); 				} 				catch (IllegalStateException ex) { 					// Ignore 				} 			}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						servletContext.addServlet("test", servlet).setLoadOnStartup(1); 					}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						try { 							Thread.sleep(500); 							date[0] = new Date(); 						} 						catch (InterruptedException ex) { 							throw new ServletException(ex); 						} 					}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						servletContext.addServlet("test", servlet).setLoadOnStartup(1); 					}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						try { 							Thread.sleep(500); 							date[0] = new Date(); 						} 						catch (InterruptedException ex) { 							throw new ServletException(ex); 						} 					}
protected void applyProperties(VelocityEngineFactory factory) { 			factory.setResourceLoaderPath(this.properties.getResourceLoaderPath()); 			factory.setPreferFileSystemAccess(this.properties.isPreferFileSystemAccess()); 			Properties velocityProperties = new Properties(); 			velocityProperties.setProperty("input.encoding", this.properties.getCharsetName()); 			velocityProperties.putAll(this.properties.getProperties()); 			factory.setVelocityProperties(velocityProperties); 		}
protected void applyProperties(VelocityEngineFactory factory) { 			factory.setResourceLoaderPath(this.properties.getResourceLoaderPath()); 			factory.setPreferFileSystemAccess(this.properties.isPreferFileSystemAccess()); 			Properties velocityProperties = new Properties(); 			velocityProperties.setProperty("input.encoding", this.properties.getCharset()); 			velocityProperties.putAll(this.properties.getProperties()); 			factory.setVelocityProperties(velocityProperties); 		}
@Test 	public void ownAuthenticationAuditListener() { 		this.contextRunner 				.withUserConfiguration(CustomAuditEventRepositoryConfiguration.class) 				.withUserConfiguration( 						CustomAuthenticationAuditListenerConfiguration.class) 				.run((context) -> assertThat( 						context.getBean(AbstractAuthenticationAuditListener.class)) 								.isInstanceOf(TestAuthenticationAuditListener.class)); 	}
@Test 	public void ownAuthorizationAuditListener() { 		this.contextRunner 				.withUserConfiguration(CustomAuditEventRepositoryConfiguration.class) 				.withUserConfiguration( 						CustomAuthorizationAuditListenerConfiguration.class) 				.run((context) -> assertThat( 						context.getBean(AbstractAuthorizationAuditListener.class)) 								.isInstanceOf(TestAuthorizationAuditListener.class)); 	}
@Test 	public void ownAuditListener() { 		this.contextRunner 				.withUserConfiguration(CustomAuditEventRepositoryConfiguration.class) 				.withUserConfiguration(CustomAuditListenerConfiguration.class) 				.run((context) -> assertThat(context.getBean(AbstractAuditListener.class)) 						.isInstanceOf(TestAuditListener.class)); 	}
@Test 	public void runWhenEnabledPropertyIsFalseShouldNotHaveEndpoint() { 		this.contextRunner 				.withUserConfiguration(CustomAuditEventRepositoryConfiguration.class) 				.withPropertyValues("management.endpoint.auditevents.enabled:false") 				.withPropertyValues("management.endpoints.web.exposure.include=*") 				.run((context) -> assertThat(context) 						.doesNotHaveBean(AuditEventsEndpoint.class)); 	}
public void process(AuthenticationAuditListener listener, 				AbstractAuthenticationEvent input) { 			if (listener != null) { 				AuthenticationSwitchUserEvent event = (AuthenticationSwitchUserEvent) input; 				Map<String, Object> data = new HashMap<>(); 				if (event.getAuthentication().getDetails() != null) { 					data.put("details", event.getAuthentication().getDetails()); 				} 				if (event.getTargetUser() != null) { 					data.put("target", event.getTargetUser().getUsername()); 				} 				listener.publish(new AuditEvent(event.getAuthentication().getName(), 						AUTHENTICATION_SWITCH, data)); 			}  		}
@Test 	public void filteredAuditEvents() throws Exception { 		OffsetDateTime now = OffsetDateTime.now(); 		String queryTimestamp = DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(now); 		given(this.repository.find("alice", now.toInstant(), "logout")).willReturn( 				Arrays.asList(new AuditEvent("alice", "logout", Collections.emptyMap()))); 		this.mockMvc 				.perform(get("/actuator/auditevents").param("principal", "alice") 						.param("after", queryTimestamp).param("type", "logout")) 				.andExpect(status().isOk()) 				.andDo(document("auditevents/filtered", 						requestParameters( 								parameterWithName("after").description( 										"Restricts the events to those that occurred " 												+ "after the given time. Optional."), 								parameterWithName("principal").description( 										"Restricts the events to those with the given " 												+ "principal. Optional."), 						parameterWithName("type").description( 								"Restricts the events to those with the given " 										+ "type. Optional.")))); 		verify(this.repository).find("alice", now.toInstant(), "logout"); 	}
@ReadOperation 	public AuditEventsDescriptor eventsWithPrincipalDateAfterAndType(String principal, 			Date after, String type) { 		return new AuditEventsDescriptor( 				this.auditEventRepository.find(principal, after, type)); 	}
@ReadOperation 	public ThreadDumpDescriptor threadDump() { 		return new ThreadDumpDescriptor(Arrays 				.asList(ManagementFactory.getThreadMXBean().dumpAllThreads(true, true))); 	}
@ReadOperation 	public TraceDescriptor traces() { 		return new TraceDescriptor(this.repository.findAll()); 	}
@Test 	public void reactiveHealthWebEndpointExtensionCanBeDisabled() { 		reactiveWebContextRunner(HealthEndpointConfiguration.class) 				.withPropertyValues("endpoints.health.enabled=false").run((context) -> { 					assertThat(context) 							.doesNotHaveBean(HealthReactiveWebEndpointExtension.class); 					assertThat(context).doesNotHaveBean(HealthWebEndpointExtension.class); 				});  	}
@Test 	public void reactiveStatusWebEndpointExtensionCanBeDisabled() { 		reactiveWebContextRunner(StatusEndpointConfiguration.class) 				.withPropertyValues("endpoints.status.enabled=false").run((context) -> { 					assertThat(context) 							.doesNotHaveBean(StatusReactiveWebEndpointExtension.class); 					assertThat(context).doesNotHaveBean(StatusWebEndpointExtension.class); 				}); 	}
@Test 	public void logFileWebEndpointIsAutoConfiguredWhenExternalFileIsSet() { 		webContextRunner() 				.withPropertyValues("endpoints.logfile.external-file:external.log") 				.run((context) -> assertThat( 						context.getBeansOfType(LogFileWebEndpoint.class)).hasSize(1)); 	}
@Test 	public void eventsWithType() { 		given(this.repository.find(null, null, "type")) 				.willReturn(Collections.singletonList(this.event)); 		List<AuditEvent> result = this.endpoint 				.eventsWithPrincipalDateAfterAndType(null, null, "type").getEvents(); 		assertThat(result).isEqualTo(Collections.singletonList(this.event)); 	}
@Test 	public void eventsWithDateAfter() { 		Date date = new Date(); 		given(this.repository.find(null, date, null)) 				.willReturn(Collections.singletonList(this.event)); 		List<AuditEvent> result = this.endpoint 				.eventsWithPrincipalDateAfterAndType(null, date, null).getEvents(); 		assertThat(result).isEqualTo(Collections.singletonList(this.event)); 	}
@Test 	public void eventsWithPrincipal() { 		given(this.repository.find("Joan", null, null)) 				.willReturn(Collections.singletonList(this.event)); 		List<AuditEvent> result = this.endpoint 				.eventsWithPrincipalDateAfterAndType("Joan", null, null).getEvents(); 		assertThat(result).isEqualTo(Collections.singletonList(this.event)); 	}
@Test 	public void dumpThreads() throws Exception { 		assertThat(new ThreadDumpEndpoint().threadDump().getThreads().size()) 				.isGreaterThan(0); 	}
@Test 	public void trace() throws Exception { 		TraceRepository repository = new InMemoryTraceRepository(); 		repository.add(Collections.<String, Object>singletonMap("a", "b")); 		Trace trace = new TraceEndpoint(repository).traces().getTraces().get(0); 		assertThat(trace.getInfo().get("a")).isEqualTo("b"); 	}
@Test 	public void eventsWithDateAfter() { 		Date date = new Date(); 		given(this.repository.find(null, date, null)) 				.willReturn(Collections.singletonList(this.event)); 		List<AuditEvent> result = this.extension.eventsWithDateAfter(date).getEvents(); 		assertThat(result).isEqualTo(Collections.singletonList(this.event)); 	}
@Test 	public void eventsWithPrincipalAndDateAfter() { 		Date date = new Date(); 		given(this.repository.find("Joan", date, null)) 				.willReturn(Collections.singletonList(this.event)); 		List<AuditEvent> result = this.extension 				.eventsWithPrincipalAndDateAfter("Joan", date).getEvents(); 		assertThat(result).isEqualTo(Collections.singletonList(this.event)); 	}
@Test 	@SuppressWarnings("unchecked") 	public void testTrace() throws Exception { 		this.restTemplate.getForEntity("/health", String.class); 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = this.restTemplate 				.withBasicAuth("user", getPassword()) 				.getForEntity("/application/trace", Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK); 		Map<String, Object> body = entity.getBody(); 		Map<String, Object> trace = ((List<Map<String, Object>>) body.get("traces")) 				.get(0); 		Map<String, Object> map = (Map<String, Object>) ((Map<String, Object>) ((Map<String, Object>) trace 				.get("info")).get("headers")).get("response"); 		assertThat(map.get("status")).isEqualTo("200"); 	}
@Test 	@SuppressWarnings("unchecked") 	public void traceWithParameterMap() throws Exception { 		this.restTemplate.withBasicAuth("user", getPassword()) 				.getForEntity("/application/health?param1=value1", String.class); 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = this.restTemplate 				.withBasicAuth("user", getPassword()) 				.getForEntity("/application/trace", Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK); 		Map<String, Object> body = entity.getBody(); 		Map<String, Object> trace = ((List<Map<String, Object>>) body.get("traces")) 				.get(0); 		Map<String, Object> map = (Map<String, Object>) ((Map<String, Object>) trace 				.get("info")).get("parameters"); 		assertThat(map.get("param1")).isNotNull(); 	}
@Override 	public void run(String... args) throws Exception { 		this.auditEventRepository.add( 				createEvent("2016-11-01T11:00:00Z", "user", "AUTHENTICATION_FAILURE")); 		this.auditEventRepository.add( 				createEvent("2016-11-01T12:00:00Z", "admin", "AUTHENTICATION_SUCCESS")); 	}
@Test 	public void invokeFilterByDateAfter() throws Exception { 		this.mvc.perform(get("/auditevents").param("after", "2016-11-01T13:00:00+0000")) 				.andExpect(status().isOk()) 				.andExpect(content().string("{\"events\":[]}")); 	}
@Test 	public void invokeFilterByPrincipalAndDateAfter() throws Exception { 		this.mvc.perform(get("/auditevents").param("principal", "user").param("after", 				"2016-11-01T10:00:00+0000")) 				.andExpect(status().isOk()) 				.andExpect(content().string( 						containsString("\"principal\":\"user\",\"type\":\"login\""))) 				.andExpect(content().string(not(containsString("admin")))); 	}
@Test 	public void invokeFilterByPrincipalAndDateAfterAndType() throws Exception { 		this.mvc.perform(get("/auditevents").param("principal", "admin") 				.param("after", "2016-11-01T10:00:00+0000").param("type", "logout")) 				.andExpect(status().isOk()) 				.andExpect(content().string( 						containsString("\"principal\":\"admin\",\"type\":\"logout\""))) 				.andExpect(content().string(not(containsString("login")))); 	}
@Bean 		public AuditEventRepository auditEventsRepository() { 			AuditEventRepository repository = new InMemoryAuditEventRepository(3); 			repository.add(createEvent("2016-11-01T11:00:00Z", "admin", "login")); 			repository.add(createEvent("2016-11-01T12:00:00Z", "admin", "logout")); 			repository.add(createEvent("2016-11-01T12:00:00Z", "user", "login")); 			return repository; 		}
@Test 	public void contextPath() throws Exception { 		EnvironmentTestUtils.addEnvironment(this.applicationContext, 				"management.contextPath:/test", "management.security.enabled:false"); 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				ServerPortConfig.class, PropertyPlaceholderAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, JacksonAutoConfiguration.class, 				EmbeddedServletContainerAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				DispatcherServletAutoConfiguration.class, WebMvcAutoConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, AuditAutoConfiguration.class); 		this.applicationContext.refresh(); 		assertContent("/controller", ports.get().server, "controlleroutput"); 		assertContent("/test/endpoint", ports.get().server, "endpointoutput"); 	}
@Test 	public void overrideServerProperties() throws Exception { 		EnvironmentTestUtils.addEnvironment(this.applicationContext, 				"server.displayName:foo"); 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				ServerPortConfig.class, PropertyPlaceholderAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, JacksonAutoConfiguration.class, 				EmbeddedServletContainerAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				DispatcherServletAutoConfiguration.class, WebMvcAutoConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, AuditAutoConfiguration.class); 		this.applicationContext.refresh(); 		assertContent("/controller", ports.get().server, "controlleroutput"); 		ServerProperties serverProperties = this.applicationContext 				.getBean(ServerProperties.class); 		assertThat(serverProperties.getDisplayName()).isEqualTo("foo"); 	}
@Test 	public void endpointsDefaultConfiguration() throws Exception { 		this.applicationContext.register(LoggingConfig.class, RootConfig.class, 				BaseConfiguration.class, ServerPortConfig.class, 				EndpointWebMvcAutoConfiguration.class); 		this.applicationContext.refresh(); 		// /health, /metrics, /loggers, /env, /actuator, /heapdump, /auditevents 		// (/shutdown is disabled by default) 		assertThat(this.applicationContext.getBeansOfType(MvcEndpoint.class)).hasSize(7); 	}
public int getCount() { 				return this.count; 			}
@Bean 		public TomcatEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new TomcatEmbeddedServletContainerFactory(); 		}
@Bean 		public UndertowEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new UndertowEmbeddedServletContainerFactory(); 		}
@Bean 		public SpecificEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new SpecificEmbeddedServletContainerFactory(); 		}
@Bean 		public UndertowEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new UndertowEmbeddedServletContainerFactory(); 		}
@Bean 		public SpecificEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new SpecificEmbeddedServletContainerFactory(); 		}
@Bean 		public TomcatEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new TomcatEmbeddedServletContainerFactory(); 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			properties.getSecurity().setEnabled(false); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
public int getCount() { 			return this.count; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			properties.getSecurity().setEnabled(false); 			return properties; 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				WebMvcAutoConfiguration.class, 				ManagementWebSecurityAutoConfiguration.class, 				JacksonAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class, AuditAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		assertThat(this.context.getBean(AuthenticationManagerBuilder.class)).isNotNull(); 		FilterChainProxy filterChainProxy = this.context.getBean(FilterChainProxy.class); 		// 1 for static resources, one for management endpoints and one for the rest 		assertThat(filterChainProxy.getFilterChains()).hasSize(3); 		assertThat(filterChainProxy.getFilters("/beans")).isNotEmpty(); 		assertThat(filterChainProxy.getFilters("/beans/")).isNotEmpty(); 		assertThat(filterChainProxy.getFilters("/beans.foo")).isNotEmpty(); 		assertThat(filterChainProxy.getFilters("/beans/foo/bar")).isNotEmpty(); 	}
@Test 	public void realmSameForManagement() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(AuthenticationConfig.class, SecurityAutoConfiguration.class, 				ManagementWebSecurityAutoConfiguration.class, 				JacksonAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				WebMvcAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class, AuditAutoConfiguration.class); 		this.context.refresh();  		Filter filter = this.context.getBean("springSecurityFilterChain", Filter.class); 		MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context) 				.addFilters(filter).build();  		// no user (Main) 		mockMvc.perform(MockMvcRequestBuilders.get("/home")) 				.andExpect(MockMvcResultMatchers.status().isUnauthorized()) 				.andExpect(springAuthenticateRealmHeader());  		// invalid user (Main) 		mockMvc.perform( 				MockMvcRequestBuilders.get("/home").header("authorization", "Basic xxx")) 				.andExpect(MockMvcResultMatchers.status().isUnauthorized()) 				.andExpect(springAuthenticateRealmHeader());  		// no user (Management) 		mockMvc.perform(MockMvcRequestBuilders.get("/beans")) 				.andExpect(MockMvcResultMatchers.status().isUnauthorized()) 				.andExpect(springAuthenticateRealmHeader());  		// invalid user (Management) 		mockMvc.perform( 				MockMvcRequestBuilders.get("/beans").header("authorization", "Basic xxx")) 				.andExpect(MockMvcResultMatchers.status().isUnauthorized()) 				.andExpect(springAuthenticateRealmHeader()); 	}
@Parameters(name = "{0}") 	public static Object[] parameters() { 		return new Object[] { new Object[] { "actuator", HalJsonMvcEndpoint.class }, 				new Object[] { "auditevents", AuditEventsMvcEndpoint.class }, 				new Object[] { "autoconfig", AutoConfigurationReportEndpoint.class }, 				new Object[] { "beans", BeansEndpoint.class }, 				new Object[] { "configprops", 						ConfigurationPropertiesReportEndpoint.class }, 				new Object[] { "docs", DocsMvcEndpoint.class }, 				new Object[] { "dump", DumpEndpoint.class }, 				new Object[] { "env", EnvironmentMvcEndpoint.class }, 				new Object[] { "flyway", FlywayEndpoint.class }, 				new Object[] { "health", HealthMvcEndpoint.class }, 				new Object[] { "info", InfoEndpoint.class }, 				new Object[] { "jolokia", JolokiaMvcEndpoint.class }, 				new Object[] { "liquibase", LiquibaseEndpoint.class }, 				new Object[] { "logfile", LogFileMvcEndpoint.class }, 				new Object[] { "loggers", LoggersMvcEndpoint.class }, 				new Object[] { "mappings", RequestMappingEndpoint.class }, 				new Object[] { "metrics", MetricsMvcEndpoint.class }, 				new Object[] { "shutdown", ShutdownEndpoint.class }, 				new Object[] { "trace", TraceEndpoint.class } }; 	}
@Test 	public void endpointsDoNotHaveLinks() throws Exception { 		for (MvcEndpoint endpoint : this.mvcEndpoints.getEndpoints()) { 			String path = endpoint.getPath(); 			if ("/actuator".equals(path) || endpoint instanceof HeapdumpMvcEndpoint) { 				continue; 			} 			path = path.length() > 0 ? path : "/"; 			MockHttpServletRequestBuilder requestBuilder = get(path); 			if (endpoint instanceof AuditEventsMvcEndpoint) { 				requestBuilder.param("after", "2016-01-01T12:00:00+00:00"); 			} 			this.mockMvc.perform(requestBuilder.accept(MediaType.APPLICATION_JSON)) 					.andExpect(status().isOk()) 					.andExpect(jsonPath("$._links").doesNotExist()); 		} 	}
@Test 	public void endpointsEachHaveSelf() throws Exception { 		Set<String> collections = new HashSet<String>(Arrays.asList("/trace", "/beans", 				"/dump", "/heapdump", "/loggers", "/auditevents")); 		for (MvcEndpoint endpoint : this.mvcEndpoints.getEndpoints()) { 			String path = endpoint.getPath(); 			if (collections.contains(path)) { 				continue; 			} 			path = path.length() > 0 ? path : "/"; 			this.mockMvc.perform(get(path).accept(MediaType.APPLICATION_JSON)) 					.andExpect(status().isOk()).andExpect(jsonPath("$._links.self.href") 							.value("http://localhost" + endpoint.getPath())); 		} 	}
public void reset() { 			this.available = true; 			this.locked = false; 			this.heapDump = "HEAPDUMP"; 		}
@After 	public void reset() { 		this.endpoint.reset(); 	}
@Override 				public void contribute(Info.Builder builder) { 					Map<String, Object> content = new LinkedHashMap<String, Object>(); 					content.put("key21", "value21"); 					content.put("key22", "value22"); 					builder.withDetail("beanName2", content); 				}
@Override 				public void contribute(Info.Builder builder) { 					Map<String, Object> content = new LinkedHashMap<String, Object>(); 					content.put("key11", "value11"); 					content.put("key12", "value12"); 					builder.withDetail("beanName1", content); 				}
@Before 	public void createContext() { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(JacksonAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class, AuditAutoConfiguration.class, 				JolokiaAutoConfiguration.class, WebMvcAutoConfiguration.class); 	}
private void onAuthenticationFailureEvent(AbstractAuthenticationFailureEvent event) { 		Map<String, Object> data = new HashMap<String, Object>(); 		data.put("type", event.getException().getClass().getName()); 		data.put("message", event.getException().getMessage()); 		if (event.getAuthentication().getDetails() != null) { 			data.put("details", event.getAuthentication().getDetails()); 		} 		publish(new AuditEvent(event.getAuthentication().getName(), 				AUTHENTICATION_FAILURE, data)); 	}
private void onAuthenticationSuccessEvent(AuthenticationSuccessEvent event) { 		Map<String, Object> data = new HashMap<String, Object>(); 		if (event.getAuthentication().getDetails() != null) { 			data.put("details", event.getAuthentication().getDetails()); 		} 		publish(new AuditEvent(event.getAuthentication().getName(), 				AUTHENTICATION_SUCCESS, data)); 	}
public void process(AuthenticationAuditListener listener, 				AbstractAuthenticationEvent input) { 			if (listener != null) { 				AuthenticationSwitchUserEvent event = (AuthenticationSwitchUserEvent) input; 				Map<String, Object> data = new HashMap<String, Object>(); 				if (event.getAuthentication().getDetails() != null) { 					data.put("details", event.getAuthentication().getDetails()); 				} 				data.put("target", event.getTargetUser().getUsername()); 				listener.publish(new AuditEvent(event.getAuthentication().getName(), 						AUTHENTICATION_SWITCH, data)); 			}  		}
private void onAuthenticationCredentialsNotFoundEvent( 			AuthenticationCredentialsNotFoundEvent event) { 		Map<String, Object> data = new HashMap<String, Object>(); 		data.put("type", event.getCredentialsNotFoundException().getClass().getName()); 		data.put("message", event.getCredentialsNotFoundException().getMessage()); 		publish(new AuditEvent("<unknown>", 				AuthenticationAuditListener.AUTHENTICATION_FAILURE, data)); 	}
private void onAuthorizationFailureEvent(AuthorizationFailureEvent event) { 		Map<String, Object> data = new HashMap<String, Object>(); 		data.put("type", event.getAccessDeniedException().getClass().getName()); 		data.put("message", event.getAccessDeniedException().getMessage()); 		if (event.getAuthentication().getDetails() != null) { 			data.put("details", event.getAuthentication().getDetails()); 		} 		publish(new AuditEvent(event.getAuthentication().getName(), 				AUTHORIZATION_FAILURE, data)); 	}
@Test 	public void testAuthenticationSuccess() { 		this.listener.onApplicationEvent(new AuthenticationSuccessEvent( 				new UsernamePasswordAuthenticationToken("user", "password"))); 		ArgumentCaptor<AuditApplicationEvent> argumentCaptor = ArgumentCaptor 				.forClass(AuditApplicationEvent.class); 		verify(this.publisher).publishEvent(argumentCaptor.capture()); 		assertThat(argumentCaptor.getValue().getAuditEvent().getType()) 				.isEqualTo(AuthenticationAuditListener.AUTHENTICATION_SUCCESS); 	}
@Test 	public void testAuthenticationFailed() { 		this.listener.onApplicationEvent(new AuthenticationFailureExpiredEvent( 				new UsernamePasswordAuthenticationToken("user", "password"), 				new BadCredentialsException("Bad user"))); 		ArgumentCaptor<AuditApplicationEvent> argumentCaptor = ArgumentCaptor 				.forClass(AuditApplicationEvent.class); 		verify(this.publisher).publishEvent(argumentCaptor.capture()); 		assertThat(argumentCaptor.getValue().getAuditEvent().getType()) 				.isEqualTo(AuthenticationAuditListener.AUTHENTICATION_FAILURE); 	}
@Test 	public void testAuthenticationSwitch() { 		this.listener.onApplicationEvent(new AuthenticationSwitchUserEvent( 				new UsernamePasswordAuthenticationToken("user", "password"), 				new User("user", "password", 						AuthorityUtils.commaSeparatedStringToAuthorityList("USER")))); 		ArgumentCaptor<AuditApplicationEvent> argumentCaptor = ArgumentCaptor 				.forClass(AuditApplicationEvent.class); 		verify(this.publisher).publishEvent(argumentCaptor.capture()); 		assertThat(argumentCaptor.getValue().getAuditEvent().getType()) 				.isEqualTo(AuthenticationAuditListener.AUTHENTICATION_SWITCH); 	}
@Test 	public void testDetailsAreIncludedInAuditEvent() throws Exception { 		Object details = new Object(); 		UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken( 				"user", "password"); 		authentication.setDetails(details); 		this.listener.onApplicationEvent(new AuthenticationFailureExpiredEvent( 				authentication, new BadCredentialsException("Bad user"))); 		ArgumentCaptor<AuditApplicationEvent> argumentCaptor = ArgumentCaptor 				.forClass(AuditApplicationEvent.class); 		verify(this.publisher).publishEvent(argumentCaptor.capture()); 		AuditApplicationEvent event = argumentCaptor.getValue(); 		assertThat(event.getAuditEvent().getType()) 				.isEqualTo(AuthenticationAuditListener.AUTHENTICATION_FAILURE); 		assertThat(event.getAuditEvent().getData()) 				.containsEntry("details", details); 	}
@Test 	public void testAuthenticationCredentialsNotFound() { 		this.listener.onApplicationEvent(new AuthenticationCredentialsNotFoundEvent(this, 				Arrays.<ConfigAttribute>asList(new SecurityConfig("USER")), 				new AuthenticationCredentialsNotFoundException("Bad user"))); 		ArgumentCaptor<AuditApplicationEvent> eventArgumentCaptor = ArgumentCaptor 				.forClass(AuditApplicationEvent.class); 		verify(this.publisher).publishEvent(eventArgumentCaptor.capture()); 		assertThat(eventArgumentCaptor.getValue().getAuditEvent().getType()) 				.isEqualTo(AuthenticationAuditListener.AUTHENTICATION_FAILURE); 	}
@Test 	public void testAuthorizationFailure() { 		this.listener.onApplicationEvent(new AuthorizationFailureEvent(this, 				Arrays.<ConfigAttribute>asList(new SecurityConfig("USER")), 				new UsernamePasswordAuthenticationToken("user", "password"), 				new AccessDeniedException("Bad user"))); 		ArgumentCaptor<AuditApplicationEvent> eventArgumentCaptor = ArgumentCaptor 				.forClass(AuditApplicationEvent.class); 		verify(this.publisher).publishEvent(eventArgumentCaptor.capture()); 		assertThat(eventArgumentCaptor.getValue().getAuditEvent().getType()) 				.isEqualTo(AuthorizationAuditListener.AUTHORIZATION_FAILURE); 	}
@Test 	public void testDetailsAreIncludedInAuditEvent() throws Exception { 		Object details = new Object(); 		UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken( 				"user", "password"); 		authentication.setDetails(details); 		this.listener.onApplicationEvent(new AuthorizationFailureEvent(this, 				Arrays.<ConfigAttribute>asList(new SecurityConfig("USER")), 				authentication, new AccessDeniedException("Bad user"))); 		ArgumentCaptor<AuditApplicationEvent> eventArgumentCaptor = ArgumentCaptor 				.forClass(AuditApplicationEvent.class); 		verify(this.publisher).publishEvent(eventArgumentCaptor.capture()); 		AuditApplicationEvent event = eventArgumentCaptor.getValue(); 		assertThat(event.getAuditEvent().getType()) 				.isEqualTo(AuthorizationAuditListener.AUTHORIZATION_FAILURE); 		assertThat(event.getAuditEvent().getData()).containsEntry("details", details); 	}
@Override 	public void onApplicationEvent(AbstractAuthenticationEvent event) { 		if (event instanceof AbstractAuthenticationFailureEvent) { 			onAuthenticationFailureEvent((AbstractAuthenticationFailureEvent) event); 		} 		else if (this.webListener != null && this.webListener.accepts(event)) { 			this.webListener.process(this, event); 		} 		else if (event instanceof AuthenticationSuccessEvent) { 			onAuthenticationEvent((AuthenticationSuccessEvent) event); 		} 	}
@Override 	public void onApplicationEvent(AuditApplicationEvent event) { 		if (logger.isDebugEnabled()) { 			logger.debug(event.getAuditEvent()); 		} 		this.auditEventRepository.add(event.getAuditEvent()); 	}
@PostConstruct 		protected void initialize() { 			boolean initialize = DataSourceInitialization.this.properties.isInitialize(); 			if (!initialize) { 				logger.debug("Initialization disabled (not running DDL scripts)"); 				return; 			} 			runSchemaScripts(); 		}
@Override 	protected Map<String, String> getVendorProperties() { 		return this.properties.getHibernateProperties(this.dataSource); 	}
public Map<String, String> getHibernateProperties(DataSource dataSource) { 		return this.hibernate.getAdditionalProperties(this.properties, dataSource); 	}
@Deprecated 		public void setNamingstrategy(Class<?> namingStrategy) { 			logger.warn("The property spring.jpa.namingstrategy has been renamed, " 					+ "please update your configuration to use namingStrategy or naming-strategy or naming_strategy"); 			this.setNamingStrategy(namingStrategy); 		}
@Override 		public void doFilter(ServletRequest request, ServletResponse response, 				FilterChain chain) throws IOException, ServletException { 			HttpServletRequest servletRequest = (HttpServletRequest) request; 			HttpServletResponse servletResponse = (HttpServletResponse) response; 			UrlPathHelper helper = new UrlPathHelper(); 			String suffix = helper.getPathWithinApplication(servletRequest); 			int status = 999; 			long t0 = System.currentTimeMillis(); 			try { 				chain.doFilter(request, response); 			} finally { 				try { 					status = servletResponse.getStatus(); 				} catch (Exception e) { 					// ignore 				} 				set("response", suffix, System.currentTimeMillis() - t0); 				increment("status." + status, suffix); 			} 		}
@Override 		protected void configure(HttpConfigurator http) throws Exception { 			http.antMatcher("/**").httpBasic().and().anonymous().disable(); 			if (this.security.isRequireSsl()) { 				http.requiresChannel().antMatchers("/**").requiresSecure(); 			}  		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Override 	protected void configureMessageConverters(List<HttpMessageConverter<?>> converters) { 		addDefaultHttpMessageConverters(converters); 		for (HttpMessageConverter<?> converter : converters) { 			if (converter instanceof MappingJackson2HttpMessageConverter) { 				MappingJackson2HttpMessageConverter jacksonConverter = (MappingJackson2HttpMessageConverter) converter; 				jacksonConverter.getObjectMapper().disable( 						SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); 			} 		} 	}
@Override 	public void onApplicationEvent(AuditApplicationEvent event) { 		logger.info(event.getAuditEvent()); 		this.auditEventRepository.add(event.getAuditEvent()); 	}
@Override 	public void increment(String metricName) { 		this.counterRepository.increment(wrap(metricName), 1, new Date()); 	}
@Override 	public void decrement(String metricName) { 		this.counterRepository.increment(wrap(metricName), -1, new Date()); 	}
@Override 	public void reset(String metricName) { 		this.counterRepository.set(wrap(metricName), 0, new Date()); 	}
@Override 	public void set(String metricName, double value) { 		this.metricRepository.set(wrap(metricName), value, new Date()); 	}
@Override 	public String toString() { 		return "Measurement [dateTime=" + this.timestamp + ", metric=" + this.metric + "]"; 	}
@Override 	public int hashCode() { 		final int prime = 31; 		int result = 1; 		result = prime * result 				+ ((this.timestamp == null) ? 0 : this.timestamp.hashCode()); 		result = prime * result + ((this.metric == null) ? 0 : this.metric.hashCode()); 		return result; 	}
@Override 	public boolean equals(Object obj) { 		if (this == obj) 			return true; 		if (obj == null) 			return false; 		if (getClass() != obj.getClass()) 			return false; 		Measurement other = (Measurement) obj; 		if (this.timestamp == null) { 			if (other.timestamp != null) 				return false; 		} else if (!this.timestamp.equals(other.timestamp)) 			return false; 		if (this.metric == null) { 			if (other.metric != null) 				return false; 		} else if (!this.metric.equals(other.metric)) 			return false; 		return true; 	}
@Override 	public void add(Map<String, Object> map) { 		Trace trace = new Trace(new Date(), map); 		synchronized (this.traces) { 			while (this.traces.size() >= this.capacity) { 				this.traces.remove(0); 			} 			this.traces.add(trace); 		} 	}
public static void configureHeaders(HeadersConfigurer<?> configurer, 			SecurityProperties.Headers headers) throws Exception { 		if (headers.getHsts() != Headers.HSTS.NONE) { 			boolean includeSubdomains = headers.getHsts() == Headers.HSTS.ALL; 			HstsHeaderWriter writer = new HstsHeaderWriter(includeSubdomains); 			writer.setRequestMatcher(AnyRequestMatcher.INSTANCE); 			configurer.addHeaderWriter(writer); 		} 		if (!headers.isContentType()) { 			configurer.contentTypeOptions().disable(); 		} 		if (!headers.isXss()) { 			configurer.xssProtection().disable(); 		} 		if (!headers.isCache()) { 			configurer.cacheControl().disable(); 		} 		if (!headers.isFrame()) { 			configurer.frameOptions().disable(); 		} 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers(HttpMethod.POST, "/**").denyAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().denyAll(); 		}
@Test 	void scheduledTasks() throws Exception { 		this.mockMvc.perform(get("/actuator/scheduledtasks").accept("application/json")).andExpect(status().isOk()) 				.andDo(document("scheduled-tasks", 						preprocessResponse(replacePattern( 								Pattern.compile("org.*\\.ScheduledTasksEndpointDocumentationTests\\$TestConfiguration"), 								"com.example.Processor")), 						responseFields(fieldWithPath("cron").description("Cron tasks, if any."), 								targetFieldWithPrefix("cron.[]."), 								fieldWithPath("cron.[].expression").description("Cron expression."), 								fieldWithPath("fixedDelay").description("Fixed delay tasks, if any."), 								targetFieldWithPrefix("fixedDelay.[]."), initialDelayWithPrefix("fixedDelay.[]."), 								fieldWithPath("fixedDelay.[].interval") 										.description("Interval, in milliseconds, between the end of the last" 												+ " execution and the start of the next."), 								fieldWithPath("fixedRate").description("Fixed rate tasks, if any."), 								targetFieldWithPrefix("fixedRate.[]."), 								fieldWithPath("fixedRate.[].interval") 										.description("Interval, in milliseconds, between the start of each execution."), 								initialDelayWithPrefix("fixedRate.[]."), 								fieldWithPath("custom").description("Tasks with custom triggers, if any."), 								targetFieldWithPrefix("custom.[]."), 								fieldWithPath("custom.[].trigger").description("Trigger for the task.")))) 				.andDo(MockMvcResultHandlers.print()); 	}
@Test 	void linksAreProvidedToAllEndpointTypes() throws Exception { 		this.contextRunner.withUserConfiguration(EndpointsConfiguration.class) 				.withPropertyValues("management.endpoints.web.exposure.include=*").run((context) -> { 					MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(context).build(); 					mockMvc.perform(get("/actuator").accept("*/*")).andExpect(status().isOk()) 							.andExpect(jsonPath("_links", both(hasKey("beans")).and(hasKey("servlet")) 									.and(hasKey("restcontroller")).and(hasKey("controller")))); 				}); 	}
@Test // gh-17938 	void errorPageAndErrorControllerAreUsed() { 		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new) 				.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class, 						ServletWebServerFactoryAutoConfiguration.class, ServletManagementContextAutoConfiguration.class, 						WebEndpointAutoConfiguration.class, EndpointAutoConfiguration.class, 						DispatcherServletAutoConfiguration.class, ErrorMvcAutoConfiguration.class)) 				.withUserConfiguration(FailingEndpoint.class) 				.withInitializer(new ServerPortInfoApplicationContextInitializer()).withPropertyValues("server.port=0", 						"management.server.port=0", "management.endpoints.web.exposure.include=*") 				.run((context) -> { 					String port = context.getEnvironment().getProperty("local.management.port"); 					WebClient client = WebClient.create("http://localhost:" + port); 					ClientResponse response = client.get().uri("actuator/fail").accept(MediaType.APPLICATION_JSON) 							.exchange().block(); 					assertThat(response.headers().contentType().get()).isEqualTo(MediaType.APPLICATION_JSON); 					assertThat(response.bodyToMono(String.class).block()).contains("message\":\"Epic Fail"); 				}); 	}
private WebOperation findOperationWithRequestPath(ExposableWebEndpoint endpoint, String requestPath) { 		for (WebOperation operation : endpoint.getOperations()) { 			WebOperationRequestPredicate predicate = operation.getRequestPredicate(); 			if (predicate.getPath().equals(requestPath) 					&& predicate.getProduces().contains(ActuatorMediaType.V3_JSON)) { 				return operation; 			} 		} 		throw new IllegalStateException( 				"No operation found with request path " + requestPath + " from " + endpoint.getOperations()); 	}
private WebOperation findOperationWithRequestPath(ExposableWebEndpoint endpoint, String requestPath) { 		for (WebOperation operation : endpoint.getOperations()) { 			WebOperationRequestPredicate predicate = operation.getRequestPredicate(); 			if (predicate.getPath().equals(requestPath) 					&& predicate.getProduces().contains(ActuatorMediaType.V3_JSON)) { 				return operation; 			} 		} 		throw new IllegalStateException( 				"No operation found with request path " + requestPath + " from " + endpoint.getOperations()); 	}
@Test 	void health() throws Exception { 		FieldDescriptor status = fieldWithPath("status").description("Overall status of the application."); 		FieldDescriptor components = fieldWithPath("components").description("The components that make up the health."); 		FieldDescriptor componentStatus = fieldWithPath("components.*.status") 				.description("Status of a specific part of the application."); 		FieldDescriptor nestedComponents = subsectionWithPath("components.*.components") 				.description("The nested components that make up the health.").optional(); 		FieldDescriptor componentDetails = subsectionWithPath("components.*.details") 				.description("Details of the health of a specific part of the application. " 						+ "Presence is controlled by `management.endpoint.health.show-details`. May contain nested " 						+ "components that make up the health.") 				.optional(); 		this.mockMvc.perform(get("/actuator/health").accept(MediaType.APPLICATION_JSON)).andExpect(status().isOk()) 				.andDo(document("health", 						responseFields(status, components, componentStatus, nestedComponents, componentDetails))); 	}
@Test 	void healthComponent() throws Exception { 		this.mockMvc.perform(get("/actuator/health/db").accept(MediaType.APPLICATION_JSON)).andExpect(status().isOk()) 				.andDo(document("health/component", responseFields(componentFields))); 	}
@Test 	void healthComponentInstance() throws Exception { 		this.mockMvc.perform(get("/actuator/health/broker/us1").accept(MediaType.APPLICATION_JSON)) 				.andExpect(status().isOk()).andDo(document("health/instance", responseFields(componentFields))); 	}
@Test 	void runCreatesHealthEndpointWebExtension() { 		this.contextRunner.run((context) -> { 			HealthEndpointWebExtension webExtension = context.getBean(HealthEndpointWebExtension.class); 			WebEndpointResponse<HealthComponent> response = webExtension.health(ApiVersion.V3, SecurityContext.NONE, 					true, "simple"); 			Health health = (Health) response.getBody(); 			assertThat(response.getStatus()).isEqualTo(200); 			assertThat(health.getDetails()).containsEntry("counter", 42); 		}); 	}
@Test 	void runWhenHasHealthEndpointWebExtensionBeanDoesNotCreateExtraHealthEndpointWebExtension() { 		this.contextRunner.withUserConfiguration(HealthEndpointWebExtensionConfiguration.class).run((context) -> { 			HealthEndpointWebExtension webExtension = context.getBean(HealthEndpointWebExtension.class); 			WebEndpointResponse<HealthComponent> response = webExtension.health(ApiVersion.V3, SecurityContext.NONE, 					true, "simple"); 			assertThat(response).isNull(); 		}); 	}
@Test 	void runCreatesReactiveHealthEndpointWebExtension() { 		this.reactiveContextRunner.run((context) -> { 			ReactiveHealthEndpointWebExtension webExtension = context.getBean(ReactiveHealthEndpointWebExtension.class); 			Mono<WebEndpointResponse<? extends HealthComponent>> response = webExtension.health(ApiVersion.V3, 					SecurityContext.NONE, true, "simple"); 			Health health = (Health) (response.block().getBody()); 			assertThat(health.getDetails()).containsEntry("counter", 42); 		}); 	}
@Test 	void runWhenHasReactiveHealthEndpointWebExtensionBeanDoesNotCreateExtraReactiveHealthEndpointWebExtension() { 		this.reactiveContextRunner.withUserConfiguration(ReactiveHealthEndpointWebExtensionConfiguration.class) 				.run((context) -> { 					ReactiveHealthEndpointWebExtension webExtension = context 							.getBean(ReactiveHealthEndpointWebExtension.class); 					Mono<WebEndpointResponse<? extends HealthComponent>> response = webExtension.health(ApiVersion.V3, 							SecurityContext.NONE, true, "simple"); 					assertThat(response).isNull(); 				}); 	}
public Builder unknown() { 			return status(Status.UNKNOWN); 		}
public Builder up() { 			return status(Status.UP); 		}
public Builder down() { 			return status(Status.DOWN); 		}
public Builder outOfService() { 			return status(Status.OUT_OF_SERVICE); 		}
public Builder status(String statusCode) { 			return status(new Status(statusCode)); 		}
public Builder status(Status status) { 			this.status = status; 			return this; 		}
public static Builder unknown() { 		return status(Status.UNKNOWN); 	}
public static Builder up() { 		return status(Status.UP); 	}
public static Builder down() { 		return status(Status.DOWN); 	}
public static Builder outOfService() { 		return status(Status.OUT_OF_SERVICE); 	}
public static Builder status(String statusCode) { 		return status(new Status(statusCode)); 	}
public static Builder status(Status status) { 		return new Builder(status); 	}
@ReadOperation 	public HealthComponent health() { 		return health(ApiVersion.V3, EMPTY_PATH); 	}
@ReadOperation 	public HealthComponent healthForPath(@Selector(match = Match.ALL_REMAINING) String... path) { 		return health(ApiVersion.V3, path); 	}
@Test 	void createWhenStatusIsNullThrowsException() { 		assertThatIllegalArgumentException() 				.isThrownBy(() -> new CompositeHealth(ApiVersion.V3, null, Collections.emptyMap())) 				.withMessage("Status must not be null"); 	}
@Test 	void getStatusReturnsStatus() { 		CompositeHealth health = new CompositeHealth(ApiVersion.V3, Status.UP, Collections.emptyMap()); 		assertThat(health.getStatus()).isEqualTo(Status.UP); 	}
@Test 	void getComponentReturnsComponents() { 		Map<String, HealthComponent> components = new LinkedHashMap<>(); 		components.put("a", Health.up().build()); 		CompositeHealth health = new CompositeHealth(ApiVersion.V3, Status.UP, components); 		assertThat(health.getComponents()).isEqualTo(components); 	}
@Test 	void getHealthResultWhenPathIsEmptyUsesPrimaryGroup() { 		this.registry.registerContributor("test", createContributor(this.up)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, SecurityContext.NONE, 				false); 		assertThat(result.getGroup()).isEqualTo(this.primaryGroup); 		assertThat(getHealth(result)).isNotSameAs(this.up); 		assertThat(getHealth(result).getStatus()).isEqualTo(Status.UP); 	}
@Test 	void getHealthResultWhenPathIsNotGroupReturnsResultFromPrimaryGroup() { 		this.registry.registerContributor("test", createContributor(this.up)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, SecurityContext.NONE, 				false, "test"); 		assertThat(result.getGroup()).isEqualTo(this.primaryGroup); 		assertThat(getHealth(result)).isEqualTo(this.up);  	}
@Test 	void getHealthResultWhenPathIsGroupReturnsResultFromGroup() { 		this.registry.registerContributor("atest", createContributor(this.up)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, SecurityContext.NONE, 				false, "alltheas", "atest"); 		assertThat(result.getGroup()).isEqualTo(this.allTheAs); 		assertThat(getHealth(result)).isEqualTo(this.up); 	}
@Test 	void getHealthResultWhenAlwaysIncludesDetailsIsFalseAndGroupIsTrueIncludesDetails() { 		this.registry.registerContributor("test", createContributor(this.up)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, SecurityContext.NONE, 				false, "test"); 		assertThat(((Health) getHealth(result)).getDetails()).containsEntry("spring", "boot"); 	}
@Test 	void getHealthResultWhenAlwaysIncludesDetailsIsFalseAndGroupIsFalseIncludesNoDetails() { 		this.primaryGroup.setIncludeDetails(false); 		this.registry.registerContributor("test", createContributor(this.up)); 		HealthEndpointSupport<C, T> endpoint = create(this.registry, this.groups); 		HealthResult<T> rootResult = endpoint.getHealth(ApiVersion.V3, SecurityContext.NONE, false); 		HealthResult<T> componentResult = endpoint.getHealth(ApiVersion.V3, SecurityContext.NONE, false, "test"); 		assertThat(((CompositeHealth) getHealth(rootResult)).getStatus()).isEqualTo(Status.UP); 		assertThat(componentResult).isNull(); 	}
@Test 	void getHealthResultWhenAlwaysIncludesDetailsIsTrueIncludesDetails() { 		this.primaryGroup.setIncludeDetails(false); 		this.registry.registerContributor("test", createContributor(this.up)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, SecurityContext.NONE, true, 				"test"); 		assertThat(((Health) getHealth(result)).getDetails()).containsEntry("spring", "boot"); 	}
@Test 	void getHealthResultWhenCompositeReturnsAggregateResult() { 		Map<String, C> contributors = new LinkedHashMap<>(); 		contributors.put("a", createContributor(this.up)); 		contributors.put("b", createContributor(this.down)); 		this.registry.registerContributor("test", createCompositeContributor(contributors)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, SecurityContext.NONE, 				false); 		CompositeHealth root = (CompositeHealth) getHealth(result); 		CompositeHealth component = (CompositeHealth) root.getComponents().get("test"); 		assertThat(root.getStatus()).isEqualTo(Status.DOWN); 		assertThat(component.getStatus()).isEqualTo(Status.DOWN); 		assertThat(component.getComponents()).containsOnlyKeys("a", "b"); 	}
@Test 	void getHealthResultWhenPathDoesNotExistReturnsNull() { 		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, SecurityContext.NONE, 				false, "missing"); 		assertThat(result).isNull(); 	}
@Test 	void getHealthResultWhenPathIsEmptyIncludesGroups() { 		this.registry.registerContributor("test", createContributor(this.up)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, SecurityContext.NONE, 				false); 		assertThat(((SystemHealth) getHealth(result)).getGroups()).containsOnly("alltheas"); 	}
@Test 	void getHealthResultWhenPathIsGroupDoesNotIncludesGroups() { 		this.registry.registerContributor("atest", createContributor(this.up)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(ApiVersion.V3, SecurityContext.NONE, 				false, "alltheas"); 		assertThat(getHealth(result)).isNotInstanceOf(SystemHealth.class); 	}
@Test 	@SuppressWarnings("deprecation") 	void createWhenUsingDeprecatedConstructorThrowsException() { 		HealthEndpoint delegate = mock(HealthEndpoint.class); 		HealthWebEndpointResponseMapper responseMapper = mock(HealthWebEndpointResponseMapper.class); 		assertThatIllegalStateException().isThrownBy(() -> new HealthEndpointWebExtension(delegate, responseMapper)) 				.withMessage("Unable to create class org.springframework.boot.actuate." 						+ "health.HealthEndpointWebExtension using deprecated constructor"); 	}
@Test 	void healthReturnsSystemHealth() { 		this.registry.registerContributor("test", createContributor(this.up)); 		WebEndpointResponse<HealthComponent> response = create(this.registry, this.groups).health(ApiVersion.LATEST, 				SecurityContext.NONE); 		HealthComponent health = response.getBody(); 		assertThat(health.getStatus()).isEqualTo(Status.UP); 		assertThat(health).isInstanceOf(SystemHealth.class); 		assertThat(response.getStatus()).isEqualTo(200); 	}
@Test 	void healthWhenPathDoesNotExistReturnsHttp404() { 		this.registry.registerContributor("test", createContributor(this.up)); 		WebEndpointResponse<HealthComponent> response = create(this.registry, this.groups).health(ApiVersion.LATEST, 				SecurityContext.NONE, "missing"); 		assertThat(response.getBody()).isNull(); 		assertThat(response.getStatus()).isEqualTo(404); 	}
@Test 	void healthWhenPathExistsReturnsHealth() { 		this.registry.registerContributor("test", createContributor(this.up)); 		WebEndpointResponse<HealthComponent> response = create(this.registry, this.groups).health(ApiVersion.LATEST, 				SecurityContext.NONE, "test"); 		assertThat(response.getBody()).isEqualTo(this.up); 		assertThat(response.getStatus()).isEqualTo(200); 	}
@WebEndpointTest 	void whenHealthIsUp200ResponseIsReturned(WebTestClient client) { 		client.get().uri("/actuator/health").accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk() 				.expectBody().jsonPath("status").isEqualTo("UP").jsonPath("components.alpha.status").isEqualTo("UP") 				.jsonPath("components.bravo.status").isEqualTo("UP"); 	}
@WebEndpointTest 	void whenHealthIsDown503ResponseIsReturned(ApplicationContext context, WebTestClient client) { 		HealthIndicator healthIndicator = () -> Health.down().build(); 		ReactiveHealthIndicator reactiveHealthIndicator = () -> Mono.just(Health.down().build()); 		withHealthContributor(context, "charlie", healthIndicator, reactiveHealthIndicator, 				() -> client.get().uri("/actuator/health").accept(MediaType.APPLICATION_JSON).exchange().expectStatus() 						.isEqualTo(HttpStatus.SERVICE_UNAVAILABLE).expectBody().jsonPath("status").isEqualTo("DOWN") 						.jsonPath("components.alpha.status").isEqualTo("UP").jsonPath("components.bravo.status") 						.isEqualTo("UP").jsonPath("components.charlie.status").isEqualTo("DOWN")); 	}
@WebEndpointTest 	void whenComponentHealthIsDown503ResponseIsReturned(ApplicationContext context, WebTestClient client) { 		HealthIndicator healthIndicator = () -> Health.down().build(); 		ReactiveHealthIndicator reactiveHealthIndicator = () -> Mono.just(Health.down().build()); 		withHealthContributor(context, "charlie", healthIndicator, reactiveHealthIndicator, 				() -> client.get().uri("/actuator/health/charlie").accept(MediaType.APPLICATION_JSON).exchange() 						.expectStatus().isEqualTo(HttpStatus.SERVICE_UNAVAILABLE).expectBody().jsonPath("status") 						.isEqualTo("DOWN")); 	}
@WebEndpointTest 	void whenComponentInstanceHealthIsDown503ResponseIsReturned(ApplicationContext context, WebTestClient client) { 		HealthIndicator healthIndicator = () -> Health.down().build(); 		CompositeHealthContributor composite = CompositeHealthContributor 				.fromMap(Collections.singletonMap("one", healthIndicator)); 		ReactiveHealthIndicator reactiveHealthIndicator = () -> Mono.just(Health.down().build()); 		CompositeReactiveHealthContributor reactiveComposite = CompositeReactiveHealthContributor 				.fromMap(Collections.singletonMap("one", reactiveHealthIndicator)); 		withHealthContributor(context, "charlie", composite, reactiveComposite, 				() -> client.get().uri("/actuator/health/charlie/one").accept(MediaType.APPLICATION_JSON).exchange() 						.expectStatus().isEqualTo(HttpStatus.SERVICE_UNAVAILABLE).expectBody().jsonPath("status") 						.isEqualTo("DOWN")); 	}
@WebEndpointTest 	void whenHealthIndicatorIsRemovedResponseIsAltered(WebTestClient client, ApplicationContext context) { 		String name = "bravo"; 		HealthContributorRegistry healthContributorRegistry = getContributorRegistry(context, 				HealthContributorRegistry.class); 		HealthContributor bravo = healthContributorRegistry.unregisterContributor(name); 		ReactiveHealthContributorRegistry reactiveHealthContributorRegistry = getContributorRegistry(context, 				ReactiveHealthContributorRegistry.class); 		ReactiveHealthContributor reactiveBravo = (reactiveHealthContributorRegistry != null) 				? reactiveHealthContributorRegistry.unregisterContributor(name) : null; 		try { 			client.get().uri("/actuator/health").accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isOk() 					.expectBody().jsonPath("status").isEqualTo("UP").jsonPath("components.alpha.status").isEqualTo("UP") 					.jsonPath("components.bravo.status").doesNotExist(); 		} 		finally { 			healthContributorRegistry.registerContributor(name, bravo); 			if (reactiveHealthContributorRegistry != null && reactiveBravo != null) { 				reactiveHealthContributorRegistry.registerContributor(name, reactiveBravo); 			} 		} 	}
@Test 	void healthReturnsSystemHealth() { 		this.registry.registerContributor("test", createContributor(this.up)); 		WebEndpointResponse<? extends HealthComponent> response = create(this.registry, this.groups) 				.health(ApiVersion.LATEST, SecurityContext.NONE).block(); 		HealthComponent health = response.getBody(); 		assertThat(health.getStatus()).isEqualTo(Status.UP); 		assertThat(health).isInstanceOf(SystemHealth.class); 		assertThat(response.getStatus()).isEqualTo(200); 	}
@Test 	void healthWhenPathDoesNotExistReturnsHttp404() { 		this.registry.registerContributor("test", createContributor(this.up)); 		WebEndpointResponse<? extends HealthComponent> response = create(this.registry, this.groups) 				.health(ApiVersion.LATEST, SecurityContext.NONE, "missing").block(); 		assertThat(response.getBody()).isNull(); 		assertThat(response.getStatus()).isEqualTo(404); 	}
@Test 	void healthWhenPathExistsReturnsHealth() { 		this.registry.registerContributor("test", createContributor(this.up)); 		WebEndpointResponse<? extends HealthComponent> response = create(this.registry, this.groups) 				.health(ApiVersion.LATEST, SecurityContext.NONE, "test").block(); 		assertThat(response.getBody()).isEqualTo(this.up); 		assertThat(response.getStatus()).isEqualTo(200); 	}
@Test 	void serializeWithJacksonReturnsValidJson() throws Exception { 		Map<String, HealthComponent> components = new LinkedHashMap<>(); 		components.put("db1", Health.up().build()); 		components.put("db2", Health.down().withDetail("a", "b").build()); 		Set<String> groups = new LinkedHashSet<>(Arrays.asList("liveness", "readiness")); 		CompositeHealth health = new SystemHealth(ApiVersion.V3, Status.UP, components, groups); 		ObjectMapper mapper = new ObjectMapper(); 		String json = mapper.writeValueAsString(health); 		assertThat(json).isEqualTo("{\"status\":\"UP\",\"components\":{" + "\"db1\":{\"status\":\"UP\"}," 				+ "\"db2\":{\"status\":\"DOWN\",\"details\":{\"a\":\"b\"}}}," 				+ "\"groups\":[\"liveness\",\"readiness\"]}"); 	}
@Bean 	@ConditionalOnMissingBean 	public RSocketStrategies rSocketStrategies( 			ObjectProvider<RSocketStrategiesCustomizer> customizers) { 		RSocketStrategies.Builder builder = RSocketStrategies.builder(); 		builder.reactiveAdapterStrategy(ReactiveAdapterRegistry.getSharedInstance()); 		customizers.orderedStream() 				.forEach((customizer) -> customizer.customize(builder)); 		builder.dataBufferFactory( 				new NettyDataBufferFactory(PooledByteBufAllocator.DEFAULT)); 		return builder.build(); 	}
@Test 	public void shouldCreateDefaultBeans() { 		this.contextRunner.run((context) -> { 			assertThat(context).getBeans(RSocketStrategies.class).hasSize(1); 			RSocketStrategies strategies = context.getBean(RSocketStrategies.class); 			assertThat(strategies.decoders()).hasSize(2); 			assertThat(strategies.decoders().get(0)) 					.isInstanceOf(Jackson2CborDecoder.class); 			assertThat(strategies.decoders().get(1)) 					.isInstanceOf(Jackson2JsonDecoder.class); 			assertThat(strategies.encoders()).hasSize(2); 			assertThat(strategies.encoders().get(0)) 					.isInstanceOf(Jackson2CborEncoder.class); 			assertThat(strategies.encoders().get(1)) 					.isInstanceOf(Jackson2JsonEncoder.class); 		}); 	}
@Test 	public void shouldUseStrategiesCustomizer() { 		this.contextRunner.withUserConfiguration(StrategiesCustomizer.class) 				.run((context) -> { 					assertThat(context).getBeans(RSocketStrategies.class).hasSize(1); 					RSocketStrategies strategies = context 							.getBean(RSocketStrategies.class); 					assertThat(strategies.decoders()).hasSize(3) 							.hasAtLeastOneElementOfType(StringDecoder.class); 					assertThat(strategies.encoders()).hasSize(3) 							.hasAtLeastOneElementOfType(CharSequenceEncoder.class); 				}); 	}
public void willRespond(HttpStatus... response) { 		for (HttpStatus status : response) { 			this.responses.add(new Response(0, NO_DATA, status)); 		} 	}
@Override 	public Map<String, Object> invoke() { 		Collection<LoggerConfiguration> configurations = this.loggingSystem 				.getLoggerConfigurations(); 		if (configurations == null) { 			return Collections.emptyMap(); 		} 		Map<String, Object> result = new LinkedHashMap<String, Object>(); 		result.put("levels", getLevels()); 		result.put("loggers", getLoggers(configurations)); 		return result; 	}
@Test 	public void loggersEndpointHasLoggers() throws Exception { 		load(CustomLoggingConfig.class, EndpointAutoConfiguration.class); 		LoggersEndpoint endpoint = this.context.getBean(LoggersEndpoint.class); 		Map<String, Object> result = endpoint.invoke(); 		Map<String, LoggerLevels> loggers = (Map<String, LoggerLevels>) result 				.get("loggers"); 		assertThat(loggers.size()).isGreaterThan(0); 	}
@Override 			public void contribute(Info.Builder builder) { 				if (!this.content.isEmpty()) { 					builder.withDetail("git", this.content); 				} 			}
@Override 				public void contribute(Info.Builder builder) { 					builder.withDetail("name", "bar"); 					builder.withDetail("version", "1.0"); 				}
@Test 	@SuppressWarnings("unchecked") 	public void invokeShouldReturnConfigurations() throws Exception { 		given(getLoggingSystem().getLoggerConfigurations()).willReturn(Collections 				.singletonList(new LoggerConfiguration("ROOT", null, LogLevel.DEBUG))); 		given(getLoggingSystem().getSupportedLogLevels()) 				.willReturn(EnumSet.allOf(LogLevel.class)); 		Map<String, Object> result = getEndpointBean().invoke(); 		Map<String, LoggerLevels> loggers = (Map<String, LoggerLevels>) result 				.get("loggers"); 		Set<LogLevel> levels = (Set<LogLevel>) result.get("levels"); 		LoggerLevels rootLevels = loggers.get("ROOT"); 		assertThat(rootLevels.getConfiguredLevel()).isNull(); 		assertThat(rootLevels.getEffectiveLevel()).isEqualTo("DEBUG"); 		assertThat(levels).containsExactly(LogLevel.OFF, LogLevel.FATAL, LogLevel.ERROR, 				LogLevel.WARN, LogLevel.INFO, LogLevel.DEBUG, LogLevel.TRACE); 	}
@Test 	public void getLoggerShouldReturnAllLoggerConfigurations() throws Exception { 		given(this.loggingSystem.getLoggerConfigurations()).willReturn(Collections 				.singletonList(new LoggerConfiguration("ROOT", null, LogLevel.DEBUG))); 		String expected = "{\"levels\":[\"OFF\",\"FATAL\",\"ERROR\",\"WARN\",\"INFO\",\"DEBUG\",\"TRACE\"]," 				+ "\"loggers\":{\"ROOT\":{\"configuredLevel\":null,\"effectiveLevel\":\"DEBUG\"}}}"; 		System.out.println(expected); 		this.mvc.perform(get("/loggers")).andExpect(status().isOk()) 				.andExpect(content().json(expected)); 	}
public void map(LogLevel system, T nativeLevel) { 			this.systemToNative.put(system, nativeLevel); 			if (!this.nativeToSystem.containsKey(nativeLevel)) { 				this.nativeToSystem.put(nativeLevel, system); 			} 		}
@Override 		public void setLogLevel(String loggerName, LogLevel level) {  		}
@Override 		public List<LoggerConfiguration> getLoggerConfigurations() { 			return Collections.emptyList(); 		}
@Override 		public LoggerConfiguration getLoggerConfiguration(String loggerName) { 			return null; 		}
public void setLogLevel(String loggerName, LogLevel level) { 		throw new UnsupportedOperationException("Unable to set log level"); 	}
public List<LoggerConfiguration> getLoggerConfigurations() { 		throw new UnsupportedOperationException("Unable to get logger configurations"); 	}
public LoggerConfiguration getLoggerConfiguration(String loggerName) { 		throw new UnsupportedOperationException("Unable to get logger configuration"); 	}
public Map<String, Object> getResults(String name) { 		if (!isRegex(name)) { 			Object value = getValue(this.source, name); 			Map<String, Object> result = new HashMap<String, Object>(); 			result.put(name, value); 			return result; 		} 		Pattern pattern = Pattern.compile(name); 		ResultCollectingNameCallback resultCollector = new ResultCollectingNameCallback( 				pattern); 		getNames(this.source, resultCollector); 		return resultCollector.getResults();  	}
@Test 	public void sub() throws Exception { 		this.mvc.perform(get("/env/foo")).andExpect(status().isOk()) 				.andExpect(content().string("{\"foo\":\"bar\"}")); 	}
@Test 	public void specificMetric() throws Exception { 		this.mvc.perform(get("/metrics/foo")).andExpect(status().isOk()) 				.andExpect(content().string(equalTo("{\"foo\":1}"))); 	}
@Test 	public void nonRegex() throws Exception { 		MockNamePatternFilter filter = new MockNamePatternFilter(); 		assertThat(filter.getResults("not.a.regex"), 				hasEntry("not.a.regex", (Object) "not.a.regex")); 		assertThat(filter.isGetNamesCalled(), equalTo(false)); 	}
@Test 	public void regex() throws Exception { 		MockNamePatternFilter filter = new MockNamePatternFilter(); 		Map<String, Object> results = filter.getResults("fo.*"); 		assertThat(results.get("foo"), equalTo((Object) "foo")); 		assertThat(results.get("fool"), equalTo((Object) "fool")); 		assertThat(filter.isGetNamesCalled(), equalTo(true));  	}
@Override 	public void increment(Delta<?> delta) { 		this.channel.send(MetricMessage.forIncrement(delta)); 	}
@Override 	public void set(Metric<?> value) { 		this.channel.send(MetricMessage.forSet(value)); 	}
@Override 	public void reset(String metricName) { 		this.channel.send(MetricMessage.forReset(metricName)); 	}
@Override 	public void handleMessage(Message<?> message) throws MessagingException { 		handleMessage(new MetricMessage(message)); 	}
@Test 	public void messageSentOnAdd() { 		this.writer.increment(new Delta<Integer>("foo", 1)); 		verify(this.channel).send(any(Message.class)); 		verify(this.observer).increment(any(Delta.class)); 	}
@Test 	public void messageSentOnSet() { 		this.writer.set(new Metric<Double>("foo", 1d)); 		verify(this.channel).send(any(Message.class)); 		verify(this.observer).set(any(Metric.class)); 	}
private void flatten(Properties properties, Map<String, Object> input, String path) { 		for (Entry<String, Object> entry : input.entrySet()) { 			String key = entry.getKey(); 			if (StringUtils.hasText(path)) { 				if (key.startsWith("[")) { 					key = path + key; 				} 				else { 					key = path + "." + key; 				} 			} 			Object value = entry.getValue(); 			if (value instanceof String) { 				properties.put(key, value); 			} 			else if (value instanceof Number) { 				properties.put(key, value.toString()); 			} 			else if (value instanceof Boolean) { 				properties.put(key, value.toString()); 			} 			else if (value instanceof Map) { 				// Need a compound key 				@SuppressWarnings("unchecked") 				Map<String, Object> map = (Map<String, Object>) value; 				flatten(properties, map, key); 			} 			else if (value instanceof Collection) { 				// Need a compound key 				@SuppressWarnings("unchecked") 				Collection<Object> collection = (Collection<Object>) value; 				properties.put(key, 						StringUtils.collectionToCommaDelimitedString(collection)); 				int count = 0; 				for (Object object : collection) { 					flatten(properties, 							Collections.singletonMap("[" + (count++) + "]", object), key); 				} 			} 			else { 				properties.put(key, value == null ? "" : value); 			} 		} 	}
@Test 	public void testServiceProperties() { 		EnvironmentTestUtils 				.addEnvironment( 						this.context, 						"VCAP_SERVICES:{\"rds-mysql-n/a\":[{" 								+ "\"name\":\"mysql\",\"label\":\"rds-mysql-n/a\"," 								+ "\"plan\":\"10mb\",\"credentials\":{" 								+ "\"name\":\"d04fb13d27d964c62b267bbba1cffb9da\"," 								+ "\"hostname\":\"mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\"," 								+ "\"ssl\":true,\"location\":null," 								+ "\"host\":\"mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\"," 								+ "\"port\":3306,\"user\":\"urpRuqTf8Cpe6\",\"username\":" 								+ "\"urpRuqTf8Cpe6\",\"password\":\"pxLsGVpsC9A5S\"}}]}"); 		this.initializer.onApplicationEvent(this.event); 		assertEquals("mysql", getProperty("vcap.services.mysql.name")); 		assertEquals("3306", getProperty("vcap.services.mysql.credentials.port")); 		assertEquals("true", getProperty("vcap.services.mysql.credentials.ssl")); 		assertEquals("", getProperty("vcap.services.mysql.credentials.location")); 	}
private void flatten(Properties properties, Map<String, Object> input, String path) { 		for (Entry<String, Object> entry : input.entrySet()) { 			String key = entry.getKey(); 			if (StringUtils.hasText(path)) { 				if (key.startsWith("[")) { 					key = path + key; 				} 				else { 					key = path + "." + key; 				} 			} 			Object value = entry.getValue(); 			if (value instanceof String) { 				properties.put(key, value); 			} 			else if (value instanceof Number) { 				properties.put(key, value.toString()); 			} 			else if (value instanceof Map) { 				// Need a compound key 				@SuppressWarnings("unchecked") 				Map<String, Object> map = (Map<String, Object>) value; 				flatten(properties, map, key); 			} 			else if (value instanceof Collection) { 				// Need a compound key 				@SuppressWarnings("unchecked") 				Collection<Object> collection = (Collection<Object>) value; 				properties.put(key, 						StringUtils.collectionToCommaDelimitedString(collection)); 				int count = 0; 				for (Object object : collection) { 					flatten(properties, 							Collections.singletonMap("[" + (count++) + "]", object), key); 				} 			} 			else { 				properties.put(key, value == null ? "" : value); 			} 		} 	}
@Test 	public void testServiceProperties() { 		EnvironmentTestUtils 				.addEnvironment( 						this.context, 						"VCAP_SERVICES:{\"rds-mysql-n/a\":[{\"name\":\"mysql\",\"label\":\"rds-mysql-n/a\",\"plan\":\"10mb\",\"credentials\":{\"name\":\"d04fb13d27d964c62b267bbba1cffb9da\",\"hostname\":\"mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\",\"host\":\"mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\",\"port\":3306,\"user\":\"urpRuqTf8Cpe6\",\"username\":\"urpRuqTf8Cpe6\",\"password\":\"pxLsGVpsC9A5S\"}}]}"); 		this.initializer.onApplicationEvent(this.event); 		assertEquals("mysql", 				this.context.getEnvironment().getProperty("vcap.services.mysql.name")); 		assertEquals( 				"3306", 				this.context.getEnvironment().getProperty( 						"vcap.services.mysql.credentials.port")); 	}
@Test 	public void testServicePropertiesWithoutNA() { 		EnvironmentTestUtils 				.addEnvironment( 						this.context, 						"VCAP_SERVICES:{\"rds-mysql\":[{\"name\":\"mysql\",\"label\":\"rds-mysql\",\"plan\":\"10mb\",\"credentials\":{\"name\":\"d04fb13d27d964c62b267bbba1cffb9da\",\"hostname\":\"mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\",\"host\":\"mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\",\"port\":3306,\"user\":\"urpRuqTf8Cpe6\",\"username\":\"urpRuqTf8Cpe6\",\"password\":\"pxLsGVpsC9A5S\"}}]}"); 		this.initializer.onApplicationEvent(this.event); 		assertEquals("mysql", 				this.context.getEnvironment().getProperty("vcap.services.mysql.name")); 		assertEquals( 				"3306", 				this.context.getEnvironment().getProperty( 						"vcap.services.mysql.credentials.port")); 	}
