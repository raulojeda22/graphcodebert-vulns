@Test 	void permitAllForHealth() { 		this.contextRunner.run((context) -> assertThat(getAuthenticateHeader(context, "/actuator/health")).isNull()); 	}
@Test 	void securesEverythingElse() { 		this.contextRunner.run((context) -> { 			assertThat(getAuthenticateHeader(context, "/actuator").get(0)).contains("Basic realm="); 			assertThat(getAuthenticateHeader(context, "/foo").toString()).contains("Basic realm="); 		}); 	}
@Test 	void usesMatchersBasedOffConfiguredActuatorBasePath() { 		this.contextRunner.withPropertyValues("management.endpoints.web.base-path=/").run((context) -> { 			assertThat(getAuthenticateHeader(context, "/health")).isNull(); 			assertThat(getAuthenticateHeader(context, "/foo").get(0)).contains("Basic realm="); 		}); 	}
@Override 	public Stream<? extends Arguments> provideArguments(ExtensionContext extensionContext) { 		String customPrefix = "CUSTOM_AUTHORITY_PREFIX_"; 		String customDelimiter = "[~,#:]"; 		String customAuthoritiesClaim = "custom_authorities"; 		String customPrincipalClaim = "custom_principal";  		String jwkSetUriProperty = "spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com"; 		String authorityPrefixProperty = "spring.security.oauth2.resourceserver.jwt.authority-prefix=" + customPrefix; 		String authoritiesDelimiterProperty = "spring.security.oauth2.resourceserver.jwt.authorities-claim-delimiter=" 				+ customDelimiter; 		String authoritiesClaimProperty = "spring.security.oauth2.resourceserver.jwt.authorities-claim-name=" 				+ customAuthoritiesClaim; 		String principalClaimProperty = "spring.security.oauth2.resourceserver.jwt.principal-claim-name=" 				+ customPrincipalClaim;  		String[] noJwtConverterProps = { jwkSetUriProperty }; 		String[] customPrefixProps = { jwkSetUriProperty, authorityPrefixProperty }; 		String[] customDelimiterProps = { jwkSetUriProperty, authoritiesDelimiterProperty }; 		String[] customAuthoritiesClaimProps = { jwkSetUriProperty, authoritiesClaimProperty }; 		String[] customPrincipalClaimProps = { jwkSetUriProperty, principalClaimProperty }; 		String[] allJwtConverterProps = { jwkSetUriProperty, authorityPrefixProperty, authoritiesDelimiterProperty, 				authoritiesClaimProperty, principalClaimProperty };  		String[] jwtScopes = { "custom_scope0", "custom_scope1" }; 		String subjectValue = UUID.randomUUID().toString(); 		String customPrincipalValue = UUID.randomUUID().toString();  		Jwt.Builder jwtBuilder = Jwt.withTokenValue("token") 			.header("alg", "none") 			.expiresAt(Instant.MAX) 			.issuedAt(Instant.MIN) 			.issuer("https://issuer.example.org") 			.jti("jti") 			.notBefore(Instant.MIN) 			.subject(subjectValue) 			.claim(customPrincipalClaim, customPrincipalValue);  		Jwt noAuthoritiesCustomizationsJwt = jwtBuilder.claim("scp", jwtScopes[0] + " " + jwtScopes[1]).build(); 		Jwt customAuthoritiesDelimiterJwt = jwtBuilder.claim("scp", jwtScopes[0] + "~" + jwtScopes[1]).build(); 		Jwt customAuthoritiesClaimJwt = jwtBuilder.claim("scp", null) 			.claim(customAuthoritiesClaim, jwtScopes[0] + " " + jwtScopes[1]) 			.build(); 		Jwt customAuthoritiesClaimAndDelimiterJwt = jwtBuilder.claim("scp", null) 			.claim(customAuthoritiesClaim, jwtScopes[0] + "~" + jwtScopes[1]) 			.build();  		String[] customPrefixAuthorities = { customPrefix + jwtScopes[0], customPrefix + jwtScopes[1] }; 		String[] defaultPrefixAuthorities = { "SCOPE_" + jwtScopes[0], "SCOPE_" + jwtScopes[1] };  		return Stream.of( 				Arguments.of(Named.named("No JWT converter customizations", noJwtConverterProps), 						noAuthoritiesCustomizationsJwt, subjectValue, defaultPrefixAuthorities), 				Arguments.of(Named.named("Custom prefix for GrantedAuthority", customPrefixProps), 						noAuthoritiesCustomizationsJwt, subjectValue, customPrefixAuthorities), 				Arguments.of(Named.named("Custom delimiter for JWT scopes", customDelimiterProps), 						customAuthoritiesDelimiterJwt, subjectValue, defaultPrefixAuthorities), 				Arguments.of(Named.named("Custom JWT authority claim name", customAuthoritiesClaimProps), 						customAuthoritiesClaimJwt, subjectValue, defaultPrefixAuthorities), 				Arguments.of(Named.named("Custom JWT principal claim name", customPrincipalClaimProps), 						noAuthoritiesCustomizationsJwt, customPrincipalValue, defaultPrefixAuthorities), 				Arguments.of(Named.named("All JWT converter customizations", allJwtConverterProps), 						customAuthoritiesClaimAndDelimiterJwt, customPrincipalValue, customPrefixAuthorities)); 	}
@Bean 		ReactiveJwtDecoder decoder() { 			return mock(ReactiveJwtDecoder.class); 		}
@Bean 		ReactiveOpaqueTokenIntrospector decoder() { 			return mock(ReactiveOpaqueTokenIntrospector.class); 		}
@Bean 		JwtDecoder decoder() { 			return mock(JwtDecoder.class); 		}
@Bean 		OpaqueTokenIntrospector decoder() { 			return mock(OpaqueTokenIntrospector.class); 		}
@Bean 		ReactiveJwtDecoder decoder() { 			return mock(ReactiveJwtDecoder.class); 		}
@Bean 		ReactiveOpaqueTokenIntrospector decoder() { 			return mock(ReactiveOpaqueTokenIntrospector.class); 		}
@Test 	void enablesWebFluxSecurityWhenUserDetailsServiceIsPresent() { 		this.contextRunner.withUserConfiguration(UserDetailsServiceConfiguration.class) 			.run((context) -> assertThat(context).getBean(WebFilterChainProxy.class).isNotNull()); 	}
@Test 	void enablesWebFluxSecurityWhenReactiveAuthenticationManagerIsPresent() { 		this.contextRunner 			.withBean(ReactiveAuthenticationManager.class, () -> mock(ReactiveAuthenticationManager.class)) 			.run((context) -> assertThat(context).getBean(WebFilterChainProxy.class).isNotNull()); 	}
@Test 	void enablesWebFluxSecurityWhenSecurityWebFilterChainIsPresent() { 		this.contextRunner.withBean(SecurityWebFilterChain.class, () -> mock(SecurityWebFilterChain.class)) 			.run((context) -> assertThat(context).getBean(WebFilterChainProxy.class).isNotNull()); 	}
@Test 	void autoConfigurationShouldConfigureResourceServer() { 		this.contextRunner 			.withPropertyValues("spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com") 			.withInitializer(ConditionEvaluationReportLoggingListener.forLogLevel(LogLevel.INFO)) 			.run((context) -> { 				assertThat(context).hasSingleBean(NimbusReactiveJwtDecoder.class); 				assertFilterConfiguredWithJwtAuthenticationManager(context); 			}); 	}
@Test 	void autoConfigurationWhenIntrospectionUriAvailableShouldConfigureIntrospectionClient() { 		this.contextRunner.withInitializer(ConditionEvaluationReportLoggingListener.forLogLevel(LogLevel.INFO)) 			.withPropertyValues( 					"spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://check-token.com", 					"spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id", 					"spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret") 			.run((context) -> { 				assertThat(context).hasSingleBean(ReactiveOpaqueTokenIntrospector.class); 				assertFilterConfiguredWithOpaqueTokenAuthenticationManager(context); 			}); 	}
@Bean 		ReactiveJwtDecoder decoder() { 			return mock(ReactiveJwtDecoder.class); 		}
@Bean 		ReactiveOpaqueTokenIntrospector decoder() { 			return mock(ReactiveOpaqueTokenIntrospector.class); 		}
@Test 	void autoConfigurationShouldConfigureResourceServer() { 		this.contextRunner 			.withPropertyValues("spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com") 			.run((context) -> { 				assertThat(context).hasSingleBean(NimbusReactiveJwtDecoder.class); 				assertFilterConfiguredWithJwtAuthenticationManager(context); 			}); 	}
@Test 	void autoConfigurationWhenIntrospectionUriAvailableShouldConfigureIntrospectionClient() { 		this.contextRunner 			.withPropertyValues( 					"spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://check-token.com", 					"spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id", 					"spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret") 			.run((context) -> { 				assertThat(context).hasSingleBean(ReactiveOpaqueTokenIntrospector.class); 				assertFilterConfiguredWithOpaqueTokenAuthenticationManager(context); 			}); 	}
@Bean 		ReactiveJwtDecoder decoder() { 			return mock(ReactiveJwtDecoder.class); 		}
@Bean 		ReactiveOpaqueTokenIntrospector decoder() { 			return mock(ReactiveOpaqueTokenIntrospector.class); 		}
@Test 	void executeWithSecurityOptionsExecutesPhases() throws Exception { 		given(this.docker.container().create(any())).willAnswer(answerWithGeneratedContainerId()); 		given(this.docker.container().create(any(), any())).willAnswer(answerWithGeneratedContainerId()); 		given(this.docker.container().wait(any())).willReturn(ContainerStatus.of(0, null)); 		BuildRequest request = getTestRequest().withSecurityOptions(List.of("label=user:USER", "label=role:ROLE")); 		createLifecycle(request).execute(); 		assertPhaseWasRun("creator", withExpectedConfig("lifecycle-creator-security-opts.json")); 		assertThat(this.out.toString()).contains("Successfully built image 'docker.io/library/my-application:latest'"); 	}
private IOConsumer<ContainerConfig> withExpectedConfig(String name) { 		return (config) -> { 			try { 				InputStream in = getClass().getResourceAsStream(name); 				String jsonString = FileCopyUtils.copyToString(new InputStreamReader(in, StandardCharsets.UTF_8)); 				JSONObject json = new JSONObject(jsonString); 				if (Platform.isWindows()) { 					JSONObject hostConfig = json.getJSONObject("HostConfig"); 					hostConfig.remove("SecurityOpt"); 				} 				JSONAssert.assertEquals(config.toString(), json, true); 			} 			catch (JSONException ex) { 				throw new IOException(ex); 			} 		}; 	}
@Bean 		ReactiveJwtDecoder decoder() { 			return mock(ReactiveJwtDecoder.class); 		}
@Bean 		ReactiveOpaqueTokenIntrospector decoder() { 			return mock(ReactiveOpaqueTokenIntrospector.class); 		}
public BuildRequest withBuilder(ImageReference builder) { 		Assert.notNull(builder, "Builder must not be null"); 		return new BuildRequest(this.name, this.applicationContent, builder.inTaggedOrDigestForm(), this.runImage, 				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, 				this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache, 				this.launchCache, this.createdDate, this.applicationDirectory); 	}
public BuildRequest withRunImage(ImageReference runImageName) { 		return new BuildRequest(this.name, this.applicationContent, this.builder, runImageName.inTaggedOrDigestForm(), 				this.creator, this.env, this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, 				this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache, 				this.launchCache, this.createdDate, this.applicationDirectory); 	}
public BuildRequest withCreator(Creator creator) { 		Assert.notNull(creator, "Creator must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory); 	}
public BuildRequest withEnv(String name, String value) { 		Assert.hasText(name, "Name must not be empty"); 		Assert.hasText(value, "Value must not be empty"); 		Map<String, String> env = new LinkedHashMap<>(this.env); 		env.put(name, value); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, 				Collections.unmodifiableMap(env), this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, 				this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace, this.buildCache, 				this.launchCache, this.createdDate, this.applicationDirectory); 	}
public BuildRequest withEnv(Map<String, String> env) { 		Assert.notNull(env, "Env must not be null"); 		Map<String, String> updatedEnv = new LinkedHashMap<>(this.env); 		updatedEnv.putAll(env); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, 				Collections.unmodifiableMap(updatedEnv), this.cleanCache, this.verboseLogging, this.pullPolicy, 				this.publish, this.buildpacks, this.bindings, this.network, this.tags, this.buildWorkspace, 				this.buildCache, this.launchCache, this.createdDate, this.applicationDirectory); 	}
public BuildRequest withCleanCache(boolean cleanCache) { 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory); 	}
public BuildRequest withVerboseLogging(boolean verboseLogging) { 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory); 	}
public BuildRequest withPullPolicy(PullPolicy pullPolicy) { 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory); 	}
public BuildRequest withPublish(boolean publish) { 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory); 	}
public BuildRequest withBuildpacks(List<BuildpackReference> buildpacks) { 		Assert.notNull(buildpacks, "Buildpacks must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory); 	}
public BuildRequest withBindings(List<Binding> bindings) { 		Assert.notNull(bindings, "Bindings must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory); 	}
public BuildRequest withNetwork(String network) { 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory); 	}
public BuildRequest withTags(List<ImageReference> tags) { 		Assert.notNull(tags, "Tags must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory); 	}
public BuildRequest withBuildWorkspace(Cache buildWorkspace) { 		Assert.notNull(buildWorkspace, "BuildWorkspace must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory); 	}
public BuildRequest withBuildCache(Cache buildCache) { 		Assert.notNull(buildCache, "BuildCache must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, buildCache, this.launchCache, this.createdDate, 				this.applicationDirectory); 	}
public BuildRequest withLaunchCache(Cache launchCache) { 		Assert.notNull(launchCache, "LaunchCache must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, launchCache, this.createdDate, 				this.applicationDirectory); 	}
public BuildRequest withCreatedDate(String createdDate) { 		Assert.notNull(createdDate, "CreatedDate must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, 				parseCreatedDate(createdDate), this.applicationDirectory); 	}
public BuildRequest withApplicationDirectory(String applicationDirectory) { 		Assert.notNull(applicationDirectory, "ApplicationDirectory must not be null"); 		return new BuildRequest(this.name, this.applicationContent, this.builder, this.runImage, this.creator, this.env, 				this.cleanCache, this.verboseLogging, this.pullPolicy, this.publish, this.buildpacks, this.bindings, 				this.network, this.tags, this.buildWorkspace, this.buildCache, this.launchCache, this.createdDate, 				applicationDirectory); 	}
private void configureDaemonAccess(Phase phase) { 		if (this.dockerHost != null) { 			if (this.dockerHost.isRemote()) { 				phase.withEnv("DOCKER_HOST", this.dockerHost.getAddress()); 				if (this.dockerHost.isSecure()) { 					phase.withEnv("DOCKER_TLS_VERIFY", "1"); 					phase.withEnv("DOCKER_CERT_PATH", this.dockerHost.getCertificatePath()); 				} 			} 			else { 				phase.withBinding(Binding.from(this.dockerHost.getAddress(), DOMAIN_SOCKET_PATH)); 			} 		} 		else { 			phase.withBinding(Binding.from(DOMAIN_SOCKET_PATH, DOMAIN_SOCKET_PATH)); 		} 		if (!Platform.isWindows()) { 			phase.withSecurityOption("label=disable"); 		} 	}
private BuildRequest customize(BuildRequest request) { 		request = customizeBuilder(request); 		request = customizeRunImage(request); 		request = customizeEnvironment(request); 		request = customizeCreator(request); 		request = request.withCleanCache(getCleanCache().get()); 		request = request.withVerboseLogging(getVerboseLogging().get()); 		request = customizePullPolicy(request); 		request = customizePublish(request); 		request = customizeBuildpacks(request); 		request = customizeBindings(request); 		request = customizeTags(request); 		request = customizeCaches(request); 		request = request.withNetwork(getNetwork().getOrNull()); 		request = customizeCreatedDate(request); 		request = customizeApplicationDirectory(request); 		return request; 	}
private BuildRequest customize(BuildRequest request) { 		if (StringUtils.hasText(this.builder)) { 			request = request.withBuilder(ImageReference.of(this.builder)); 		} 		if (StringUtils.hasText(this.runImage)) { 			request = request.withRunImage(ImageReference.of(this.runImage)); 		} 		if (this.env != null && !this.env.isEmpty()) { 			request = request.withEnv(this.env); 		} 		if (this.cleanCache != null) { 			request = request.withCleanCache(this.cleanCache); 		} 		request = request.withVerboseLogging(this.verboseLogging); 		if (this.pullPolicy != null) { 			request = request.withPullPolicy(this.pullPolicy); 		} 		if (this.publish != null) { 			request = request.withPublish(this.publish); 		} 		if (!CollectionUtils.isEmpty(this.buildpacks)) { 			request = request.withBuildpacks(this.buildpacks.stream().map(BuildpackReference::of).toList()); 		} 		if (!CollectionUtils.isEmpty(this.bindings)) { 			request = request.withBindings(this.bindings.stream().map(Binding::of).toList()); 		} 		request = request.withNetwork(this.network); 		if (!CollectionUtils.isEmpty(this.tags)) { 			request = request.withTags(this.tags.stream().map(ImageReference::of).toList()); 		} 		if (this.buildWorkspace != null) { 			request = request.withBuildWorkspace(this.buildWorkspace.asCache()); 		} 		if (this.buildCache != null) { 			request = request.withBuildCache(this.buildCache.asCache()); 		} 		if (this.launchCache != null) { 			request = request.withLaunchCache(this.launchCache.asCache()); 		} 		if (StringUtils.hasText(this.createdDate)) { 			request = request.withCreatedDate(this.createdDate); 		} 		if (StringUtils.hasText(this.applicationDirectory)) { 			request = request.withApplicationDirectory(this.applicationDirectory); 		} 		return request; 	}
@Override 				public boolean supportsContext(Context context) { 					return true; 				}
@Override 				public boolean supportsContext(Context context) { 					return true; 				}
@Override 				public boolean supportsContext(Context context) { 					return true; 				}
@Override 				public boolean supportsContext(Context context) { 					return true; 				}
@Override 		public boolean supportsContext(Context context) { 			return true; 		}
@Override 		public boolean supportsContext(Context context) { 			return true; 		}
@Override 		public boolean supportsContext(Context context) { 			return context instanceof CustomContext; 		}
@Override 		public boolean supportsContext(Context context) { 			return context instanceof CustomContext; 		}
@Override 		public boolean supportsContext(Context context) { 			return context instanceof CustomContext; 		}
@Override 		public boolean supportsContext(Context context) { 			return context instanceof CustomContext; 		}
@Override 		public boolean supportsContext(Context context) { 			return true; 		}
@Override 		public boolean supportsContext(Context context) { 			return true; 		}
@Override 		public boolean supportsContext(Context context) { 			return true; 		}
@Override 		public boolean supportsContext(Context context) { 			return true; 		}
AuthorizationServerSettings asAuthorizationServerSettings() { 		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 		OAuth2AuthorizationServerProperties.Endpoint endpoint = this.properties.getEndpoint(); 		OAuth2AuthorizationServerProperties.OidcEndpoint oidc = endpoint.getOidc(); 		AuthorizationServerSettings.Builder builder = AuthorizationServerSettings.builder(); 		map.from(this.properties::getIssuer).to(builder::issuer); 		map.from(endpoint::getAuthorizationUri).to(builder::authorizationEndpoint); 		map.from(endpoint::getTokenUri).to(builder::tokenEndpoint); 		map.from(endpoint::getJwkSetUri).to(builder::jwkSetEndpoint); 		map.from(endpoint::getTokenRevocationUri).to(builder::tokenRevocationEndpoint); 		map.from(endpoint::getTokenIntrospectionUri).to(builder::tokenIntrospectionEndpoint); 		map.from(oidc::getLogoutUri).to(builder::oidcLogoutEndpoint); 		map.from(oidc::getClientRegistrationUri).to(builder::oidcClientRegistrationEndpoint); 		map.from(oidc::getUserInfoUri).to(builder::oidcUserInfoEndpoint); 		return builder.build(); 	}
private TokenSettings getTokenSettings(Client client, PropertyMapper map) { 		OAuth2AuthorizationServerProperties.Token token = client.getToken(); 		TokenSettings.Builder builder = TokenSettings.builder(); 		map.from(token::getAuthorizationCodeTimeToLive).to(builder::authorizationCodeTimeToLive); 		map.from(token::getAccessTokenTimeToLive).to(builder::accessTokenTimeToLive); 		map.from(token::getAccessTokenFormat).as(OAuth2TokenFormat::new).to(builder::accessTokenFormat); 		map.from(token::isReuseRefreshTokens).to(builder::reuseRefreshTokens); 		map.from(token::getRefreshTokenTimeToLive).to(builder::refreshTokenTimeToLive); 		map.from(token::getIdTokenSignatureAlgorithm) 			.as(this::signatureAlgorithm) 			.to(builder::idTokenSignatureAlgorithm); 		return builder.build(); 	}
@Test 	void authorizationServerSettingsBeanShouldBeCreatedWhenPropertiesPresent() { 		this.contextRunner 			.withPropertyValues(PROPERTIES_PREFIX + ".issuer=https://example.com", 					PROPERTIES_PREFIX + ".endpoint.authorization-uri=/authorize", 					PROPERTIES_PREFIX + ".endpoint.token-uri=/token", PROPERTIES_PREFIX + ".endpoint.jwk-set-uri=/jwks", 					PROPERTIES_PREFIX + ".endpoint.token-revocation-uri=/revoke", 					PROPERTIES_PREFIX + ".endpoint.token-introspection-uri=/introspect", 					PROPERTIES_PREFIX + ".endpoint.oidc.logout-uri=/logout", 					PROPERTIES_PREFIX + ".endpoint.oidc.client-registration-uri=/register", 					PROPERTIES_PREFIX + ".endpoint.oidc.user-info-uri=/user") 			.run((context) -> { 				AuthorizationServerSettings settings = context.getBean(AuthorizationServerSettings.class); 				assertThat(settings.getIssuer()).isEqualTo("https://example.com"); 				assertThat(settings.getAuthorizationEndpoint()).isEqualTo("/authorize"); 				assertThat(settings.getTokenEndpoint()).isEqualTo("/token"); 				assertThat(settings.getJwkSetEndpoint()).isEqualTo("/jwks"); 				assertThat(settings.getTokenRevocationEndpoint()).isEqualTo("/revoke"); 				assertThat(settings.getTokenIntrospectionEndpoint()).isEqualTo("/introspect"); 				assertThat(settings.getOidcLogoutEndpoint()).isEqualTo("/logout"); 				assertThat(settings.getOidcClientRegistrationEndpoint()).isEqualTo("/register"); 				assertThat(settings.getOidcUserInfoEndpoint()).isEqualTo("/user"); 			}); 	}
private OAuth2AuthorizationServerProperties.Client createClient() { 		OAuth2AuthorizationServerProperties.Client client = new OAuth2AuthorizationServerProperties.Client(); 		client.setRequireProofKey(true); 		client.setRequireAuthorizationConsent(true); 		client.setJwkSetUri("https://example.com/jwks"); 		client.setTokenEndpointAuthenticationSigningAlgorithm("rs256"); 		OAuth2AuthorizationServerProperties.Registration registration = client.getRegistration(); 		registration.setClientId("foo"); 		registration.setClientSecret("secret"); 		registration.getClientAuthenticationMethods().add("client_secret_basic"); 		registration.getAuthorizationGrantTypes().add("authorization_code"); 		registration.getRedirectUris().add("https://example.com/redirect"); 		registration.getPostLogoutRedirectUris().add("https://example.com/logout"); 		registration.getScopes().add("user.read"); 		OAuth2AuthorizationServerProperties.Token token = client.getToken(); 		token.setAccessTokenFormat("reference"); 		token.setAccessTokenTimeToLive(Duration.ofSeconds(300)); 		token.setRefreshTokenTimeToLive(Duration.ofHours(24)); 		token.setReuseRefreshTokens(true); 		token.setIdTokenSignatureAlgorithm("rs512"); 		return client; 	}
@Test 	void getAuthorizationServerSettingsWhenValidParametersShouldAdapt() { 		this.properties.setIssuer("https://example.com"); 		OAuth2AuthorizationServerProperties.Endpoint endpoints = this.properties.getEndpoint(); 		endpoints.setAuthorizationUri("/authorize"); 		endpoints.setTokenUri("/token"); 		endpoints.setJwkSetUri("/jwks"); 		endpoints.setTokenRevocationUri("/revoke"); 		endpoints.setTokenIntrospectionUri("/introspect"); 		OAuth2AuthorizationServerProperties.OidcEndpoint oidc = endpoints.getOidc(); 		oidc.setLogoutUri("/logout"); 		oidc.setClientRegistrationUri("/register"); 		oidc.setUserInfoUri("/user"); 		AuthorizationServerSettings settings = this.mapper.asAuthorizationServerSettings(); 		assertThat(settings.getIssuer()).isEqualTo("https://example.com"); 		assertThat(settings.getAuthorizationEndpoint()).isEqualTo("/authorize"); 		assertThat(settings.getTokenEndpoint()).isEqualTo("/token"); 		assertThat(settings.getJwkSetEndpoint()).isEqualTo("/jwks"); 		assertThat(settings.getTokenRevocationEndpoint()).isEqualTo("/revoke"); 		assertThat(settings.getTokenIntrospectionEndpoint()).isEqualTo("/introspect"); 		assertThat(settings.getOidcLogoutEndpoint()).isEqualTo("/logout"); 		assertThat(settings.getOidcClientRegistrationEndpoint()).isEqualTo("/register"); 		assertThat(settings.getOidcUserInfoEndpoint()).isEqualTo("/user"); 	}
@Test 	void defaultFilterDispatcherTypes() { 		this.contextRunner.withConfiguration(AutoConfigurations.of(SecurityFilterAutoConfiguration.class)) 				.run((context) -> { 					DelegatingFilterProxyRegistrationBean bean = context.getBean("securityFilterChainRegistration", 							DelegatingFilterProxyRegistrationBean.class); 					assertThat(bean) 							.extracting("dispatcherTypes", InstanceOfAssertFactories.iterable(DispatcherType.class)) 							.containsOnly(DispatcherType.ASYNC, DispatcherType.ERROR, DispatcherType.REQUEST); 				}); 	}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.csrf().disable(); 			http.authorizeHttpRequests((requests) -> requests.anyRequest().fullyAuthenticated()); 			http.httpBasic(); 			http.formLogin((form) -> form.loginPage("/login").permitAll()); 			http.exceptionHandling((exceptions) -> exceptions.accessDeniedPage("/access")); 			return http.build(); 		}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.csrf().disable(); 			http.authorizeHttpRequests((requests) -> requests.anyRequest().fullyAuthenticated()); 			http.formLogin((form) -> form.loginPage("/login").permitAll()); 			return http.build(); 		}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.csrf().disable(); 			http.authorizeHttpRequests((requests) -> requests.anyRequest().fullyAuthenticated()); 			http.formLogin((form) -> form.loginPage("/login").permitAll()); 			return http.build(); 		}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.csrf().disable(); 			http.authorizeHttpRequests((requests) -> { 				requests.requestMatchers("/public/**").permitAll(); 				requests.anyRequest().fullyAuthenticated(); 			}); 			http.httpBasic(); 			http.formLogin((form) -> form.loginPage("/login").permitAll()); 			return http.build(); 		}
@Test 	void testFilterOrdering() { 		load(); 		List<RegisteredFilter> registeredFilters = this.context.getBean(MockServletWebServerFactory.class) 				.getWebServer().getRegisteredFilters(); 		List<Filter> filters = new ArrayList<>(registeredFilters.size()); 		for (RegisteredFilter registeredFilter : registeredFilters) { 			filters.add(registeredFilter.getFilter()); 		} 		Iterator<Filter> iterator = filters.iterator(); 		assertThat(iterator.next()).isInstanceOf(OrderedCharacterEncodingFilter.class); 		assertThat(iterator.next()).isInstanceOf(SessionRepositoryFilter.class); 		assertThat(iterator.next()).isInstanceOf(Filter.class); 		assertThat(iterator.next()).isInstanceOf(Filter.class); 		assertThat(iterator.next()).isInstanceOf(OrderedRequestContextFilter.class); 		assertThat(iterator.next()).isInstanceOf(ErrorPageSecurityFilter.class); 		assertThat(iterator.next()).isInstanceOf(FilterChainProxy.class); 	}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.authorizeHttpRequests((requests) -> { 				requests.antMatchers("/custom/servlet/path/public/**").permitAll(); 				requests.anyRequest().fullyAuthenticated(); 				requests.shouldFilterAllDispatcherTypes(false); 			}); 			http.httpBasic(); 			http.formLogin((form) -> form.loginPage("/custom/servlet/path/login").permitAll()); 			return http.build(); 		}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.authorizeHttpRequests((requests) -> { 				requests.antMatchers("/public/**").permitAll(); 				requests.anyRequest().fullyAuthenticated(); 				requests.shouldFilterAllDispatcherTypes(false); 			}); 			http.httpBasic(); 			http.formLogin((form) -> form.loginPage("/login").permitAll()); 			return http.build(); 		}
@Bean 		SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { 			http.sessionManagement((session) -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) 					.authorizeHttpRequests((requests) -> { 						requests.antMatchers("/public/**").permitAll(); 						requests.anyRequest().authenticated(); 						requests.shouldFilterAllDispatcherTypes(false); 					}); 			http.httpBasic(); 			return http.build(); 		}
private void configureDaemonAccess(Phase phase) { 		if (this.dockerHost != null) { 			if (this.dockerHost.isRemote()) { 				phase.withEnv("DOCKER_HOST", this.dockerHost.getAddress()); 				if (this.dockerHost.isSecure()) { 					phase.withEnv("DOCKER_TLS_VERIFY", "1"); 					phase.withEnv("DOCKER_CERT_PATH", this.dockerHost.getCertificatePath()); 				} 			} 			else { 				phase.withBinding(Binding.from(this.dockerHost.getAddress(), DOMAIN_SOCKET_PATH)); 			} 		} 		else { 			phase.withBinding(Binding.from(DOMAIN_SOCKET_PATH, DOMAIN_SOCKET_PATH)); 		} 	}
void apply(ContainerConfig.Update update) { 		if (this.daemonAccess) { 			update.withUser("root"); 		} 		update.withCommand("/cnb/lifecycle/" + this.name, StringUtils.toStringArray(this.args)); 		update.withLabel("author", "spring-boot"); 		this.bindings.forEach(update::withBinding); 		this.env.forEach(update::withEnv); 		if (this.networkMode != null) { 			update.withNetworkMode(this.networkMode); 		} 	}
private ContainerConfig run(Consumer<Update> update) { 			update.accept(this); 			try { 				return new ContainerConfig(this.user, this.image, this.command, this.args, this.labels, this.bindings, 						this.env, this.networkMode); 			} 			catch (IOException ex) { 				throw new IllegalStateException(ex); 			} 		}
@Test 	void writeToWritesJson() throws Exception { 		ImageReference imageReference = ImageReference.of("ubuntu:bionic"); 		ContainerConfig containerConfig = ContainerConfig.of(imageReference, (update) -> { 			update.withUser("root"); 			update.withCommand("ls", "-l"); 			update.withArgs("-h"); 			update.withLabel("spring", "boot"); 			update.withBinding(Binding.from("bind-source", "bind-dest")); 			update.withEnv("name1", "value1"); 			update.withEnv("name2", "value2"); 			update.withNetworkMode("test"); 		}); 		ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); 		containerConfig.writeTo(outputStream); 		String actualJson = new String(outputStream.toByteArray(), StandardCharsets.UTF_8); 		String expectedJson = StreamUtils.copyToString(getContent("container-config.json"), StandardCharsets.UTF_8); 		JSONAssert.assertEquals(expectedJson, actualJson, false); 	}
@Bean 	SecurityFilterChain configure(HttpSecurity http) throws Exception { 		http.authorizeRequests((requests) -> { 			requests.mvcMatchers("/actuator/beans").hasRole("BEANS"); 			requests.requestMatchers(EndpointRequest.to("health")).permitAll(); 			requests.requestMatchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)) 					.hasRole("ACTUATOR"); 			requests.requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll(); 			requests.antMatchers("/foo").permitAll(); 			requests.antMatchers("/**").hasRole("USER"); 		}); 		http.cors(Customizer.withDefaults()); 		http.httpBasic(); 		return http.build(); 	}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.csrf().disable(); 			http.authorizeRequests((requests) -> requests.anyRequest().fullyAuthenticated()); 			http.formLogin((form) -> form.loginPage("/login").permitAll()); 			http.exceptionHandling((exceptions) -> exceptions.accessDeniedPage("/access")); 			return http.build(); 		}
@Bean 		SecurityFilterChain actuatorSecurity(HttpSecurity http) throws Exception { 			http.csrf().disable(); 			http.requestMatcher(EndpointRequest.toAnyEndpoint()); 			http.authorizeRequests((requests) -> requests.anyRequest().authenticated()); 			http.httpBasic(); 			return http.build(); 		}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.authorizeRequests((requests) -> { 				requests.antMatchers("/custom/servlet/path/public/**").permitAll(); 				requests.anyRequest().fullyAuthenticated(); 			}); 			http.httpBasic(); 			http.formLogin((form) -> form.loginPage("/custom/servlet/path/login").permitAll()); 			return http.build(); 		}
@Bean 		SecurityFilterChain configure(HttpSecurity http) throws Exception { 			http.authorizeRequests((requests) -> { 				requests.antMatchers("/public/**").permitAll(); 				requests.anyRequest().fullyAuthenticated(); 			}); 			http.httpBasic(); 			http.formLogin((form) -> form.loginPage("/login").permitAll()); 			return http.build(); 		}
@Bean 		SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception { 			http.sessionManagement((session) -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) 					.authorizeRequests((requests) -> { 						requests.antMatchers("/public/**").permitAll(); 						requests.anyRequest().authenticated(); 					}); 			http.httpBasic(); 			return http.build(); 		}
@Bean 		FilterRegistrationBean<ResourceUrlEncodingFilter> filterRegistration() { 			FilterRegistrationBean<ResourceUrlEncodingFilter> bean = new FilterRegistrationBean<>( 					new ResourceUrlEncodingFilter()); 			bean.setDispatcherTypes(EnumSet.of(DispatcherType.INCLUDE)); 			return bean; 		}
@Bean 		FilterRegistrationBean<OrderedCharacterEncodingFilter> filterRegistration() { 			return new FilterRegistrationBean<>(new OrderedCharacterEncodingFilter()); 		}
@Test 	void backOffIfSaml2RelyingPartyAutoConfigurationPresent() { 		this.contextRunner.withConfiguration(AutoConfigurations.of(Saml2RelyingPartyAutoConfiguration.class)) 				.withPropertyValues( 						"spring.security.saml2.relyingparty.registration.simplesamlphp.asserting-party.single-sign-on.url=https://simplesaml-for-spring-saml/SSOService.php", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.asserting-party.single-sign-on.sign-request=false", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.asserting-party.entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.asserting-party.verification.credentials[0].certificate-location=classpath:saml/certificate-location") 				.run((context) -> assertThat(context).doesNotHaveBean(ManagementWebSecurityAutoConfiguration.class) 						.doesNotHaveBean(MANAGEMENT_SECURITY_FILTER_CHAIN_BEAN)); 	}
public List<Credential> getCredentials() { 				return this.credentials; 			}
public void setCredentials(List<Credential> credentials) { 				this.credentials = credentials; 			}
public Resource getPrivateKeyLocation() { 					return this.privateKeyLocation; 				}
public void setPrivateKeyLocation(Resource privateKey) { 					this.privateKeyLocation = privateKey; 				}
public Resource getCertificateLocation() { 					return this.certificateLocation; 				}
public Resource getCertificateLocation() { 					return this.certificateLocation; 				}
public void setCertificateLocation(Resource certificate) { 					this.certificateLocation = certificate; 				}
public void setCertificateLocation(Resource certificate) { 					this.certificateLocation = certificate; 				}
public List<Credential> getCredentials() { 			return this.credentials; 		}
public List<Credential> getCredentials() { 			return this.credentials; 		}
public void setCredentials(List<Credential> credentials) { 			this.credentials = credentials; 		}
public void setCredentials(List<Credential> credentials) { 			this.credentials = credentials; 		}
public Resource getPrivateKeyLocation() { 				return this.privateKeyLocation; 			}
public void setPrivateKeyLocation(Resource privateKey) { 				this.privateKeyLocation = privateKey; 			}
public Resource getCertificateLocation() { 				return this.certificateLocation; 			}
public Resource getCertificateLocation() { 				return this.certificateLocation; 			}
public void setCertificateLocation(Resource certificate) { 				this.certificateLocation = certificate; 			}
public void setCertificateLocation(Resource certificate) { 				this.certificateLocation = certificate; 			}
public List<Credential> getCredentials() { 				return this.credentials; 			}
public void setCredentials(List<Credential> credentials) { 				this.credentials = credentials; 			}
public Resource getCertificateLocation() { 					return this.certificate; 				}
public Resource getCertificateLocation() { 					return this.certificate; 				}
public void setCertificateLocation(Resource certificate) { 					this.certificate = certificate; 				}
public void setCertificateLocation(Resource certificate) { 					this.certificate = certificate; 				}
@SuppressWarnings("deprecation") 		private <T> T get(String name, Function<AssertingParty, T> getter) { 			T newValue = getter.apply(this.registration.getAssertingParty()); 			if (newValue != null) { 				return newValue; 			} 			T deprecatedValue = getter.apply(this.registration.getIdentityprovider()); 			if (deprecatedValue != null) { 				logger.warn(LogMessage.format( 						"Property 'spring.security.saml2.relyingparty.registration.identityprovider.%1$s.%2$s' is deprecated, " 								+ "please use 'spring.security.saml2.relyingparty.registration.asserting-party.%1$s.%2$s' instead", 						this.id, name)); 				return deprecatedValue; 			} 			return newValue; 		}
@Test 	void autoconfigurationShouldQueryAssertingPartyMetadataWhenMetadataUrlIsPresent() throws Exception { 		try (MockWebServer server = new MockWebServer()) { 			server.start(); 			String metadataUrl = server.url("").toString(); 			setupMockResponse(server, new ClassPathResource("saml/idp-metadata")); 			this.contextRunner.withPropertyValues(PREFIX + ".foo.asserting-party.metadata-uri=" + metadataUrl) 					.run((context) -> { 						assertThat(context).hasSingleBean(RelyingPartyRegistrationRepository.class); 						assertThat(server.getRequestCount()).isEqualTo(1); 					}); 		} 	}
@Test 	void autoconfigurationShouldUseBindingFromMetadataUrlIfPresent() throws Exception { 		try (MockWebServer server = new MockWebServer()) { 			server.start(); 			String metadataUrl = server.url("").toString(); 			setupMockResponse(server, new ClassPathResource("saml/idp-metadata")); 			this.contextRunner.withPropertyValues(PREFIX + ".foo.asserting-party.metadata-uri=" + metadataUrl) 					.run((context) -> { 						RelyingPartyRegistrationRepository repository = context 								.getBean(RelyingPartyRegistrationRepository.class); 						RelyingPartyRegistration registration = repository.findByRegistrationId("foo"); 						assertThat(registration.getAssertingPartyDetails().getSingleSignOnServiceBinding()) 								.isEqualTo(Saml2MessageBinding.POST); 					}); 		} 	}
@Test 	void autoconfigurationWhenMetadataUrlAndPropertyPresentShouldUseBindingFromProperty() throws Exception { 		try (MockWebServer server = new MockWebServer()) { 			server.start(); 			String metadataUrl = server.url("").toString(); 			setupMockResponse(server, new ClassPathResource("saml/idp-metadata")); 			this.contextRunner.withPropertyValues(PREFIX + ".foo.asserting-party.metadata-uri=" + metadataUrl, 					PREFIX + ".foo.asserting-party.singlesignon.binding=redirect").run((context) -> { 						RelyingPartyRegistrationRepository repository = context 								.getBean(RelyingPartyRegistrationRepository.class); 						RelyingPartyRegistration registration = repository.findByRegistrationId("foo"); 						assertThat(registration.getAssertingPartyDetails().getSingleSignOnServiceBinding()) 								.isEqualTo(Saml2MessageBinding.REDIRECT); 					}); 		} 	}
private String[] getPropertyValuesWithoutSigningCredentials(boolean signRequests, boolean useDeprecated) { 		String assertingParty = useDeprecated ? "identityprovider" : "asserting-party"; 		return new String[] { 				PREFIX + ".foo." + assertingParty 						+ ".singlesignon.url=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php", 				PREFIX + ".foo." + assertingParty + ".singlesignon.binding=post", 				PREFIX + ".foo." + assertingParty + ".singlesignon.sign-request=" + signRequests, 				PREFIX + ".foo." + assertingParty 						+ ".entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php", 				PREFIX + ".foo." + assertingParty 						+ ".verification.credentials[0].certificate-location=classpath:saml/certificate-location" }; 	}
private String[] getPropertyValuesWithoutSsoBinding(boolean useDeprecated) { 		String assertingParty = useDeprecated ? "identityprovider" : "asserting-party"; 		return new String[] { 				PREFIX + ".foo." + assertingParty 						+ ".singlesignon.url=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php", 				PREFIX + ".foo." + assertingParty + ".singlesignon.sign-request=false", 				PREFIX + ".foo." + assertingParty 						+ ".entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php", 				PREFIX + ".foo." + assertingParty 						+ ".verification.credentials[0].certificate-location=classpath:saml/certificate-location" }; 	}
private String[] getPropertyValues(boolean useDeprecated) { 		String assertingParty = useDeprecated ? "identityprovider" : "asserting-party"; 		return new String[] { 				PREFIX + ".foo.signing.credentials[0].private-key-location=classpath:saml/private-key-location", 				PREFIX + ".foo.signing.credentials[0].certificate-location=classpath:saml/certificate-location", 				PREFIX + ".foo.decryption.credentials[0].private-key-location=classpath:saml/private-key-location", 				PREFIX + ".foo.decryption.credentials[0].certificate-location=classpath:saml/certificate-location", 				PREFIX + ".foo." + assertingParty 						+ ".singlesignon.url=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php", 				PREFIX + ".foo." + assertingParty + ".singlesignon.binding=post", 				PREFIX + ".foo." + assertingParty + ".singlesignon.sign-request=false", 				PREFIX + ".foo." + assertingParty 						+ ".entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php", 				PREFIX + ".foo." + assertingParty 						+ ".verification.credentials[0].certificate-location=classpath:saml/certificate-location", 				PREFIX + ".foo.entity-id={baseUrl}/saml2/foo-entity-id", 				PREFIX + ".foo.acs.location={baseUrl}/login/saml2/foo-entity-id", 				PREFIX + ".foo.acs.binding=redirect" }; 	}
@Test 	void customizeSsoUrl() { 		bind("spring.security.saml2.relyingparty.registration.simplesamlphp.asserting-party.single-sign-on.url", 				"https://simplesaml-for-spring-saml/SSOService.php"); 		assertThat( 				this.properties.getRegistration().get("simplesamlphp").getAssertingParty().getSinglesignon().getUrl()) 						.isEqualTo("https://simplesaml-for-spring-saml/SSOService.php"); 	}
@Test 	void customizeSsoBinding() { 		bind("spring.security.saml2.relyingparty.registration.simplesamlphp.asserting-party.single-sign-on.binding", 				"post"); 		assertThat(this.properties.getRegistration().get("simplesamlphp").getAssertingParty().getSinglesignon() 				.getBinding()).isEqualTo(Saml2MessageBinding.POST); 	}
@Test 	void customizeSsoSignRequests() { 		bind("spring.security.saml2.relyingparty.registration.simplesamlphp.asserting-party.single-sign-on.sign-request", 				"false"); 		assertThat(this.properties.getRegistration().get("simplesamlphp").getAssertingParty().getSinglesignon() 				.getSignRequest()).isEqualTo(false); 	}
@Test 	void customizeAssertingPartyMetadataUri() { 		bind("spring.security.saml2.relyingparty.registration.simplesamlphp.asserting-party.metadata-uri", 				"https://idp.example.org/metadata"); 		assertThat(this.properties.getRegistration().get("simplesamlphp").getAssertingParty().getMetadataUri()) 				.isEqualTo("https://idp.example.org/metadata"); 	}
@Test 	void backOffIfSaml2RelyingPartyAutoConfigurationPresent() { 		this.contextRunner.withConfiguration(AutoConfigurations.of(Saml2RelyingPartyAutoConfiguration.class)) 				.withPropertyValues( 						"spring.security.saml2.relyingparty.registration.simplesamlphp.identity-provider.single-sign-on.url=https://simplesaml-for-spring-saml/SSOService.php", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.identity-provider.single-sign-on.sign-request=false", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.identityprovider.entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.identityprovider.verification.credentials[0].certificate-location=classpath:saml/certificate-location") 				.run((context) -> assertThat(context).doesNotHaveBean(ManagementWebSecurityAutoConfiguration.class) 						.doesNotHaveBean(MANAGEMENT_SECURITY_FILTER_CHAIN_BEAN)); 	}
public List<Credential> getCredentials() { 				return this.credentials; 			}
public void setCredentials(List<Credential> credentials) { 				this.credentials = credentials; 			}
public Resource getPrivateKeyLocation() { 					return this.privateKeyLocation; 				}
public void setPrivateKeyLocation(Resource privateKey) { 					this.privateKeyLocation = privateKey; 				}
public Resource getCertificateLocation() { 					return this.certificateLocation; 				}
public Resource getCertificateLocation() { 					return this.certificateLocation; 				}
public void setCertificateLocation(Resource certificate) { 					this.certificateLocation = certificate; 				}
public void setCertificateLocation(Resource certificate) { 					this.certificateLocation = certificate; 				}
public List<Credential> getCredentials() { 			return this.credentials; 		}
public List<Credential> getCredentials() { 			return this.credentials; 		}
public void setCredentials(List<Credential> credentials) { 			this.credentials = credentials; 		}
public void setCredentials(List<Credential> credentials) { 			this.credentials = credentials; 		}
public Resource getPrivateKeyLocation() { 				return this.privateKeyLocation; 			}
public void setPrivateKeyLocation(Resource privateKey) { 				this.privateKeyLocation = privateKey; 			}
public Resource getCertificateLocation() { 				return this.certificateLocation; 			}
public Resource getCertificateLocation() { 				return this.certificateLocation; 			}
public void setCertificateLocation(Resource certificate) { 				this.certificateLocation = certificate; 			}
public void setCertificateLocation(Resource certificate) { 				this.certificateLocation = certificate; 			}
public List<Credential> getCredentials() { 				return this.credentials; 			}
public void setCredentials(List<Credential> credentials) { 				this.credentials = credentials; 			}
public Resource getCertificateLocation() { 					return this.certificate; 				}
public Resource getCertificateLocation() { 					return this.certificate; 				}
public void setCertificateLocation(Resource certificate) { 					this.certificate = certificate; 				}
public void setCertificateLocation(Resource certificate) { 					this.certificate = certificate; 				}
private RelyingPartyRegistration asRegistration(String id, Registration properties) { 		boolean usingMetadata = StringUtils.hasText(properties.getIdentityprovider().getMetadataUri()); 		Builder builder = (usingMetadata) ? RelyingPartyRegistrations 				.fromMetadataLocation(properties.getIdentityprovider().getMetadataUri()).registrationId(id) 				: RelyingPartyRegistration.withRegistrationId(id); 		builder.assertionConsumerServiceLocation(properties.getAcs().getLocation()); 		builder.assertionConsumerServiceBinding(properties.getAcs().getBinding()); 		builder.assertingPartyDetails(mapIdentityProvider(properties, usingMetadata)); 		builder.signingX509Credentials((credentials) -> properties.getSigning().getCredentials().stream() 				.map(this::asSigningCredential).forEach(credentials::add)); 		builder.decryptionX509Credentials((credentials) -> properties.getDecryption().getCredentials().stream() 				.map(this::asDecryptionCredential).forEach(credentials::add)); 		builder.assertingPartyDetails((details) -> details 				.verificationX509Credentials((credentials) -> properties.getIdentityprovider().getVerification() 						.getCredentials().stream().map(this::asVerificationCredential).forEach(credentials::add))); 		builder.entityId(properties.getEntityId()); 		RelyingPartyRegistration registration = builder.build(); 		boolean signRequest = registration.getAssertingPartyDetails().getWantAuthnRequestsSigned(); 		validateSigningCredentials(properties, signRequest); 		return registration; 	}
@Test 	void autoConfigurationShouldBeConditionalOnRelyingPartyRegistrationRepositoryClass() { 		this.contextRunner.withPropertyValues(getPropertyValues()).withClassLoader(new FilteredClassLoader( 				"org.springframework.security.saml2.provider.service.registration.RelyingPartyRegistrationRepository")) 				.run((context) -> assertThat(context).doesNotHaveBean(RelyingPartyRegistrationRepository.class)); 	}
@Test 	void autoConfigurationShouldBeConditionalOnServletWebApplication() { 		new ApplicationContextRunner() 				.withConfiguration(AutoConfigurations.of(Saml2RelyingPartyAutoConfiguration.class)) 				.withPropertyValues(getPropertyValues()) 				.run((context) -> assertThat(context).doesNotHaveBean(RelyingPartyRegistrationRepository.class)); 	}
@Test 	void relyingPartyRegistrationRepositoryBeanShouldBeCreatedWhenPropertiesPresent() { 		this.contextRunner.withPropertyValues(getPropertyValues()).run((context) -> { 			RelyingPartyRegistrationRepository repository = context.getBean(RelyingPartyRegistrationRepository.class); 			RelyingPartyRegistration registration = repository.findByRegistrationId("foo");  			assertThat(registration.getAssertingPartyDetails().getSingleSignOnServiceLocation()) 					.isEqualTo("https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php"); 			assertThat(registration.getAssertingPartyDetails().getEntityId()) 					.isEqualTo("https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php"); 			assertThat(registration.getAssertionConsumerServiceLocation()) 					.isEqualTo("{baseUrl}/login/saml2/foo-entity-id"); 			assertThat(registration.getAssertionConsumerServiceBinding()).isEqualTo(Saml2MessageBinding.REDIRECT); 			assertThat(registration.getAssertingPartyDetails().getSingleSignOnServiceBinding()) 					.isEqualTo(Saml2MessageBinding.POST); 			assertThat(registration.getAssertingPartyDetails().getWantAuthnRequestsSigned()).isEqualTo(false); 			assertThat(registration.getSigningX509Credentials()).hasSize(1); 			assertThat(registration.getDecryptionX509Credentials()).hasSize(1); 			assertThat(registration.getAssertingPartyDetails().getVerificationX509Credentials()).isNotNull(); 			assertThat(registration.getEntityId()).isEqualTo("{baseUrl}/saml2/foo-entity-id"); 		}); 	}
@Test 	void autoConfigurationWhenSignRequestsTrueAndNoSigningCredentialsShouldThrowException() { 		this.contextRunner.withPropertyValues(getPropertyValuesWithoutSigningCredentials(true)).run((context) -> { 			assertThat(context).hasFailed(); 			assertThat(context.getStartupFailure()).hasMessageContaining( 					"Signing credentials must not be empty when authentication requests require signing."); 		}); 	}
@Test 	void autoConfigurationWhenSignRequestsFalseAndNoSigningCredentialsShouldNotThrowException() { 		this.contextRunner.withPropertyValues(getPropertyValuesWithoutSigningCredentials(false)) 				.run((context) -> assertThat(context).hasSingleBean(RelyingPartyRegistrationRepository.class)); 	}
@Test 	void autoconfigurationShouldUseBindingFromMetadataUrlIfPresent() throws Exception { 		try (MockWebServer server = new MockWebServer()) { 			server.start(); 			String metadataUrl = server.url("").toString(); 			setupMockResponse(server, new ClassPathResource("saml/idp-metadata")); 			this.contextRunner.withPropertyValues(PREFIX + ".foo.identityprovider.metadata-uri=" + metadataUrl) 					.run((context) -> { 						RelyingPartyRegistrationRepository repository = context 								.getBean(RelyingPartyRegistrationRepository.class); 						RelyingPartyRegistration registration = repository.findByRegistrationId("foo"); 						assertThat(registration.getAssertingPartyDetails().getSingleSignOnServiceBinding()) 								.isEqualTo(Saml2MessageBinding.POST); 					}); 		} 	}
@Test 	void autoconfigurationWhenMetadataUrlAndPropertyPresentShouldUseBindingFromProperty() throws Exception { 		try (MockWebServer server = new MockWebServer()) { 			server.start(); 			String metadataUrl = server.url("").toString(); 			setupMockResponse(server, new ClassPathResource("saml/idp-metadata")); 			this.contextRunner.withPropertyValues(PREFIX + ".foo.identityprovider.metadata-uri=" + metadataUrl, 					PREFIX + ".foo.identityprovider.singlesignon.binding=redirect").run((context) -> { 						RelyingPartyRegistrationRepository repository = context 								.getBean(RelyingPartyRegistrationRepository.class); 						RelyingPartyRegistration registration = repository.findByRegistrationId("foo"); 						assertThat(registration.getAssertingPartyDetails().getSingleSignOnServiceBinding()) 								.isEqualTo(Saml2MessageBinding.REDIRECT); 					}); 		} 	}
@Test 	void autoconfigurationWhenNoMetadataUrlOrPropertyPresentShouldUseRedirectBinding() { 		this.contextRunner.withPropertyValues(getPropertyValuesWithoutSsoBinding()).run((context) -> { 			RelyingPartyRegistrationRepository repository = context.getBean(RelyingPartyRegistrationRepository.class); 			RelyingPartyRegistration registration = repository.findByRegistrationId("foo"); 			assertThat(registration.getAssertingPartyDetails().getSingleSignOnServiceBinding()) 					.isEqualTo(Saml2MessageBinding.REDIRECT); 		}); 	}
@Test 	void relyingPartyRegistrationRepositoryShouldBeConditionalOnMissingBean() { 		this.contextRunner.withPropertyValues(getPropertyValues()) 				.withUserConfiguration(RegistrationRepositoryConfiguration.class).run((context) -> { 					assertThat(context).hasSingleBean(RelyingPartyRegistrationRepository.class); 					assertThat(context).hasBean("testRegistrationRepository"); 				}); 	}
@Test 	void samlLoginShouldBeConfigured() { 		this.contextRunner.withPropertyValues(getPropertyValues()) 				.run((context) -> assertThat(hasFilter(context, Saml2WebSsoAuthenticationFilter.class)).isTrue()); 	}
@Test 	void samlLoginShouldBackOffWhenAWebSecurityConfigurerAdapterIsDefined() { 		this.contextRunner.withUserConfiguration(WebSecurityConfigurerAdapterConfiguration.class) 				.withPropertyValues(getPropertyValues()) 				.run((context) -> assertThat(hasFilter(context, Saml2WebSsoAuthenticationFilter.class)).isFalse()); 	}
@Test 	void samlLoginShouldBackOffWhenASecurityFilterChainBeanIsPresent() { 		this.contextRunner.withUserConfiguration(TestSecurityFilterChainConfig.class) 				.withPropertyValues(getPropertyValues()) 				.run((context) -> assertThat(hasFilter(context, Saml2WebSsoAuthenticationFilter.class)).isFalse()); 	}
@Test 	void samlLoginShouldShouldBeConditionalOnSecurityWebFilterClass() { 		this.contextRunner.withClassLoader(new FilteredClassLoader(SecurityFilterChain.class)) 				.withPropertyValues(getPropertyValues()) 				.run((context) -> assertThat(context).doesNotHaveBean(SecurityFilterChain.class)); 	}
@Test 	void customizeSsoUrl() { 		bind("spring.security.saml2.relyingparty.registration.simplesamlphp.identity-provider.single-sign-on.url", 				"https://simplesaml-for-spring-saml/SSOService.php"); 		assertThat( 				this.properties.getRegistration().get("simplesamlphp").getIdentityprovider().getSinglesignon().getUrl()) 						.isEqualTo("https://simplesaml-for-spring-saml/SSOService.php"); 	}
@Test 	void customizeSsoBinding() { 		bind("spring.security.saml2.relyingparty.registration.simplesamlphp.identity-provider.single-sign-on.binding", 				"post"); 		assertThat(this.properties.getRegistration().get("simplesamlphp").getIdentityprovider().getSinglesignon() 				.getBinding()).isEqualTo(Saml2MessageBinding.POST); 	}
@Test 	void customizeSsoSignRequests() { 		bind("spring.security.saml2.relyingparty.registration.simplesamlphp.identity-provider.single-sign-on.sign-request", 				"false"); 		assertThat(this.properties.getRegistration().get("simplesamlphp").getIdentityprovider().getSinglesignon() 				.isSignRequest()).isEqualTo(false); 	}
private boolean isAllowed(HttpServletRequest request, Integer errorCode) { 		Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); 		if (isUnauthenticated(authentication) && isNotAuthenticationError(errorCode)) { 			return true; 		} 		return getPrivilegeEvaluator().isAllowed(request.getRequestURI(), authentication); 	}
@Test 	void testNoCredentials() { 		final ResponseEntity<JsonNode> response = this.testRestTemplate.exchange("/test", HttpMethod.GET, null, 				JsonNode.class); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED); 		JsonNode jsonResponse = response.getBody(); 		assertThat(jsonResponse).isNull(); 	}
@Test 	void testPublicNotFoundPage() { 		final ResponseEntity<JsonNode> response = this.testRestTemplate.exchange("/public/notfound", HttpMethod.GET, 				null, JsonNode.class); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND); 		JsonNode jsonResponse = response.getBody(); 		assertThat(jsonResponse.get("error").asText()).isEqualTo("Not Found"); 	}
@Test 	void testPublicNotFoundPageWithCorrectCredentials() { 		final ResponseEntity<JsonNode> response = this.testRestTemplate.withBasicAuth("username", "password") 				.exchange("/public/notfound", HttpMethod.GET, null, JsonNode.class); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND); 		JsonNode jsonResponse = response.getBody(); 		assertThat(jsonResponse.get("error").asText()).isEqualTo("Not Found"); 	}
@Test 	void testPublicNotFoundPageWithBadCredentials() { 		final ResponseEntity<JsonNode> response = this.testRestTemplate.withBasicAuth("username", "wrong") 				.exchange("/public/notfound", HttpMethod.GET, null, JsonNode.class); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED); 		JsonNode jsonResponse = response.getBody(); 		assertThat(jsonResponse).isNull(); 	}
@Test 	void testCorrectCredentialsWithControllerException() { 		final ResponseEntity<JsonNode> response = this.testRestTemplate.withBasicAuth("username", "password") 				.exchange("/fail", HttpMethod.GET, null, JsonNode.class); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 		JsonNode jsonResponse = response.getBody(); 		assertThat(jsonResponse.get("error").asText()).isEqualTo("Internal Server Error"); 	}
@Test 	void testCorrectCredentials() { 		final ResponseEntity<String> response = this.testRestTemplate.withBasicAuth("username", "password") 				.exchange("/test", HttpMethod.GET, null, String.class); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK); 		response.getBody(); 		assertThat(response.getBody()).isEqualTo("test"); 	}
@Override 	public void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) 			throws IOException, ServletException { 		Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); 		if (!getPrivilegeEvaluator().isAllowed(request.getRequestURI(), authentication)) { 			sendError(request, response); 			return; 		} 		chain.doFilter(request, response); 	}
@BeforeEach 	void setup() { 		given(this.context.getBean(WebInvocationPrivilegeEvaluator.class)).willReturn(this.privilegeEvaluator); 		this.securityFilter = new ErrorPageSecurityFilter(this.context); 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		http.authorizeRequests((requests) -> { 			requests.requestMatchers(EndpointRequest.to(HealthEndpoint.class, InfoEndpoint.class)).permitAll(); 			requests.anyRequest().authenticated(); 		}); 		http.formLogin(Customizer.withDefaults()); 		http.httpBasic(Customizer.withDefaults()); 	}
protected void testJerseyEndpoints(Class<?>[] userConfigurations) { 		FilteredClassLoader classLoader = new FilteredClassLoader(DispatcherServlet.class); 		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new) 				.withClassLoader(classLoader) 				.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class, JerseyAutoConfiguration.class, 						EndpointAutoConfiguration.class, ServletWebServerFactoryAutoConfiguration.class, 						WebEndpointAutoConfiguration.class, ManagementContextAutoConfiguration.class, 						BeansEndpointAutoConfiguration.class)) 				.withUserConfiguration(userConfigurations) 				.withPropertyValues("management.endpoints.web.exposure.include:*", "server.port:0").run((context) -> { 					int port = context 							.getSourceApplicationContext(AnnotationConfigServletWebServerApplicationContext.class) 							.getWebServer().getPort(); 					WebTestClient client = WebTestClient.bindToServer().baseUrl("http://localhost:" + port).build(); 					client.get().uri("/actuator").exchange().expectStatus().isOk().expectBody().jsonPath("_links.beans") 							.isNotEmpty().jsonPath("_links.restcontroller").doesNotExist().jsonPath("_links.controller") 							.doesNotExist(); 				}); 	}
@Test 	void backsOffIfSecurityFilterChainBeanIsPresent() { 		this.contextRunner.withUserConfiguration(TestSecurityFilterChainConfig.class).run((context) -> { 			assertThat(context.getBeansOfType(SecurityFilterChain.class).size()).isEqualTo(1); 			assertThat(context.containsBean("testSecurityFilterChain")).isTrue(); 		}); 	}
private void configureTestConventions(Project project) { 		project.getTasks().withType(Test.class, (test) -> { 			withOptionalBuildJavaHome(project, (javaHome) -> test.setExecutable(javaHome + "/bin/java")); 			test.useJUnitPlatform(); 			test.setMaxHeapSize("1024M"); 			if (buildingWithJava8(project)) { 				test.systemProperty("java.security.properties", 						getClass().getClassLoader().getResource("jdk-8156584-security.properties")); 			} 		}); 		project.getPlugins().withType(JavaPlugin.class, (javaPlugin) -> project.getDependencies() 				.add(JavaPlugin.TEST_RUNTIME_ONLY_CONFIGURATION_NAME, "org.junit.platform:junit-platform-launcher")); 		project.getPlugins().apply(TestRetryPlugin.class); 		project.getTasks().withType(Test.class, 				(test) -> project.getPlugins().withType(TestRetryPlugin.class, (testRetryPlugin) -> { 					TestRetryTaskExtension testRetry = test.getExtensions().getByType(TestRetryTaskExtension.class); 					testRetry.getFailOnPassedAfterRetry().set(true); 					testRetry.getMaxRetries().set(isCi() ? 3 : 0); 				})); 	}
private void configureTestConventions(Project project) { 		project.getTasks().withType(Test.class, (test) -> { 			withOptionalBuildJavaHome(project, (javaHome) -> test.setExecutable(javaHome + "/bin/java")); 			test.useJUnitPlatform(); 			test.setMaxHeapSize("1024M"); 		}); 		project.getPlugins().withType(JavaPlugin.class, (javaPlugin) -> project.getDependencies() 				.add(JavaPlugin.TEST_RUNTIME_ONLY_CONFIGURATION_NAME, "org.junit.platform:junit-platform-launcher")); 		project.getPlugins().apply(TestRetryPlugin.class); 		project.getTasks().withType(Test.class, 				(test) -> project.getPlugins().withType(TestRetryPlugin.class, (testRetryPlugin) -> { 					TestRetryTaskExtension testRetry = test.getExtensions().getByType(TestRetryTaskExtension.class); 					testRetry.getFailOnPassedAfterRetry().set(true); 					testRetry.getMaxRetries().set(isCi() ? 3 : 0); 				})); 	}
@Test 	void securityConfigurationShouldAllowAccess() throws Exception { 		this.context = getContext(() -> loadContext("spring.devtools.remote.secret:supersecret")); 		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); 		MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context).apply(springSecurity()).addFilter(filter) 				.build(); 		mockMvc.perform(MockMvcRequestBuilders.get(DEFAULT_CONTEXT_PATH + "/restart").header(DEFAULT_SECRET_HEADER_NAME, 				"supersecret")).andExpect(status().isOk()); 		assertRestartInvoked(true); 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		http.authorizeRequests((requests) -> { 			requests.requestMatchers(EndpointRequest.to(HealthEndpoint.class, InfoEndpoint.class)).permitAll(); 			requests.anyRequest().authenticated(); 		}); 		http.formLogin(Customizer.withDefaults()); 		http.httpBasic(Customizer.withDefaults()); 	}
@Test 	void backOffIfOAuth2ResourceServerAutoConfigurationPresent() { 		this.contextRunner.withConfiguration(AutoConfigurations.of(OAuth2ResourceServerAutoConfiguration.class)) 				.withPropertyValues("spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://authserver") 				.run((context) -> assertThat(context).doesNotHaveBean(ManagementWebSecurityConfigurerAdapter.class)); 	}
@Test 	void backOffIfSaml2RelyingPartyAutoConfigurationPresent() { 		this.contextRunner.withConfiguration(AutoConfigurations.of(Saml2RelyingPartyAutoConfiguration.class)) 				.withPropertyValues( 						"spring.security.saml2.relyingparty.registration.simplesamlphp.identity-provider.single-sign-on.url=https://simplesaml-for-spring-saml/SSOService.php", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.identity-provider.single-sign-on.sign-request=false", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.identityprovider.entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php", 						"spring.security.saml2.relyingparty.registration.simplesamlphp.identityprovider.verification.credentials[0].certificate-location=classpath:saml/certificate-location") 				.run((context) -> assertThat(context).doesNotHaveBean(ManagementWebSecurityConfigurerAdapter.class)); 	}
@Bean 		JwtDecoder decoder() { 			return mock(JwtDecoder.class); 		}
@Bean 		OpaqueTokenIntrospector decoder() { 			return mock(OpaqueTokenIntrospector.class); 		}
@Test 	void matchWhenHasNoControllers() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithNoControllers.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); 		assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); 		assertThat(excludes(filter, ExampleModule.class)).isFalse(); 	}
@Test 	void matchWhenHasController() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithController.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); 		assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); 		assertThat(excludes(filter, ExampleModule.class)).isFalse(); 	}
@Test 	void matchNotUsingDefaultFilters() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(NotUsingDefaultFilters.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isTrue(); 		assertThat(excludes(filter, ExampleWeb.class)).isTrue(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isTrue(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isTrue(); 		assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isTrue(); 		assertThat(excludes(filter, ExampleModule.class)).isTrue(); 	}
@Test 	void matchWithExcludeFilter() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithExcludeFilter.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); 		assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); 		assertThat(excludes(filter, ExampleModule.class)).isFalse(); 	}
public List<String> getBootstrapServers() { 		return this.bootstrapServers; 	}
public List<String> getBootstrapServers() { 		return this.bootstrapServers; 	}
public List<String> getBootstrapServers() { 		return this.bootstrapServers; 	}
public void setBootstrapServers(List<String> bootstrapServers) { 		this.bootstrapServers = bootstrapServers; 	}
public void setBootstrapServers(List<String> bootstrapServers) { 		this.bootstrapServers = bootstrapServers; 	}
public void setBootstrapServers(List<String> bootstrapServers) { 		this.bootstrapServers = bootstrapServers; 	}
public String getClientId() { 		return this.clientId; 	}
public String getClientId() { 		return this.clientId; 	}
public String getClientId() { 		return this.clientId; 	}
public String getClientId() { 		return this.clientId; 	}
public String getClientId() { 		return this.clientId; 	}
public void setClientId(String clientId) { 		this.clientId = clientId; 	}
public void setClientId(String clientId) { 		this.clientId = clientId; 	}
public void setClientId(String clientId) { 		this.clientId = clientId; 	}
public void setClientId(String clientId) { 		this.clientId = clientId; 	}
public void setClientId(String clientId) { 		this.clientId = clientId; 	}
public Map<String, String> getProperties() { 		return this.properties; 	}
public Map<String, String> getProperties() { 		return this.properties; 	}
public Map<String, String> getProperties() { 		return this.properties; 	}
public Map<String, String> getProperties() { 		return this.properties; 	}
public Ssl getSsl() { 		return this.ssl; 	}
public Ssl getSsl() { 		return this.ssl; 	}
public Ssl getSsl() { 		return this.ssl; 	}
public Ssl getSsl() { 		return this.ssl; 	}
private Map<String, Object> buildCommonProperties() { 		Map<String, Object> properties = new HashMap<>(); 		if (this.bootstrapServers != null) { 			properties.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, this.bootstrapServers); 		} 		if (this.clientId != null) { 			properties.put(CommonClientConfigs.CLIENT_ID_CONFIG, this.clientId); 		} 		properties.putAll(this.ssl.buildProperties()); 		if (!CollectionUtils.isEmpty(this.properties)) { 			properties.putAll(this.properties); 		} 		return properties; 	}
public Ssl getSsl() { 			return this.ssl; 		}
public List<String> getBootstrapServers() { 			return this.bootstrapServers; 		}
public void setBootstrapServers(List<String> bootstrapServers) { 			this.bootstrapServers = bootstrapServers; 		}
public String getClientId() { 			return this.clientId; 		}
public void setClientId(String clientId) { 			this.clientId = clientId; 		}
public Map<String, String> getProperties() { 			return this.properties; 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAutoCommitInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG)); 			map.from(this::getAutoOffsetReset).to(properties.in(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getClientId).to(properties.in(ConsumerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getEnableAutoCommit).to(properties.in(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG)); 			map.from(this::getFetchMaxWait).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG)); 			map.from(this::getFetchMinSize).asInt(DataSize::toBytes) 					.to(properties.in(ConsumerConfig.FETCH_MIN_BYTES_CONFIG)); 			map.from(this::getGroupId).to(properties.in(ConsumerConfig.GROUP_ID_CONFIG)); 			map.from(this::getHeartbeatInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG)); 			map.from(() -> getIsolationLevel().name().toLowerCase(Locale.ROOT)) 					.to(properties.in(ConsumerConfig.ISOLATION_LEVEL_CONFIG)); 			map.from(this::getKeyDeserializer).to(properties.in(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getValueDeserializer).to(properties.in(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getMaxPollRecords).to(properties.in(ConsumerConfig.MAX_POLL_RECORDS_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAutoCommitInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG)); 			map.from(this::getAutoOffsetReset).to(properties.in(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getClientId).to(properties.in(ConsumerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getEnableAutoCommit).to(properties.in(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG)); 			map.from(this::getFetchMaxWait).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG)); 			map.from(this::getFetchMinSize).asInt(DataSize::toBytes) 					.to(properties.in(ConsumerConfig.FETCH_MIN_BYTES_CONFIG)); 			map.from(this::getGroupId).to(properties.in(ConsumerConfig.GROUP_ID_CONFIG)); 			map.from(this::getHeartbeatInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG)); 			map.from(() -> getIsolationLevel().name().toLowerCase(Locale.ROOT)) 					.to(properties.in(ConsumerConfig.ISOLATION_LEVEL_CONFIG)); 			map.from(this::getKeyDeserializer).to(properties.in(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getValueDeserializer).to(properties.in(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getMaxPollRecords).to(properties.in(ConsumerConfig.MAX_POLL_RECORDS_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAutoCommitInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG)); 			map.from(this::getAutoOffsetReset).to(properties.in(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getClientId).to(properties.in(ConsumerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getEnableAutoCommit).to(properties.in(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG)); 			map.from(this::getFetchMaxWait).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG)); 			map.from(this::getFetchMinSize).asInt(DataSize::toBytes) 					.to(properties.in(ConsumerConfig.FETCH_MIN_BYTES_CONFIG)); 			map.from(this::getGroupId).to(properties.in(ConsumerConfig.GROUP_ID_CONFIG)); 			map.from(this::getHeartbeatInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG)); 			map.from(() -> getIsolationLevel().name().toLowerCase(Locale.ROOT)) 					.to(properties.in(ConsumerConfig.ISOLATION_LEVEL_CONFIG)); 			map.from(this::getKeyDeserializer).to(properties.in(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getValueDeserializer).to(properties.in(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getMaxPollRecords).to(properties.in(ConsumerConfig.MAX_POLL_RECORDS_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAutoCommitInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG)); 			map.from(this::getAutoOffsetReset).to(properties.in(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getClientId).to(properties.in(ConsumerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getEnableAutoCommit).to(properties.in(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG)); 			map.from(this::getFetchMaxWait).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG)); 			map.from(this::getFetchMinSize).asInt(DataSize::toBytes) 					.to(properties.in(ConsumerConfig.FETCH_MIN_BYTES_CONFIG)); 			map.from(this::getGroupId).to(properties.in(ConsumerConfig.GROUP_ID_CONFIG)); 			map.from(this::getHeartbeatInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG)); 			map.from(() -> getIsolationLevel().name().toLowerCase(Locale.ROOT)) 					.to(properties.in(ConsumerConfig.ISOLATION_LEVEL_CONFIG)); 			map.from(this::getKeyDeserializer).to(properties.in(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getValueDeserializer).to(properties.in(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getMaxPollRecords).to(properties.in(ConsumerConfig.MAX_POLL_RECORDS_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAutoCommitInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG)); 			map.from(this::getAutoOffsetReset).to(properties.in(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getClientId).to(properties.in(ConsumerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getEnableAutoCommit).to(properties.in(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG)); 			map.from(this::getFetchMaxWait).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG)); 			map.from(this::getFetchMinSize).asInt(DataSize::toBytes) 					.to(properties.in(ConsumerConfig.FETCH_MIN_BYTES_CONFIG)); 			map.from(this::getGroupId).to(properties.in(ConsumerConfig.GROUP_ID_CONFIG)); 			map.from(this::getHeartbeatInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG)); 			map.from(() -> getIsolationLevel().name().toLowerCase(Locale.ROOT)) 					.to(properties.in(ConsumerConfig.ISOLATION_LEVEL_CONFIG)); 			map.from(this::getKeyDeserializer).to(properties.in(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getValueDeserializer).to(properties.in(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getMaxPollRecords).to(properties.in(ConsumerConfig.MAX_POLL_RECORDS_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAutoCommitInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG)); 			map.from(this::getAutoOffsetReset).to(properties.in(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getClientId).to(properties.in(ConsumerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getEnableAutoCommit).to(properties.in(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG)); 			map.from(this::getFetchMaxWait).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG)); 			map.from(this::getFetchMinSize).asInt(DataSize::toBytes) 					.to(properties.in(ConsumerConfig.FETCH_MIN_BYTES_CONFIG)); 			map.from(this::getGroupId).to(properties.in(ConsumerConfig.GROUP_ID_CONFIG)); 			map.from(this::getHeartbeatInterval).asInt(Duration::toMillis) 					.to(properties.in(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG)); 			map.from(() -> getIsolationLevel().name().toLowerCase(Locale.ROOT)) 					.to(properties.in(ConsumerConfig.ISOLATION_LEVEL_CONFIG)); 			map.from(this::getKeyDeserializer).to(properties.in(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getValueDeserializer).to(properties.in(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG)); 			map.from(this::getMaxPollRecords).to(properties.in(ConsumerConfig.MAX_POLL_RECORDS_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Ssl getSsl() { 			return this.ssl; 		}
public List<String> getBootstrapServers() { 			return this.bootstrapServers; 		}
public void setBootstrapServers(List<String> bootstrapServers) { 			this.bootstrapServers = bootstrapServers; 		}
public String getClientId() { 			return this.clientId; 		}
public void setClientId(String clientId) { 			this.clientId = clientId; 		}
public Map<String, String> getProperties() { 			return this.properties; 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAcks).to(properties.in(ProducerConfig.ACKS_CONFIG)); 			map.from(this::getBatchSize).asInt(DataSize::toBytes).to(properties.in(ProducerConfig.BATCH_SIZE_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getBufferMemory).as(DataSize::toBytes) 					.to(properties.in(ProducerConfig.BUFFER_MEMORY_CONFIG)); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getCompressionType).to(properties.in(ProducerConfig.COMPRESSION_TYPE_CONFIG)); 			map.from(this::getKeySerializer).to(properties.in(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG)); 			map.from(this::getRetries).to(properties.in(ProducerConfig.RETRIES_CONFIG)); 			map.from(this::getValueSerializer).to(properties.in(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAcks).to(properties.in(ProducerConfig.ACKS_CONFIG)); 			map.from(this::getBatchSize).asInt(DataSize::toBytes).to(properties.in(ProducerConfig.BATCH_SIZE_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getBufferMemory).as(DataSize::toBytes) 					.to(properties.in(ProducerConfig.BUFFER_MEMORY_CONFIG)); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getCompressionType).to(properties.in(ProducerConfig.COMPRESSION_TYPE_CONFIG)); 			map.from(this::getKeySerializer).to(properties.in(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG)); 			map.from(this::getRetries).to(properties.in(ProducerConfig.RETRIES_CONFIG)); 			map.from(this::getValueSerializer).to(properties.in(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAcks).to(properties.in(ProducerConfig.ACKS_CONFIG)); 			map.from(this::getBatchSize).asInt(DataSize::toBytes).to(properties.in(ProducerConfig.BATCH_SIZE_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getBufferMemory).as(DataSize::toBytes) 					.to(properties.in(ProducerConfig.BUFFER_MEMORY_CONFIG)); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getCompressionType).to(properties.in(ProducerConfig.COMPRESSION_TYPE_CONFIG)); 			map.from(this::getKeySerializer).to(properties.in(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG)); 			map.from(this::getRetries).to(properties.in(ProducerConfig.RETRIES_CONFIG)); 			map.from(this::getValueSerializer).to(properties.in(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAcks).to(properties.in(ProducerConfig.ACKS_CONFIG)); 			map.from(this::getBatchSize).asInt(DataSize::toBytes).to(properties.in(ProducerConfig.BATCH_SIZE_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getBufferMemory).as(DataSize::toBytes) 					.to(properties.in(ProducerConfig.BUFFER_MEMORY_CONFIG)); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getCompressionType).to(properties.in(ProducerConfig.COMPRESSION_TYPE_CONFIG)); 			map.from(this::getKeySerializer).to(properties.in(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG)); 			map.from(this::getRetries).to(properties.in(ProducerConfig.RETRIES_CONFIG)); 			map.from(this::getValueSerializer).to(properties.in(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAcks).to(properties.in(ProducerConfig.ACKS_CONFIG)); 			map.from(this::getBatchSize).asInt(DataSize::toBytes).to(properties.in(ProducerConfig.BATCH_SIZE_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getBufferMemory).as(DataSize::toBytes) 					.to(properties.in(ProducerConfig.BUFFER_MEMORY_CONFIG)); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getCompressionType).to(properties.in(ProducerConfig.COMPRESSION_TYPE_CONFIG)); 			map.from(this::getKeySerializer).to(properties.in(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG)); 			map.from(this::getRetries).to(properties.in(ProducerConfig.RETRIES_CONFIG)); 			map.from(this::getValueSerializer).to(properties.in(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getAcks).to(properties.in(ProducerConfig.ACKS_CONFIG)); 			map.from(this::getBatchSize).asInt(DataSize::toBytes).to(properties.in(ProducerConfig.BATCH_SIZE_CONFIG)); 			map.from(this::getBootstrapServers).to(properties.in(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getBufferMemory).as(DataSize::toBytes) 					.to(properties.in(ProducerConfig.BUFFER_MEMORY_CONFIG)); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			map.from(this::getCompressionType).to(properties.in(ProducerConfig.COMPRESSION_TYPE_CONFIG)); 			map.from(this::getKeySerializer).to(properties.in(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG)); 			map.from(this::getRetries).to(properties.in(ProducerConfig.RETRIES_CONFIG)); 			map.from(this::getValueSerializer).to(properties.in(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Ssl getSsl() { 			return this.ssl; 		}
public String getClientId() { 			return this.clientId; 		}
public void setClientId(String clientId) { 			this.clientId = clientId; 		}
public Map<String, String> getProperties() { 			return this.properties; 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG)); 			return properties.with(this.ssl, this.properties); 		}
public Ssl getSsl() { 			return this.ssl; 		}
public List<String> getBootstrapServers() { 			return this.bootstrapServers; 		}
public void setBootstrapServers(List<String> bootstrapServers) { 			this.bootstrapServers = bootstrapServers; 		}
public String getClientId() { 			return this.clientId; 		}
public void setClientId(String clientId) { 			this.clientId = clientId; 		}
public Map<String, String> getProperties() { 			return this.properties; 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getApplicationId).to(properties.in("application.id")); 			map.from(this::getBootstrapServers).to(properties.in(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getCacheMaxSizeBuffering).asInt(DataSize::toBytes) 					.to(properties.in("cache.max.bytes.buffering")); 			map.from(this::getClientId).to(properties.in(CommonClientConfigs.CLIENT_ID_CONFIG)); 			map.from(this::getReplicationFactor).to(properties.in("replication.factor")); 			map.from(this::getStateDir).to(properties.in("state.dir")); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getApplicationId).to(properties.in("application.id")); 			map.from(this::getBootstrapServers).to(properties.in(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getCacheMaxSizeBuffering).asInt(DataSize::toBytes) 					.to(properties.in("cache.max.bytes.buffering")); 			map.from(this::getClientId).to(properties.in(CommonClientConfigs.CLIENT_ID_CONFIG)); 			map.from(this::getReplicationFactor).to(properties.in("replication.factor")); 			map.from(this::getStateDir).to(properties.in("state.dir")); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getApplicationId).to(properties.in("application.id")); 			map.from(this::getBootstrapServers).to(properties.in(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getCacheMaxSizeBuffering).asInt(DataSize::toBytes) 					.to(properties.in("cache.max.bytes.buffering")); 			map.from(this::getClientId).to(properties.in(CommonClientConfigs.CLIENT_ID_CONFIG)); 			map.from(this::getReplicationFactor).to(properties.in("replication.factor")); 			map.from(this::getStateDir).to(properties.in("state.dir")); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getApplicationId).to(properties.in("application.id")); 			map.from(this::getBootstrapServers).to(properties.in(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getCacheMaxSizeBuffering).asInt(DataSize::toBytes) 					.to(properties.in("cache.max.bytes.buffering")); 			map.from(this::getClientId).to(properties.in(CommonClientConfigs.CLIENT_ID_CONFIG)); 			map.from(this::getReplicationFactor).to(properties.in("replication.factor")); 			map.from(this::getStateDir).to(properties.in("state.dir")); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getApplicationId).to(properties.in("application.id")); 			map.from(this::getBootstrapServers).to(properties.in(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getCacheMaxSizeBuffering).asInt(DataSize::toBytes) 					.to(properties.in("cache.max.bytes.buffering")); 			map.from(this::getClientId).to(properties.in(CommonClientConfigs.CLIENT_ID_CONFIG)); 			map.from(this::getReplicationFactor).to(properties.in("replication.factor")); 			map.from(this::getStateDir).to(properties.in("state.dir")); 			return properties.with(this.ssl, this.properties); 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getApplicationId).to(properties.in("application.id")); 			map.from(this::getBootstrapServers).to(properties.in(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG)); 			map.from(this::getCacheMaxSizeBuffering).asInt(DataSize::toBytes) 					.to(properties.in("cache.max.bytes.buffering")); 			map.from(this::getClientId).to(properties.in(CommonClientConfigs.CLIENT_ID_CONFIG)); 			map.from(this::getReplicationFactor).to(properties.in("replication.factor")); 			map.from(this::getStateDir).to(properties.in("state.dir")); 			return properties.with(this.ssl, this.properties); 		}
public String getClientId() { 			return this.clientId; 		}
public void setClientId(String clientId) { 			this.clientId = clientId; 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getKeyPassword).to(properties.in(SslConfigs.SSL_KEY_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)); 			map.from(this::getKeyStorePassword).to(properties.in(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreType).to(properties.in(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)); 			map.from(this::getTrustStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)); 			map.from(this::getTrustStorePassword).to(properties.in(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)); 			map.from(this::getTrustStoreType).to(properties.in(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)); 			map.from(this::getProtocol).to(properties.in(SslConfigs.SSL_PROTOCOL_CONFIG)); 			return properties; 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getKeyPassword).to(properties.in(SslConfigs.SSL_KEY_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)); 			map.from(this::getKeyStorePassword).to(properties.in(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreType).to(properties.in(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)); 			map.from(this::getTrustStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)); 			map.from(this::getTrustStorePassword).to(properties.in(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)); 			map.from(this::getTrustStoreType).to(properties.in(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)); 			map.from(this::getProtocol).to(properties.in(SslConfigs.SSL_PROTOCOL_CONFIG)); 			return properties; 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getKeyPassword).to(properties.in(SslConfigs.SSL_KEY_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)); 			map.from(this::getKeyStorePassword).to(properties.in(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreType).to(properties.in(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)); 			map.from(this::getTrustStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)); 			map.from(this::getTrustStorePassword).to(properties.in(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)); 			map.from(this::getTrustStoreType).to(properties.in(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)); 			map.from(this::getProtocol).to(properties.in(SslConfigs.SSL_PROTOCOL_CONFIG)); 			return properties; 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getKeyPassword).to(properties.in(SslConfigs.SSL_KEY_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)); 			map.from(this::getKeyStorePassword).to(properties.in(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreType).to(properties.in(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)); 			map.from(this::getTrustStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)); 			map.from(this::getTrustStorePassword).to(properties.in(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)); 			map.from(this::getTrustStoreType).to(properties.in(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)); 			map.from(this::getProtocol).to(properties.in(SslConfigs.SSL_PROTOCOL_CONFIG)); 			return properties; 		}
public Map<String, Object> buildProperties() { 			Properties properties = new Properties(); 			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 			map.from(this::getKeyPassword).to(properties.in(SslConfigs.SSL_KEY_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)); 			map.from(this::getKeyStorePassword).to(properties.in(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)); 			map.from(this::getKeyStoreType).to(properties.in(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)); 			map.from(this::getTrustStoreLocation).as(this::resourceToPath) 					.to(properties.in(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)); 			map.from(this::getTrustStorePassword).to(properties.in(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)); 			map.from(this::getTrustStoreType).to(properties.in(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)); 			map.from(this::getProtocol).to(properties.in(SslConfigs.SSL_PROTOCOL_CONFIG)); 			return properties; 		}
@Test 	void consumerProperties() { 		this.contextRunner.withPropertyValues("spring.kafka.bootstrap-servers=foo:1234", 				"spring.kafka.properties.foo=bar", "spring.kafka.properties.baz=qux", 				"spring.kafka.properties.foo.bar.baz=qux.fiz.buz", "spring.kafka.ssl.key-password=p1", 				"spring.kafka.ssl.key-store-location=classpath:ksLoc", "spring.kafka.ssl.key-store-password=p2", 				"spring.kafka.ssl.key-store-type=PKCS12", "spring.kafka.ssl.trust-store-location=classpath:tsLoc", 				"spring.kafka.ssl.trust-store-password=p3", "spring.kafka.ssl.trust-store-type=PKCS12", 				"spring.kafka.ssl.protocol=TLSv1.2", "spring.kafka.consumer.auto-commit-interval=123", 				"spring.kafka.consumer.max-poll-records=42", "spring.kafka.consumer.auto-offset-reset=earliest", 				"spring.kafka.consumer.client-id=ccid", // test override common 				"spring.kafka.consumer.enable-auto-commit=false", "spring.kafka.consumer.fetch-max-wait=456", 				"spring.kafka.consumer.properties.fiz.buz=fix.fox", "spring.kafka.consumer.fetch-min-size=1KB", 				"spring.kafka.consumer.group-id=bar", "spring.kafka.consumer.heartbeat-interval=234", 				"spring.kafka.consumer.isolation-level = read-committed", 				"spring.kafka.consumer.key-deserializer = org.apache.kafka.common.serialization.LongDeserializer", 				"spring.kafka.consumer.value-deserializer = org.apache.kafka.common.serialization.IntegerDeserializer") 				.run((context) -> { 					DefaultKafkaConsumerFactory<?, ?> consumerFactory = context 							.getBean(DefaultKafkaConsumerFactory.class); 					Map<String, Object> configs = consumerFactory.getConfigurationProperties(); 					// common 					assertThat(configs.get(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG)) 							.isEqualTo(Collections.singletonList("foo:1234")); 					assertThat(configs.get(SslConfigs.SSL_KEY_PASSWORD_CONFIG)).isEqualTo("p1"); 					assertThat((String) configs.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "ksLoc"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)).isEqualTo("p2"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat((String) configs.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "tsLoc"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)).isEqualTo("p3"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat(configs.get(SslConfigs.SSL_PROTOCOL_CONFIG)).isEqualTo("TLSv1.2"); 					// consumer 					assertThat(configs.get(ConsumerConfig.CLIENT_ID_CONFIG)).isEqualTo("ccid"); // override 					assertThat(configs.get(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG)).isEqualTo(Boolean.FALSE); 					assertThat(configs.get(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG)).isEqualTo(123); 					assertThat(configs.get(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG)).isEqualTo("earliest"); 					assertThat(configs.get(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG)).isEqualTo(456); 					assertThat(configs.get(ConsumerConfig.FETCH_MIN_BYTES_CONFIG)).isEqualTo(1024); 					assertThat(configs.get(ConsumerConfig.GROUP_ID_CONFIG)).isEqualTo("bar"); 					assertThat(configs.get(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG)).isEqualTo(234); 					assertThat(configs.get(ConsumerConfig.ISOLATION_LEVEL_CONFIG)).isEqualTo("read_committed"); 					assertThat(configs.get(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG)) 							.isEqualTo(LongDeserializer.class); 					assertThat(configs.get(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG)) 							.isEqualTo(IntegerDeserializer.class); 					assertThat(configs.get(ConsumerConfig.MAX_POLL_RECORDS_CONFIG)).isEqualTo(42); 					assertThat(configs.get("foo")).isEqualTo("bar"); 					assertThat(configs.get("baz")).isEqualTo("qux"); 					assertThat(configs.get("foo.bar.baz")).isEqualTo("qux.fiz.buz"); 					assertThat(configs.get("fiz.buz")).isEqualTo("fix.fox"); 				}); 	}
@Test 	void producerProperties() { 		this.contextRunner.withPropertyValues("spring.kafka.clientId=cid", 				"spring.kafka.properties.foo.bar.baz=qux.fiz.buz", "spring.kafka.producer.acks=all", 				"spring.kafka.producer.batch-size=2KB", "spring.kafka.producer.bootstrap-servers=bar:1234", // test 				// override 				"spring.kafka.producer.buffer-memory=4KB", "spring.kafka.producer.compression-type=gzip", 				"spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.LongSerializer", 				"spring.kafka.producer.retries=2", "spring.kafka.producer.properties.fiz.buz=fix.fox", 				"spring.kafka.producer.ssl.key-password=p4", 				"spring.kafka.producer.ssl.key-store-location=classpath:ksLocP", 				"spring.kafka.producer.ssl.key-store-password=p5", "spring.kafka.producer.ssl.key-store-type=PKCS12", 				"spring.kafka.producer.ssl.trust-store-location=classpath:tsLocP", 				"spring.kafka.producer.ssl.trust-store-password=p6", 				"spring.kafka.producer.ssl.trust-store-type=PKCS12", "spring.kafka.producer.ssl.protocol=TLSv1.2", 				"spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.IntegerSerializer") 				.run((context) -> { 					DefaultKafkaProducerFactory<?, ?> producerFactory = context 							.getBean(DefaultKafkaProducerFactory.class); 					Map<String, Object> configs = producerFactory.getConfigurationProperties(); 					// common 					assertThat(configs.get(ProducerConfig.CLIENT_ID_CONFIG)).isEqualTo("cid"); 					// producer 					assertThat(configs.get(ProducerConfig.ACKS_CONFIG)).isEqualTo("all"); 					assertThat(configs.get(ProducerConfig.BATCH_SIZE_CONFIG)).isEqualTo(2048); 					assertThat(configs.get(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG)) 							.isEqualTo(Collections.singletonList("bar:1234")); // override 					assertThat(configs.get(ProducerConfig.BUFFER_MEMORY_CONFIG)).isEqualTo(4096L); 					assertThat(configs.get(ProducerConfig.COMPRESSION_TYPE_CONFIG)).isEqualTo("gzip"); 					assertThat(configs.get(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG)).isEqualTo(LongSerializer.class); 					assertThat(configs.get(SslConfigs.SSL_KEY_PASSWORD_CONFIG)).isEqualTo("p4"); 					assertThat((String) configs.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "ksLocP"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)).isEqualTo("p5"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat((String) configs.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "tsLocP"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)).isEqualTo("p6"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat(configs.get(SslConfigs.SSL_PROTOCOL_CONFIG)).isEqualTo("TLSv1.2"); 					assertThat(configs.get(ProducerConfig.RETRIES_CONFIG)).isEqualTo(2); 					assertThat(configs.get(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG)) 							.isEqualTo(IntegerSerializer.class); 					assertThat(context.getBeansOfType(KafkaJaasLoginModuleInitializer.class)).isEmpty(); 					assertThat(context.getBeansOfType(KafkaTransactionManager.class)).isEmpty(); 					assertThat(configs.get("foo.bar.baz")).isEqualTo("qux.fiz.buz"); 					assertThat(configs.get("fiz.buz")).isEqualTo("fix.fox"); 				}); 	}
@Test 	void adminProperties() { 		this.contextRunner 				.withPropertyValues("spring.kafka.clientId=cid", "spring.kafka.properties.foo.bar.baz=qux.fiz.buz", 						"spring.kafka.admin.fail-fast=true", "spring.kafka.admin.properties.fiz.buz=fix.fox", 						"spring.kafka.admin.ssl.key-password=p4", 						"spring.kafka.admin.ssl.key-store-location=classpath:ksLocP", 						"spring.kafka.admin.ssl.key-store-password=p5", "spring.kafka.admin.ssl.key-store-type=PKCS12", 						"spring.kafka.admin.ssl.trust-store-location=classpath:tsLocP", 						"spring.kafka.admin.ssl.trust-store-password=p6", 						"spring.kafka.admin.ssl.trust-store-type=PKCS12", "spring.kafka.admin.ssl.protocol=TLSv1.2") 				.run((context) -> { 					KafkaAdmin admin = context.getBean(KafkaAdmin.class); 					Map<String, Object> configs = admin.getConfig(); 					// common 					assertThat(configs.get(AdminClientConfig.CLIENT_ID_CONFIG)).isEqualTo("cid"); 					// admin 					assertThat(configs.get(SslConfigs.SSL_KEY_PASSWORD_CONFIG)).isEqualTo("p4"); 					assertThat((String) configs.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "ksLocP"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)).isEqualTo("p5"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat((String) configs.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "tsLocP"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)).isEqualTo("p6"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat(configs.get(SslConfigs.SSL_PROTOCOL_CONFIG)).isEqualTo("TLSv1.2"); 					assertThat(context.getBeansOfType(KafkaJaasLoginModuleInitializer.class)).isEmpty(); 					assertThat(configs.get("foo.bar.baz")).isEqualTo("qux.fiz.buz"); 					assertThat(configs.get("fiz.buz")).isEqualTo("fix.fox"); 					assertThat(admin).hasFieldOrPropertyWithValue("fatalIfBrokerNotAvailable", true); 				}); 	}
@SuppressWarnings("unchecked") 	@Test 	void streamsProperties() { 		this.contextRunner.withUserConfiguration(EnableKafkaStreamsConfiguration.class).withPropertyValues( 				"spring.kafka.client-id=cid", "spring.kafka.bootstrap-servers=localhost:9092,localhost:9093", 				"spring.application.name=appName", "spring.kafka.properties.foo.bar.baz=qux.fiz.buz", 				"spring.kafka.streams.auto-startup=false", "spring.kafka.streams.cache-max-size-buffering=1KB", 				"spring.kafka.streams.client-id=override", "spring.kafka.streams.properties.fiz.buz=fix.fox", 				"spring.kafka.streams.replication-factor=2", "spring.kafka.streams.state-dir=/tmp/state", 				"spring.kafka.streams.ssl.key-password=p7", 				"spring.kafka.streams.ssl.key-store-location=classpath:ksLocP", 				"spring.kafka.streams.ssl.key-store-password=p8", "spring.kafka.streams.ssl.key-store-type=PKCS12", 				"spring.kafka.streams.ssl.trust-store-location=classpath:tsLocP", 				"spring.kafka.streams.ssl.trust-store-password=p9", "spring.kafka.streams.ssl.trust-store-type=PKCS12", 				"spring.kafka.streams.ssl.protocol=TLSv1.2").run((context) -> { 					Properties configs = context 							.getBean(KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_CONFIG_BEAN_NAME, 									KafkaStreamsConfiguration.class) 							.asProperties(); 					assertThat((List<String>) configs.get(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG)) 							.containsExactly("localhost:9092", "localhost:9093"); 					assertThat(configs.get(StreamsConfig.CACHE_MAX_BYTES_BUFFERING_CONFIG)).isEqualTo(1024); 					assertThat(configs.get(StreamsConfig.CLIENT_ID_CONFIG)).isEqualTo("override"); 					assertThat(configs.get(StreamsConfig.REPLICATION_FACTOR_CONFIG)).isEqualTo(2); 					assertThat(configs.get(StreamsConfig.STATE_DIR_CONFIG)).isEqualTo("/tmp/state"); 					assertThat(configs.get(SslConfigs.SSL_KEY_PASSWORD_CONFIG)).isEqualTo("p7"); 					assertThat((String) configs.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "ksLocP"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG)).isEqualTo("p8"); 					assertThat(configs.get(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat((String) configs.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG)) 							.endsWith(File.separator + "tsLocP"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)).isEqualTo("p9"); 					assertThat(configs.get(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG)).isEqualTo("PKCS12"); 					assertThat(configs.get(SslConfigs.SSL_PROTOCOL_CONFIG)).isEqualTo("TLSv1.2"); 					assertThat(context.getBeansOfType(KafkaJaasLoginModuleInitializer.class)).isEmpty(); 					assertThat(configs.get("foo.bar.baz")).isEqualTo("qux.fiz.buz"); 					assertThat(configs.get("fiz.buz")).isEqualTo("fix.fox"); 					assertThat(context.getBean(KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_BUILDER_BEAN_NAME)) 							.isNotNull(); 				}); 	}
@Test 	void securityConfigurationShouldAllowAccess() throws Exception { 		this.context = getContext(() -> loadContext("spring.devtools.remote.secret:supersecret")); 		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); 		Filter securityFilterChain = this.context.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN, Filter.class); 		MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context).addFilter(securityFilterChain) 				.addFilter(filter).build(); 		mockMvc.perform(MockMvcRequestBuilders.get(DEFAULT_CONTEXT_PATH + "/restart").header(DEFAULT_SECRET_HEADER_NAME, 				"supersecret")).andExpect(status().isOk()); 		assertRestartInvoked(true); 	}
@Test 	void securityConfigurationShouldAllowAccessToCustomPath() throws Exception { 		this.context = getContext(() -> loadContext("spring.devtools.remote.secret:supersecret", 				"server.servlet.context-path:/test", "spring.devtools.remote.context-path:/custom")); 		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); 		Filter securityFilterChain = this.context.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN, Filter.class); 		MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context).addFilter(securityFilterChain) 				.addFilter(filter).build(); 		mockMvc.perform( 				MockMvcRequestBuilders.get("/test/custom/restart").header(DEFAULT_SECRET_HEADER_NAME, "supersecret")) 				.andExpect(status().isOk()); 		assertRestartInvoked(true); 	}
@Bean 	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 		http.authorizeExchange((exchanges) -> { 			exchanges.matchers(HEALTH_OR_INFO_ENDPOINT).permitAll(); 			exchanges.anyExchange().authenticated(); 		}); 		http.httpBasic(Customizer.withDefaults()); 		http.formLogin(Customizer.withDefaults()); 		return http.build(); 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		http.authorizeRequests((requests) -> { 			requests.requestMatchers(HEALTH_OR_INFO_ENDPOINT).permitAll(); 			requests.anyRequest().authenticated(); 		}); 		http.formLogin(Customizer.withDefaults()); 		http.httpBasic(Customizer.withDefaults()); 	}
@Bean 	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 		// @formatter:off 		http.authorizeExchange((exchanges) -> 				exchanges 					.matchers(EndpointRequest.to(HealthEndpoint.class, InfoEndpoint.class)).permitAll() 					.anyExchange().authenticated()) 			.httpBasic(Customizer.withDefaults()) 			.formLogin(Customizer.withDefaults()); 		// @formatter:on 		return http.build(); 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		// @formatter:off 		http.authorizeRequests((requests) -> 				requests 					.requestMatchers(EndpointRequest.to(HealthEndpoint.class, InfoEndpoint.class)).permitAll() 					.anyRequest().authenticated()) 			.formLogin(Customizer.withDefaults()) 			.httpBasic(Customizer.withDefaults()); 		// @formatter:on 	}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			return http 					.authorizeExchange( 							(exchanges) -> exchanges.pathMatchers("/foo").permitAll().anyExchange().authenticated()) 					.formLogin(Customizer.withDefaults()).build(); 		}
private List<SecurityWebFilterChain> getFilterChains(ServerHttpSecurity http) throws Exception { 			return Collections 					.singletonList(http.authorizeExchange((exchanges) -> exchanges.anyExchange().authenticated()) 							.formLogin(Customizer.withDefaults()).build()); 		}
@ReadOperation 		Object getAll() { 			return "endpoint 1"; 		}
@ReadOperation 		Object getAll() { 			return "endpoint 1"; 		}
@ReadOperation 		Object getAll() { 			return "endpoint 2"; 		}
@ReadOperation 		Object getAll() { 			return "endpoint 2"; 		}
@ReadOperation 		Object getAll() { 			return null; 		}
@ReadOperation 		Object getAll() { 			return null; 		}
@Bean 		WebSecurityConfigurerAdapter webSecurityConfigurerAdapter() { 			return new WebSecurityConfigurerAdapter() { 				@Override 				protected void configure(HttpSecurity http) throws Exception { 					// @formatter:off 					http.authorizeRequests((requests) -> requests 							.requestMatchers(EndpointRequest.toLinks()).permitAll() 							.requestMatchers(EndpointRequest.to(TestEndpoint1.class)).permitAll() 							.requestMatchers(EndpointRequest.toAnyEndpoint()).authenticated().anyRequest() 							.hasRole("ADMIN")) 						.httpBasic(); 					// @formatter:on 				} 			}; 		}
@Override 				protected void configure(HttpSecurity http) throws Exception { 					// @formatter:off 					http.authorizeRequests((requests) -> requests 							.requestMatchers(EndpointRequest.toLinks()).permitAll() 							.requestMatchers(EndpointRequest.to(TestEndpoint1.class)).permitAll() 							.requestMatchers(EndpointRequest.toAnyEndpoint()).authenticated().anyRequest() 							.hasRole("ADMIN")) 						.httpBasic(); 					// @formatter:on 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests((requests) -> requests.antMatchers("/foo").permitAll().anyRequest().authenticated()) 					.formLogin(Customizer.withDefaults()).httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests((requests) -> requests.anyRequest().authenticated()) 					.oauth2Login(Customizer.withDefaults()).oauth2Client(); 		}
@Bean 		@ConditionalOnBean(ReactiveJwtDecoder.class) 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http, ReactiveJwtDecoder jwtDecoder) 				throws Exception { 			http.authorizeExchange((exchanges) -> exchanges.anyExchange().authenticated()) 					.oauth2ResourceServer((server) -> server.jwt((jwt) -> jwt.jwtDecoder(jwtDecoder))); 			return http.build(); 		}
@Bean 		@ConditionalOnBean(ReactiveOAuth2TokenIntrospectionClient.class) 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			http.authorizeExchange((exchanges) -> exchanges.anyExchange().authenticated()) 					.oauth2ResourceServer(ServerHttpSecurity.OAuth2ResourceServerSpec::opaqueToken); 			return http.build(); 		}
@Bean 		@ConditionalOnBean(JwtDecoder.class) 		WebSecurityConfigurerAdapter jwtDecoderWebSecurityConfigurerAdapter() { 			return new WebSecurityConfigurerAdapter() { 				@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests((requests) -> requests.anyRequest().authenticated()) 							.oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt); 				} 			}; 		}
@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests((requests) -> requests.anyRequest().authenticated()) 							.oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt); 				}
@Bean 		@ConditionalOnBean(OAuth2TokenIntrospectionClient.class) 		WebSecurityConfigurerAdapter opaqueTokenWebSecurityConfigurerAdapter() { 			return new WebSecurityConfigurerAdapter() { 				@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests((requests) -> requests.anyRequest().authenticated()) 							.oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken); 				} 			}; 		}
@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests((requests) -> requests.anyRequest().authenticated()) 							.oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken); 				}
@Bean 		ReactiveJwtDecoder decoder() { 			return mock(ReactiveJwtDecoder.class); 		}
@Bean 		ReactiveOAuth2TokenIntrospectionClient decoder() { 			return mock(ReactiveOAuth2TokenIntrospectionClient.class); 		}
@Bean 		SecurityWebFilterChain testSpringSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			http.authorizeExchange( 					(exchanges) -> exchanges.pathMatchers("/message/**").hasRole("ADMIN").anyExchange().authenticated()) 					.httpBasic(); 			return http.build(); 		}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			return http.authorizeExchange((exchanges) -> exchanges.anyExchange().permitAll()).build(); 		}
@SuppressWarnings("deprecation") 	@Bean 	public InMemoryUserDetailsManager inMemoryUserDetailsManager() { 		return new InMemoryUserDetailsManager( 				User.withDefaultPasswordEncoder().username("user").password("password").authorities("ROLE_USER") 						.build(), 				User.withDefaultPasswordEncoder().username("beans").password("beans").authorities("ROLE_BEANS").build(), 				User.withDefaultPasswordEncoder().username("admin").password("admin") 						.authorities("ROLE_ACTUATOR", "ROLE_USER").build()); 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		// @formatter:off 		http.authorizeRequests((requests) -> 				requests 					.mvcMatchers("/actuator/beans").hasRole("BEANS") 					.requestMatchers(EndpointRequest.to("health", "info")).permitAll() 					.requestMatchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)).hasRole("ACTUATOR") 					.requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll() 					.antMatchers("/foo").permitAll() 					.antMatchers("/**").hasRole("USER")) 			.cors(Customizer.withDefaults()) 			.httpBasic(); 		// @formatter:on 	}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeExchange((exchanges) -> 					exchanges 						.matchers(EndpointRequest.to("health", "info")).permitAll() 						.matchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)).hasRole("ACTUATOR") 						.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll() 						.pathMatchers("/login").permitAll() 						.anyExchange().authenticated()) 				.httpBasic(); 			// @formatter:on 			return http.build(); 		}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeExchange((exchanges) -> 					exchanges 						.matchers(EndpointRequest.to("health", "info")).permitAll() 						.matchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)).hasRole("ACTUATOR") 						.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll() 						.pathMatchers("/login").permitAll() 						.anyExchange().authenticated()) 				.httpBasic(Customizer.withDefaults()); 			// @formatter:off 			return http.build(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests((requests) -> 					requests 						.antMatchers("/login").permitAll() 						.anyRequest().fullyAuthenticated()) 				.formLogin((form) -> form.loginPage("/login").failureUrl("/login?error")) 				.logout((logout) -> logout.logoutRequestMatcher(new AntPathRequestMatcher("/logout"))) 				.exceptionHandling((exceptions) -> exceptions.accessDeniedPage("/access?error")); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests((requests) -> 					requests 						.antMatchers("/login").permitAll() 						.anyRequest().fullyAuthenticated()) 				.formLogin((form) -> form.loginPage("/login").failureUrl("/login?error")) 				.logout((logout) -> logout.logoutRequestMatcher(new AntPathRequestMatcher("/logout"))) 				.exceptionHandling((exceptions) -> exceptions.accessDeniedPage("/access?error")); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(EndpointRequest.toAnyEndpoint()) 					.authorizeRequests((requests) -> requests.anyRequest().authenticated()).httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(EndpointRequest.toAnyEndpoint()) 					.authorizeRequests((requests) -> requests.anyRequest().authenticated()).httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests((requests) -> 					requests 						.antMatchers("/css/**").permitAll().anyRequest().fullyAuthenticated()) 				.formLogin((form) -> form.loginPage("/login").failureUrl("/login?error").permitAll()) 				.logout(LogoutConfigurer::permitAll); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests( 					(requests) -> requests.antMatchers("/css/**").permitAll().anyRequest().fullyAuthenticated()) 					.formLogin((form) -> form.loginPage("/login").failureUrl("/login?error").permitAll()) 					.logout(LogoutConfigurer::permitAll); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests((requests) -> 					requests 						.requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll() 						.anyRequest().fullyAuthenticated()) 				.formLogin((form) -> 					form.loginPage("/login").failureUrl("/login?error").permitAll()) 				.logout(LogoutConfigurer::permitAll); 			// @formatter:on 		}
@Bean 	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { 		return http.authorizeExchange().matchers(EndpointRequest.to(HealthEndpoint.class, InfoEndpoint.class)) 				.permitAll().anyExchange().authenticated().and().httpBasic().and().formLogin().and().build(); 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		http.authorizeRequests().requestMatchers(EndpointRequest.to(HealthEndpoint.class, InfoEndpoint.class)) 				.permitAll().anyRequest().authenticated().and().formLogin().and().httpBasic(); 	}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { 			return http.authorizeExchange().pathMatchers("/foo").permitAll().anyExchange().authenticated().and() 					.formLogin().and().build(); 		}
private List<SecurityWebFilterChain> getFilterChains(ServerHttpSecurity http) { 			return Collections.singletonList( 					http.authorizeExchange().anyExchange().authenticated().and().formLogin().and().build()); 		}
@ReadOperation 		Object getAll() { 			return "endpoint 1"; 		}
@ReadOperation 		Object getAll() { 			return "endpoint 1"; 		}
@ReadOperation 		Object getAll() { 			return "endpoint 2"; 		}
@ReadOperation 		Object getAll() { 			return "endpoint 2"; 		}
@ReadOperation 		Object getAll() { 			return null; 		}
@ReadOperation 		Object getAll() { 			return null; 		}
@Bean 		WebSecurityConfigurerAdapter webSecurityConfigurerAdapter() { 			return new WebSecurityConfigurerAdapter() { 				@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests().requestMatchers(EndpointRequest.toLinks()).permitAll() 							.requestMatchers(EndpointRequest.to(TestEndpoint1.class)).permitAll() 							.requestMatchers(EndpointRequest.toAnyEndpoint()).authenticated().anyRequest() 							.hasRole("ADMIN").and().httpBasic(); 				} 			}; 		}
@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests().requestMatchers(EndpointRequest.toLinks()).permitAll() 							.requestMatchers(EndpointRequest.to(TestEndpoint1.class)).permitAll() 							.requestMatchers(EndpointRequest.toAnyEndpoint()).authenticated().anyRequest() 							.hasRole("ADMIN").and().httpBasic(); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers("/foo").permitAll().anyRequest().authenticated().and().formLogin() 					.and().httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().authenticated().and().oauth2Login().and().oauth2Client(); 		}
@Bean 		@ConditionalOnBean(ReactiveJwtDecoder.class) 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http, ReactiveJwtDecoder jwtDecoder) { 			http.authorizeExchange().anyExchange().authenticated().and().oauth2ResourceServer().jwt() 					.jwtDecoder(jwtDecoder); 			return http.build(); 		}
@Bean 		@ConditionalOnBean(ReactiveOAuth2TokenIntrospectionClient.class) 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { 			http.authorizeExchange().anyExchange().authenticated().and().oauth2ResourceServer().opaqueToken(); 			return http.build(); 		}
@Bean 		@ConditionalOnBean(JwtDecoder.class) 		WebSecurityConfigurerAdapter jwtDecoderWebSecurityConfigurerAdapter() { 			return new WebSecurityConfigurerAdapter() { 				@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests().anyRequest().authenticated().and().oauth2ResourceServer().jwt(); 				} 			}; 		}
@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests().anyRequest().authenticated().and().oauth2ResourceServer().jwt(); 				}
@Bean 		@ConditionalOnBean(OAuth2TokenIntrospectionClient.class) 		WebSecurityConfigurerAdapter opaqueTokenWebSecurityConfigurerAdapter() { 			return new WebSecurityConfigurerAdapter() { 				@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests().anyRequest().authenticated().and().oauth2ResourceServer().opaqueToken(); 				} 			}; 		}
@Override 				protected void configure(HttpSecurity http) throws Exception { 					http.authorizeRequests().anyRequest().authenticated().and().oauth2ResourceServer().opaqueToken(); 				}
@Bean 		ReactiveJwtDecoder decoder() { 			return mock(ReactiveJwtDecoder.class); 		}
@Bean 		ReactiveOAuth2TokenIntrospectionClient decoder() { 			return mock(ReactiveOAuth2TokenIntrospectionClient.class); 		}
@Bean 		SecurityWebFilterChain testSpringSecurityFilterChain(ServerHttpSecurity http) { 			http.authorizeExchange().pathMatchers("/message/**").hasRole("ADMIN").anyExchange().authenticated().and() 					.httpBasic(); 			return http.build(); 		}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { 			return http.authorizeExchange().anyExchange().permitAll().and().build(); 		}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		// @formatter:off 		http.authorizeRequests() 				.mvcMatchers("/actuator/beans").hasRole("BEANS") 				.requestMatchers(EndpointRequest.to("health", "info")).permitAll() 				.requestMatchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)).hasRole("ACTUATOR") 				.requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll() 				.antMatchers("/foo").permitAll() 				.antMatchers("/**").hasRole("USER") 				.and() 			.cors() 				.and() 			.httpBasic(); 		// @formatter:on 	}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { 			return http.authorizeExchange().matchers(EndpointRequest.to("health", "info")).permitAll() 					.matchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)).hasRole("ACTUATOR") 					.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll().pathMatchers("/login") 					.permitAll().anyExchange().authenticated().and().httpBasic().and().build(); 		}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { 			return http.authorizeExchange().matchers(EndpointRequest.to("health", "info")).permitAll() 					.matchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)).hasRole("ACTUATOR") 					.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll().pathMatchers("/login") 					.permitAll().anyExchange().authenticated().and().httpBasic().and().build(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.antMatchers("/login").permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error") 					.and() 				.logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout")) 					.and() 				.exceptionHandling().accessDeniedPage("/access?error"); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.antMatchers("/login").permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error") 					.and() 				.logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout")) 					.and() 				.exceptionHandling().accessDeniedPage("/access?error"); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests() 					.anyRequest().authenticated() 					.and() 				.httpBasic(); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests() 					.anyRequest().authenticated() 					.and() 				.httpBasic(); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers("/css/**").permitAll().anyRequest().fullyAuthenticated().and() 					.formLogin().loginPage("/login").failureUrl("/login?error").permitAll().and().logout().permitAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers("/css/**").permitAll().anyRequest().fullyAuthenticated().and() 					.formLogin().loginPage("/login").failureUrl("/login?error").permitAll().and().logout().permitAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error").permitAll() 					.and() 				.logout().permitAll(); 			// @formatter:on 		}
@Test 	public void matchWhenHasNoControllers() throws Exception { 		WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter( 				WithNoControllers.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleServerHttpSecurity.class)).isFalse(); 	}
@Test 	public void matchWhenHasController() throws Exception { 		WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter( 				WithController.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleServerHttpSecurity.class)).isFalse(); 	}
@Test 	public void matchNotUsingDefaultFilters() throws Exception { 		WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter( 				NotUsingDefaultFilters.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isTrue(); 		assertThat(excludes(filter, ExampleWeb.class)).isTrue(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleServerHttpSecurity.class)).isTrue(); 	}
@Test 	public void matchWithIncludeFilter() throws Exception { 		WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter( 				WithIncludeFilter.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isFalse(); 		assertThat(excludes(filter, ExampleServerHttpSecurity.class)).isFalse(); 	}
@Test 	public void matchWithExcludeFilter() throws Exception { 		WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter( 				WithExcludeFilter.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 		assertThat(excludes(filter, ExampleServerHttpSecurity.class)).isFalse(); 	}
@Test 	public void useSecurityDialect() { 		load(BaseConfiguration.class); 		ISpringWebFluxTemplateEngine engine = this.context 				.getBean(ISpringWebFluxTemplateEngine.class); 		MockServerWebExchange exchange = MockServerWebExchange 				.from(MockServerHttpRequest.get("/test").build()); 		exchange.getAttributes().put( 				SpringSecurityContextUtils.SECURITY_CONTEXT_MODEL_ATTRIBUTE_NAME, 				new SecurityContextImpl( 						new TestingAuthenticationToken("alice", "admin"))); 		IContext attrs = new SpringWebFluxContext(exchange); 		String result = engine.process("security-dialect", attrs); 		assertThat(result).isEqualTo("<html><body><div>alice</div></body></html>\n"); 	}
@Test 	public void useSecurityDialect() { 		load(BaseConfiguration.class); 		TemplateEngine engine = this.context.getBean(TemplateEngine.class); 		WebContext attrs = new WebContext(new MockHttpServletRequest(), 				new MockHttpServletResponse(), new MockServletContext()); 		try { 			SecurityContextHolder.setContext(new SecurityContextImpl( 					new TestingAuthenticationToken("alice", "admin"))); 			String result = engine.process("security-dialect", attrs); 			assertThat(result).isEqualTo("<html><body><div>alice</div></body></html>\n"); 		} 		finally { 			SecurityContextHolder.clearContext(); 		} 	}
@Bean 		public FilterRegistrationBean<ResourceUrlEncodingFilter> filterRegistration() { 			FilterRegistrationBean<ResourceUrlEncodingFilter> bean = new FilterRegistrationBean<ResourceUrlEncodingFilter>( 					new ResourceUrlEncodingFilter()); 			bean.setDispatcherTypes(EnumSet.of(DispatcherType.INCLUDE)); 			return bean; 		}
@Bean 		public FilterRegistrationBean<OrderedCharacterEncodingFilter> filterRegistration() { 			return new FilterRegistrationBean<OrderedCharacterEncodingFilter>( 					new OrderedCharacterEncodingFilter()); 		}
@ReadOperation 		public Object getAll() { 			return "endpoint 1"; 		}
@ReadOperation 		public Object getAll() { 			return "endpoint 1"; 		}
@ReadOperation 		public Object getAll() { 			return "endpoint 2"; 		}
@ReadOperation 		public Object getAll() { 			return "endpoint 2"; 		}
@ReadOperation 		public Object getAll() { 			return null; 		}
@ReadOperation 		public Object getAll() { 			return null; 		}
@Override 	protected WebApplicationContextRunner getContextRunner() { 		return new WebApplicationContextRunner( 				AnnotationConfigServletWebServerApplicationContext::new) 						.withUserConfiguration(JerseyEndpointConfiguration.class, 								SecurityConfiguration.class, BaseConfiguration.class) 						.withConfiguration(AutoConfigurations.of( 								SecurityAutoConfiguration.class, 								ServletWebSecurityAutoConfiguration.class, 								UserDetailsServiceAutoConfiguration.class, 								SecurityRequestMatcherProviderAutoConfiguration.class, 								JacksonAutoConfiguration.class, 								JerseyAutoConfiguration.class)); 	}
@Override 	protected WebApplicationContextRunner getContextRunner() { 		return new WebApplicationContextRunner( 				AnnotationConfigServletWebServerApplicationContext::new) 						.withUserConfiguration(WebMvcEndpointConfiguration.class, 								SecurityConfiguration.class, BaseConfiguration.class) 						.withConfiguration(AutoConfigurations.of( 								SecurityAutoConfiguration.class, 								ServletWebSecurityAutoConfiguration.class, 								UserDetailsServiceAutoConfiguration.class, 								WebMvcAutoConfiguration.class, 								SecurityRequestMatcherProviderAutoConfiguration.class, 								JacksonAutoConfiguration.class, 								HttpMessageConvertersAutoConfiguration.class, 								DispatcherServletAutoConfiguration.class)); 	}
private void load() { 		this.context = new AnnotationConfigServletWebServerApplicationContext(); 		this.context.register(MockWebServerConfiguration.class, 				TestSessionConfiguration.class, TestRedisConfiguration.class, 				WebMvcAutoConfiguration.class, SecurityAutoConfiguration.class, 				ServletWebSecurityAutoConfiguration.class, SessionAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class, 				HttpEncodingAutoConfiguration.class); 		this.context.refresh(); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.antMatchers("/login").permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error") 					.and() 				.logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout")) 					.and() 				.exceptionHandling().accessDeniedPage("/access?error"); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests() 					.anyRequest().authenticated() 					.and() 				.httpBasic(); 			// @formatter:on 		}
@Override 		protected RequestMatcher createDelegate(WebApplicationContext context, 				RequestMatcherFactory requestMatcherFactory) { 			PathMappedEndpoints pathMappedEndpoints = context 					.getBean(PathMappedEndpoints.class); 			RequestMatcherProvider matcherProvider = getRequestMatcherProvider(context); 			Set<String> paths = new LinkedHashSet<>(); 			if (this.includes.isEmpty()) { 				paths.addAll(pathMappedEndpoints.getAllPaths()); 			} 			streamPaths(this.includes, pathMappedEndpoints).forEach(paths::add); 			streamPaths(this.excludes, pathMappedEndpoints).forEach(paths::remove); 			List<RequestMatcher> delegateMatchers = getDelegateMatchers( 					requestMatcherFactory, matcherProvider, paths); 			String basePath = pathMappedEndpoints.getBasePath(); 			if (this.includeLinks && StringUtils.hasText(basePath)) { 				delegateMatchers.addAll(getLinksMatchers(requestMatcherFactory, 						matcherProvider, basePath)); 			} 			return new OrRequestMatcher(delegateMatchers); 		}
@Override 		protected RequestMatcher createDelegate(WebApplicationContext context, 				RequestMatcherFactory requestMatcherFactory) { 			WebEndpointProperties properties = context 					.getBean(WebEndpointProperties.class); 			String basePath = properties.getBasePath(); 			if (StringUtils.hasText(basePath)) { 				return new OrRequestMatcher(getLinksMatchers(requestMatcherFactory, 						getRequestMatcherProvider(context), basePath)); 			} 			return EMPTY_MATCHER; 		}
private void load() { 		this.context = new AnnotationConfigServletWebServerApplicationContext(); 		this.context.register(MockWebServerConfiguration.class, 				TestSessionConfiguration.class, TestRedisConfiguration.class, 				WebMvcAutoConfiguration.class, SecurityAutoConfiguration.class, 				SessionAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class, 				HttpEncodingAutoConfiguration.class); 		this.context.refresh(); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.antMatchers("/login").permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error") 					.and() 				.logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout")) 					.and() 				.exceptionHandling().accessDeniedPage("/access?error"); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests() 					.anyRequest().authenticated() 					.and() 				.httpBasic(); 			// @formatter:on 		}
@Bean 		@ConditionalOnMissingBean 		public SpringTemplateEngine templateEngine() { 			SpringTemplateEngine engine = new SpringTemplateEngine(); 			engine.setEnableSpringELCompiler(this.properties.isEnableSpringElCompiler()); 			this.templateResolvers.forEach(engine::addTemplateResolver); 			this.dialects.orderedStream().forEach(engine::addDialect); 			return engine; 		}
@Bean 		@ConditionalOnMissingBean(ISpringWebFluxTemplateEngine.class) 		public SpringWebFluxTemplateEngine templateEngine() { 			SpringWebFluxTemplateEngine engine = new SpringWebFluxTemplateEngine(); 			engine.setEnableSpringELCompiler(this.properties.isEnableSpringElCompiler()); 			this.templateResolvers.forEach(engine::addTemplateResolver); 			this.dialects.orderedStream().forEach(engine::addDialect); 			return engine; 		}
@Override 	protected Set<Class<?>> getDefaultIncludes() { 		if (ObjectUtils.isEmpty(this.annotation.controllers())) { 			return DEFAULT_INCLUDES_AND_CONTROLLER; 		} 		return DEFAULT_INCLUDES; 	}
@Test 	public void matchWhenHasNoControllers() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				WithNoControllers.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 	}
@Test 	public void matchWhenHasController() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				WithController.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 	}
@Test 	public void matchNotUsingDefaultFilters() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				NotUsingDefaultFilters.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isTrue(); 		assertThat(excludes(filter, ExampleWeb.class)).isTrue(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isTrue(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 	}
@Test 	public void matchWithExcludeFilter() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				WithExcludeFilter.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 	}
public Map<String, Provider> getProvider() { 		return this.provider; 	}
public String getRedirectUriTemplate() { 			return this.redirectUriTemplate; 		}
public String getProvider() { 			return this.provider; 		}
private void addProperties( 			Map.Entry<String, OAuth2ClientProperties.LoginClientRegistration> entry, 			ConfigurationPropertySource source, Map<String, Object> map) { 		OAuth2ClientProperties.LoginClientRegistration registration = entry.getValue(); 		String registrationId = entry.getKey(); 		addProperty(registrationId, "client-id", registration::getClientId, map, source); 		addProperty(registrationId, "client-secret", registration::getClientSecret, map, 				source); 		addProperty(registrationId, "client-name", registration::getClientName, map, 				source); 		addProperty(registrationId, "redirect-uri-template", 				registration::getRedirectUriTemplate, map, source); 		addProperty(registrationId, "authorization-grant-type", 				registration::getAuthorizationGrantType, map, source); 		addProperty(registrationId, "client-authentication-method", 				registration::getClientAuthenticationMethod, map, source); 		addProperty(registrationId, "provider", registration::getProvider, map, source); 		addProperty(registrationId, "scope", registration::getScope, map, source); 	}
private static ClientRegistration getLoginClientRegistration(String registrationId, 			OAuth2ClientProperties.LoginClientRegistration properties, 			Map<String, Provider> providers) { 		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); 		Builder builder = getBuilder(map, registrationId, properties, providers); 		map.from(properties::getRedirectUriTemplate).to(builder::redirectUriTemplate); 		return builder.build(); 	}
@Test 	public void getClientRegistrationsWhenUsingDefinedProviderShouldAdapt() { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		Provider provider = new Provider(); 		provider.setAuthorizationUri("http://example.com/auth"); 		provider.setTokenUri("http://example.com/token"); 		provider.setUserInfoUri("http://example.com/info"); 		provider.setUserInfoAuthenticationMethod("form"); 		provider.setUserNameAttribute("sub"); 		provider.setJwkSetUri("http://example.com/jwk"); 		OAuth2ClientProperties.LoginClientRegistration login = new OAuth2ClientProperties.LoginClientRegistration(); 		login.setProvider("provider"); 		login.setClientId("clientId"); 		login.setClientSecret("clientSecret"); 		login.setClientAuthenticationMethod("post"); 		login.setAuthorizationGrantType("authorization_code"); 		login.setRedirectUriTemplate("http://example.com/redirect"); 		login.setScope(Collections.singleton("scope")); 		login.setClientName("clientName"); 		properties.getRegistration().getLogin().put("registration", login); 		properties.getProvider().put("provider", provider); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("registration"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("http://example.com/auth"); 		assertThat(adaptedProvider.getTokenUri()).isEqualTo("http://example.com/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("http://example.com/info"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getAuthenticationMethod()) 				.isEqualTo( 						org.springframework.security.oauth2.core.AuthenticationMethod.FORM); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUserNameAttributeName()) 				.isEqualTo("sub"); 		assertThat(adaptedProvider.getJwkSetUri()).isEqualTo("http://example.com/jwk"); 		assertThat(adapted.getRegistrationId()).isEqualTo("registration"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.POST); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUriTemplate()) 				.isEqualTo("http://example.com/redirect"); 		assertThat(adapted.getScopes()).containsExactly("scope"); 		assertThat(adapted.getClientName()).isEqualTo("clientName"); 	}
@Test 	public void getClientRegistrationsWhenUsingCommonProviderWithOverrideShouldAdapt() { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		OAuth2ClientProperties.LoginClientRegistration login = new OAuth2ClientProperties.LoginClientRegistration(); 		login.setProvider("google"); 		login.setClientId("clientId"); 		login.setClientSecret("clientSecret"); 		login.setClientAuthenticationMethod("post"); 		login.setAuthorizationGrantType("authorization_code"); 		login.setRedirectUriTemplate("http://example.com/redirect"); 		login.setScope(Collections.singleton("scope")); 		login.setClientName("clientName"); 		properties.getRegistration().getLogin().put("registration", login); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("registration"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("https://accounts.google.com/o/oauth2/v2/auth"); 		assertThat(adaptedProvider.getTokenUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v4/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/userinfo"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUserNameAttributeName()) 				.isEqualTo(IdTokenClaimNames.SUB); 		assertThat(adaptedProvider.getUserInfoEndpoint().getAuthenticationMethod()) 				.isEqualTo( 						org.springframework.security.oauth2.core.AuthenticationMethod.HEADER); 		assertThat(adaptedProvider.getJwkSetUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/certs"); 		assertThat(adapted.getRegistrationId()).isEqualTo("registration"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.POST); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUriTemplate()) 				.isEqualTo("http://example.com/redirect"); 		assertThat(adapted.getScopes()).containsExactly("scope"); 		assertThat(adapted.getClientName()).isEqualTo("clientName"); 	}
@Test 	public void oidcProviderConfigurationWithCustomConfigurationOverridesProviderDefaults() 			throws Exception { 		this.server = new MockWebServer(); 		this.server.start(); 		String issuer = this.server.url("").toString(); 		String cleanIssuerPath = cleanIssuerPath(issuer); 		setupMockResponse(cleanIssuerPath); 		OAuth2ClientProperties.LoginClientRegistration login = new OAuth2ClientProperties.LoginClientRegistration(); 		login.setProvider("okta-oidc"); 		login.setClientId("clientId"); 		login.setClientSecret("clientSecret"); 		login.setClientAuthenticationMethod("post"); 		login.setRedirectUriTemplate("http://example.com/redirect"); 		login.setScope(Collections.singleton("user")); 		Provider provider = new Provider(); 		provider.setIssuerUri(issuer); 		provider.setAuthorizationUri("http://example.com/auth"); 		provider.setTokenUri("http://example.com/token"); 		provider.setUserInfoUri("http://example.com/info"); 		provider.setUserNameAttribute("sub"); 		provider.setJwkSetUri("http://example.com/jwk"); 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		properties.getProvider().put("okta-oidc", provider); 		properties.getRegistration().getLogin().put("okta", login); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("okta"); 		ProviderDetails providerDetails = adapted.getProviderDetails(); 		assertThat(adapted.getClientAuthenticationMethod()) 				.isEqualTo(ClientAuthenticationMethod.POST); 		assertThat(adapted.getAuthorizationGrantType()) 				.isEqualTo(AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRegistrationId()).isEqualTo("okta"); 		assertThat(adapted.getClientName()).isEqualTo(cleanIssuerPath); 		assertThat(adapted.getScopes()).containsOnly("user"); 		assertThat(adapted.getRedirectUriTemplate()) 				.isEqualTo("http://example.com/redirect"); 		assertThat(providerDetails.getAuthorizationUri()) 				.isEqualTo("http://example.com/auth"); 		assertThat(providerDetails.getTokenUri()).isEqualTo("http://example.com/token"); 		assertThat(providerDetails.getJwkSetUri()).isEqualTo("http://example.com/jwk"); 		assertThat(providerDetails.getUserInfoEndpoint().getUri()) 				.isEqualTo("http://example.com/info"); 		assertThat(providerDetails.getUserInfoEndpoint().getUserNameAttributeName()) 				.isEqualTo("sub"); 	}
@Test 	public void testHiddenHttpMethodFilterOrderedFirst() throws Exception { 		this.context = SpringApplication.run(DenyPostRequestConfig.class, 				"--server.port=0"); 		int port = Integer 				.parseInt(this.context.getEnvironment().getProperty("local.server.port")); 		TestRestTemplate rest = new TestRestTemplate();  		// not overriding causes forbidden 		MultiValueMap<String, String> form = new LinkedMultiValueMap<String, String>();  		ResponseEntity<Object> result = rest 				.postForEntity("http://localhost:" + port + "/", form, Object.class); 		assertThat(result.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);  		// override method with GET 		form = new LinkedMultiValueMap<String, String>(); 		form.add("_method", "GET");  		result = rest.postForEntity("http://localhost:" + port + "/", form, Object.class); 		assertThat(result.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().denyAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers(HttpMethod.POST, "/**").denyAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers(HttpMethod.POST, "/**").denyAll(); 		}
public static EndpointServerWebExchangeMatcher toAnyEndpoint() { 		return new EndpointServerWebExchangeMatcher(); 	}
public static EndpointServerWebExchangeMatcher to(Class<?>... endpoints) { 		return new EndpointServerWebExchangeMatcher(endpoints); 	}
public static EndpointServerWebExchangeMatcher to(String... endpoints) { 		return new EndpointServerWebExchangeMatcher(endpoints); 	}
public EndpointServerWebExchangeMatcher excluding(Class<?>... endpoints) { 			List<Object> excludes = new ArrayList<>(this.excludes); 			excludes.addAll(Arrays.asList((Object[]) endpoints)); 			return new EndpointServerWebExchangeMatcher(this.includes, excludes); 		}
public EndpointServerWebExchangeMatcher excluding(String... endpoints) { 			List<Object> excludes = new ArrayList<>(this.excludes); 			excludes.addAll(Arrays.asList((Object[]) endpoints)); 			return new EndpointServerWebExchangeMatcher(this.includes, excludes); 		}
private ServerWebExchangeMatcher createDelegate( 				PathMappedEndpoints pathMappedEndpoints) { 			Set<String> paths = new LinkedHashSet<>(); 			if (this.includes.isEmpty()) { 				paths.addAll(pathMappedEndpoints.getAllPaths()); 			} 			streamPaths(this.includes, pathMappedEndpoints).forEach(paths::add); 			streamPaths(this.excludes, pathMappedEndpoints).forEach(paths::remove); 			return new OrServerWebExchangeMatcher(getDelegateMatchers(paths)); 		}
public static EndpointRequestMatcher toAnyEndpoint() { 		return new EndpointRequestMatcher(); 	}
public static EndpointRequestMatcher to(Class<?>... endpoints) { 		return new EndpointRequestMatcher(endpoints); 	}
public static EndpointRequestMatcher to(String... endpoints) { 		return new EndpointRequestMatcher(endpoints); 	}
public EndpointRequestMatcher excluding(Class<?>... endpoints) { 			List<Object> excludes = new ArrayList<>(this.excludes); 			excludes.addAll(Arrays.asList((Object[]) endpoints)); 			return new EndpointRequestMatcher(this.includes, excludes); 		}
public EndpointRequestMatcher excluding(String... endpoints) { 			List<Object> excludes = new ArrayList<>(this.excludes); 			excludes.addAll(Arrays.asList((Object[]) endpoints)); 			return new EndpointRequestMatcher(this.includes, excludes); 		}
private RequestMatcher createDelegate(PathMappedEndpoints pathMappedEndpoints) { 			Set<String> paths = new LinkedHashSet<>(); 			if (this.includes.isEmpty()) { 				paths.addAll(pathMappedEndpoints.getAllPaths()); 			} 			streamPaths(this.includes, pathMappedEndpoints).forEach(paths::add); 			streamPaths(this.excludes, pathMappedEndpoints).forEach(paths::remove); 			return new OrRequestMatcher(getDelegateMatchers(paths)); 		}
@Test 	public void toAnyEndpointShouldMatchEndpointPath() { 		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint(); 		assertMatcher(matcher).matches("/actuator/foo"); 		assertMatcher(matcher).matches("/actuator/bar"); 	}
@Test 	public void excludeByClassShouldNotMatchExcluded() { 		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint() 				.excluding(FooEndpoint.class); 		assertMatcher(matcher).doesNotMatch("/actuator/foo"); 		assertMatcher(matcher).matches("/actuator/bar"); 	}
@Test 	public void excludeByIdShouldNotMatchExcluded() { 		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint() 				.excluding("foo"); 		assertMatcher(matcher).doesNotMatch("/actuator/foo"); 		assertMatcher(matcher).matches("/actuator/bar"); 	}
@Test 	public void noEndpointPathsBeansShouldNeverMatch() { 		ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint(); 		assertMatcher(matcher, null).doesNotMatch("/actuator/foo"); 		assertMatcher(matcher, null).doesNotMatch("/actuator/bar"); 	}
private RequestMatcherAssert assertMatcher(ServerWebExchangeMatcher matcher) { 		return assertMatcher(matcher, mockPathMappedEndpoints()); 	}
private RequestMatcherAssert assertMatcher(ServerWebExchangeMatcher matcher, 			PathMappedEndpoints pathMappedEndpoints) { 		StaticApplicationContext context = new StaticApplicationContext(); 		if (pathMappedEndpoints != null) { 			context.registerBean(PathMappedEndpoints.class, () -> pathMappedEndpoints); 		} 		return assertThat(new RequestMatcherAssert(context, matcher)); 	}
@Test 	public void toAnyEndpointShouldMatchEndpointPath() { 		RequestMatcher matcher = EndpointRequest.toAnyEndpoint(); 		assertMatcher(matcher).matches("/actuator/foo"); 		assertMatcher(matcher).matches("/actuator/bar"); 	}
@Test 	public void toEndpointClassShouldNotMatchOtherPath() { 		RequestMatcher matcher = EndpointRequest.to(FooEndpoint.class); 		assertMatcher(matcher).doesNotMatch("/actuator/bar"); 	}
@Test 	public void toEndpointIdShouldNotMatchOtherPath() { 		RequestMatcher matcher = EndpointRequest.to("foo"); 		assertMatcher(matcher).doesNotMatch("/actuator/bar"); 	}
@Test 	public void excludeByClassShouldNotMatchExcluded() { 		RequestMatcher matcher = EndpointRequest.toAnyEndpoint() 				.excluding(FooEndpoint.class); 		assertMatcher(matcher).doesNotMatch("/actuator/foo"); 		assertMatcher(matcher).matches("/actuator/bar"); 	}
@Test 	public void excludeByIdShouldNotMatchExcluded() { 		RequestMatcher matcher = EndpointRequest.toAnyEndpoint().excluding("foo"); 		assertMatcher(matcher).doesNotMatch("/actuator/foo"); 		assertMatcher(matcher).matches("/actuator/bar"); 	}
@Test 	public void noEndpointPathsBeansShouldNeverMatch() { 		RequestMatcher matcher = EndpointRequest.toAnyEndpoint(); 		assertMatcher(matcher, null).doesNotMatch("/actuator/foo"); 		assertMatcher(matcher, null).doesNotMatch("/actuator/bar"); 	}
private RequestMatcherAssert assertMatcher(RequestMatcher matcher) { 		return assertMatcher(matcher, mockPathMappedEndpoints()); 	}
private RequestMatcherAssert assertMatcher(RequestMatcher matcher, 			PathMappedEndpoints pathMappedEndpoints) { 		StaticWebApplicationContext context = new StaticWebApplicationContext(); 		if (pathMappedEndpoints != null) { 			context.registerBean(PathMappedEndpoints.class, () -> pathMappedEndpoints); 		} 		return assertThat(new RequestMatcherAssert(context, matcher)); 	}
@SuppressWarnings("unchecked") 	private C createContext(ServerWebExchange exchange) { 		ApplicationContext context = exchange.getApplicationContext(); 		Assert.state(context != null, "No WebApplicationContext found."); 		if (this.contextClass.isInstance(context)) { 			return (C) context; 		} 		try { 			return context.getBean(this.contextClass); 		} 		catch (NoSuchBeanDefinitionException ex) { 			return (C) context.getAutowireCapableBeanFactory().createBean( 					this.contextClass, AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR, 					false); 		} 	}
@SuppressWarnings("unchecked") 	private C createContext(HttpServletRequest request) { 		WebApplicationContext context = WebApplicationContextUtils 				.getRequiredWebApplicationContext(request.getServletContext()); 		if (this.contextClass.isInstance(context)) { 			return (C) context; 		} 		try { 			return context.getBean(this.contextClass); 		} 		catch (NoSuchBeanDefinitionException ex) { 			return (C) context.getAutowireCapableBeanFactory().createBean( 					this.contextClass, AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR, 					false); 		} 	}
@Test 	public void matchesWhenContextClassIsApplicationContextShouldProvideContext() { 		ServerWebExchange exchange = createHttpWebHandlerAdapter(); 		StaticApplicationContext context = (StaticApplicationContext) exchange 				.getApplicationContext(); 		assertThat(new TestApplicationContextServerWebExchangeMatcher<>( 				ApplicationContext.class).callMatchesAndReturnProvidedContext(exchange)) 						.isEqualTo(context); 	}
@Test 	public void matchesWhenContextClassIsExistingBeanShouldProvideBean() { 		ServerWebExchange exchange = createHttpWebHandlerAdapter(); 		StaticApplicationContext context = (StaticApplicationContext) exchange 				.getApplicationContext(); 		context.registerSingleton("existingBean", ExistingBean.class); 		assertThat( 				new TestApplicationContextServerWebExchangeMatcher<>(ExistingBean.class) 						.callMatchesAndReturnProvidedContext(exchange)) 								.isEqualTo(context.getBean(ExistingBean.class)); 	}
@Test 	public void matchesWhenContextClassIsApplicationContextShouldProvideContext() { 		StaticWebApplicationContext context = createWebApplicationContext(); 		assertThat(new TestApplicationContextRequestMatcher<>(ApplicationContext.class) 				.callMatchesAndReturnProvidedContext(context)).isEqualTo(context); 	}
@Test 	public void matchesWhenContextClassIsExistingBeanShouldProvideBean() { 		StaticWebApplicationContext context = createWebApplicationContext(); 		context.registerSingleton("existingBean", ExistingBean.class); 		assertThat(new TestApplicationContextRequestMatcher<>(ExistingBean.class) 				.callMatchesAndReturnProvidedContext(context)) 						.isEqualTo(context.getBean(ExistingBean.class)); 	}
@Test 	public void getEndpointsShouldAddCloudFoundryHealthExtension() { 		load(TestConfiguration.class, (discoverer) -> { 			Collection<ExposableWebEndpoint> endpoints = discoverer.getEndpoints(); 			assertThat(endpoints.size()).isEqualTo(2); 			for (ExposableWebEndpoint endpoint : endpoints) { 				if (endpoint.getId().equals("health")) { 					WebOperation operation = endpoint.getOperations().iterator().next(); 					assertThat(operation 							.invoke(new InvocationContext(null, Collections.emptyMap()))) 									.isEqualTo("cf"); 				} 			} 		}); 	}
@ReadOperation 		public Object getAll() { 			return null; 		}
@ReadOperation 		public Object getAll() { 			return null; 		}
@ReadOperation 		public Object getAll() { 			return null; 		}
@ReadOperation 		public Object getAll() { 			return "cf"; 		}
@ReadOperation 		public Object getAll() { 			return "cf"; 		}
@ReadOperation 		public Object getAll() { 			return "cf"; 		}
@Test 	public void runWithCustomHealthMappingShouldMapStatusCode() { 		this.contextRunner 				.withPropertyValues("management.health.status.http-mapping.CUSTOM=500") 				.run((context) -> { 					Object extension = context.getBean(HealthEndpointWebExtension.class); 					HealthStatusHttpMapper mapper = (HealthStatusHttpMapper) ReflectionTestUtils 							.getField(extension, "statusHttpMapper"); 					Map<String, Integer> statusMappings = mapper.getStatusMapping(); 					assertThat(statusMappings).containsEntry("DOWN", 503); 					assertThat(statusMappings).containsEntry("OUT_OF_SERVICE", 503); 					assertThat(statusMappings).containsEntry("CUSTOM", 500); 				}); 	}
@Test 	public void unauthenticatedUsersAreNotShownDetailsByDefault() { 		this.contextRunner.run((context) -> { 			HealthEndpointWebExtension extension = context 					.getBean(HealthEndpointWebExtension.class); 			assertThat(extension.getHealth(null).getBody().getDetails()).isEmpty(); 		}); 	}
@Test 	public void authenticatedUsersAreShownDetailsByDefault() { 		this.contextRunner.run((context) -> { 			HealthEndpointWebExtension extension = context 					.getBean(HealthEndpointWebExtension.class); 			assertThat(extension.getHealth(mock(Principal.class)).getBody().getDetails()) 					.isNotEmpty(); 		}); 	}
@Test 	public void detailsCanBeHiddenFromAuthenticatedUsers() { 		this.contextRunner 				.withPropertyValues("management.endpoint.health.show-details=never") 				.run((context) -> { 					HealthEndpointWebExtension extension = context 							.getBean(HealthEndpointWebExtension.class); 					assertThat(extension.getHealth(mock(Principal.class)).getBody() 							.getDetails()).isEmpty(); 				}); 	}
@Test 	public void runWithCustomHealthMappingShouldMapStatusCode() { 		this.contextRunner 				.withPropertyValues("management.health.status.http-mapping.CUSTOM=500") 				.run((context) -> { 					Object extension = context 							.getBean(ReactiveHealthEndpointWebExtension.class); 					HealthStatusHttpMapper mapper = (HealthStatusHttpMapper) ReflectionTestUtils 							.getField(extension, "statusHttpMapper"); 					Map<String, Integer> statusMappings = mapper.getStatusMapping(); 					assertThat(statusMappings).containsEntry("DOWN", 503); 					assertThat(statusMappings).containsEntry("OUT_OF_SERVICE", 503); 					assertThat(statusMappings).containsEntry("CUSTOM", 500); 				}); 	}
@Test 	public void regularAndReactiveHealthIndicatorsMatch() { 		this.contextRunner.withUserConfiguration(HealthIndicatorsConfiguration.class) 				.run((context) -> { 					HealthEndpoint endpoint = context.getBean(HealthEndpoint.class); 					ReactiveHealthEndpointWebExtension extension = context 							.getBean(ReactiveHealthEndpointWebExtension.class); 					Health endpointHealth = endpoint.health(); 					Health extensionHealth = extension.health(mock(Principal.class)) 							.block().getBody(); 					assertThat(endpointHealth.getDetails()) 							.containsOnlyKeys("application", "first", "second"); 					assertThat(extensionHealth.getDetails()) 							.containsOnlyKeys("application", "first", "second"); 				}); 	}
@Test 	public void unauthenticatedUsersAreNotShownDetailsByDefault() { 		this.contextRunner.run((context) -> { 			ReactiveHealthEndpointWebExtension extension = context 					.getBean(ReactiveHealthEndpointWebExtension.class); 			assertThat(extension.health(null).block().getBody().getDetails()).isEmpty(); 		}); 	}
@Test 	public void authenticatedUsersAreShownDetailsByDefault() { 		this.contextRunner.run((context) -> { 			ReactiveHealthEndpointWebExtension extension = context 					.getBean(ReactiveHealthEndpointWebExtension.class); 			assertThat(extension.health(mock(Principal.class)).block().getBody() 					.getDetails()).isNotEmpty(); 		}); 	}
@Test 	public void detailsCanBeHiddenFromAuthenticatedUsers() { 		this.contextRunner 				.withPropertyValues("management.endpoint.health.show-details=never") 				.run((context) -> { 					ReactiveHealthEndpointWebExtension extension = context 							.getBean(ReactiveHealthEndpointWebExtension.class); 					assertThat(extension.health(mock(Principal.class)).block().getBody() 							.getDetails()).isEmpty(); 				}); 	}
private boolean isMissing(InvocationContext context, OperationParameter parameter) { 		if (!parameter.isMandatory()) { 			return false; 		} 		if (Principal.class.equals(parameter.getType())) { 			return context.getPrincipal() == null; 		} 		return context.getArguments().get(parameter.getName()) == null; 	}
private Object resolveArgument(OperationParameter parameter, 			InvocationContext context) { 		if (Principal.class.equals(parameter.getType())) { 			return context.getPrincipal(); 		} 		Object value = context.getArguments().get(parameter.getName()); 		return this.parameterValueMapper.mapParameterValue(parameter, value); 	}
private boolean hasInput(InvocationContext context) { 		if (context.getPrincipal() != null) { 			return true; 		} 		Map<String, Object> arguments = context.getArguments(); 		if (!ObjectUtils.isEmpty(arguments)) { 			return arguments.values().stream().anyMatch(Objects::nonNull); 		} 		return false; 	}
private Object invoke(JmxOperation operation, Object[] params) { 		try { 			String[] parameterNames = operation.getParameters().stream() 					.map(JmxOperationParameter::getName).toArray(String[]::new); 			Map<String, Object> arguments = getArguments(parameterNames, params); 			Object result = operation.invoke(new InvocationContext(null, arguments)); 			if (REACTOR_PRESENT) { 				result = ReactiveHandler.handle(result); 			} 			return this.responseMapper.mapResponse(result); 		} 		catch (InvalidEndpointRequestException ex) { 			throw new IllegalArgumentException(ex.getMessage(), ex); 		} 	}
@Override 		public Response apply(ContainerRequestContext data) { 			Map<String, Object> arguments = new HashMap<>(); 			if (this.readBody) { 				arguments.putAll(extractBodyArguments(data)); 			} 			arguments.putAll(extractPathParameters(data)); 			arguments.putAll(extractQueryParameters(data)); 			try { 				Object response = this.operation.invoke(new InvocationContext( 						data.getSecurityContext().getUserPrincipal(), arguments)); 				return convertToJaxRsResponse(response, data.getRequest().getMethod()); 			} 			catch (InvalidEndpointRequestException ex) { 				return Response.status(Status.BAD_REQUEST).build(); 			} 		}
@Override 		public Object apply(Object body) { 			if (body instanceof org.springframework.core.io.Resource) { 				try { 					return ((org.springframework.core.io.Resource) body).getInputStream(); 				} 				catch (IOException ex) { 					throw new IllegalStateException(); 				} 			} 			return body; 		}
@Override 		public Object apply(Object body) { 			if (body instanceof Mono) { 				return ((Mono<?>) body).block(); 			} 			return body; 		}
@Override 		public Mono<ResponseEntity<Object>> handle(ServerWebExchange exchange, 				Map<String, String> body) { 			return exchange.getPrincipal().defaultIfEmpty(NO_PRINCIPAL) 					.flatMap((principal) -> { 						Map<String, Object> arguments = getArguments(exchange, body); 						return handleResult( 								(Publisher<?>) this.invoker.invoke(new InvocationContext( 										principal == NO_PRINCIPAL ? null : principal, 										arguments)), 								exchange.getRequest().getMethod()); 					}); 		}
@Override 		public Object handle(HttpServletRequest request, 				@RequestBody(required = false) Map<String, String> body) { 			Map<String, Object> arguments = getArguments(request, body); 			try { 				return handleResult( 						this.invoker.invoke(new InvocationContext( 								request.getUserPrincipal(), arguments)), 						HttpMethod.valueOf(request.getMethod())); 			} 			catch (InvalidEndpointRequestException ex) { 				throw new BadOperationRequestException(ex.getReason()); 			} 		}
@Override 		public Object handle(HttpServletRequest request, 				@RequestBody(required = false) Map<String, String> body) { 			Map<String, Object> arguments = getArguments(request, body); 			try { 				return handleResult( 						this.invoker.invoke(new InvocationContext( 								request.getUserPrincipal(), arguments)), 						HttpMethod.valueOf(request.getMethod())); 			} 			catch (InvalidEndpointRequestException ex) { 				throw new BadOperationRequestException(ex.getReason()); 			} 		}
@ResponseBody 		public Object handle(HttpServletRequest request, 				@RequestBody(required = false) Map<String, String> body) { 			return this.operation.handle(request, body); 		}
@Test 	public void createOperationsShouldProviderInvoker() { 		TestOperation operation = getFirst( 				this.factory.createOperations("test", new ExampleWithParams())); 		Map<String, Object> params = Collections.singletonMap("name", 123); 		Object result = operation.invoke(new InvocationContext(null, params)); 		assertThat(result).isEqualTo("123"); 	}
@Test 	public void createOperationShouldApplyAdvisors() { 		TestOperationInvokerAdvisor advisor = new TestOperationInvokerAdvisor(); 		this.invokerAdvisors.add(advisor); 		TestOperation operation = getFirst( 				this.factory.createOperations("test", new ExampleRead())); 		operation.invoke(new InvocationContext(null, Collections.emptyMap())); 		assertThat(advisor.getEndpointId()).isEqualTo("test"); 		assertThat(advisor.getOperationType()).isEqualTo(OperationType.READ); 		assertThat(advisor.getParameters()).isEmpty(); 	}
@Test 	public void invokeShouldInvokeMethod() { 		ReflectiveOperationInvoker invoker = new ReflectiveOperationInvoker(this.target, 				this.operationMethod, this.parameterValueMapper); 		Object result = invoker.invoke( 				new InvocationContext(null, Collections.singletonMap("name", "boot"))); 		assertThat(result).isEqualTo("toob"); 	}
@Test 	public void invokeWhenMissingNonNullableArgumentShouldThrowException() { 		ReflectiveOperationInvoker invoker = new ReflectiveOperationInvoker(this.target, 				this.operationMethod, this.parameterValueMapper); 		this.thrown.expect(MissingParametersException.class); 		invoker.invoke( 				new InvocationContext(null, Collections.singletonMap("name", null))); 	}
@Test 	public void invokeWhenMissingNullableArgumentShouldInvoke() { 		OperationMethod operationMethod = new OperationMethod(ReflectionUtils.findMethod( 				Example.class, "reverseNullable", String.class), OperationType.READ); 		ReflectiveOperationInvoker invoker = new ReflectiveOperationInvoker(this.target, 				operationMethod, this.parameterValueMapper); 		Object result = invoker.invoke( 				new InvocationContext(null, Collections.singletonMap("name", null))); 		assertThat(result).isEqualTo("llun"); 	}
@Test 	public void invokeShouldResolveParameters() { 		ReflectiveOperationInvoker invoker = new ReflectiveOperationInvoker(this.target, 				this.operationMethod, this.parameterValueMapper); 		Object result = invoker.invoke( 				new InvocationContext(null, Collections.singletonMap("name", 1234))); 		assertThat(result).isEqualTo("4321"); 	}
private void assertCacheIsUsed(Map<String, Object> parameters) { 		OperationInvoker target = mock(OperationInvoker.class); 		Object expected = new Object(); 		InvocationContext context = new InvocationContext(null, parameters); 		given(target.invoke(context)).willReturn(expected); 		CachingOperationInvoker invoker = new CachingOperationInvoker(target, 500L); 		Object response = invoker.invoke(context); 		assertThat(response).isSameAs(expected); 		verify(target, times(1)).invoke(context); 		Object cachedResponse = invoker.invoke(context); 		assertThat(cachedResponse).isSameAs(response); 		verifyNoMoreInteractions(target); 	}
@Test 	public void targetAlwaysInvokedWithArguments() { 		OperationInvoker target = mock(OperationInvoker.class); 		Map<String, Object> parameters = new HashMap<>(); 		parameters.put("test", "value"); 		parameters.put("something", null); 		InvocationContext context = new InvocationContext(null, parameters); 		given(target.invoke(context)).willReturn(new Object()); 		CachingOperationInvoker invoker = new CachingOperationInvoker(target, 500L); 		invoker.invoke(context); 		invoker.invoke(context); 		invoker.invoke(context); 		verify(target, times(3)).invoke(context); 	}
@Test 	public void targetInvokedWhenCacheExpires() throws InterruptedException { 		OperationInvoker target = mock(OperationInvoker.class); 		Map<String, Object> parameters = new HashMap<>(); 		InvocationContext context = new InvocationContext(null, parameters); 		given(target.invoke(context)).willReturn(new Object()); 		CachingOperationInvoker invoker = new CachingOperationInvoker(target, 50L); 		invoker.invoke(context); 		Thread.sleep(55); 		invoker.invoke(context); 		verify(target, times(2)).invoke(context); 	}
@Bean 		public TestEndpoint testEndpoint(EndpointDelegate endpointDelegate) { 			return new TestEndpoint(endpointDelegate); 		}
@Bean 		public QueryEndpoint queryEndpoint() { 			return new QueryEndpoint(); 		}
@Bean 		public QueryWithListEndpoint queryEndpoint() { 			return new QueryWithListEndpoint(); 		}
@Bean 		public ResourceEndpoint resourceEndpoint() { 			return new ResourceEndpoint(); 		}
@Bean 		public ResourceWebEndpointResponseEndpoint resourceEndpoint() { 			return new ResourceWebEndpointResponseEndpoint(); 		}
@Bean 		public MonoResponseEndpoint testEndpoint(EndpointDelegate endpointDelegate) { 			return new MonoResponseEndpoint(); 		}
@WriteOperation 		public void write() { 			this.delegate.write(); 		}
@WriteOperation 		public Object write() { 			this.delegate.write(); 			return null; 		}
@ReadOperation 		public Resource read() { 			return new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }); 		}
@ReadOperation 		public Resource read() { 			return new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }); 		}
@ReadOperation 		public WebEndpointResponse<Resource> read() { 			return new WebEndpointResponse<>( 					new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }), 					200); 		}
@ReadOperation 		public WebEndpointResponse<Resource> read() { 			return new WebEndpointResponse<>( 					new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }), 					200); 		}
@ReadOperation(produces = "text/plain") 		public String read() { 			return "read"; 		}
@ReadOperation(produces = "text/plain") 		public String read() { 			return "read"; 		}
@Bean 		public Filter securityFilter() { 			return new OncePerRequestFilter() {  				@Override 				protected void doFilterInternal(HttpServletRequest request, 						HttpServletResponse response, FilterChain filterChain) 						throws ServletException, IOException { 					filterChain.doFilter(new MockPrincipalWrapper(request), response); 				}  			}; 		}
@Override 				protected void doFilterInternal(HttpServletRequest request, 						HttpServletResponse response, FilterChain filterChain) 						throws ServletException, IOException { 					filterChain.doFilter(new MockPrincipalWrapper(request), response); 				}
@Bean 		public WebFilter webFilter() { 			return new WebFilter() {  				@Override 				public Mono<Void> filter(ServerWebExchange exchange, 						WebFilterChain chain) { 					return chain.filter( 							new MockPrincipalServerWebExchangeDecorator(exchange)); 				}  			}; 		}
@Override 				public Mono<Void> filter(ServerWebExchange exchange, 						WebFilterChain chain) { 					return chain.filter( 							new MockPrincipalServerWebExchangeDecorator(exchange)); 				}
@Bean 		public Filter securityFilter() { 			return new OncePerRequestFilter() {  				@Override 				protected void doFilterInternal(HttpServletRequest request, 						HttpServletResponse response, FilterChain filterChain) 						throws ServletException, IOException { 					filterChain.doFilter(new MockPrincipalWrapper(request), response); 				}  			}; 		}
@Override 				protected void doFilterInternal(HttpServletRequest request, 						HttpServletResponse response, FilterChain filterChain) 						throws ServletException, IOException { 					filterChain.doFilter(new MockPrincipalWrapper(request), response); 				}
@Bean 		public HealthEndpointWebExtension healthWebEndpointExtension( 				Map<String, HealthIndicator> healthIndicators) { 			return new HealthEndpointWebExtension( 					new CompositeHealthIndicatorFactory().createHealthIndicator( 							new OrderedHealthAggregator(), healthIndicators), 					new HealthStatusHttpMapper(), ShowDetails.ALWAYS); 		}
@Test 	public void excludeFromSetWhenSetIsNullShouldThrowException() { 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("Locations must not be null"); 		StaticResourceRequest.toCommonLocations().excluding(null); 	}
@Bean 		public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) { 			http.authorizeExchange().matchers(EndpointRequest.to("health", "info")) 					.permitAll().matchers(EndpointRequest.toAnyEndpoint()) 					.hasRole("ACTUATOR") 					.matchers(StaticResourceRequest.toCommonLocations()).permitAll() 					.pathMatchers("/login").permitAll().anyExchange().authenticated() 					.and().httpBasic(); 			return http.build(); 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return endpoint.isSensitive(); 			}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return endpoint.isSensitive(); 			}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@Test 	public void securityConfigurerBacksOffWhenOtherWebSecurityAdapterPresent() 			throws Exception { 		this.contextRunner 				.withUserConfiguration(TestWebSecurityConfigurerConfig.class, 						OAuth2WebSecurityConfiguration.class) 				.run((context) -> assertThat(getAuthCodeFilters(context)).isEmpty()); 	}
@Test 	public void getClientRegistrationsWhenUsingCommonProviderShouldAdapt() 			throws Exception { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		Registration registration = new Registration(); 		registration.setProvider("google"); 		registration.setClientId("clientId"); 		registration.setClientSecret("clientSecret"); 		properties.getRegistration().put("registration", registration); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("registration"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("https://accounts.google.com/o/oauth2/v2/auth"); 		assertThat(adaptedProvider.getTokenUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v4/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/userinfo"); 		assertThat(adaptedProvider.getJwkSetUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/certs"); 		assertThat(adapted.getRegistrationId()).isEqualTo("registration"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.BASIC); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUri()).isEqualTo( 				"{scheme}://{serverName}:{serverPort}{contextPath}/login/oauth2/{registrationId}"); 		assertThat(adapted.getScopes()).containsExactly("openid", "profile", "email", 				"address", "phone"); 		assertThat(adapted.getClientName()).isEqualTo("Google"); 	}
@Test 	public void getClientRegistrationsWhenProviderNotSpecifiedShouldUseRegistrationId() 			throws Exception { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		Registration registration = new Registration(); 		registration.setClientId("clientId"); 		registration.setClientSecret("clientSecret"); 		properties.getRegistration().put("google", registration); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("google"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("https://accounts.google.com/o/oauth2/v2/auth"); 		assertThat(adaptedProvider.getTokenUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v4/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/userinfo"); 		assertThat(adaptedProvider.getJwkSetUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/certs"); 		assertThat(adapted.getRegistrationId()).isEqualTo("google"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.BASIC); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUri()).isEqualTo( 				"{scheme}://{serverName}:{serverPort}{contextPath}/login/oauth2/{registrationId}"); 		assertThat(adapted.getScopes()).containsExactly("openid", "profile", "email", 				"address", "phone"); 		assertThat(adapted.getClientName()).isEqualTo("Google"); 	}
private static Builder getBuilder(String registrationId, String configuredProviderId, 			Map<String, Provider> providers) { 		String providerId = (configuredProviderId == null ? registrationId : configuredProviderId); 		CommonOAuth2Provider provider = getCommonProvider(providerId); 		if (provider == null && !providers.containsKey(providerId)) { 			throw new IllegalStateException(getErrorMessage(configuredProviderId, registrationId)); 		} 		Builder builder = (provider != null ? provider.getBuilder(registrationId) 				: new Builder(registrationId)); 		if (providers.containsKey(providerId)) { 			return getBuilder(builder, providers.get(providerId)); 		} 		return builder; 	}
@Test 	public void getClientRegistrationsWhenUsingDefinedProviderShouldAdapt() 			throws Exception { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		Provider provider = new Provider(); 		provider.setAuthorizationUri("http://example.com/auth"); 		provider.setTokenUri("http://example.com/token"); 		provider.setUserInfoUri("http://example.com/info"); 		provider.setJwkSetUri("http://example.com/jwk"); 		Registration registration = new Registration(); 		registration.setProvider("provider"); 		registration.setClientId("clientId"); 		registration.setClientSecret("clientSecret"); 		registration.setClientAuthenticationMethod("post"); 		registration.setAuthorizationGrantType("authorization_code"); 		registration.setRedirectUri("http://example.com/redirect"); 		registration.setScope(Collections.singleton("scope")); 		registration.setClientName("clientName"); 		properties.getProvider().put("provider", provider); 		properties.getRegistration().put("registration", registration); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("registration"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("http://example.com/auth"); 		assertThat(adaptedProvider.getTokenUri()).isEqualTo("http://example.com/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("http://example.com/info"); 		assertThat(adaptedProvider.getJwkSetUri()).isEqualTo("http://example.com/jwk"); 		assertThat(adapted.getRegistrationId()).isEqualTo("registration"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.POST); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUri()).isEqualTo("http://example.com/redirect"); 		assertThat(adapted.getScope()).containsExactly("scope"); 		assertThat(adapted.getClientName()).isEqualTo("clientName"); 	}
@Test 	public void getClientRegistrationsWhenUsingCommonProviderShouldAdapt() 			throws Exception { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		Registration registration = new Registration(); 		registration.setProvider("google"); 		registration.setClientId("clientId"); 		registration.setClientSecret("clientSecret"); 		properties.getRegistration().put("registration", registration); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("registration"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("https://accounts.google.com/o/oauth2/v2/auth"); 		assertThat(adaptedProvider.getTokenUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v4/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/userinfo"); 		assertThat(adaptedProvider.getJwkSetUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/certs"); 		assertThat(adapted.getRegistrationId()).isEqualTo("registration"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.BASIC); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUri()).isEqualTo( 				"{scheme}://{serverName}:{serverPort}{contextPath}/oauth2/authorize/code/{registrationId}"); 		assertThat(adapted.getScope()).containsExactly("openid", "profile", "email", 				"address", "phone"); 		assertThat(adapted.getClientName()).isEqualTo("Google"); 	}
@Test 	public void getClientRegistrationsWhenUsingCommonProviderWithOverrideShouldAdapt() 			throws Exception { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		Registration registration = new Registration(); 		registration.setProvider("google"); 		registration.setClientId("clientId"); 		registration.setClientSecret("clientSecret"); 		registration.setClientAuthenticationMethod("post"); 		registration.setAuthorizationGrantType("authorization_code"); 		registration.setRedirectUri("http://example.com/redirect"); 		registration.setScope(Collections.singleton("scope")); 		registration.setClientName("clientName"); 		properties.getRegistration().put("registration", registration); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("registration"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("https://accounts.google.com/o/oauth2/v2/auth"); 		assertThat(adaptedProvider.getTokenUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v4/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/userinfo"); 		assertThat(adaptedProvider.getJwkSetUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/certs"); 		assertThat(adapted.getRegistrationId()).isEqualTo("registration"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.POST); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUri()).isEqualTo("http://example.com/redirect"); 		assertThat(adapted.getScope()).containsExactly("scope"); 		assertThat(adapted.getClientName()).isEqualTo("clientName"); 	}
@Test 	public void getClientRegistrationsWhenProviderNotSpecifiedShouldUseRegistrationId() 			throws Exception { 		OAuth2ClientProperties properties = new OAuth2ClientProperties(); 		Registration registration = new Registration(); 		registration.setClientId("clientId"); 		registration.setClientSecret("clientSecret"); 		properties.getRegistration().put("google", registration); 		Map<String, ClientRegistration> registrations = OAuth2ClientPropertiesRegistrationAdapter 				.getClientRegistrations(properties); 		ClientRegistration adapted = registrations.get("google"); 		ProviderDetails adaptedProvider = adapted.getProviderDetails(); 		assertThat(adaptedProvider.getAuthorizationUri()) 				.isEqualTo("https://accounts.google.com/o/oauth2/v2/auth"); 		assertThat(adaptedProvider.getTokenUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v4/token"); 		assertThat(adaptedProvider.getUserInfoEndpoint().getUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/userinfo"); 		assertThat(adaptedProvider.getJwkSetUri()) 				.isEqualTo("https://www.googleapis.com/oauth2/v3/certs"); 		assertThat(adapted.getRegistrationId()).isEqualTo("google"); 		assertThat(adapted.getClientId()).isEqualTo("clientId"); 		assertThat(adapted.getClientSecret()).isEqualTo("clientSecret"); 		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo( 				org.springframework.security.oauth2.core.ClientAuthenticationMethod.BASIC); 		assertThat(adapted.getAuthorizationGrantType()).isEqualTo( 				org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE); 		assertThat(adapted.getRedirectUri()).isEqualTo( 				"{scheme}://{serverName}:{serverPort}{contextPath}/oauth2/authorize/code/{registrationId}"); 		assertThat(adapted.getScope()).containsExactly("openid", "profile", "email", 				"address", "phone"); 		assertThat(adapted.getClientName()).isEqualTo("Google"); 	}
@SuppressWarnings("unchecked") 	private List<Filter> getAuthCodeFilters(AssertableApplicationContext context) { 		FilterChainProxy filterChain = (FilterChainProxy) context 				.getBean("springSecurityFilterChain"); 		List<SecurityFilterChain> filterChains = filterChain.getFilterChains(); 		List<Filter> filters = (List<Filter>) ReflectionTestUtils 				.getField(filterChains.get(0), "filters"); 		List<Filter> oauth2Filters = filters.stream() 				.filter((f) -> f instanceof AuthorizationCodeAuthenticationFilter 						|| f instanceof AuthorizationCodeRequestRedirectFilter) 				.collect(Collectors.toList()); 		return oauth2Filters.stream() 				.filter((f) -> f instanceof AuthorizationCodeAuthenticationFilter) 				.collect(Collectors.toList()); 	}
private boolean isEqual(ClientRegistration reg1, ClientRegistration reg2) { 		boolean result = ObjectUtils.nullSafeEquals(reg1.getClientId(), 				reg2.getClientId()); 		result = result 				&& ObjectUtils.nullSafeEquals(reg1.getClientName(), reg2.getClientName()); 		result = result && ObjectUtils.nullSafeEquals(reg1.getClientSecret(), 				reg2.getClientSecret()); 		result = result && ObjectUtils.nullSafeEquals(reg1.getScope(), reg2.getScope()); 		result = result && ObjectUtils.nullSafeEquals(reg1.getRedirectUri(), 				reg2.getRedirectUri()); 		result = result && ObjectUtils.nullSafeEquals(reg1.getRegistrationId(), 				reg2.getRegistrationId()); 		result = result && ObjectUtils.nullSafeEquals(reg1.getAuthorizationGrantType(), 				reg2.getAuthorizationGrantType()); 		result = result && ObjectUtils.nullSafeEquals( 				reg1.getProviderDetails().getAuthorizationUri(), 				reg2.getProviderDetails().getAuthorizationUri()); 		result = result && ObjectUtils.nullSafeEquals( 				reg1.getProviderDetails().getUserInfoEndpoint(), 				reg2.getProviderDetails().getUserInfoEndpoint()); 		result = result 				&& ObjectUtils.nullSafeEquals(reg1.getProviderDetails().getTokenUri(), 						reg2.getProviderDetails().getTokenUri()); 		return result; 	}
private ClientRegistration getClientRegistration(String id, String userInfoUri) { 			ClientRegistration.Builder builder = new ClientRegistration.Builder(id); 			builder.clientName("foo").clientId("foo") 					.clientAuthenticationMethod( 							org.springframework.security.oauth2.core.ClientAuthenticationMethod.BASIC) 					.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE) 					.scope("read").clientSecret("secret") 					.redirectUri("http://redirect-uri.com") 					.authorizationUri("http://authorization-uri.com") 					.tokenUri("http://token-uri.com").userInfoUri(userInfoUri) 					.userNameAttributeName("login"); 			return builder.build(); 		}
@Test 	public void enablesWebFluxSecurity() { 		this.contextRunner.withUserConfiguration(TestConfig.class) 				.withConfiguration( 						AutoConfigurations.of(ReactiveSecurityAutoConfiguration.class)) 				.run((context) -> { 					assertThat(context).getBean(HttpSecurityConfiguration.class) 							.isNotNull(); 					assertThat(context).getBean(WebFluxSecurityConfiguration.class) 							.isNotNull(); 					assertThat(context).getBean(WebFilterChainFilter.class).isNotNull(); 				}); 	}
@Test 	public void configuresADefaultUser() { 		this.contextRunner.withUserConfiguration(TestConfig.class) 				.withConfiguration( 						AutoConfigurations.of(ReactiveSecurityAutoConfiguration.class)) 				.run((context) -> { 					UserDetailsRepository userDetailsRepository = context 							.getBean(UserDetailsRepository.class); 					assertThat(userDetailsRepository.findByUsername("user").block()) 							.isNotNull(); 				}); 	}
@Test 	public void doesNotConfigureDefaultUserIfUserDetailsRepositoryAvailable() { 		this.contextRunner.withUserConfiguration(UserConfig.class, TestConfig.class) 				.withConfiguration( 						AutoConfigurations.of(ReactiveSecurityAutoConfiguration.class)) 				.run((context) -> { 					UserDetailsRepository userDetailsRepository = context 							.getBean(UserDetailsRepository.class); 					assertThat(userDetailsRepository.findByUsername("user").block()) 							.isNull(); 					assertThat(userDetailsRepository.findByUsername("foo").block()) 							.isNotNull(); 					assertThat(userDetailsRepository.findByUsername("admin").block()) 							.isNotNull(); 				}); 	}
@Test 	public void doesNotConfigureDefaultUserIfAuthenticationManagerAvailable() { 		this.contextRunner 				.withUserConfiguration(AuthenticationManagerConfig.class, 						TestConfig.class) 				.withConfiguration( 						AutoConfigurations.of(ReactiveSecurityAutoConfiguration.class)) 				.run((context) -> assertThat(context).getBean(UserDetailsRepository.class) 						.isNull()); 	}
@Bean 	public UserDetailsRepository userDetailsRepository() { 		return new MapUserDetailsRepository( 				User.withUsername("foo").password("password").roles("USER").build()); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.antMatchers("/login").permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error") 					.and() 				.logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout")) 					.and() 				.exceptionHandling().accessDeniedPage("/access?error"); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests() 					.anyRequest().authenticated() 					.and() 				.httpBasic(); 			// @formatter:on 		}
@Bean 	@ConditionalOnBean(name = DEFAULT_FILTER_NAME) 	public DelegatingFilterProxyRegistrationBean securityFilterChainRegistration( 			SecurityProperties securityProperties) { 		DelegatingFilterProxyRegistrationBean registration = new DelegatingFilterProxyRegistrationBean( 				DEFAULT_FILTER_NAME); 		registration.setOrder(securityProperties.getFilterOrder()); 		registration.setDispatcherTypes(getDispatcherTypes(securityProperties)); 		return registration; 	}
private EnumSet<DispatcherType> getDispatcherTypes( 			SecurityProperties securityProperties) { 		if (securityProperties.getFilterDispatcherTypes() == null) { 			return null; 		} 		return securityProperties.getFilterDispatcherTypes().stream() 				.map((type) -> DispatcherType.valueOf(type.name())).collect(Collectors 						.collectingAndThen(Collectors.toSet(), EnumSet::copyOf)); 	}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 		public FilterRegistrationBean<OAuth2ClientContextFilter> oauth2ClientFilterRegistration( 				OAuth2ClientContextFilter filter, SecurityProperties security) { 			FilterRegistrationBean<OAuth2ClientContextFilter> registration = new FilterRegistrationBean<>(); 			registration.setFilter(filter); 			registration.setOrder(security.getFilterOrder() - 10); 			return registration; 		}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Test 	public void testCustomFilterOrder() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		TestPropertyValues.of("security.filter-order:12345").applyTo(this.context); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				SecurityFilterAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertThat(this.context.getBean("securityFilterChainRegistration", 				DelegatingFilterProxyRegistrationBean.class).getOrder()).isEqualTo(12345); 	}
@Test 	public void customFilterDispatcherTypes() { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				SecurityFilterAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		TestPropertyValues.of("security.filter-dispatcher-types:INCLUDE,ERROR") 				.applyTo(this.context); 		this.context.refresh(); 		DelegatingFilterProxyRegistrationBean bean = this.context.getBean( 				"securityFilterChainRegistration", 				DelegatingFilterProxyRegistrationBean.class); 		@SuppressWarnings("unchecked") 		EnumSet<DispatcherType> dispatcherTypes = (EnumSet<DispatcherType>) ReflectionTestUtils 				.getField(bean, "dispatcherTypes"); 		assertThat(dispatcherTypes).containsOnly(DispatcherType.INCLUDE, 				DispatcherType.ERROR); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.authenticationManager = (authentication) -> this.builder.getOrBuild() 					.authenticate(authentication); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.userDetails = http.getSharedObject(UserDetailsService.class); 		}
@Test 	public void testBinding() { 		bind("security.basic.enabled", "false"); 		assertThat(this.security.getBasic().isEnabled()).isFalse(); 	}
private void bind(ConfigurationPropertySource source) { 		new Binder(source).bind("security", Bindable.ofInstance(this.security)); 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		// FIXME 		// @formatter:off //		http.authorizeRequests() //				.requestMatchers(endpointIds("status", "info")).permitAll() //				.requestMatchers(endpointIds(SpringBootSecurity.ALL_ENDPOINTS)).hasRole("ACTUATOR") //				.requestMatchers(staticResources()).permitAll() //				.antMatchers("/foo").permitAll() //				.antMatchers("/**").hasRole("USER") //				.and() //			.cors() //				.and() //			.httpBasic(); 		// @formatter:on 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		// FIXME 		// @formatter:off //		http.requestMatcher(ALL_ENDPOINTS).authorizeRequests() //				.antMatchers("/**").authenticated() //				.and() //			.httpBasic(); 		// @formatter:on 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.antMatchers("/login").permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error") 					.and() 				.logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout")) 					.and() 				.exceptionHandling().accessDeniedPage("/access?error"); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// FIXME 			// http.requestMatcher(ALL_ENDPOINTS) 			// .authorizeRequests().anyRequest().authenticated().and().httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// FIXME 			// http.requestMatcher(ALL_ENDPOINTS) 			// .authorizeRequests().anyRequest().authenticated().and().httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// FIXME 			// @formatter:off //			http.authorizeRequests() //					.requestMatchers(staticResources()).permitAll() //					.anyRequest().fullyAuthenticated() //					.and() //				.formLogin().loginPage("/login").failureUrl("/login?error").permitAll() //					.and() //				.logout().permitAll(); 			// @formatter:on 		}
@Override 	protected void configure(HttpSecurity http) throws Exception {  		// @formatter:off 		http.authorizeRequests() 				.requestMatchers(this.bootSecurity.endpointIds("status", "info")).permitAll() 				.requestMatchers(this.bootSecurity.endpointIds(SpringBootSecurity.ALL_ENDPOINTS)).hasRole("ACTUATOR") 				.requestMatchers(this.bootSecurity.staticResources()).permitAll() 				.antMatchers("/foo").permitAll() 				.antMatchers("/**").hasRole("USER") 				.and() 			.cors() 				.and() 			.httpBasic(); 		// @formatter:on 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		// @formatter:off 		http.requestMatcher(this.springBootSecurity.endpointIds(SpringBootSecurity.ALL_ENDPOINTS)).authorizeRequests() 				.antMatchers("/**").authenticated() 				.and() 			.httpBasic(); 		// @formatter:on 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.antMatchers("/login").permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error") 					.and() 				.logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout")) 					.and() 				.exceptionHandling().accessDeniedPage("/access?error"); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher( 					this.springBootSecurity.endpointIds(SpringBootSecurity.ALL_ENDPOINTS)) 					.authorizeRequests().anyRequest().authenticated().and().httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher( 					this.springBootSecurity.endpointIds(SpringBootSecurity.ALL_ENDPOINTS)) 					.authorizeRequests().anyRequest().authenticated().and().httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests() 					.requestMatchers(this.springBootSecurity.staticResources()).permitAll() 					.anyRequest().fullyAuthenticated() 					.and() 				.formLogin().loginPage("/login").failureUrl("/login?error").permitAll() 					.and() 				.logout().permitAll(); 			// @formatter:on 		}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		// @formatter:off 		http.authorizeRequests() 				.requestMatchers(this.bootSecurity.endpointIds("status", "info")).permitAll() 				.requestMatchers(this.bootSecurity.endpointIds(SpringBootSecurity.ALL_ENDPOINTS)).hasRole("ACTUATOR") 				.requestMatchers(this.bootSecurity.staticResources()).permitAll() 				.antMatchers("/foo").permitAll() 				.antMatchers("/**").hasRole("USER") 				.and() 			.cors() 				.and() 			.httpBasic(); 		// @formatter:on 	}
@Override 	protected void configure(HttpSecurity http) throws Exception { 		http.requestMatcher( 				this.springBootSecurity.endpointIds(SpringBootSecurity.ALL_ENDPOINTS)) 				.authorizeRequests().antMatchers("/**").authenticated().and().httpBasic(); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers("/login").permitAll().anyRequest() 					.fullyAuthenticated().and().formLogin().loginPage("/login") 					.failureUrl("/login?error").and().logout() 					.logoutRequestMatcher(new AntPathRequestMatcher("/logout")).and() 					.exceptionHandling().accessDeniedPage("/access?error"); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers("/login").permitAll().anyRequest() 					.fullyAuthenticated().and().formLogin().loginPage("/login") 					.failureUrl("/login?error").and().logout() 					.logoutRequestMatcher(new AntPathRequestMatcher("/logout")).and() 					.exceptionHandling().accessDeniedPage("/access?error"); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher( 					this.springBootSecurity.endpointIds(SpringBootSecurity.ALL_ENDPOINTS)) 					.authorizeRequests().anyRequest().authenticated().and().httpBasic(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests() 					.requestMatchers(this.springBootSecurity.staticResources()) 					.permitAll().anyRequest().fullyAuthenticated().and().formLogin() 					.loginPage("/login").failureUrl("/login?error").permitAll().and() 					.logout().permitAll(); 		}
@Test 	public void endpointsAreSecureByDefault() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(SecureConfiguration.class); 		MockMvc mockMvc = createSecureMockMvc(); 		mockMvc.perform(get("/application/beans")).andExpect(status().isUnauthorized()); 	}
@Test 	public void endpointsAreSecureByDefaultWithCustomContextPath() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(SecureConfiguration.class); 		TestPropertyValues.of("management.context-path:/management") 				.applyTo(this.context); 		MockMvc mockMvc = createSecureMockMvc(); 		mockMvc.perform(get("/management/beans")).andExpect(status().isUnauthorized()); 	}
@Test 	public void endpointsAreSecureWithActuatorRoleWithCustomContextPath() 			throws Exception { 		TestSecurityContextHolder.getContext().setAuthentication( 				new TestingAuthenticationToken("user", "N/A", "ROLE_ACTUATOR")); 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(SecureConfiguration.class); 		TestPropertyValues.of("management.context-path:/management") 				.applyTo(this.context); 		MockMvc mockMvc = createSecureMockMvc(); 		mockMvc.perform(get("/management/beans")).andExpect(status().isOk()); 	}
@Override 			public void configure(HttpSecurity http) throws Exception { 				String path = this.console.getPath(); 				String antPattern = (path.endsWith("/") ? path + "**" : path + "/**"); 				HttpSecurity h2Console = http.antMatcher(antPattern); 				h2Console.csrf().disable(); 				h2Console.httpBasic(); 				h2Console.headers().frameOptions().sameOrigin(); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			}
@Override 		public void configure(AuthenticationManagerBuilder auth) throws Exception { 			if (auth.isConfigured()) { 				return; 			} 			User user = this.securityProperties.getUser(); 			if (user.isDefaultPassword()) { 				logger.info(String.format("%n%nUsing default security password: %s%n", 						user.getPassword())); 			} 			Set<String> roles = new LinkedHashSet<>(user.getRole()); 			withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()])); 			setField(auth, "defaultUserDetailsService", getUserDetailsService()); 			super.configure(auth); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher((request) -> false); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Test 	public void noPrincipal() throws Exception { 		MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context) 				.apply(springSecurity()).build(); 		mockMvc.perform(get("/h2-console/")).andExpect(status().isUnauthorized()); 	}
@Test 	public void userPrincipal() throws Exception { 		MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context) 				.apply(springSecurity()).build(); 		mockMvc.perform(get("/h2-console/").with(user("test").roles("USER"))) 				.andExpect(status().isOk()) 				.andExpect(header().string("X-Frame-Options", "SAMEORIGIN")); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertThat(this.context.getBean(AuthenticationManagerBuilder.class)).isNotNull(); 		// 1 for static resources and one for the rest 		assertThat(this.context.getBean(FilterChainProxy.class).getFilterChains()) 				.hasSize(2); 	}
@Test 	public void testDefaultUsernamePassword() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class); 		this.context.refresh(); 		SecurityProperties security = this.context.getBean(SecurityProperties.class); 		AuthenticationManager manager = this.context.getBean(AuthenticationManager.class); 		UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken( 				security.getUser().getName(), security.getUser().getPassword()); 		assertThat(manager.authenticate(token)).isNotNull(); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.authenticationManager = (authentication) -> this.builder.getOrBuild() 					.authenticate(authentication); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.userDetails = http.getSharedObject(UserDetailsService.class); 		}
@Test 	public void testSecurityFilterDoesNotCauseEarlyInitialization() throws Exception { 		try (AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext()) { 			TestPropertyValues.of("server.port:0", "security.user.password:password") 					.applyTo(context); 			context.register(Config.class); 			context.refresh(); 			int port = context.getWebServer().getPort(); 			new TestRestTemplate("user", "password") 					.getForEntity("http://localhost:" + port, Object.class); 			// If early initialization occurred a ConverterNotFoundException is thrown  		} 	}
@Test 	public void requiresAuthentication() throws Exception { 		this.springSecurityFilterChain.doFilter(this.request, this.response, this.chain); 		assertThat(this.response.getStatus()) 				.isEqualTo(HttpServletResponse.SC_UNAUTHORIZED); 	}
@Test 	public void userAuthenticates() throws Exception { 		this.request.addHeader("Authorization", "Basic " + new String( 				Base64.getEncoder().encode("user:password".getBytes("UTF-8"))));  		this.springSecurityFilterChain.doFilter(this.request, this.response, this.chain);  		assertThat(this.response.getStatus()).isEqualTo(HttpServletResponse.SC_OK); 	}
@Test 	public void validateLoggersEndpoint() throws Exception { 		this.mvc.perform(get("/application/loggers/org.apache.coyote.http11.Http11NioProtocol")) 				.andExpect(status().isOk()) 				.andExpect(content().string(equalTo("{\"configuredLevel\":\"WARN\"," 						+ "\"effectiveLevel\":\"WARN\"}"))); 	}
private String getPassword() { 		return this.security.getUser().getPassword(); 	}
@Test 	public void testHome() throws Exception { 		HttpHeaders headers = new HttpHeaders(); 		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML)); 		ResponseEntity<String> entity = this.restTemplate.exchange("/", HttpMethod.GET, 				new HttpEntity<Void>(headers), String.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK); 		assertThat(entity.getBody()).contains("<title>Hello"); 	}
@Test 	public void testError() throws Exception { 		HttpHeaders headers = new HttpHeaders(); 		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML)); 		ResponseEntity<String> entity = this.restTemplate.exchange("/error", 				HttpMethod.GET, new HttpEntity<Void>(headers), String.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 		assertThat(entity.getBody()).contains("<html>").contains("<body>") 				.contains("Please contact the operator with the above information"); 	}
private String getPassword() { 		return this.security.getUser().getPassword(); 	}
private String getPassword() { 		return this.security.getUser().getPassword(); 	}
private String getPassword() { 		return this.securityProperties.getUser().getPassword(); 	}
@Test 	public void testErrorPage() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = new TestRestTemplate() 				.getForEntity("http://localhost:" + this.port + "/error", Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertThat(body.get("status")).isEqualTo(999); 	}
@Test 	public void testManagementErrorPage() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity( 				"http://localhost:" + this.managementPort + "/error", Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertThat(body.get("status")).isEqualTo(999); 	}
private String getPassword() { 		return this.security.getUser().getPassword(); 	}
@Test 	public void testErrorPage() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity( 				"http://localhost:" + this.managementPort + "/error", Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertThat(body.get("status")).isEqualTo(999); 	}
private String getPassword() { 		return this.security.getUser().getPassword(); 	}
private String getPassword() { 		return this.security.getUser().getPassword(); 	}
@Test 	public void testErrorPageDirectAccess() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = this.restTemplate.getForEntity("/error", Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertThat(body.get("error")).isEqualTo("None"); 		assertThat(body.get("status")).isEqualTo(999); 	}
private String getPassword() { 		return this.security.getUser().getPassword(); 	}
@Test 	public void testErrorPath() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = this.restTemplate.getForEntity("/spring/error", 				Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertThat(body.get("error")).isEqualTo("None"); 		assertThat(body.get("status")).isEqualTo(999); 	}
private String getPassword() { 		return this.security.getUser().getPassword(); 	}
private String getPassword() { 		return this.security.getUser().getPassword(); 	}
@Before 	public void init() { 		AuthenticationManager authenticationManager = this.context 				.getBean(AuthenticationManager.class); 		this.authentication = authenticationManager.authenticate( 				new UsernamePasswordAuthenticationToken("user", "password")); 	}
@Test 	public void testHomeIsSecure() throws Exception { 		ResponseEntity<String> entity = this.restTemplate.getForEntity("/", String.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED); 	}
private String getPassword() { 		return this.security.getUser().getPassword(); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers("/login").permitAll().anyRequest() 					.fullyAuthenticated().and().formLogin().loginPage("/login") 					.failureUrl("/login?error").and().logout() 					.logoutRequestMatcher(new AntPathRequestMatcher("/logout")).and() 					.exceptionHandling().accessDeniedPage("/access?error"); 		}
@Test 	public void testManagementProtected() throws Exception { 		ResponseEntity<String> entity = this.restTemplate 				.getForEntity("/application/beans", String.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().fullyAuthenticated().and().formLogin() 					.loginPage("/login").failureUrl("/login?error").permitAll().and() 					.logout().permitAll(); 		}
@Test 	public void unauthorizedResponseWithNoUser() throws Exception { 		this.mockMvc.perform(get("/")).andExpect(status().isUnauthorized()); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// secure endpoints 			RequestMatcher matcher = getRequestMatcher(); 			if (matcher != null) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				// Match all the requests for actuator endpoints ... 				http.requestMatcher(matcher); 				// ... but permitAll() for the non-sensitive ones 				configurePermittedRequests(http.authorizeRequests()); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement() 						.sessionCreationPolicy(asSpringSecuritySessionCreationPolicy( 								this.management.getSecurity().getSessions())); 				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders()); 			} 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return endpoint.isSensitive(); 			}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return endpoint.isSensitive(); 			}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
private Object bindBean(ConfigurationPropertyName name, Bindable<?> target, 			BindHandler handler, Context context) { 		boolean hasKnownBindableProperties = hasKnownBindableProperties(name, context); 		if (!hasKnownBindableProperties && isUnbindableBean(target)) { 			return null; 		} 		BeanPropertyBinder propertyBinder = (propertyName, propertyTarget) -> bind( 				name.append(propertyName), propertyTarget, handler, context); 		Class<?> type = target.getType().resolve(); 		if (context.hasBoundBean(type)) { 			return null; 		} 		return context.withBean(type, () -> { 			Stream<?> boundBeans = BEAN_BINDERS.stream().map( 					(b) -> b.bind(target, hasKnownBindableProperties, propertyBinder)); 			return boundBeans.filter(Objects::nonNull).findFirst().orElse(null); 		}); 	}
private void addField(Field field) { 			BeanProperty property = this.properties.get(field.getName()); 			if (property != null) { 				property.addField(field); 			} 		}
public Class<?> getType() { 			return this.type; 		}
public void addField(Field field) { 			if (this.field == null) { 				this.field = field; 			} 		}
public ResolvableType getType() { 			if (this.setter != null) { 				return ResolvableType.forMethodParameter(this.setter, 0); 			} 			return ResolvableType.forMethodReturnType(this.getter); 		}
private Object bindBean(ConfigurationPropertyName name, Bindable<?> target, 			BindHandler handler, Context context) { 		boolean hasKnownBindableProperties = context.streamSources() 				.flatMap((s) -> s.filter(name::isAncestorOf).stream()).findAny() 				.isPresent(); 		if (!hasKnownBindableProperties && isUnbindableBean(target)) { 			return null; 		} 		BeanPropertyBinder propertyBinder = (propertyName, propertyTarget) -> bind( 				name.append(propertyName), propertyTarget, handler, context); 		Class<?> type = target.getType().resolve(); 		if (context.hasBoundBean(type)) { 			return null; 		} 		return context.withBean(type, () -> { 			Stream<?> boundBeans = BEAN_BINDERS.stream().map( 					(b) -> b.bind(target, hasKnownBindableProperties, propertyBinder)); 			return boundBeans.filter(Objects::nonNull).findFirst().orElse(null); 		}); 	}
private MultiValueMap<String, ConfigurationProperty> getKnownIndexedChildren( 			ConfigurationPropertySource source, ConfigurationPropertyName root) { 		MultiValueMap<String, ConfigurationProperty> children = new LinkedMultiValueMap<>(); 		for (ConfigurationPropertyName name : source.filter(root::isAncestorOf)) { 			name = rollUp(name, root); 			if (name.getElement().isIndexed()) { 				String key = name.getElement().getValue(Form.UNIFORM); 				ConfigurationProperty value = source.getConfigurationProperty(name); 				children.add(key, value); 			} 		} 		return children; 	}
public void bindEntries(ConfigurationPropertySource source, 				Map<Object, Object> map) { 			for (ConfigurationPropertyName name : source) { 				Bindable<?> valueBindable = getValueBindable(name); 				ConfigurationPropertyName entryName = getEntryName(source, name); 				Object key = getContext().getConversionService() 						.convert(getKeyName(entryName), this.keyType); 				Object value = this.elementBinder.bind(entryName, valueBindable); 				map.putIfAbsent(key, value); 			} 		}
private void checkNoUnboundElements(ConfigurationPropertyName name, 			BindContext context) { 		Set<ConfigurationProperty> unbound = new TreeSet<>(); 		for (ConfigurationPropertySource source : context.getSources()) { 			ConfigurationPropertySource filtered = source 					.filter((candidate) -> isUnbound(name, candidate)); 			for (ConfigurationPropertyName unboundName : filtered) { 				try { 					unbound.add(filtered.getConfigurationProperty(unboundName)); 				} 				catch (Exception ex) { 				} 			} 		} 		if (!unbound.isEmpty()) { 			throw new UnboundConfigurationPropertiesException(unbound); 		} 	}
@Override 	public ConfigurationProperty getConfigurationProperty( 			ConfigurationPropertyName name) { 		Assert.notNull(name, "Name must not be null"); 		ConfigurationProperty result = this.source.getConfigurationProperty(name); 		if (result == null) { 			ConfigurationPropertyName aliasedName = this.aliases.getNameForAlias(name); 			result = this.source.getConfigurationProperty(aliasedName); 		} 		return result; 	}
private ConfigurationPropertySource adapt(PropertySource<?> source) { 		return this.adapters.computeIfAbsent(source, (k) -> { 			return new PropertySourceConfigurationPropertySource(source, 					getPropertyMapper(source)); 		}); 	}
@Override 	public ConfigurationProperty getConfigurationProperty( 			ConfigurationPropertyName name) { 		return (this.filter.test(name) ? this.source.getConfigurationProperty(name) 				: null); 	}
public void putAll(Map<?, ?> map) { 		Assert.notNull(map, "Map must not be null"); 		map.forEach(this::put); 	}
@Override 	public ConfigurationProperty getConfigurationProperty( 			ConfigurationPropertyName name) { 		ConfigurationProperty configurationProperty = findDirectly(name); 		if (configurationProperty == null) { 			configurationProperty = findByEnumeration(name); 		} 		return configurationProperty; 	}
private ConfigurationProperty find(List<PropertyMapping> mappings, 			ConfigurationPropertyName name) { 		// Use for-loops rather than streams since this method is called often 		for (PropertyMapping mapping : mappings) { 			if (mapping.isApplicable(name)) { 				ConfigurationProperty property = find(mapping); 				if (property != null) { 					return property; 				} 			} 		} 		return null; 	}
private ConfigurationProperty find(PropertyMapping mapping) { 		String propertySourceName = mapping.getPropertySourceName(); 		Object value = this.propertySource.getProperty(propertySourceName); 		if (value == null) { 			return null; 		} 		value = mapping.getValueExtractor().apply(value); 		ConfigurationPropertyName configurationPropertyName = mapping 				.getConfigurationPropertyName(); 		Origin origin = PropertySourceOrigin.get(this.propertySource, propertySourceName); 		return ConfigurationProperty.of(configurationPropertyName, value, origin); 	}
@Test 	public void bindToArrayWhenNonIterableShouldReturnPopulatedArray() throws Exception { 		MockConfigurationPropertySource source = new MockConfigurationPropertySource(); 		source.put("foo[1]", "2"); 		source.put("foo[0]", "1"); 		source.put("foo[2]", "3"); 		source.setNonIterable(true); 		this.sources.add(source); 		Integer[] result = this.binder.bind("foo", INTEGER_ARRAY).get(); 		assertThat(result).containsExactly(1, 2, 3); 	}
@Test 	public void bindToJavaBeanWhenNonIterableShouldReturnPopulatedBean() 			throws Exception { 		MockConfigurationPropertySource source = new MockConfigurationPropertySource( 				"foo.value", "bar"); 		source.setNonIterable(true); 		this.sources.add(source); 		JavaBean result = this.binder.bind("foo", Bindable.of(JavaBean.class)).get(); 		assertThat(result.getValue()).isEqualTo("bar"); 	}
@Test 	public void bindToCollectionWhenNonIterableShouldReturnPopulatedCollection() 			throws Exception { 		MockConfigurationPropertySource source = new MockConfigurationPropertySource(); 		source.put("foo[1]", "2"); 		source.put("foo[0]", "1"); 		source.put("foo[2]", "3"); 		source.setNonIterable(true); 		this.sources.add(source); 		List<Integer> result = this.binder.bind("foo", INTEGER_LIST).get(); 		assertThat(result).containsExactly(1, 2, 3); 	}
@Test 	public void bindToClassWhenNotIterableShouldNotBindNestedBasedOnInstance() 			throws Exception { 		// If we can't tell that binding will happen, we don't want to randomly invoke 		// getters on the class and cause side effects 		MockConfigurationPropertySource source = new MockConfigurationPropertySource(); 		source.put("foo.value-bean.int-value", "123"); 		source.put("foo.value-bean.string-value", "foo"); 		source.setNonIterable(true); 		this.sources.add(source); 		BindResult<ExampleNestedBeanWithoutSetterOrType> bean = this.binder.bind("foo", 				Bindable.of(ExampleNestedBeanWithoutSetterOrType.class)); 		assertThat(bean.isBound()).isFalse(); 	}
@Test 	public void bindToClassShouldNotInvokeExtraMethods() throws Exception { 		MockConfigurationPropertySource source = new MockConfigurationPropertySource( 				"foo.value", "123"); 		source.setNonIterable(true); 		this.sources.add(source); 		ExampleWithThrowingGetters bean = this.binder 				.bind("foo", Bindable.of(ExampleWithThrowingGetters.class)).get(); 		assertThat(bean.getValue()).isEqualTo(123); 	}
public int getFoo() { 			return this.foo; 		}
public NestedImmutable getNested() { 			return this.nested; 		}
public String getFoo() { 				return "foo"; 			}
public String getValue() { 			return this.value; 		}
public String getValue() { 			return String.valueOf(this.value); 		}
public String getValue() { 			return String.valueOf(this.value); 		}
public String getValue() { 			return String.valueOf(this.value); 		}
public int getValue() { 			return this.value; 		}
public ExampleValueBean getNested() { 			throw new RuntimeException(); 		}
public int getValue() { 			return this.value; 		}
@Test 	public void getConfigurationPropertyShouldConsiderAliases() throws Exception { 		MockConfigurationPropertySource source = new MockConfigurationPropertySource(); 		source.put("foo.bar", "bing"); 		source.put("foo.baz", "biff"); 		ConfigurationPropertySource aliased = source 				.withAliases(new ConfigurationPropertyNameAliases("foo.bar", "foo.bar1")); 		assertThat(getValue(aliased, "foo.bar")).isEqualTo("bing"); 		assertThat(getValue(aliased, "foo.bar1")).isEqualTo("bing"); 	}
@Test 	public void getConfigurationPropertyWhenNotAliasesShouldReturnValue() 			throws Exception { 		MockConfigurationPropertySource source = new MockConfigurationPropertySource(); 		source.put("foo.bar", "bing"); 		source.put("foo.baz", "biff"); 		ConfigurationPropertySource aliased = source 				.withAliases(new ConfigurationPropertyNameAliases("foo.bar", "foo.bar1")); 		assertThat(getValue(aliased, "foo.baz")).isEqualTo("biff"); 	}
@Test 	public void getValueShouldFilterNames() throws Exception { 		MockConfigurationPropertySource source = createTestSource(); 		ConfigurationPropertySource filtered = source.filter(this::noBrackets); 		ConfigurationPropertyName name = ConfigurationPropertyName.of("a"); 		assertThat(source.getConfigurationProperty(name).getValue()).isEqualTo("1"); 		assertThat(filtered.getConfigurationProperty(name).getValue()).isEqualTo("1"); 		ConfigurationPropertyName bracketName = ConfigurationPropertyName.of("a[1]"); 		assertThat(source.getConfigurationProperty(bracketName).getValue()) 				.isEqualTo("2"); 		assertThat(filtered.getConfigurationProperty(bracketName)).isNull();  	}
private MockConfigurationPropertySource createTestSource() { 		MockConfigurationPropertySource source = new MockConfigurationPropertySource(); 		source.put("a", "1"); 		source.put("a[1]", "2"); 		source.put("b", "3"); 		source.put("b[1]", "4"); 		source.put("c", "5"); 		return source; 	}
@Override 	public Iterator<ConfigurationPropertyName> iterator() { 		if (this.nonIterable) { 			return Collections.<ConfigurationPropertyName>emptyList().iterator(); 		} 		return this.map.keySet().iterator(); 	}
@Override 	public Stream<ConfigurationPropertyName> stream() { 		if (this.nonIterable) { 			return Collections.<ConfigurationPropertyName>emptyList().stream(); 		} 		return this.map.keySet().stream(); 	}
@Test 	public void getValueShouldUseDirectMapping() throws Exception { 		Map<String, Object> source = new LinkedHashMap<>(); 		source.put("key1", "value1"); 		source.put("key2", "value2"); 		source.put("key3", "value3"); 		PropertySource<?> propertySource = new NonEnumerablePropertySource<>( 				new MapPropertySource("test", source)); 		TestPropertyMapper mapper = new TestPropertyMapper(); 		ConfigurationPropertyName name = ConfigurationPropertyName.of("my.key"); 		mapper.addFromConfigurationProperty(name, "key2"); 		PropertySourceConfigurationPropertySource adapter = new PropertySourceConfigurationPropertySource( 				propertySource, mapper); 		assertThat(adapter.getConfigurationProperty(name).getValue()).isEqualTo("value2"); 	}
@Test 	public void getValueShouldUseExtractor() throws Exception { 		Map<String, Object> source = new LinkedHashMap<>(); 		source.put("key", "value"); 		PropertySource<?> propertySource = new NonEnumerablePropertySource<>( 				new MapPropertySource("test", source)); 		TestPropertyMapper mapper = new TestPropertyMapper(); 		ConfigurationPropertyName name = ConfigurationPropertyName.of("my.key"); 		mapper.addFromConfigurationProperty(name, "key", 				(value) -> value.toString().replace("ue", "let")); 		PropertySourceConfigurationPropertySource adapter = new PropertySourceConfigurationPropertySource( 				propertySource, mapper); 		assertThat(adapter.getConfigurationProperty(name).getValue()).isEqualTo("vallet"); 	}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnEnabledEndpoint("health") 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate, 				isHealthSecure()); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint 					.addStatusMapping(this.healthMvcEndpointProperties.getMapping()); 		} 		return healthMvcEndpoint; 	}
@Override 	public void setEnvironment(Environment environment) { 		this.healthPropertyResolver = new RelaxedPropertyResolver(environment, 				"endpoints.health."); 		this.endpointPropertyResolver = new RelaxedPropertyResolver(environment, 				"endpoints."); 		this.roleResolver = new RelaxedPropertyResolver(environment, 				"management.security."); 	}
@Test 	public void testSecureByDefault() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(TestConfiguration.class); 		this.context.refresh(); 		Health health = (Health) this.context.getBean(HealthMvcEndpoint.class) 				.invoke(null); 		assertThat(health.getStatus()).isEqualTo(Status.UP); 		assertThat(health.getDetails().get("foo")).isNull(); 	}
@Test 	public void up() { 		given(this.endpoint.invoke()).willReturn(new Health.Builder().up().build()); 		Object result = this.mvc.invoke(null); 		assertThat(result instanceof Health).isTrue(); 		assertThat(((Health) result).getStatus() == Status.UP).isTrue(); 	}
@SuppressWarnings("unchecked") 	@Test 	public void down() { 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		Object result = this.mvc.invoke(null); 		assertThat(result instanceof ResponseEntity).isTrue(); 		ResponseEntity<Health> response = (ResponseEntity<Health>) result; 		assertThat(response.getBody().getStatus() == Status.DOWN).isTrue(); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.SERVICE_UNAVAILABLE); 	}
@Test 	@SuppressWarnings("unchecked") 	public void customMapping() { 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().status("OK").build()); 		this.mvc.setStatusMapping( 				Collections.singletonMap("OK", HttpStatus.INTERNAL_SERVER_ERROR)); 		Object result = this.mvc.invoke(null); 		assertThat(result instanceof ResponseEntity).isTrue(); 		ResponseEntity<Health> response = (ResponseEntity<Health>) result; 		assertThat(response.getBody().getStatus().equals(new Status("OK"))).isTrue(); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 	}
@Test 	@SuppressWarnings("unchecked") 	public void customMappingWithRelaxedName() { 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().outOfService().build()); 		this.mvc.setStatusMapping(Collections.singletonMap("out-of-service", 				HttpStatus.INTERNAL_SERVER_ERROR)); 		Object result = this.mvc.invoke(null); 		assertThat(result instanceof ResponseEntity).isTrue(); 		ResponseEntity<Health> response = (ResponseEntity<Health>) result; 		assertThat(response.getBody().getStatus().equals(Status.OUT_OF_SERVICE)).isTrue(); 		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 	}
@Test 	public void healthIsCached() { 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.isSensitive()).willReturn(true); 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(this.actuator); 		assertThat(result instanceof Health).isTrue(); 		Health health = (Health) result; 		assertThat(health.getStatus() == Status.UP).isTrue(); 		assertThat(health.getDetails()).hasSize(1); 		assertThat(health.getDetails().get("foo")).isEqualTo("bar"); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); // insecure now 		assertThat(result instanceof Health).isTrue(); 		health = (Health) result; 		// so the result is cached 		assertThat(health.getStatus() == Status.UP).isTrue(); 		// but the details are hidden 		assertThat(health.getDetails()).isEmpty(); 	}
@Test 	public void noCachingWhenTimeToLiveIsZero() { 		given(this.endpoint.getTimeToLive()).willReturn(0L); 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertThat(result instanceof Health).isTrue(); 		assertThat(((Health) result).getStatus() == Status.UP).isTrue(); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertThat(health.getStatus() == Status.DOWN).isTrue(); 	}
@Test 	public void newValueIsReturnedOnceTtlExpires() throws InterruptedException { 		given(this.endpoint.getTimeToLive()).willReturn(50L); 		given(this.endpoint.isSensitive()).willReturn(false); 		given(this.endpoint.invoke()) 				.willReturn(new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertThat(result instanceof Health).isTrue(); 		assertThat(((Health) result).getStatus() == Status.UP).isTrue(); 		Thread.sleep(100); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertThat(health.getStatus() == Status.DOWN).isTrue(); 	}
private void sendFailureResponse(HttpServletRequest request, 			HttpServletResponse response) throws Exception { 		if (request.getUserPrincipal() != null) { 			StringBuilder message = new StringBuilder(); 			for (String role : this.roles) { 				message.append(role).append(" "); 			} 			response.sendError(HttpStatus.FORBIDDEN.value(), 					"Access is denied. User must have one of the these roles: " 							+ message.toString().trim()); 		} 		else { 			response.sendError(HttpStatus.UNAUTHORIZED.value(), 					"Full authentication is required to access this resource. " 							+ "Consider adding Spring Security or set management.security.enabled to false."); 		} 	}
@Test 	public void sensitiveEndpointIfNotAuthenticatedShouldNotAllowAccess() 			throws Exception { 		assertThat(this.securityInterceptor.preHandle(this.request, this.response, 				this.handlerMethod)).isFalse(); 		verify(this.response).sendError(HttpStatus.UNAUTHORIZED.value(), 				"Full authentication is required to access this resource. " 						+ "Consider adding Spring Security or set management.security.enabled to false."); 	}
@Override 	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, 			Object handler) throws Exception { 		if (CorsUtils.isPreFlightRequest(request) || !this.secure) { 			return true; 		} 		HandlerMethod handlerMethod = (HandlerMethod) handler; 		MvcEndpoint mvcEndpoint = (MvcEndpoint) handlerMethod.getBean(); 		if (!mvcEndpoint.isSensitive()) { 			return true; 		} 		for (String role : this.roles) { 			if (request.isUserInRole(role)) { 				return true; 			} 		} 		setFailureResponseStatus(request, response); 		return false; 	}
@Before 	public void setup() throws Exception { 		this.roles = Arrays.asList("SUPER_HERO"); 		this.securityInterceptor = new MvcEndpointSecurityInterceptor(true, this.roles); 		this.endpoint = new TestEndpoint("a"); 		this.mvcEndpoint = new TestMvcEndpoint(this.endpoint); 		this.handlerMethod = new HandlerMethod(this.mvcEndpoint, "invoke"); 		this.servletContext = new MockServletContext(); 		this.request = new MockHttpServletRequest(this.servletContext); 		this.response = new MockHttpServletResponse(); 	}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@PostConstruct 		public void init() { 			FS commandFileSystem = createFileSystem( 					this.properties.getCommandPathPatterns(), 					this.properties.getDisabledCommands()); 			FS configurationFileSystem = createFileSystem( 					this.properties.getConfigPathPatterns(), new String[0]);  			PluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery( 					this.resourceLoader.getClassLoader(), this.beanFactory, 					this.properties.getDisabledPlugins());  			PluginContext context = new PluginContext(discovery, 					createPluginContextAttributes(), commandFileSystem, 					configurationFileSystem, this.resourceLoader.getClassLoader());  			context.refresh(); 			start(context); 		}
@Override 		public String getName() { 			return "spring"; 		}
@Override 		public void init() { 			String rolesPropertyValue = getContext().getProperty(ROLES); 			if (rolesPropertyValue != null) { 				this.roles = StringUtils 						.commaDelimitedListToStringArray(rolesPropertyValue); 			} 		}
public String getName() { 			return this.name; 		}
protected void validateCrshShellConfig(Properties properties) { 		getAuth().validateCrshShellConfig(properties); 	}
protected void validateCrshShellConfig(Properties properties) { 			String finalAuth = properties.getProperty("crash.auth"); 			if (!this.defaultAuth && !this.type.equals(finalAuth)) { 				logger.warn(String.format( 						"Shell authentication fell back to method '%s' opposed to " 								+ "configured method '%s'. Please check your classpath.", 						finalAuth, this.type)); 			} 			// Make sure we keep track of final authentication method 			this.type = finalAuth; 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", String.valueOf(this.port)); 				config.put("crash.ssh.auth_timeout", String.valueOf(this.authTimeout)); 				config.put("crash.ssh.idle_timeout", String.valueOf(this.idleTimeout)); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", String.valueOf(this.port)); 				config.put("crash.ssh.auth_timeout", String.valueOf(this.authTimeout)); 				config.put("crash.ssh.idle_timeout", String.valueOf(this.idleTimeout)); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", String.valueOf(this.port)); 				config.put("crash.ssh.auth_timeout", String.valueOf(this.authTimeout)); 				config.put("crash.ssh.idle_timeout", String.valueOf(this.idleTimeout)); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", String.valueOf(this.port)); 				config.put("crash.ssh.auth_timeout", String.valueOf(this.authTimeout)); 				config.put("crash.ssh.idle_timeout", String.valueOf(this.idleTimeout)); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", String.valueOf(this.port)); 				config.put("crash.ssh.auth_timeout", String.valueOf(this.authTimeout)); 				config.put("crash.ssh.idle_timeout", String.valueOf(this.idleTimeout)); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", String.valueOf(this.port)); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", String.valueOf(this.port)); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", String.valueOf(this.port)); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", String.valueOf(this.port)); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", String.valueOf(this.port)); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info(String.format( 						"%n%nUsing default password for shell access: %s%n%n", 						this.user.getPassword())); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info(String.format( 						"%n%nUsing default password for shell access: %s%n%n", 						this.user.getPassword())); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info(String.format( 						"%n%nUsing default password for shell access: %s%n%n", 						this.user.getPassword())); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info(String.format( 						"%n%nUsing default password for shell access: %s%n%n", 						this.user.getPassword())); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info(String.format( 						"%n%nUsing default password for shell access: %s%n%n", 						this.user.getPassword())); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
private boolean isSecure(Principal principal) { 		if (principal == null || principal.getClass().getName().contains("Anonymous")) { 			return false; 		} 		if (isSpringSecurityAuthentication(principal)) { 			Authentication authentication = (Authentication) principal; 			List<String> roles = Arrays.asList(StringUtils 					.trimArrayElements(StringUtils.commaDelimitedListToStringArray( 							this.roleResolver.getProperty("roles", "ROLE_ADMIN")))); 			for (GrantedAuthority authority : authentication.getAuthorities()) { 				String name = authority.getAuthority(); 				for (String role : roles) { 					if (role.equals(name) || ("ROLE_" + role).equals(name)) { 						return true; 					} 				} 			} 		} 		return false; 	}
@Bean 		public AuthenticationManager authenticationManager() { 			return new AuthenticationManager() {  				@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					if (authentication.getName().equals(USERNAME) 							&& authentication.getCredentials().equals(PASSWORD)) { 						authentication = new UsernamePasswordAuthenticationToken( 								authentication.getPrincipal(), 								authentication.getCredentials(), Collections 										.singleton(new SimpleGrantedAuthority("ADMIN"))); 					} 					else { 						throw new BadCredentialsException( 								"Invalid username and password"); 					} 					return authentication; 				} 			}; 		}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					if (authentication.getName().equals(USERNAME) 							&& authentication.getCredentials().equals(PASSWORD)) { 						authentication = new UsernamePasswordAuthenticationToken( 								authentication.getPrincipal(), 								authentication.getCredentials(), Collections 										.singleton(new SimpleGrantedAuthority("ADMIN"))); 					} 					else { 						throw new BadCredentialsException( 								"Invalid username and password"); 					} 					return authentication; 				}
@Test 	public void testWebConfigurationWithExtraRole() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(WebConfiguration.class); 		this.context.refresh(); 		UserDetails user = getUser(); 		ArrayList<GrantedAuthority> authorities = new ArrayList<GrantedAuthority>( 				user.getAuthorities()); 		assertThat(authorities).containsAll(AuthorityUtils 				.commaSeparatedStringToAuthorityList("ROLE_USER,ROLE_ADMIN")); 	}
@Test 	public void defaultJsonResponseIsNotIndented() throws Exception { 		TestSecurityContextHolder.getContext().setAuthentication( 				new TestingAuthenticationToken("user", "N/A", "ROLE_ADMIN")); 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(SecureConfiguration.class); 		MockMvc mockMvc = createSecureMockMvc(); 		mockMvc.perform(get("/mappings")).andExpect(content().string(startsWith("{\""))); 	}
@Test 	public void jsonExtensionProvided() throws Exception { 		TestSecurityContextHolder.getContext().setAuthentication( 				new TestingAuthenticationToken("user", "N/A", "ROLE_ADMIN")); 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(SecureConfiguration.class); 		MockMvc mockMvc = createSecureMockMvc(); 		mockMvc.perform(get("/beans.json")).andExpect(status().isOk()); 	}
private void assertIndentedJsonResponse(Class<?> configuration) throws Exception { 		TestSecurityContextHolder.getContext().setAuthentication( 				new TestingAuthenticationToken("user", "N/A", "ROLE_ADMIN")); 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(configuration); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.jackson.serialization.indent-output:true"); 		MockMvc mockMvc = createSecureMockMvc(); 		mockMvc.perform(get("/mappings")) 				.andExpect(content().string(startsWith("{" + LINE_SEPARATOR))); 	}
@Override 		public void init(AuthenticationManagerBuilder auth) throws Exception { 			auth.inMemoryAuthentication().withUser("admin").password("admin") 					.roles("ADMIN", "USER").and().withUser("user").password("user") 					.roles("USER"); 		}
@Bean 	@ConditionalOnMissingBean 	public EndpointHandlerMapping endpointHandlerMapping() { 		Set<MvcEndpoint> endpoints = mvcEndpoints().getEndpoints(); 		CorsConfiguration corsConfiguration = getCorsConfiguration(this.corsProperties); 		EndpointHandlerMapping mapping = new EndpointHandlerMapping(endpoints, 				corsConfiguration); 		mapping.setPrefix(this.managementServerProperties.getContextPath()); 		for (EndpointHandlerMappingCustomizer customizer : this.mappingCustomizers) { 			customizer.customize(mapping); 		} 		return mapping; 	}
@Before 	public void defaultContextPath() { 		management.setContextPath(""); 		server.setContextPath(""); 	}
@Test 	public void onSamePort() throws Exception { 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				BaseConfiguration.class, ServerPortConfig.class, 				EndpointWebMvcAutoConfiguration.class); 		this.applicationContext.refresh(); 		assertContent("/controller", ports.get().server, "controlleroutput"); 		assertContent("/endpoint", ports.get().server, "endpointoutput"); 		assertContent("/controller", ports.get().management, null); 		assertContent("/endpoint", ports.get().management, null); 		assertThat(hasHeader("/endpoint", ports.get().server, "X-Application-Context")) 				.isTrue(); 		assertThat(this.applicationContext.containsBean("applicationContextIdFilter")) 				.isTrue(); 	}
@Test 	public void specificPortsViaProperties() throws Exception { 		EnvironmentTestUtils.addEnvironment(this.applicationContext, 				"server.port:" + ports.get().server, 				"management.port:" + ports.get().management); 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				BaseConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ErrorMvcAutoConfiguration.class); 		this.applicationContext.refresh(); 		assertContent("/controller", ports.get().server, "controlleroutput"); 		assertContent("/endpoint", ports.get().server, null); 		assertContent("/controller", ports.get().management, null); 		assertContent("/endpoint", ports.get().management, "endpointoutput"); 	}
@Test 	public void contextPath() throws Exception { 		EnvironmentTestUtils.addEnvironment(this.applicationContext, 				"management.contextPath:/test"); 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				ServerPortConfig.class, PropertyPlaceholderAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, JacksonAutoConfiguration.class, 				EmbeddedServletContainerAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				DispatcherServletAutoConfiguration.class, WebMvcAutoConfiguration.class, 				EndpointWebMvcAutoConfiguration.class); 		this.applicationContext.refresh(); 		assertContent("/controller", ports.get().server, "controlleroutput"); 		assertContent("/test/endpoint", ports.get().server, "endpointoutput"); 	}
public int getCount() { 			return this.count; 		}
@Bean 		public SpecificEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new SpecificEmbeddedServletContainerFactory(); 		}
@Bean 		public SpecificEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new SpecificEmbeddedServletContainerFactory(); 		}
@Bean 		public TomcatEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new TomcatEmbeddedServletContainerFactory(); 		}
@Bean 		public TomcatEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new TomcatEmbeddedServletContainerFactory(); 		}
@Bean 		public UndertowEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new UndertowEmbeddedServletContainerFactory(); 		}
@Bean 		public UndertowEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new UndertowEmbeddedServletContainerFactory(); 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
public int getCount() { 				return this.count; 			}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
@Bean 		public EndpointHandlerMapping endpointHandlerMapping( 				Collection<? extends MvcEndpoint> endpoints) { 			return new EndpointHandlerMapping(endpoints); 		}
@After 	public void reset() { 		this.endpoint.reset(); 	}
public void reset() { 			this.available = true; 			this.locked = false; 			this.heapDump = "HEAPDUMP"; 		}
@Test 	public void defaultJsonResponseIsNotIndented() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(DefaultConfiguration.class); 		MockMvc mockMvc = createMockMvc(); 		mockMvc.perform(get("/mappings")).andExpect(content().string(startsWith("{\""))); 	}
@Test 	public void jsonResponsesCanBeIndented() throws Exception { 		assertIndentedJsonResponse(DefaultConfiguration.class); 	}
@Test 	public void jsonExtensionProvided() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(DefaultConfiguration.class); 		MockMvc mockMvc = createMockMvc(); 		mockMvc.perform(get("/beans.json")).andExpect(status().isOk()); 	}
private void assertIndentedJsonResponse(Class<?> configuration) throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(configuration); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.jackson.serialization.indent-output:true"); 		MockMvc mockMvc = createMockMvc(); 		mockMvc.perform(get("/mappings")) 				.andExpect(content().string(startsWith("{" + LINE_SEPARATOR))); 	}
private HandlerInterceptor[] addSecurityInterceptor(HandlerInterceptor[] existing) { 		List<HandlerInterceptor> interceptors = new ArrayList<HandlerInterceptor>(); 		interceptors.add(this.securityInterceptor); 		if (existing != null) { 			interceptors.addAll(Arrays.asList(existing)); 		} 		return interceptors.toArray(new HandlerInterceptor[interceptors.size()]); 	}
@Test 	public void getHandlerExecutionChainShouldHaveSecurityInterceptor() throws Exception { 		CloudFoundrySecurityInterceptor securityInterceptor = Mockito 				.mock(CloudFoundrySecurityInterceptor.class); 		TestMvcEndpoint endpoint = new TestMvcEndpoint(new TestEndpoint("a")); 		CloudFoundryEndpointHandlerMapping handlerMapping = new CloudFoundryEndpointHandlerMapping( 				Collections.singleton(endpoint), null, securityInterceptor); 		HandlerExecutionChain handlerExecutionChain = handlerMapping 				.getHandlerExecutionChain(endpoint, new MockHttpServletRequest()); 		HandlerInterceptor[] interceptors = handlerExecutionChain.getInterceptors(); 		assertThat(interceptors).contains(securityInterceptor); 	}
public static void configureHeaders(HeadersConfigurer<?> configurer, 			SecurityProperties.Headers headers) throws Exception { 		if (headers.getHsts() != Headers.HSTS.NONE) { 			boolean includeSubDomains = headers.getHsts() == Headers.HSTS.ALL; 			HstsHeaderWriter writer = new HstsHeaderWriter(includeSubDomains); 			writer.setRequestMatcher(AnyRequestMatcher.INSTANCE); 			configurer.addHeaderWriter(writer); 		} 		if (!headers.isContentType()) { 			configurer.contentTypeOptions().disable(); 		} 		if (StringUtils.hasText(headers.getContentSecurityPolicy())) { 			if (headers.getContentSecurityPolicyMode() == Headers.ContentSecurityPolicyMode.DEFAULT) { 				configurer.contentSecurityPolicy(headers.getContentSecurityPolicy()); 			} 			else { 				assert headers.getContentSecurityPolicyMode() == Headers.ContentSecurityPolicyMode.REPORT_ONLY; 				configurer.contentSecurityPolicy(headers.getContentSecurityPolicy()).reportOnly(); 			} 		} 		if (!headers.isXss()) { 			configurer.xssProtection().disable(); 		} 		if (!headers.isCache()) { 			configurer.cacheControl().disable(); 		} 		if (!headers.isFrame()) { 			configurer.frameOptions().disable(); 		} 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Test 	public void defaultHeaderConfiguration() throws Exception { 		this.context = SpringApplication.run(VanillaWebConfiguration.class, 				"--server.port=0"); 		MockMvc mockMvc = MockMvcBuilders 				.webAppContextSetup((WebApplicationContext) this.context) 				.addFilters((FilterChainProxy) this.context 						.getBean("springSecurityFilterChain", Filter.class)) 				.build(); 		mockMvc.perform(MockMvcRequestBuilders.get("/")) 				.andExpect(MockMvcResultMatchers.header().string("X-Content-Type-Options", 						is(notNullValue()))) 				.andExpect(MockMvcResultMatchers.header().string("X-XSS-Protection", 						is(notNullValue()))) 				.andExpect(MockMvcResultMatchers.header().string("Cache-Control", 						is(notNullValue()))) 				.andExpect(MockMvcResultMatchers.header().string("X-Frame-Options", 						is(notNullValue()))) 				.andExpect(MockMvcResultMatchers.header().doesNotExist("Content-Security-Policy")); 	}
@Test 	public void contentSecurityPolicyConfiguration() throws Exception { 		this.context = SpringApplication.run(VanillaWebConfiguration.class, 				"--security.headers.content-security-policy=default-src 'self';"); 		MockMvc mockMvc = MockMvcBuilders 				.webAppContextSetup((WebApplicationContext) this.context) 				.addFilters((FilterChainProxy) this.context 						.getBean("springSecurityFilterChain", Filter.class)) 				.build(); 		mockMvc.perform(MockMvcRequestBuilders.get("/")) 				.andExpect(MockMvcResultMatchers.header().string("Content-Security-Policy", 						is("default-src 'self';"))) 				.andExpect(MockMvcResultMatchers.header().doesNotExist("Content-Security-Policy-Report-Only")); 	}
@Test 	public void contentSecurityPolicyReportOnlyConfiguration() throws Exception { 		this.context = SpringApplication.run(VanillaWebConfiguration.class, 				"--security.headers.content-security-policy=default-src 'self';", 				"--security.headers.content-security-policy-mode=report-only"); 		MockMvc mockMvc = MockMvcBuilders 				.webAppContextSetup((WebApplicationContext) this.context) 				.addFilters((FilterChainProxy) this.context 						.getBean("springSecurityFilterChain", Filter.class)) 				.build(); 		mockMvc.perform(MockMvcRequestBuilders.get("/")) 				.andExpect(MockMvcResultMatchers.header().string("Content-Security-Policy-Report-Only", 						is("default-src 'self';"))) 				.andExpect(MockMvcResultMatchers.header().doesNotExist("Content-Security-Policy")); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().denyAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers(HttpMethod.POST, "/**").denyAll(); 		}
public static void configureHeaders(HeadersConfigurer<?> configurer, 			SecurityProperties.Headers headers) throws Exception { 		if (headers.getHsts() != Headers.HSTS.NONE) { 			boolean includeSubDomains = headers.getHsts() == Headers.HSTS.ALL; 			HstsHeaderWriter writer = new HstsHeaderWriter(includeSubDomains); 			writer.setRequestMatcher(AnyRequestMatcher.INSTANCE); 			configurer.addHeaderWriter(writer); 		} 		if (!headers.isContentType()) { 			configurer.contentTypeOptions().disable(); 		} 		if (!headers.isXss()) { 			configurer.xssProtection().disable(); 		} 		if (!headers.isCache()) { 			configurer.cacheControl().disable(); 		} 		if (!headers.isFrame()) { 			configurer.frameOptions().disable(); 		} 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Test 	public void defaultHeaderConfiguration() throws Exception { 		this.context = SpringApplication.run(VanillaWebConfiguration.class, 				"--server.port=0"); 		MockMvc mockMvc = MockMvcBuilders 				.webAppContextSetup((WebApplicationContext) this.context) 				.addFilters((FilterChainProxy) this.context 						.getBean("springSecurityFilterChain", Filter.class)) 				.build(); 		mockMvc.perform(MockMvcRequestBuilders.get("/")) 				.andExpect(MockMvcResultMatchers.header().string("X-Content-Type-Options", 						is(notNullValue()))) 				.andExpect(MockMvcResultMatchers.header().string("X-XSS-Protection", 						is(notNullValue()))) 				.andExpect(MockMvcResultMatchers.header().string("Cache-Control", 						is(notNullValue()))) 				.andExpect(MockMvcResultMatchers.header().string("X-Frame-Options", 						is(notNullValue()))); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().denyAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers(HttpMethod.POST, "/**").denyAll(); 		}
@Override 	protected void postProcessEndpoints(Set<NamedMvcEndpoint> endpoints) { 		super.postProcessEndpoints(endpoints); 		Iterator<NamedMvcEndpoint> iterator = endpoints.iterator(); 		while (iterator.hasNext()) { 			if (iterator.next() instanceof HalJsonMvcEndpoint) { 				iterator.remove(); 			} 		} 	}
@Override 	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, 			Object o) throws Exception { 		if (CorsUtils.isPreFlightRequest(request)) { 			return true; 		} 		try { 			if (!StringUtils.hasText(this.applicationId)) { 				throw new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE, 						"Application id is not available"); 			} 			if (this.cloudFoundrySecurityService == null) { 				throw new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE, 						"Cloud controller URL is not available"); 			} 			HandlerMethod handlerMethod = (HandlerMethod) o; 			MvcEndpoint mvcEndpoint = (MvcEndpoint) handlerMethod.getBean(); 			check(request, mvcEndpoint); 		} 		catch (CloudFoundryAuthorizationException ex) { 			this.logger.error(ex); 			response.setStatus(ex.getStatusCode().value()); 			return false; 		} 		return true; 	}
@Test 	public void preHandleWhenTokenIsMissingShouldReturnFalse() throws Exception { 		boolean preHandle = this.interceptor.preHandle(this.request, this.response, 				this.handlerMethod); 		assertThat(preHandle).isFalse(); 		assertThat(this.response.getStatus()) 				.isEqualTo(Reason.MISSING_AUTHORIZATION.getStatus().value()); 	}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnEnabledEndpoint("health") 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		Security security = this.managementServerProperties.getSecurity(); 		boolean secure = (security != null && security.isEnabled()); 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate, secure); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint 					.addStatusMapping(this.healthMvcEndpointProperties.getMapping()); 		} 		return healthMvcEndpoint; 	}
private HandlerInterceptor[] addSecurityInterceptor(HandlerInterceptor[] existing) { 		List<HandlerInterceptor> interceptors = new ArrayList<HandlerInterceptor>(); 		interceptors.add(new SecurityInterceptor()); 		if (existing != null) { 			interceptors.addAll(Arrays.asList(existing)); 		} 		return interceptors.toArray(new HandlerInterceptor[interceptors.size()]); 	}
@Test 	public void cloudFoundryPlatformActive() throws Exception { 		EnvironmentTestUtils.addEnvironment(this.context, "VCAP_APPLICATION:---", 				"management.cloudfoundry.enabled:true"); 		this.context.refresh(); 		CloudFoundryEndpointHandlerMapping handlerMapping = this.context.getBean( 				"cloudFoundryEndpointHandlerMapping", 				CloudFoundryEndpointHandlerMapping.class); 		assertThat(handlerMapping.getPrefix()).isEqualTo("/cloudfoundryapplication"); 	}
@Test 	public void getHandlerExecutionChainShouldHaveSecurityInterceptor() throws Exception { 		TestMvcEndpoint endpoint = new TestMvcEndpoint(new TestEndpoint("a")); 		CloudFoundryEndpointHandlerMapping handlerMapping = new CloudFoundryEndpointHandlerMapping( 				Arrays.asList(endpoint)); 		HandlerExecutionChain handlerExecutionChain = handlerMapping 				.getHandlerExecutionChain(endpoint, new MockHttpServletRequest()); 		HandlerInterceptor[] interceptors = handlerExecutionChain.getInterceptors(); 		assertThat(interceptors).hasAtLeastOneElementOfType( 				CloudFoundryEndpointHandlerMapping.SecurityInterceptor.class); 	}
@Test 	public void getHandlerExecutionChainWhenEndpointHasPathShouldMapAgainstName() 			throws Exception { 		TestMvcEndpoint testMvcEndpoint = new TestMvcEndpoint(new TestEndpoint("a")); 		testMvcEndpoint.setPath("something-else"); 		CloudFoundryEndpointHandlerMapping handlerMapping = new CloudFoundryEndpointHandlerMapping( 				Arrays.asList(testMvcEndpoint)); 		assertThat(handlerMapping.getPath(testMvcEndpoint)).isEqualTo("/a"); 	}
@Test 	public void doesNotRegisterHalJsonMvcEndpoint() throws Exception { 		CloudFoundryEndpointHandlerMapping handlerMapping = new CloudFoundryEndpointHandlerMapping( 				Collections.<NamedMvcEndpoint>singleton(new TestHalJsonMvcEndpoint())); 		assertThat(handlerMapping.getEndpoints()).hasSize(0); 	}
@Test 	public void registersCloudFoundryDiscoveryEndpoint() throws Exception { 		StaticApplicationContext context = new StaticApplicationContext(); 		CloudFoundryEndpointHandlerMapping handlerMapping = new CloudFoundryEndpointHandlerMapping( 				Collections.<NamedMvcEndpoint>emptyList()); 		handlerMapping.setPrefix("/test"); 		handlerMapping.setApplicationContext(context); 		handlerMapping.afterPropertiesSet(); 		HandlerExecutionChain handler = handlerMapping 				.getHandler(new MockHttpServletRequest("GET", "/test")); 		HandlerMethod handlerMethod = (HandlerMethod) handler.getHandler(); 		assertThat(handlerMethod.getBean()) 				.isInstanceOf(CloudFoundryDiscoveryMvcEndpoint.class); 	}
private RequestMatcher getRequestMatcher() { 			if (this.management.getSecurity().isEnabled()) { 				return null; 			} 			return LazyEndpointPathRequestMatcher.getRequestMatcher(this.contextResolver); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// secure endpoints 			RequestMatcher matcher = getRequestMatcher(); 			if (matcher != null) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				// Match all the requests for actuator endpoints ... 				http.requestMatcher(matcher); 				// ... but permitAll() for the non-sensitive ones 				configurePermittedRequests(http.authorizeRequests()); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions()); 				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders()); 			} 		}
private RequestMatcher getRequestMatcher() { 			if (this.management.getSecurity().isEnabled()) { 				return LazyEndpointPathRequestMatcher 						.getRequestMatcher(this.contextResolver); 			} 			return null; 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
private boolean isSecure(Principal principal) { 		if (principal == null || principal.getClass().getName().contains("Anonymous")) { 			return false; 		} 		if (isSpringSecurityAuthentication(principal)) { 			Authentication authentication = (Authentication) principal; 			String role = this.roleResolver.getProperty("role", "ROLE_ADMIN"); 			for (GrantedAuthority authority : authentication.getAuthorities()) { 				String name = authority.getAuthority(); 				if (role.equals(name) || ("ROLE_" + role).equals(name)) { 					return true; 				} 			} 		} 		return false; 	}
@Override 	public String getContentType() { 		return this.jarEntryName.getContentType(); 	}
@Override 	public Permission getPermission() throws IOException { 		return this.permission; 	}
public String getContentType() { 			if (this.contentType == null) { 				this.contentType = deduceContentType(); 			} 			return this.contentType; 		}
@Bean 		@ConfigurationProperties("security.oauth2.client") 		@Primary 		public AuthorizationCodeResourceDetails oauth2RemoteResource() { 			AuthorizationCodeResourceDetails details = new AuthorizationCodeResourceDetails(); 			return details; 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
private int countBeans(Class<?> type) { 		return this.context.getBeanNamesForType(type).length; 	}
@Bean 		@ConfigurationProperties("security.oauth2.client") 		@Primary 		public AuthorizationCodeResourceDetails oauth2RemoteResource() { 			AuthorizationCodeResourceDetails details = new AuthorizationCodeResourceDetails(); 			return details; 		}
@Bean 		@ConfigurationProperties("security.oauth2.client") 		@Primary 		public ClientCredentialsResourceDetails oauth2RemoteResource() { 			ClientCredentialsResourceDetails details = new ClientCredentialsResourceDetails(); 			return details; 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
private EnumSet<DispatcherType> getDispatcherTypes( 			SecurityProperties securityProperties) { 		Set<DispatcherType> dispatcherTypes = new HashSet<DispatcherType>(); 		for (String dispatcherType : securityProperties.getFilterDispatcherTypes()) { 			dispatcherTypes.add(DispatcherType.valueOf(dispatcherType)); 		} 		return EnumSet.copyOf(dispatcherTypes); 	}
@Bean 	@ConditionalOnBean(name = DEFAULT_FILTER_NAME) 	public DelegatingFilterProxyRegistrationBean securityFilterChainRegistration( 			SecurityProperties securityProperties) { 		DelegatingFilterProxyRegistrationBean registration = new DelegatingFilterProxyRegistrationBean( 				DEFAULT_FILTER_NAME); 		registration.setOrder(securityProperties.getFilterOrder()); 		return registration; 	}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return new TestingAuthenticationToken("foo", "bar"); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.authenticationManager = new AuthenticationManager() { 				@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				} 			}; 		}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.userDetails = http.getSharedObject(UserDetailsService.class); 		}
@Autowired 		public void handlerMapping(MvcEndpoints endpoints, 				ListableBeanFactory beanFactory, EndpointHandlerMapping mapping) { 			// In a child context we definitely want to see the parent endpoints 			mapping.setDetectHandlerMethodsInAncestorContexts(true); 			postProcessMapping(beanFactory, mapping); 		}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			// The ignores are not cumulative, so to prevent overwriting the defaults we 			// add them back. 			List<String> ignored = SpringBootWebSecurityConfiguration 					.getIgnored(this.security); 			if (!this.management.getSecurity().isEnabled()) { 				ignored.addAll(Arrays 						.asList(EndpointPaths.ALL.getPaths(this.endpointHandlerMapping))); 			} 			if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			if (this.server != null) { 				String[] paths = this.server.getPathsArray(ignored); 				if (!ObjectUtils.isEmpty(paths)) { 					ignoring.antMatchers(paths); 				} 			} 		}
protected final EndpointHandlerMapping getRequiredEndpointHandlerMapping() { 			if (this.endpointHandlerMapping == null) { 				ApplicationContext context = (this.contextResolver == null ? null 						: this.contextResolver.getApplicationContext()); 				if (context != null && context 						.getBeanNamesForType(EndpointHandlerMapping.class).length > 0) { 					this.endpointHandlerMapping = context 							.getBean(EndpointHandlerMapping.class); 				} 				if (this.endpointHandlerMapping == null) { 					this.endpointHandlerMapping = new EndpointHandlerMapping( 							Collections.<MvcEndpoint>emptySet()); 				} 			} 			return this.endpointHandlerMapping; 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// secure endpoints 			RequestMatcher matcher = getRequestMatcher(); 			if (matcher != null) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				// Match all the requests for actuator endpoints ... 				http.requestMatcher(matcher); 				// ... but permitAll() for the non-sensitive ones 				configurePermittedRequests(http.authorizeRequests()); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions()); 				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders()); 			} 		}
private void configurePermittedRequests( 				ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry requests) { 			// Permit access to the non-sensitive endpoints 			requests.requestMatchers( 					new EndpointPathRequestMatcher(EndpointPaths.NON_SENSITIVE)) 					.permitAll(); 			// Restrict the rest to the configured role 			requests.anyRequest().hasRole(this.management.getSecurity().getRole()); 		}
@Override 			public boolean matches(HttpServletRequest request) { 				if (this.delegate == null) { 					this.delegate = createDelegate(); 				} 				return this.delegate.matches(request); 			}
private RequestMatcher createDelegate() { 				ServerProperties server = ManagementWebSecurityConfigurerAdapter.this.server; 				List<RequestMatcher> matchers = new ArrayList<RequestMatcher>(); 				EndpointHandlerMapping endpointHandlerMapping = ManagementWebSecurityConfigurerAdapter.this 						.getRequiredEndpointHandlerMapping(); 				for (String path : this.endpointPaths.getPaths(endpointHandlerMapping)) { 					matchers.add(new AntPathRequestMatcher(server.getPath(path))); 				} 				return (matchers.isEmpty() ? MATCH_NONE : new OrRequestMatcher(matchers)); 			}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@Test 	public void onDifferentPortAndContext() throws Exception { 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				DifferentPortConfig.class, BaseConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class); 		management.setContextPath("/admin"); 		this.applicationContext.refresh(); 		assertContent("/controller", ports.get().server, "controlleroutput"); 		assertContent("/admin/endpoint", ports.get().management, "endpointoutput"); 		assertContent("/admin/error", ports.get().management, startsWith("{")); 		this.applicationContext.close(); 		assertAllClosed(); 	}
@Test 	public void onDifferentPortAndMainContext() throws Exception { 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				DifferentPortConfig.class, BaseConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class); 		management.setContextPath("/admin"); 		server.setContextPath("/spring"); 		this.applicationContext.refresh(); 		assertContent("/spring/controller", ports.get().server, "controlleroutput"); 		assertContent("/admin/endpoint", ports.get().management, "endpointoutput"); 		assertContent("/admin/error", ports.get().management, startsWith("{")); 		this.applicationContext.close(); 		assertAllClosed(); 	}
public int getCount() { 			return this.count; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
public int getCount() { 				return this.count; 			}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				WebMvcAutoConfiguration.class, 				ManagementWebSecurityAutoConfiguration.class, 				JacksonAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		FilterChainProxy filterChainProxy = this.context.getBean(FilterChainProxy.class); 		// 4 for static resources, one for management endpoints and one for the rest 		assertThat(filterChainProxy.getFilterChains(), hasSize(6)); 		assertThat(filterChainProxy.getFilters("/beans"), hasSize(greaterThan(0))); 		assertThat(filterChainProxy.getFilters("/beans/"), hasSize(greaterThan(0))); 		assertThat(filterChainProxy.getFilters("/beans.foo"), hasSize(greaterThan(0))); 		assertThat(filterChainProxy.getFilters("/beans/foo/bar"), 				hasSize(greaterThan(0))); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(WebConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Just the management endpoints (one filter) and ignores now plus the backup 		// filter on app endpoints 		assertEquals(6, 				this.context.getBean(FilterChainProxy.class).getFilterChains().size()); 	}
@Test 	public void testCustomErrorPath() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = new TestRestTemplate("user", "password") 				.getForEntity("http://localhost:" + this.port + "/oops", Map.class); 		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("None", body.get("error")); 		assertEquals(999, body.get("status")); 	}
public void configure(HttpSecurity http) throws Exception { 		OAuth2SsoProperties sso = this.beanFactory.getBean(OAuth2SsoProperties.class); 		// Delay the processing of the filter until we know the 		// SessionAuthenticationStrategy is available: 		http.apply(new OAuth2ClientAuthenticationConfigurer(oauth2SsoFilter(sso))); 		http.exceptionHandling().authenticationEntryPoint( 				new LoginUrlAuthenticationEntryPoint(sso.getLoginPath())); 	}
@Test 	public void testTraceConfiguration() throws Exception { 		this.context = new AnnotationConfigApplicationContext(); 		this.context.register(AuditAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuditEventRepository.class)); 		assertNotNull(this.context.getBean(AuthenticationAuditListener.class)); 		assertNotNull(this.context.getBean(AuthorizationAuditListener.class)); 	}
@Test 	public void ownAutoRepository() throws Exception { 		this.context = new AnnotationConfigApplicationContext(); 		this.context.register(Config.class, AuditAutoConfiguration.class); 		this.context.refresh(); 		assertThat(this.context.getBean(AuditEventRepository.class), 				instanceOf(TestAuditEventRepository.class)); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Override 	public void onApplicationEvent(AbstractAuthenticationEvent event) { 		if (event instanceof AbstractAuthenticationFailureEvent) { 			onAuthenticationFailureEvent((AbstractAuthenticationFailureEvent) event); 		} 		else if (this.webListener != null && this.webListener.accepts(event)) { 			this.webListener.process(this, event); 		} 		else { 			onAuthenticationEvent(event); 		} 	}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			// The ignores are not cumulative, so to prevent overwriting the defaults we 			// add them back. 			List<String> ignored = SpringBootWebSecurityConfiguration 					.getIgnored(this.security); 			if (!this.management.getSecurity().isEnabled()) { 				ignored.addAll(Arrays 						.asList(EndpointPaths.ALL.getPaths(this.endpointHandlerMapping))); 			} 			if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			if (this.server != null) { 				String[] paths = this.server.getPathsArray(ignored); 				ignoring.antMatchers(paths); 			} 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@Test 	public void testDisableIgnoredStaticApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ManagementWebSecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.ignored:none"); 		this.context.refresh(); 		// Just the application and management endpoints now 		assertEquals(3, 				this.context.getBean(FilterChainProxy.class).getFilterChains().size()); 	}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = getIgnored(this.security); 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			String[] paths = this.server.getPathsArray(ignored); 			ignoring.antMatchers(paths); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 5 for static resources and one for the rest 		List<SecurityFilterChain> filterChains = this.context 				.getBean(FilterChainProxy.class).getFilterChains(); 		assertEquals(5, filterChains.size()); 	}
@Test 	public void testDisableIgnoredStaticApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.ignored:none"); 		this.context.refresh(); 		// Just the application endpoints now 		assertEquals(2, 				this.context.getBean(FilterChainProxy.class).getFilterChains().size()); 	}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return new TestingAuthenticationToken("foo", "bar"); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.authenticationManager = new AuthenticationManager() { 				@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				} 			}; 		}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.userDetails = http.getSharedObject(UserDetailsService.class); 		}
@Test 	public void everythingIsSecuredByDefault() throws Exception { 		this.mvc.perform(get("/")).andExpect(status().isFound()) 				.andExpect(redirectedUrlPattern("**/login")); 	}
@Test 	public void loginRedirectsToGithub() throws Exception { 		this.mvc.perform(get("/login")).andExpect(status().isFound()) 				.andExpect(redirectedUrlPattern("https://github.com/**")); 	}
public static void configureHeaders(HeadersConfigurer<?> configurer, 			SecurityProperties.Headers headers) throws Exception { 		if (headers.getHsts() != Headers.HSTS.NONE) { 			boolean includeSubdomains = headers.getHsts() == Headers.HSTS.ALL; 			HstsHeaderWriter writer = new HstsHeaderWriter(includeSubdomains); 			writer.setRequestMatcher(AnyRequestMatcher.INSTANCE); 			configurer.addHeaderWriter(writer); 		} 		if (headers.isContentType()) { 			configurer.contentTypeOptions(); 		} 		if (headers.isXss()) { 			configurer.xssProtection(); 		} 		if (headers.isCache()) { 			configurer.cacheControl(); 		} 		if (headers.isFrame()) { 			configurer.frameOptions(); 		} 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().denyAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers(HttpMethod.POST, "/**").denyAll(); 		}
@Override 	public void setEnvironment(Environment environment) { 		this.propertyResolver = new RelaxedPropertyResolver(environment, 				"endpoints.health."); 	}
private boolean isSecure(Principal principal) { 		return (principal != null 				&& !principal.getClass().getName().contains("Anonymous")); 	}
@Test 	@SuppressWarnings("unchecked") 	public void customMapping() { 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().status("OK").build()); 		this.mvc.setStatusMapping(Collections.singletonMap("OK", 				HttpStatus.INTERNAL_SERVER_ERROR)); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof ResponseEntity); 		ResponseEntity<Health> response = (ResponseEntity<Health>) result; 		assertTrue(response.getBody().getStatus().equals(new Status("OK"))); 		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode()); 	}
@Test 	@SuppressWarnings("unchecked") 	public void customMappingWithRelaxedName() { 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().outOfService().build()); 		this.mvc.setStatusMapping(Collections.singletonMap("out-of-service", 				HttpStatus.INTERNAL_SERVER_ERROR)); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof ResponseEntity); 		ResponseEntity<Health> response = (ResponseEntity<Health>) result; 		assertTrue(response.getBody().getStatus().equals(Status.OUT_OF_SERVICE)); 		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode()); 	}
@Test 	public void healthIsCached() { 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.isSensitive()).willReturn(true); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(this.user); 		assertTrue(result instanceof Health); 		Health health = (Health) result; 		assertTrue(health.getStatus() == Status.UP); 		assertThat(health.getDetails().size(), is(equalTo(1))); 		assertThat(health.getDetails().get("foo"), is(equalTo((Object) "bar"))); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); // insecure now 		assertTrue(result instanceof Health); 		health = (Health) result; 		// so the result is cached 		assertTrue(health.getStatus() == Status.UP); 		// but the details are hidden 		assertThat(health.getDetails().size(), is(equalTo(0))); 	}
@Test 	public void unsecureAnonymousAccessUnrestricted() { 		this.mvc = new HealthMvcEndpoint(this.endpoint, false); 		this.mvc.setEnvironment(this.environment); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void unsensitiveAnonymousAccessRestricted() { 		this.environment.getPropertySources().addLast(NON_SENSITIVE); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertNull(((Health) result).getDetails().get("foo")); 	}
@Test 	public void unsecureUnsensitiveAnonymousAccessUnrestricted() { 		this.mvc = new HealthMvcEndpoint(this.endpoint, false); 		this.mvc.setEnvironment(this.environment); 		this.environment.getPropertySources().addLast(NON_SENSITIVE); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void noCachingWhenTimeToLiveIsZero() { 		given(this.endpoint.getTimeToLive()).willReturn(0L); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertTrue(health.getStatus() == Status.DOWN); 	}
@Test 	public void newValueIsReturnedOnceTtlExpires() throws InterruptedException { 		given(this.endpoint.getTimeToLive()).willReturn(50L); 		given(this.endpoint.isSensitive()).willReturn(false); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		Thread.sleep(100); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertTrue(health.getStatus() == Status.DOWN); 	}
private void assertIndentedJsonResponse(Class<?> configuration) throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(configuration); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.jackson.serialization.indent-output:true"); 		MockMvc mockMvc = createMockMvc(); 		mockMvc.perform(get("/beans")).andExpect( 				content().string(startsWith("{" + LINE_SEPARATOR))); 	}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			// The ignores are not cumulative, so to prevent overwriting the defaults we 			// add them back. 			List<String> ignored = SpringBootWebSecurityConfiguration 					.getIgnored(this.security); 			if (!this.management.getSecurity().isEnabled()) { 				ignored.addAll(Arrays.asList(EndpointPaths 						.get(this.endpointHandlerMapping))); 			} 			if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			if (this.server != null) { 				String[] paths = this.server.getPathsArray(ignored); 				ignoring.antMatchers(paths); 			} 		}
private RequestMatcher getRequestMatcher() { 			if (!this.management.getSecurity().isEnabled()) { 				return null; 			} 			String path = this.management.getContextPath(); 			if (StringUtils.hasText(path)) { 				AntPathRequestMatcher matcher = new AntPathRequestMatcher( 						this.server.getPath(path) + "/**"); 				return matcher; 			} 			// Match everything, including the sensitive and non-sensitive paths 			return new EndpointPathRequestMatcher( 					EndpointPaths.get(this.endpointHandlerMapping)); 		}
private void configurePermittedRequests( 				ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry requests) { 			// Permit access to the non-sensitive endpoints 			requests.requestMatchers( 					new EndpointPathRequestMatcher(EndpointPaths.get( 							this.endpointHandlerMapping, false))).permitAll(); 			// Restrict the rest to the configured role 			requests.anyRequest().hasRole(this.management.getSecurity().getRole()); 		}
@Override 			public boolean matches(HttpServletRequest request) { 				ManagementWebSecurityConfigurerAdapter.this 						.deduceEndpointHandlerMappingIfMissing(); 				if (this.delegate == null) { 					this.delegate = createDelegate(); 				} 				return this.delegate.matches(request); 			}
private RequestMatcher createDelegate() { 				ServerProperties server = ManagementWebSecurityConfigurerAdapter.this.server; 				List<RequestMatcher> matchers = new ArrayList<RequestMatcher>(); 				for (String path : this.paths) { 					matchers.add(new AntPathRequestMatcher(server.getPath(path))); 				} 				return (matchers.isEmpty() ? AnyRequestMatcher.INSTANCE 						: new OrRequestMatcher(matchers)); 			}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			// The ignores are not cumulative, so to prevent overwriting the defaults we 			// add them back. 			List<String> ignored = SpringBootWebSecurityConfiguration 					.getIgnored(this.security); 			if (!this.management.getSecurity().isEnabled()) { 				ignored.addAll(Arrays.asList(EndpointPaths 						.get(this.endpointHandlerMapping))); 			} 			if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			if (this.server != null) { 				String[] paths = this.server.getPathsArray(ignored); 				ignoring.antMatchers(paths); 			} 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			String managementEnabled = context.getEnvironment().getProperty( 					"management.security.enabled", "true"); 			String basicEnabled = context.getEnvironment().getProperty( 					"security.basic.enabled", "true"); 			return new ConditionOutcome("true".equalsIgnoreCase(managementEnabled) 					&& !"true".equalsIgnoreCase(basicEnabled), 					"Management security enabled and basic disabled"); 		}
protected final void deduceEndpointHandlerMappingIfMissing() { 			if (this.endpointHandlerMapping == null) { 				ApplicationContext context = (this.contextResolver == null ? null 						: this.contextResolver.getApplicationContext()); 				if (context != null 						&& context.getBeanNamesForType(EndpointHandlerMapping.class).length > 0) { 					this.endpointHandlerMapping = context 							.getBean(EndpointHandlerMapping.class); 				} 				if (this.endpointHandlerMapping == null) { 					this.endpointHandlerMapping = new EndpointHandlerMapping( 							Collections.<MvcEndpoint>emptySet()); 				} 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// secure endpoints 			RequestMatcher matcher = getRequestMatcher(); 			if (matcher != null) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.requestMatcher(matcher); 				configureAuthorizeRequests(new EndpointPathRequestMatcher(false), 						http.authorizeRequests()); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions()); 				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders()); 			} 		}
private RequestMatcher getRequestMatcher() { 			if (!this.management.getSecurity().isEnabled()) { 				return null; 			} 			String path = this.management.getContextPath(); 			if (StringUtils.hasText(path)) { 				AntPathRequestMatcher matcher = new AntPathRequestMatcher( 						this.server.getPath(path) + "/**"); 				return matcher; 			} 			return new EndpointPathRequestMatcher(); 		}
private RequestMatcher createDelegate() { 				ServerProperties server = ManagementWebSecurityConfigurerAdapter.this.server; 				List<RequestMatcher> matchers = new ArrayList<RequestMatcher>(); 				for (String path : getPaths()) { 					matchers.add(new AntPathRequestMatcher(server.getPath(path))); 				} 				return (matchers.isEmpty() ? AnyRequestMatcher.INSTANCE 						: new OrRequestMatcher(matchers)); 			}
public static String[] get(EndpointHandlerMapping endpointHandlerMapping, 				boolean secure) { 			if (endpointHandlerMapping == null) { 				return NO_PATHS; 			} 			Set<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints(); 			Set<String> paths = new LinkedHashSet<String>(endpoints.size()); 			for (MvcEndpoint endpoint : endpoints) { 				if (endpoint.isSensitive() == secure) { 					String path = endpointHandlerMapping.getPath(endpoint.getPath()); 					paths.add(path); 					if (!path.equals("")) { 						// Ensure that nested paths are secured 						paths.add(path + "/**"); 						// Add Spring MVC-generated additional paths 						paths.add(path + ".*"); 					} 					else { 						paths.add("/"); 					} 				} 			} 			return paths.toArray(new String[paths.size()]); 		}
private void assertIndentedJsonResponse(Class<?> configuration) throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.register(configuration); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.jackson.serialization.indent-output:true"); 		MockMvc mockMvc = createMockMvc(); 		mockMvc.perform(get("/beans")).andExpect( 				content().string(startsWith("{" + LINE_SEPARATOR))); 	}
private MockMvc createMockMvc() { 		this.context.setServletContext(new MockServletContext()); 		this.context.refresh(); 		return MockMvcBuilders.webAppContextSetup(this.context).build(); 	}
@PostConstruct 		public void init() { 			String prefix = "spring.oauth2.client"; 			boolean defaultSecret = this.credentials.isDefaultSecret(); 			logger.info(String.format( 					"Initialized OAuth2 Client\n\n%s.clientId = %s\n%s.secret = %s\n\n", 					prefix, this.credentials.getClientId(), prefix, 					defaultSecret ? this.credentials.getClientSecret() : "****")); 		}
@Bean 		@ConfigurationProperties("spring.oauth2.client") 		@Primary 		public AuthorizationCodeResourceDetails oauth2RemoteResource() { 			AuthorizationCodeResourceDetails details = new AuthorizationCodeResourceDetails(); 			return details; 		}
@Bean 		@ConfigurationProperties("spring.oauth2.client") 		@Primary 		public ClientCredentialsResourceDetails oauth2RemoteResource() { 			ClientCredentialsResourceDetails details = new ClientCredentialsResourceDetails(); 			return details; 		}
@Bean 		public OAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 		public OAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 		@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 		public OAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(this.accessTokenRequest); 		}
@Bean 		@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 		public OAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(this.accessTokenRequest); 		}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public OAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public OAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			PropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "spring.oauth2.client."); 			String clientId = resolver.getProperty("client-id"); 			return new ConditionOutcome(StringUtils.hasLength(clientId), 					"Non empty spring.oauth2.client.client-id"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"spring.oauth2.resource."); 			String client = environment 					.resolvePlaceholders("${spring.oauth2.client.clientId:}"); 			if (StringUtils.hasText(client)) { 				return ConditionOutcome.match("found client id"); 			} 			if (!resolver.getSubProperties("jwt").isEmpty()) { 				return ConditionOutcome.match("found JWT resource configuration"); 			} 			if (StringUtils.hasText(resolver.getProperty("user-info-uri"))) { 				return ConditionOutcome.match("found UserInfo " 						+ "URI resource configuration"); 			} 			if (ClassUtils.isPresent(AUTHORIZATION_ANNOTATION, null)) { 				if (AuthorizationServerEndpointsConfigurationBeanCondition 						.matches(context)) { 					return ConditionOutcome.match("found authorization " 							+ "server endpoints configuration"); 				} 			} 			return ConditionOutcome.noMatch("found neither client id nor " 					+ "JWT resource nor authorization server"); 		}
@Bean 			@ConditionalOnMissingBean({ ConnectionFactoryLocator.class, 					ResourceServerTokenServices.class }) 			public ResourceServerTokenServices userInfoTokenServices() { 				UserInfoTokenServices services = new UserInfoTokenServices( 						this.sso.getUserInfoUri(), this.sso.getClientId()); 				services.setTokenType(this.sso.getTokenType()); 				services.setRestTemplate(this.restTemplate); 				return services; 			}
@Bean 			@ConditionalOnMissingBean(ResourceServerTokenServices.class) 			public ResourceServerTokenServices userInfoTokenServices() { 				UserInfoTokenServices services = new UserInfoTokenServices( 						this.sso.getUserInfoUri(), this.sso.getClientId()); 				services.setRestTemplate(this.restTemplate); 				services.setTokenType(this.sso.getTokenType()); 				return services; 			}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"spring.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment.resolvePlaceholders( 						"${OAUTH2_RESOURCE_PREFERTOKENINFO:true}").equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match("Token info endpoint " 						+ "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"spring.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment.resolvePlaceholders( 						"${OAUTH2_RESOURCE_PREFERTOKENINFO:true}").equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match("Token info endpoint " 						+ "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"spring.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment.resolvePlaceholders( 						"${OAUTH2_RESOURCE_PREFERTOKENINFO:true}").equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match("Token info endpoint " 						+ "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"spring.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment.resolvePlaceholders( 						"${OAUTH2_RESOURCE_PREFERTOKENINFO:true}").equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match("Token info endpoint " 						+ "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "spring.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "spring.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "spring.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "spring.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome.inverse(this.tokenInfoCondition.getMatchOutcome( 					context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome.inverse(this.tokenInfoCondition.getMatchOutcome( 					context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome.inverse(this.tokenInfoCondition.getMatchOutcome( 					context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome.inverse(this.jwtTokenCondition.getMatchOutcome( 					context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome.inverse(this.jwtTokenCondition.getMatchOutcome( 					context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome.inverse(this.jwtTokenCondition.getMatchOutcome( 					context, metadata)); 		}
@Test 	public void testEnvironmentalOverrides() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.oauth2.client.clientId:myclientid", 				"spring.oauth2.client.clientSecret:mysecret"); 		this.context.register(AuthorizationAndResourceServerConfiguration.class, 				MinimalSecureWebApplication.class); 		this.context.refresh(); 		ClientDetails config = this.context.getBean(ClientDetails.class); 		assertThat(config.getClientId(), equalTo("myclientid")); 		assertThat(config.getClientSecret(), equalTo("mysecret")); 		verifyAuthentication(config); 	}
@Test 	public void testDisablingAuthorizationServer() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(ResourceServerConfiguration.class, 				MinimalSecureWebApplication.class); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.oauth2.resource.jwt.keyValue:DEADBEEF"); 		this.context.refresh(); 		assertThat(countBeans(RESOURCE_SERVER_CONFIG), equalTo(1)); 		assertThat(countBeans(AUTHORIZATION_SERVER_CONFIG), equalTo(0)); 		assertThat(countBeans(UserApprovalHandler.class), equalTo(0)); 		assertThat(countBeans(DefaultTokenServices.class), equalTo(1)); 	}
@Test 	public void testAuthorizationServerOverride() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.oauth2.resourceId:resource-id"); 		this.context.register(AuthorizationAndResourceServerConfiguration.class, 				CustomAuthorizationServer.class, MinimalSecureWebApplication.class); 		this.context.refresh(); 		BaseClientDetails config = new BaseClientDetails(); 		config.setClientId("client"); 		config.setClientSecret("secret"); 		config.setResourceIds(Arrays.asList("resource-id")); 		config.setAuthorizedGrantTypes(Arrays.asList("password")); 		config.setAuthorities(AuthorityUtils.commaSeparatedStringToAuthorityList("USER")); 		config.setScope(Arrays.asList("read")); 		assertThat(countBeans(AUTHORIZATION_SERVER_CONFIG), equalTo(0)); 		assertThat(countBeans(RESOURCE_SERVER_CONFIG), equalTo(1)); 		verifyAuthentication(config); 	}
@Test 	public void useRemoteTokenServices() { 		EnvironmentTestUtils.addEnvironment(this.environment, 				"spring.oauth2.resource.tokenInfoUri:http://example.com", 				"spring.oauth2.resource.clientId=acme"); 		this.context = new SpringApplicationBuilder(ResourceConfiguration.class) 				.environment(this.environment).web(false).run(); 		RemoteTokenServices services = this.context.getBean(RemoteTokenServices.class); 		assertNotNull(services); 	}
@Test 	public void switchToUserInfo() { 		EnvironmentTestUtils.addEnvironment(this.environment, 				"spring.oauth2.resource.userInfoUri:http://example.com"); 		this.context = new SpringApplicationBuilder(ResourceConfiguration.class) 				.environment(this.environment).web(false).run(); 		UserInfoTokenServices services = this.context 				.getBean(UserInfoTokenServices.class); 		assertNotNull(services); 	}
@Test 	public void userInfoNoClient() { 		EnvironmentTestUtils.addEnvironment(this.environment, 				"spring.oauth2.client.clientId=acme", 				"spring.oauth2.resource.userInfoUri:http://example.com", 				"server.port=-1", "debug=true"); 		this.context = new SpringApplicationBuilder(ResourceNoClientConfiguration.class) 				.environment(this.environment).web(true).run(); 		BeanDefinition bean = ((BeanDefinitionRegistry) this.context) 				.getBeanDefinition("scopedTarget.oauth2ClientContext"); 		assertEquals("request", bean.getScope()); 	}
@Test 	public void preferUserInfo() { 		EnvironmentTestUtils.addEnvironment(this.environment, 				"spring.oauth2.resource.userInfoUri:http://example.com", 				"spring.oauth2.resource.tokenInfoUri:http://example.com", 				"spring.oauth2.resource.preferTokenInfo:false"); 		this.context = new SpringApplicationBuilder(ResourceConfiguration.class) 				.environment(this.environment).web(false).run(); 		UserInfoTokenServices services = this.context 				.getBean(UserInfoTokenServices.class); 		assertNotNull(services); 	}
@Test 	public void switchToJwt() { 		EnvironmentTestUtils.addEnvironment(this.environment, 				"spring.oauth2.resource.jwt.keyValue=FOOBAR"); 		this.context = new SpringApplicationBuilder(ResourceConfiguration.class) 				.environment(this.environment).web(false).run(); 		DefaultTokenServices services = this.context.getBean(DefaultTokenServices.class); 		assertNotNull(services); 	}
@Test 	public void asymmetricJwt() { 		EnvironmentTestUtils.addEnvironment(this.environment, 				"spring.oauth2.resource.jwt.keyValue=" + PUBLIC_KEY); 		this.context = new SpringApplicationBuilder(ResourceConfiguration.class) 				.environment(this.environment).web(false).run(); 		DefaultTokenServices services = this.context.getBean(DefaultTokenServices.class); 		assertNotNull(services); 	}
@Test 	public void springSocialUserInfo() { 		EnvironmentTestUtils.addEnvironment(this.environment, 				"spring.oauth2.resource.userInfoUri:http://example.com", 				"spring.social.facebook.app-id=foo", 				"spring.social.facebook.app-secret=bar"); 		this.context = new SpringApplicationBuilder(SocialResourceConfiguration.class) 				.environment(this.environment).web(true).run(); 		ConnectionFactoryLocator connectionFactory = this.context 				.getBean(ConnectionFactoryLocator.class); 		assertNotNull(connectionFactory); 		SpringSocialTokenServices services = this.context 				.getBean(SpringSocialTokenServices.class); 		assertNotNull(services); 	}
@Bean 		public MockEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new MockEmbeddedServletContainerFactory(); 		}
@Bean 		public EmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return mock(EmbeddedServletContainerFactory.class); 		}
@Test 	public void oauth2Sample() throws Exception { 		String output = this.cli.run("oauth2.groovy"); 		assertTrue("Wrong output: " + output, 				output.contains("spring.oauth2.client.clientId")); 		assertTrue("Wrong output: " + output, 				output.contains("spring.oauth2.client.secret =")); 	}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnEnabledEndpoint("health") 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		Security security = this.managementServerProperties.getSecurity(); 		boolean secure = (security == null || security.isEnabled()); 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate, secure); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint.addStatusMapping(this.healthMvcEndpointProperties 					.getMapping()); 		} 		return healthMvcEndpoint; 	}
private boolean isUnrestricted() { 		Boolean sensitive = this.propertyResolver.getProperty("sensitive", Boolean.class); 		return !this.secure || Boolean.FALSE.equals(sensitive); 	}
@Test 	public void unsecureAnonymousAccessUnrestricted() { 		this.environment.getPropertySources().addLast(NON_SENSITIVE); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity( 				"http://localhost:" + port, Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testSecureHealth() throws Exception { 		ResponseEntity<String> entity = new TestRestTemplate().getForEntity( 				"http://localhost:" + this.port + "/health", String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertTrue("Wrong body: " + entity.getBody(), 				entity.getBody().contains("\"hello\":1")); 	}
@Bean 	public ClientHttpRequestFactory clientHttpRequestFactory() { 		return new SimpleClientHttpRequestFactory(); 	}
@Test 	public void ignoresUnmappedUrl() throws Exception { 		loadContext("spring.developertools.remote.enabled:true"); 		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); 		this.request.setRequestURI("/restart"); 		filter.doFilter(this.request, this.response, this.chain); 		assertRestartInvoked(false); 	}
@Test 	public void invokeRestartWithDefaultSetup() throws Exception { 		loadContext("spring.developertools.remote.enabled:true"); 		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); 		this.request.setRequestURI(DEFAULT_CONTEXT_PATH + "/restart"); 		filter.doFilter(this.request, this.response, this.chain); 		assertRestartInvoked(true); 	}
@Test 	public void disableRestart() throws Exception { 		loadContext("spring.developertools.remote.enabled:true", 				"spring.developertools.remote.restart.enabled:false"); 		this.thrown.expect(NoSuchBeanDefinitionException.class); 		this.context.getBean("remoteRestartHanderMapper"); 	}
@Test 	public void invokeTunnelWithDefaultSetup() throws Exception { 		loadContext("spring.developertools.remote.enabled:true"); 		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); 		this.request.setRequestURI(DEFAULT_CONTEXT_PATH + "/debug"); 		filter.doFilter(this.request, this.response, this.chain); 		assertTunnelInvoked(true); 	}
@Test 	public void disableRemoteDebug() throws Exception { 		loadContext("spring.developertools.remote.enabled:true", 				"spring.developertools.remote.debug.enabled:false"); 		this.thrown.expect(NoSuchBeanDefinitionException.class); 		this.context.getBean("remoteDebugHanderMapper"); 	}
@Test 	public void developerToolsHealthReturns200() throws Exception { 		loadContext("spring.developertools.remote.enabled:true"); 		DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); 		this.request.setRequestURI(DEFAULT_CONTEXT_PATH); 		this.response.setStatus(500); 		filter.doFilter(this.request, this.response, this.chain); 		assertThat(this.response.getStatus(), equalTo(200)); 	}
@Test 	public void warnIfNotHttps() throws Exception { 		configureWithRemoteUrl("http://localhost"); 		assertThat(this.output.toString(), containsString("is insecure")); 	}
@Test 	public void doesntWarnIfUsingHttps() throws Exception { 		configureWithRemoteUrl("https://localhost"); 		assertThat(this.output.toString(), not(containsString("is insecure"))); 	}
private void configure(String... pairs) { 		configureWithRemoteUrl("http://localhost", pairs); 	}
@Bean 		public AccessDecisionManager shellAccessDecisionManager() { 			List<AccessDecisionVoter> voters = new ArrayList<AccessDecisionVoter>(); 			RoleVoter voter = new RoleVoter(); 			voter.setRolePrefix(""); 			voters.add(voter); 			AccessDecisionManager result = new UnanimousBased(voters); 			return result; 		}
@Test 	public void testDefaultConfiguration() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(AuthorizationAndResourceServerConfiguration.class, 				MinimalSecureWebApplication.class); 		this.context.refresh();  		this.context.getBean(SpringSecurityOAuth2AuthorizationServerConfiguration.class); 		this.context.getBean(SpringSecurityOAuth2ResourceServerConfiguration.class); 		this.context.getBean(SpringSecurityOAuth2MethodSecurityConfiguration.class);  		ClientDetails config = this.context.getBean(BaseClientDetails.class); 		AuthorizationEndpoint endpoint = this.context 				.getBean(AuthorizationEndpoint.class); 		UserApprovalHandler handler = (UserApprovalHandler) ReflectionTestUtils.getField( 				endpoint, "userApprovalHandler"); 		ClientDetailsService clientDetailsService = this.context 				.getBean(ClientDetailsService.class); 		ClientDetails clientDetails = clientDetailsService.loadClientByClientId(config 				.getClientId());  		assertThat(AopUtils.isJdkDynamicProxy(clientDetailsService), is(true)); 		assertThat(AopUtils.getTargetClass(clientDetailsService).getName(), 				is(ClientDetailsService.class.getName()));  		assertThat(handler instanceof ApprovalStoreUserApprovalHandler, is(true));  		assertThat(clientDetails, equalTo(config));  		verifyAuthentication(config); 	}
@Test 	public void testDisablingResourceServer() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(AuthorizationServerConfiguration.class, 				MinimalSecureWebApplication.class); 		this.context.refresh();  		assertThat( 				this.context 						.getBeanNamesForType(SpringSecurityOAuth2ResourceServerConfiguration.class).length, 				is(0));  		assertThat( 				this.context 						.getBeanNamesForType(SpringSecurityOAuth2AuthorizationServerConfiguration.class).length, 				is(1)); 	}
@Test 	public void testDisablingAuthorizationServer() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(ResourceServerConfiguration.class, 				MinimalSecureWebApplication.class); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.oauth2.resource.jwt.keyValue:DEADBEEF"); 		this.context.refresh();  		assertThat( 				this.context 						.getBeanNamesForType(SpringSecurityOAuth2ResourceServerConfiguration.class).length, 				is(1));  		assertThat( 				this.context 						.getBeanNamesForType(SpringSecurityOAuth2AuthorizationServerConfiguration.class).length, 				is(0));  		assertThat(this.context.getBeanNamesForType(UserApprovalHandler.class).length, 				is(0)); 		assertThat(this.context.getBeanNamesForType(DefaultTokenServices.class).length, 				is(1)); 	}
@Test 	public void testResourceServerOverride() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(AuthorizationAndResourceServerConfiguration.class, 				CustomResourceServer.class, MinimalSecureWebApplication.class); 		this.context.refresh();  		ClientDetails config = this.context.getBean(ClientDetails.class);  		assertThat( 				this.context 						.getBeanNamesForType(SpringSecurityOAuth2AuthorizationServerConfiguration.class).length, 				is(1));  		assertThat(this.context.getBeanNamesForType(CustomResourceServer.class).length, 				is(1));  		assertThat( 				this.context 						.getBeanNamesForType(SpringSecurityOAuth2ResourceServerConfiguration.class).length, 				is(1));  		verifyAuthentication(config);  	}
@Test 	public void testAuthorizationServerOverride() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.oauth2.resourceId:resource-id"); 		this.context.register(AuthorizationAndResourceServerConfiguration.class, 				CustomAuthorizationServer.class, MinimalSecureWebApplication.class); 		this.context.refresh();  		BaseClientDetails config = new BaseClientDetails(); 		config.setClientId("client"); 		config.setClientSecret("secret"); 		config.setResourceIds(Arrays.asList("resource-id")); 		config.setAuthorizedGrantTypes(Arrays.asList("password")); 		config.setAuthorities(AuthorityUtils.commaSeparatedStringToAuthorityList("USER")); 		config.setScope(Arrays.asList("read"));  		assertThat( 				this.context 						.getBeanNamesForType(SpringSecurityOAuth2AuthorizationServerConfiguration.class).length, 				is(0));  		assertThat( 				this.context 						.getBeanNamesForType(SpringSecurityOAuth2ResourceServerConfiguration.class).length, 				is(1));  		verifyAuthentication(config); 	}
@Test 	public void testDefaultPrePostSecurityAnnotations() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(AuthorizationAndResourceServerConfiguration.class, 				MinimalSecureWebApplication.class); 		this.context.refresh();  		this.context.getBean(SpringSecurityOAuth2MethodSecurityConfiguration.class);  		ClientDetails config = this.context.getBean(ClientDetails.class);  		DelegatingMethodSecurityMetadataSource source = this.context 				.getBean(DelegatingMethodSecurityMetadataSource.class); 		List<MethodSecurityMetadataSource> sources = source 				.getMethodSecurityMetadataSources();  		assertThat(sources.size(), is(1)); 		assertThat(sources.get(0).getClass().getName(), 				is(PrePostAnnotationSecurityMetadataSource.class.getName()));  		verifyAuthentication(config); 	}
@Test 	public void testClassicSecurityAnnotationOverride() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(SecuredEnabledConfiguration.class, 				MinimalSecureWebApplication.class); 		this.context.refresh();  		this.context.getBean(SpringSecurityOAuth2MethodSecurityConfiguration.class);  		ClientDetails config = this.context.getBean(ClientDetails.class);  		DelegatingMethodSecurityMetadataSource source = this.context 				.getBean(DelegatingMethodSecurityMetadataSource.class); 		List<MethodSecurityMetadataSource> sources = source 				.getMethodSecurityMetadataSources();  		assertThat(sources.size(), is(1)); 		assertThat(sources.get(0).getClass().getName(), 				is(SecuredAnnotationSecurityMetadataSource.class.getName()));  		verifyAuthentication(config, HttpStatus.OK); 	}
@Test 	public void testJsr250SecurityAnnotationOverride() { 		this.context = new AnnotationConfigEmbeddedWebApplicationContext(); 		this.context.register(Jsr250EnabledConfiguration.class, 				MinimalSecureWebApplication.class); 		this.context.refresh();  		this.context.getBean(SpringSecurityOAuth2MethodSecurityConfiguration.class);  		ClientDetails config = this.context.getBean(ClientDetails.class);  		DelegatingMethodSecurityMetadataSource source = this.context 				.getBean(DelegatingMethodSecurityMetadataSource.class); 		List<MethodSecurityMetadataSource> sources = source 				.getMethodSecurityMetadataSources();  		assertThat(sources.size(), is(1)); 		assertThat(sources.get(0).getClass().getName(), 				is(Jsr250MethodSecurityMetadataSource.class.getName()));  		verifyAuthentication(config, HttpStatus.OK); 	}
@Override 	public boolean matches(ClassNode classNode) { 		return AstUtils.hasAtLeastOneAnnotation(classNode, "EnableWebSecurity"); 	}
@Override 	public void applyDependencies(DependencyCustomizer dependencies) { 		dependencies 				.ifAnyMissingClasses( 						"org.springframework.security.config.annotation.web.configuration.EnableWebSecurity") 				.add("spring-security-config").add("spring-security-web", false); 	}
@Override 	public void applyImports(ImportCustomizer imports) { 		imports.addImports("org.springframework.security.core.Authentication", 				"org.springframework.security.core.authority.AuthorityUtils") 				.addStarImports( 						"org.springframework.security.config.annotation.web.configuration", 						"org.springframework.security.authentication", 						"org.springframework.security.config.annotation.web", 						"org.springframework.security.config.annotation.web.builders"); 	}
@Override 	public boolean matches(ClassNode classNode) { 		return AstUtils.hasAtLeastOneAnnotation(classNode, 				"EnableAuthorizationServer", "EnableResourceServer"); 	}
@Override 	public void applyImports(ImportCustomizer imports) throws CompilationFailedException { 		imports 			.addImports( 					"org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity") 			.addStarImports( 					"org.springframework.security.oauth2.config.annotation.web.configuration", 					"org.springframework.security.access.prepost"); 	}
@Test 	@Ignore("Spring Security Oauth2 autoconfiguration reports bean creation issue with methodSecurityInterceptor") 	public void oauth2Sample() throws Exception { 		String output = this.cli.run("oauth2.groovy"); 		assertTrue("Wrong output: " + output, output.contains("spring.oauth2.clientId")); 		assertTrue("Wrong output: " + output, output.contains("spring.oauth2.secret = ****")); 		assertTrue("Wrong output: " + output, output.contains("spring.oauth2.resourceId")); 		assertTrue("Wrong output: " + output, output.contains("spring.oauth2.authorizationTypes")); 		assertTrue("Wrong output: " + output, output.contains("spring.oauth2.scopes")); 		assertTrue("Wrong output: " + output, output.contains("spring.oauth2.redirectUris")); 	}
@Override 	protected void registerHandlerMethod(Object handler, Method method, 			RequestMappingInfo mapping) { 		if (mapping == null) { 			return; 		} 		String[] patterns = getPatterns(handler, mapping); 		super.registerHandlerMethod(handler, method, withNewPatterns(mapping, patterns)); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping); 			if (paths.length > 0 && this.management.getSecurity().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				paths = this.server.getPathsArray(paths); 				http.requestMatchers().antMatchers(paths); 				String[] endpointPaths = this.server.getPathsArray(getEndpointPaths( 						this.endpointHandlerMapping, false)); 				configureAuthorizeRequests(endpointPaths, http.authorizeRequests()); 				http.httpBasic(); 				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions()); 				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders()); 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
private Health getHealth(Principal principal) { 		long accessTime = System.currentTimeMillis(); 		if (isCacheStale(accessTime) || isSecure(principal) || isUnrestricted()) { 			this.lastAccess = accessTime; 			this.cached = this.delegate.invoke(); 		} 		if (isSecure(principal) || isUnrestricted()) { 			return this.cached; 		} 		return Health.status(this.cached.getStatus()).build(); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] role = this.security.getUser().getRole().toArray(new String[0]); 				http.authorizeRequests().anyRequest().hasAnyRole(role); 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] role = this.security.getUser().getRole().toArray(new String[0]); 				http.authorizeRequests().anyRequest().hasAnyRole(role); 			} 		}
@Autowired 		public void init(AuthenticationManagerBuilder auth) throws Exception { 			// @formatter:off 			auth.inMemoryAuthentication().withUser("dave").password("secret") 					.roles("USER"); 			// @formatter:on 		}
@Bean 	@ConditionalOnMissingBean 	public HealthEndpoint healthEndpoint() { 		HealthEndpoint endpoint = new HealthEndpoint(this.healthAggregator, 				this.healthIndicators); 		endpoint.setSensitive(isHealthEndpointSensitive()); 		return endpoint; 	}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnProperty(prefix = "endpoints.health", name = "enabled", matchIfMissing = true) 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint.addStatusMapping(this.healthMvcEndpointProperties 					.getMapping()); 		} 		return healthMvcEndpoint; 	}
private void configureAuthorizeRequests( 				String[] endpointPaths, 				ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry requests) { 			requests.antMatchers(endpointPaths).permitAll(); 			if (this.endpointHandlerMapping != null) { 				requests.requestMatchers(new PrincipalHandlerRequestMatcher()) 						.permitAll(); 			} 			requests.anyRequest().hasRole(this.management.getSecurity().getRole()); 		}
@Override 	protected void registerHandlerMethod(Object handler, Method method, 			RequestMappingInfo mapping) { 		if (mapping == null) { 			return; 		} 		String[] patterns = getPatterns(handler, mapping); 		if (handlesPrincipal(method)) { 			this.principalHandlers.add(new HandlerMethod(handler, method)); 		} 		super.registerHandlerMethod(handler, method, withNewPatterns(mapping, patterns)); 	}
@RequestMapping 	@ResponseBody 	public Object invoke(Principal principal) { 		if (!this.delegate.isEnabled()) { 			// Shouldn't happen because the request mapping should not be registered 			return new ResponseEntity<Map<String, String>>(Collections.singletonMap( 					"message", "This endpoint is disabled"), HttpStatus.NOT_FOUND); 		} 		Health health = getHealth(principal); 		Status status = health.getStatus(); 		if (this.statusMapping.containsKey(status.getCode())) { 			return new ResponseEntity<Health>(health, this.statusMapping.get(status 					.getCode())); 		} 		return health; 	}
private Health getHealth(Principal principal) { 		Health health = (useCachedValue(principal) ? this.cached : (Health) this.delegate 				.invoke()); 		// Not too worried about concurrent access here, the worst that can happen is the 		// odd extra call to delegate.invoke() 		this.cached = health; 		if (!secure(principal) && this.delegate.isSensitive()) { 			// If not secure we only expose the status 			health = Health.status(health.getStatus()).build(); 		} 		return health; 	}
@Before 	public void init() { 		this.endpoint = mock(HealthEndpoint.class); 		given(this.endpoint.isEnabled()).willReturn(true); 		this.mvc = new HealthMvcEndpoint(this.endpoint); 	}
@Test 	public void unsecureAnonymousAccessUnrestricted() { 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		given(this.endpoint.isSensitive()).willReturn(false); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void unsecureIsNotCachedWhenAnonymousAccessIsUnrestricted() { 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.isSensitive()).willReturn(false); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertTrue(health.getStatus() == Status.DOWN); 	}
@Test 	public void testCustomContextPath() throws Exception { 		ResponseEntity<String> entity = new TestRestTemplate().getForEntity( 				"http://localhost:" + this.port + "/admin/health", String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertTrue("Wrong body: " + entity.getBody(), 				entity.getBody().contains("\"status\":\"UP\"")); 		System.err.println(entity.getBody()); 		assertTrue("Wrong body: " + entity.getBody(), 				entity.getBody().contains("\"hello\":\"world\"")); 	}
@Bean 	@ConditionalOnMissingBean 	public HealthEndpoint healthEndpoint() { 		return new HealthEndpoint(this.healthAggregator, this.healthIndicators); 	}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnProperty(prefix = "endpoints.health", name = "enabled", matchIfMissing = true) 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate); 		boolean secure = this.managementServerProperties.getSecurity() != null 				&& this.managementServerProperties.getSecurity().isEnabled() 				&& ClassUtils.isPresent( 						"org.springframework.security.core.Authentication", null); 		delegate.setSensitive(secure); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint.addStatusMapping(this.healthMvcEndpointProperties 					.getMapping()); 		} 		return healthMvcEndpoint; 	}
@Bean 	public HandlerMapping handlerMapping(MvcEndpoints endpoints, 			ListableBeanFactory beanFactory) { 		Set<MvcEndpoint> set = new HashSet<MvcEndpoint>(endpoints.getEndpoints()); 		set.addAll(beanFactory.getBeansOfType(MvcEndpoint.class).values()); 		EndpointHandlerMapping mapping = new EndpointHandlerMapping(set); 		// In a child context we definitely want to see the parent endpoints 		mapping.setDetectHandlerMethodsInAncestorContexts(true); 		if (this.mappingCustomizers != null) { 			for (EndpointHandlerMappingCustomizer customizer : this.mappingCustomizers) { 				customizer.customize(mapping); 			} 		} 		return mapping; 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping); 			if (paths.length > 0 && this.management.getSecurity().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				paths = this.server.getPathsArray(paths); 				http.requestMatchers().antMatchers(paths); 				String[] endpointPaths = this.server.getPathsArray(getEndpointPaths( 						this.endpointHandlerMapping, false)); 				http.authorizeRequests().antMatchers(endpointPaths).access("permitAll()") 						.anyRequest().hasRole(this.management.getSecurity().getRole()); 				http.httpBasic();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions());  				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
private static String[] getEndpointPaths( 			EndpointHandlerMapping endpointHandlerMapping, boolean secure) { 		if (endpointHandlerMapping == null) { 			return NO_PATHS; 		}  		Set<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints(); 		List<String> paths = new ArrayList<String>(endpoints.size()); 		for (MvcEndpoint endpoint : endpoints) { 			if (endpoint.isSensitive() == secure 					|| (!secure && endpoint instanceof AnonymouslyAccessibleMvcEndpoint)) { 				String path = endpointHandlerMapping.getPath(endpoint.getPath()); 				paths.add(path); 				// Add Spring MVC-generated additional paths 				paths.add(path + "/"); 				paths.add(path + ".*"); 			} 		} 		return paths.toArray(new String[paths.size()]); 	}
@Override 	protected void registerHandlerMethod(Object handler, Method method, 			RequestMappingInfo mapping) {  		if (mapping == null) { 			return; 		}  		Set<String> defaultPatterns = mapping.getPatternsCondition().getPatterns(); 		String[] patterns = new String[defaultPatterns.isEmpty() ? 1 : defaultPatterns 				.size()];  		String path = ""; 		Object bean = handler; 		if (bean instanceof String) { 			bean = getApplicationContext().getBean((String) handler); 		} 		if (bean instanceof MvcEndpoint) { 			MvcEndpoint endpoint = (MvcEndpoint) bean; 			path = endpoint.getPath(); 		}  		int i = 0; 		String prefix = StringUtils.hasText(this.prefix) ? this.prefix + path : path; 		if (defaultPatterns.isEmpty()) { 			patterns[0] = prefix; 		} 		else { 			for (String pattern : defaultPatterns) { 				patterns[i] = prefix + pattern; 				i++; 			} 		} 		PatternsRequestCondition patternsInfo = new PatternsRequestCondition(patterns);  		RequestMappingInfo modified = new RequestMappingInfo(patternsInfo, 				mapping.getMethodsCondition(), mapping.getParamsCondition(), 				mapping.getHeadersCondition(), mapping.getConsumesCondition(), 				mapping.getProducesCondition(), mapping.getCustomCondition());  		super.registerHandlerMethod(handler, method, modified); 	}
@Test 	public void testCustomContextPath() throws Exception { 		ResponseEntity<String> entity = new TestRestTemplate().getForEntity( 				"http://localhost:" + this.port + "/admin/health", String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertTrue("Wrong body: " + entity.getBody(), 				entity.getBody().contains("\"status\":\"UP\"")); 	}
private static String[] getEndpointPaths( 			EndpointHandlerMapping endpointHandlerMapping, boolean secure) { 		if (endpointHandlerMapping == null) { 			return NO_PATHS; 		}  		Set<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints(); 		List<String> paths = new ArrayList<String>(endpoints.size()); 		for (MvcEndpoint endpoint : endpoints) { 			if (endpoint.isSensitive() == secure) { 				String path = endpointHandlerMapping.getPath(endpoint.getPath()); 				paths.add(path); 				// Add Spring MVC-generated additional paths 				paths.add(path + "/"); 				paths.add(path + ".*"); 			} 		} 		return paths.toArray(new String[paths.size()]); 	}
@Test 	public void testEventPublisherInjected() throws Exception { 		testAuthenticationManagerCreated(); 		final AtomicReference<ApplicationEvent> wrapper = new AtomicReference<ApplicationEvent>(); 		this.context.addApplicationListener(new ApplicationListener<ApplicationEvent>() { 			@Override 			public void onApplicationEvent(ApplicationEvent event) { 				wrapper.set(event); 			}; 		}); 		AuthenticationManager manager = this.context.getBean(AuthenticationManager.class); 		try { 			manager.authenticate(new UsernamePasswordAuthenticationToken("foo", "bar")); 			fail("Expected BadCredentialsException"); 		} 		catch (BadCredentialsException e) { 			// expected 		} 		assertTrue(wrapper.get() instanceof AuthenticationFailureBadCredentialsEvent); 	}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return new TestingAuthenticationToken("foo", "bar"); 				}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return new TestingAuthenticationToken("foo", "bar"); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  			String[] paths = getSecureApplicationPaths();  			if (paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.httpBasic(); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests() 						.anyRequest() 						.hasAnyRole( 								this.security.getUser().getRole().toArray(new String[0])); 			}  		}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = getIgnored(this.security); 			String[] paths = this.server.getPathsArray(ignored); 			ignoring.antMatchers(paths); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  			String[] paths = getSecureApplicationPaths();  			if (paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.httpBasic(); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests() 						.anyRequest() 						.hasAnyRole( 								this.security.getUser().getRole().toArray(new String[0])); 			}  		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 5 for static resources and one for the rest 		List<SecurityFilterChain> filterChains = this.context.getBean( 				FilterChainProxy.class).getFilterChains(); 		assertEquals(6, filterChains.size()); 	}
@Test 	public void testDefaultIgnores() { 		assertTrue(SpringBootWebSecurityConfiguration 				.getIgnored(new SecurityProperties()).contains("/error")); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 6 for static resources, one for management endpoints and one for the rest 		assertEquals(8, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				FallbackWebSecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Just the management endpoints (one filter) and ignores now plus the backup 		// filter on app endpoints 		assertEquals(8, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  			String[] paths = getSecureApplicationPaths();  			if (paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.httpBasic(); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests() 						.anyRequest() 						.hasAnyRole( 								this.security.getUser().getRole().toArray(new String[0])); 			}  		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 4 for static resources and one for the rest 		List<SecurityFilterChain> filterChains = this.context.getBean( 				FilterChainProxy.class).getFilterChains(); 		assertEquals(5, filterChains.size()); 	}
@PostConstruct 		public void init() { 			FS commandFileSystem = createFileSystem( 					this.properties.getCommandPathPatterns(), 					this.properties.getDisabledCommands()); 			FS configurationFileSystem = createFileSystem( 					this.properties.getConfigPathPatterns(), new String[0]);  			PluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery( 					this.resourceLoader.getClassLoader(), this.beanFactory, 					this.properties.getDisabledPlugins());  			PluginContext context = new PluginContext(discovery, 					createPluginContextAttributes(), commandFileSystem, 					configurationFileSystem, this.resourceLoader.getClassLoader());  			context.refresh(); 			start(context); 		}
@Override 		public String getName() { 			return "spring"; 		}
@Override 		public void init() { 			String rolesPropertyValue = getContext().getProperty(ROLES); 			if (rolesPropertyValue != null) { 				this.roles = StringUtils 						.commaDelimitedListToStringArray(rolesPropertyValue); 			} 		}
public String getName() { 			return this.name; 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.user.getName()); 			config.put("crash.auth.simple.password", this.user.getPassword()); 			if (this.user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.user.getPassword() + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
public void setRoles(String[] roles) { 			// 'roles' can be empty. This means no special to access right to connect to 			// shell is required. 			Assert.notNull(roles, "roles must not be null"); 			this.roles = roles; 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  			String[] paths = getSecureApplicationPaths(); 			configureAdditionalRules(http, paths);  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  			String[] paths = getSecureApplicationPaths(); 			configureAdditionalRules(http, paths);  		}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Ignores and permitAll() security on application endpoints 		assertEquals(1, this.context.getBeanNamesForType(FilterChainProxy.class).length); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				FallbackWebSecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Just the management endpoints (one filter) and ignores now 		assertEquals(7, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Bean 	@Lazy 	@Scope(proxyMode = ScopedProxyMode.INTERFACES) 	protected AuthenticationManager lazyAuthenticationManager() { 		return this.configurer.getAuthenticationManagerBuilder().getOrBuild(); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests() 						.anyRequest() 						.hasAnyRole( 								this.security.getUser().getRole().toArray(new String[0])) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// No security at all not even ignores 		assertEquals(0, this.context.getBeanNamesForType(FilterChainProxy.class).length); 	}
public static void main(String[] args) throws Exception { 		// Set user password to "password" for demo purposes only 		new SpringApplicationBuilder(SampleWebSecureApplication.class).properties( 				"security.user.password=password").run(args); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().fullyAuthenticated().and().formLogin() 					.loginPage("/login").failureUrl("/login?error").permitAll(); 		}
@Test 	public void testHome() throws Exception { 		HttpHeaders headers = new HttpHeaders(); 		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML)); 		ResponseEntity<String> entity = new TestRestTemplate().exchange( 				"http://localhost:" + this.port, HttpMethod.GET, new HttpEntity<Void>( 						headers), String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertTrue("Wrong body (title doesn't match):\n" + entity.getBody(), entity 				.getBody().contains("<title>Login")); 	}
@Override 	public void customize(ConfigurableEmbeddedServletContainer container) { 		container.addErrorPages(new ErrorPage(this.errorPath)); 	}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			// The ignores are not cumulative, so to prevent overwriting the defaults we 			// add them back. 			List<String> ignored = SpringBootWebSecurityConfiguration 					.getIgnored(this.security); 			ignored.addAll(Arrays.asList(getEndpointPaths(this.endpointHandlerMapping, 					false))); 			if (!this.management.getSecurity().isEnabled()) { 				ignored.addAll(Arrays.asList(getEndpointPaths( 						this.endpointHandlerMapping, true))); 			} 			if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			ignoring.antMatchers(ignored.toArray(new String[0])); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping, true); 			if (paths.length > 0 && this.management.getSecurity().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.management.getSecurity().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions());  				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
@Bean 	@ConditionalOnMissingBean 	@ConditionalOnBean(DataSource.class) 	public JobExplorer jobExplorer(DataSource dataSource) throws Exception { 		JobExplorerFactoryBean factory = new JobExplorerFactoryBean(); 		factory.setDataSource(dataSource); 		factory.afterPropertiesSet(); 		return (JobExplorer) factory.getObject(); 	}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = getIgnored(this.security); 			ignoring.antMatchers(ignored.toArray(new String[0])); 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 4 for static resources and one for the rest 		List<SecurityFilterChain> filterChains = this.context.getBean( 				FilterChainProxy.class).getFilterChains(); 		assertEquals(5, filterChains.size()); 	}
@Test 	public void testDisableIgnoredStaticApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.ignored:none"); 		this.context.refresh(); 		// Just the application endpoints now 		assertEquals(1, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// No security at all not even ignores 		assertEquals(0, this.context.getBeanNamesForType(FilterChainProxy.class).length); 	}
@Test 	public void testAuthenticationManagerCreated() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testOverrideAuthenticationManager() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(TestConfiguration.class, SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertEquals(this.context.getBean(TestConfiguration.class).authenticationManager, 				this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testJpaCoexistsHappily() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(EntityConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class, 				DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class, 				SecurityAutoConfiguration.class); 		// This can fail if security @Conditionals force early instantiation of the 		// HibernateJpaAutoConfiguration (e.g. the EntityManagerFactory is not found) 		this.context.refresh(); 		assertNotNull(this.context.getBean(JpaTransactionManager.class)); 	}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			// The ignores are not cumulative, so to prevent overwriting the defaults we 			// add them back. 			List<String> ignored = SpringBootWebSecurityConfiguration 					.getIgnored(this.security); 			ignored.addAll(Arrays.asList(getEndpointPaths(this.endpointHandlerMapping, 					false))); 			if (!this.management.getSecurity().isEnabled()) { 				ignored.addAll(Arrays.asList(getEndpointPaths( 						this.endpointHandlerMapping, true))); 			} 			if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			ignoring.antMatchers(ignored.toArray(new String[0])); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping, true); 			if (paths.length > 0 && this.management.getSecurity().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.management.getSecurity().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions());  				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = getIgnored(this.security); 			ignoring.antMatchers(ignored.toArray(new String[0])); 		}
@Override 					public void customize(Connector connector) { 						ProtocolHandler handler = connector.getProtocolHandler(); 						if (handler instanceof AbstractProtocol) { 							AbstractProtocol protocol = (AbstractProtocol) handler; 							protocol.setMaxThreads(Tomcat.this.maxThreads); 						} 					}
@Override 					public void customize(Connector connector) { 						ProtocolHandler handler = connector.getProtocolHandler(); 						if (handler instanceof AbstractHttp11Protocol) { 							AbstractHttp11Protocol protocol = (AbstractHttp11Protocol) handler; 							protocol.setMaxHttpHeaderSize(Tomcat.this.maxHttpHeaderSize); 						} 					}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 4 for static resources and one for the rest 		List<SecurityFilterChain> filterChains = this.context.getBean( 				FilterChainProxy.class).getFilterChains(); 		assertEquals(5, filterChains.size()); 	}
@Test 	public void testDisableIgnoredStaticApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.ignored:none"); 		this.context.refresh(); 		// Just the application endpoints now 		assertEquals(1, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// No security at all not even ignores 		assertEquals(0, this.context.getBeanNamesForType(FilterChainProxy.class).length); 	}
@Test 	public void testAuthenticationManagerCreated() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testOverrideAuthenticationManager() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(TestConfiguration.class, SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertEquals(this.context.getBean(TestConfiguration.class).authenticationManager, 				this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testJpaCoexistsHappily() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.datasource.url:jdbc:hsqldb:mem:testsecdb"); 		this.context.register(EntityConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class, 				DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class, 				SecurityAutoConfiguration.class); 		// This can fail if security @Conditionals force early instantiation of the 		// HibernateJpaAutoConfiguration (e.g. the EntityManagerFactory is not found) 		this.context.refresh(); 		assertNotNull(this.context.getBean(JpaTransactionManager.class)); 	}
public static void main(String[] args) throws Exception { 		new SpringApplicationBuilder(SampleMethodSecurityApplication.class).run(args); 	}
@Override 		public void init(AuthenticationManagerBuilder auth) throws Exception { 			// @formatter:off 			auth.inMemoryAuthentication().withUser("admin").password("admin") 					.roles("ADMIN", "USER").and().withUser("user").password("user") 					.roles("USER"); 			// @formatter:on 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// @formatter:off 			http.authorizeRequests().antMatchers("/login").permitAll().anyRequest() 					.fullyAuthenticated().and().formLogin().loginPage("/login") 					.failureUrl("/login?error").and().logout() 					.logoutRequestMatcher(new AntPathRequestMatcher("/logout")).and() 					.exceptionHandling().accessDeniedPage("/access?error"); 			// @formatter:on 		}
public static void main(String[] args) throws Exception { 		// Set user password to "password" for demo purposes only 		new SpringApplicationBuilder(SampleWebSecureApplication.class).properties( 				"security.user.password=password").run(args); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().fullyAuthenticated().and().formLogin() 					.loginPage("/login").failureUrl("/login?error").permitAll(); 		}
@Override 		public void configure(AuthenticationManagerBuilder auth) throws Exception { 			if (auth.isConfigured()) { 				this.defaultAuth = auth; 				return; 			}  			User user = AuthenticationManagerConfiguration.this.security.getUser(); 			if (user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for application endpoints: " 						+ user.getPassword() + "\n\n"); 			}  			this.defaultAuth = new AuthenticationManagerBuilder( 					AuthenticationManagerConfiguration.this.objectPostProcessor);  			Set<String> roles = new LinkedHashSet<String>(user.getRole());  			AuthenticationManager parent = this.defaultAuth.inMemoryAuthentication() 					.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()])).and().and().build();  			auth.parentAuthenticationManager(parent); 		}
@Test 	public void testBindingIgnoredSingleValued() { 		SecurityProperties security = new SecurityProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.ignored", "/css/**"))); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertEquals(1, security.getIgnored().size()); 	}
@Test 	public void testBindingIgnoredEmpty() { 		SecurityProperties security = new SecurityProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.setConversionService(new DefaultConversionService()); 		binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.ignored", ""))); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertEquals(0, security.getIgnored().size()); 	}
@Test 	public void testBindingIgnoredDisable() { 		SecurityProperties security = new SecurityProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.setConversionService(new DefaultConversionService()); 		binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.ignored", "none"))); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertEquals(1, security.getIgnored().size()); 	}
@Test 	public void testBindingIgnoredMultiValued() { 		SecurityProperties security = new SecurityProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.setConversionService(new DefaultConversionService()); 		binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.ignored", "/css/**,/images/**"))); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertEquals(2, security.getIgnored().size()); 	}
@Test 	public void testBindingIgnoredMultiValuedList() { 		SecurityProperties security = new SecurityProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.setConversionService(new DefaultConversionService()); 		Map<String, String> map = new HashMap<String, String>(); 		map.put("security.ignored[0]", "/css/**"); 		map.put("security.ignored[1]", "/foo/**"); 		binder.bind(new MutablePropertyValues(map)); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertEquals(2, security.getIgnored().size()); 		assertTrue(security.getIgnored().contains("/foo/**")); 	}
@Test 	public void testDefaultPasswordAutogeneratedIfUnresolovedPlaceholder() { 		SecurityProperties security = new SecurityProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.user.password", "${ADMIN_PASSWORD}"))); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertTrue(security.getUser().isDefaultPassword()); 	}
@Test 	public void testDefaultPasswordAutogeneratedIfEmpty() { 		SecurityProperties security = new SecurityProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.user.password", ""))); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertTrue(security.getUser().isDefaultPassword()); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Just the management endpoints (one filter) and ignores now 		assertEquals(7, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
public static void main(String[] args) throws Exception { 		// Set user password to "password" for demo purposes only 		new SpringApplicationBuilder(SampleSecureApplication.class).properties( 				"security.basic.enabled=false", "security.user.password=password").run( 				args); 	}
@Override 	public final boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { 		String classOrMethodName = getClassOrMethodName(metadata); 		ConditionOutcome outcome = getMatchOutcome(context, metadata); 		logOutcome(classOrMethodName, outcome); 		recordEvaluation(context, classOrMethodName, outcome); 		return outcome.isMatch(); 	}
@Override 	public void init(AuthenticationManagerBuilder auth) throws Exception { 		auth.apply(new BootDefaultingAuthenticationConfigurerAdapter()); 	}
@Override 		public void configure(AuthenticationManagerBuilder auth) throws Exception { 			if (auth.isConfigured()) { 				return; 			}  			User user = AuthenticationManagerConfiguration.this.security.getUser(); 			if (user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for application endpoints: " 						+ user.getPassword() + "\n\n"); 			}  			AuthenticationManagerBuilder defaultAuth = new AuthenticationManagerBuilder( 					AuthenticationManagerConfiguration.this.objectPostProcessor);  			Set<String> roles = new LinkedHashSet<String>(user.getRole());  			AuthenticationManager parent = defaultAuth.inMemoryAuthentication() 					.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()])).and().and().build();  			auth.parentAuthenticationManager(parent); 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		debugRefresh(this.context); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 4 for static resources and one for the rest 		List<SecurityFilterChain> filterChains = this.context.getBean( 				FilterChainProxy.class).getFilterChains(); 		assertEquals(5, filterChains.size()); 	}
private UserDetails getUser() { 		ProviderManager manager = this.context.getBean(ProviderManager.class); 		ProviderManager parent = (ProviderManager) ReflectionTestUtils.getField( 				manager, "parent"); 		DaoAuthenticationProvider provider = (DaoAuthenticationProvider) parent 				.getProviders().get(0); 		UserDetailsService service = (UserDetailsService) ReflectionTestUtils.getField( 				provider, "userDetailsService"); 		UserDetails user = service.loadUserByUsername("user"); 		return user; 	}
@Test 	public void testSecurityPropertiesNotAvailable() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(TestConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertEquals(this.context.getBean(TestConfiguration.class).authenticationManager, 				this.context.getBean(AuthenticationManager.class)); 	}
@Override 		public void configure(AuthenticationManagerBuilder auth) 				throws Exception { 			if(auth.isConfigured()) { 				return; 			}  			User user = AuthenticationManagerConfiguration.this.security.getUser(); 			if (user.isDefaultPassword()) { 				logger.info("\n\nUsing default password for application endpoints: " 						+ user.getPassword() + "\n\n"); 			}  			AuthenticationManagerBuilder defaultAuth = new AuthenticationManagerBuilder(objectPostProcessor);  			Set<String> roles = new LinkedHashSet<String>(user.getRole());  			AuthenticationManager parent = defaultAuth. 				inMemoryAuthentication() 					.withUser(user.getName()) 						.password(user.getPassword()) 						.roles(roles.toArray(new String[roles.size()])) 						.and() 					.and() 				.build();  			auth.parentAuthenticationManager(parent); 		}
@Before 	public void init() { 		AuthenticationManager authenticationManager = context 				.getBean(AuthenticationManager.class); 		authentication = authenticationManager 				.authenticate(new UsernamePasswordAuthenticationToken("user", "password")); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 		// 6 for static resources, one for management endpoints and one for the rest 		assertEquals(8, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testWebConfigurationWithExtraRole() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(EndpointAutoConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		debugRefresh(this.context); 		UserDetails user = getUser(); 		assertTrue(user.getAuthorities().containsAll( 				AuthorityUtils 						.commaSeparatedStringToAuthorityList("ROLE_USER,ROLE_ADMIN"))); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		debugRefresh(this.context); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 		// 4 for static resources and one for the rest 		assertEquals(5, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
public static void main(String[] args) throws Exception { 		SpringApplication.run(SampleSecureApplication.class, args); 	}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.ssh.port", this.port); 				if (this.keyPath != null) { 					config.put("crash.ssh.keypath", this.keyPath); 				} 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			if (this.enabled) { 				config.put("crash.telnet.port", this.port); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "jaas"); 			config.put("crash.auth.jaas.domain", this.domain); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "key"); 			if (this.path != null) { 				config.put("crash.auth.key.path", this.path); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.username); 			config.put("crash.auth.simple.password", this.password); 			if (this.defaultPassword) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.password + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.username); 			config.put("crash.auth.simple.password", this.password); 			if (this.defaultPassword) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.password + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.username); 			config.put("crash.auth.simple.password", this.password); 			if (this.defaultPassword) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.password + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.username); 			config.put("crash.auth.simple.password", this.password); 			if (this.defaultPassword) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.password + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.username); 			config.put("crash.auth.simple.password", this.password); 			if (this.defaultPassword) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.password + "\n\n"); 			} 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "simple"); 			config.put("crash.auth.simple.username", this.username); 			config.put("crash.auth.simple.password", this.password); 			if (this.defaultPassword) { 				logger.info("\n\nUsing default password for shell access: " 						+ this.password + "\n\n"); 			} 		}
boolean isDefaultPassword() { 			return this.defaultPassword; 		}
public void setPassword(String password) { 			if (password.startsWith("${") && password.endsWith("}") 					|| !StringUtils.hasLength(password)) { 				return; 			} 			this.password = password; 			this.defaultPassword = false; 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Override 		protected void applyToCrshShellConfig(Properties config) { 			config.put("crash.auth", "spring"); 			config.put("crash.auth.spring.roles", 					StringUtils.arrayToCommaDelimitedString(this.roles)); 		}
@Test 	public void testSimpleAuthenticationProvider() throws Exception { 		MockEnvironment env = new MockEnvironment(); 		env.setProperty("shell.auth", "simple"); 		env.setProperty("shell.auth.simple.username", "user"); 		env.setProperty("shell.auth.simple.password", "password"); 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setEnvironment(env); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityConfiguration.class); 		this.context.register(CrshAutoConfiguration.class); 		this.context.refresh();  		PluginLifeCycle lifeCycle = this.context.getBean(PluginLifeCycle.class); 		assertEquals(lifeCycle.getConfig().get("crash.auth"), "simple");  		AuthenticationPlugin<String> authenticationPlugin = null; 		String authentication = lifeCycle.getConfig().getProperty("crash.auth"); 		assertNotNull(authentication); 		for (AuthenticationPlugin plugin : lifeCycle.getContext().getPlugins( 				AuthenticationPlugin.class)) { 			if (authentication.equals(plugin.getName())) { 				authenticationPlugin = plugin; 				break; 			} 		} 		assertNotNull(authenticationPlugin); 		assertTrue(authenticationPlugin.authenticate("user", "password")); 		assertFalse(authenticationPlugin.authenticate(UUID.randomUUID().toString(), 				"password")); 	}
@Test 	public void testBindingSimple() { 		SimpleAuthenticationProperties props = new SimpleAuthenticationProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(props, "shell.auth.simple"); 		binder.setConversionService(new DefaultConversionService()); 		Map<String, String> map = new HashMap<String, String>(); 		map.put("shell.auth.simple.username", "username123"); 		map.put("shell.auth.simple.password", "password123"); 		binder.bind(new MutablePropertyValues(map)); 		assertFalse(binder.getBindingResult().hasErrors());  		Properties p = new Properties(); 		props.applyToCrshShellConfig(p);  		assertEquals("username123", p.get("crash.auth.simple.username")); 		assertEquals("password123", p.get("crash.auth.simple.password")); 	}
@Test 	public void testDefaultPasswordAutogeneratedIfUnresolovedPlaceholder() { 		SimpleAuthenticationProperties security = new SimpleAuthenticationProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"shell.auth.simple.password", "${ADMIN_PASSWORD}"))); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertTrue(security.isDefaultPassword()); 	}
@Test 	public void testDefaultPasswordAutogeneratedIfEmpty() { 		SimpleAuthenticationProperties security = new SimpleAuthenticationProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"shell.auth.simple.password", ""))); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertTrue(security.isDefaultPassword()); 	}
@Bean 	@ConditionalOnExpression("'${shell.auth:simple}' == 'spring'") 	@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 	public CrshShellAuthenticationProperties springAuthenticationProperties() { 		return new SpringAuthenticationProperties(); 	}
@Bean 		@ConditionalOnExpression("'${shell.auth:default_spring}' == 'default_spring'") 		@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 		public CrshShellAuthenticationProperties springAuthenticationProperties() { 			// In case no shell.auth property is provided fall back to Spring Security 			// based authentication and get role to access shell from SecurityProperties. 			SpringAuthenticationProperties authenticationProperties = new SpringAuthenticationProperties(); 			if (this.management != null) { 				authenticationProperties.setRoles(new String[] { this.management 						.getSecurity().getRole() }); 			} 			return authenticationProperties; 		}
@Bean 		@ConditionalOnExpression("'${shell.auth:default_spring}' == 'default_spring'") 		@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 		public CrshShellAuthenticationProperties springAuthenticationProperties() { 			// In case no shell.auth property is provided fall back to Spring Security 			// based authentication and get role to access shell from SecurityProperties. 			SpringAuthenticationProperties authenticationProperties = new SpringAuthenticationProperties(); 			if (this.management != null) { 				authenticationProperties.setRoles(new String[] { this.management 						.getSecurity().getRole() }); 			} 			return authenticationProperties; 		}
@PostConstruct 		public void init() throws Exception { 			FS commandFileSystem = createFileSystem(this.properties 					.getCommandPathPatterns()); 			FS configurationFileSystem = createFileSystem(this.properties 					.getConfigPathPatterns());  			PluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery( 					this.resourceLoader.getClassLoader(), this.beanFactory, 					this.properties.getDisabledPlugins());  			PluginContext context = new PluginContext(discovery, 					createPluginContextAttributes(), commandFileSystem, 					configurationFileSystem, this.resourceLoader.getClassLoader());  			context.refresh(); 			start(context); 		}
@Override 		public String getName() { 			return "spring"; 		}
@Override 		public void init() { 			String rolesPropertyValue = getContext().getProperty(ROLES); 			if (rolesPropertyValue != null) { 				this.roles = StringUtils 						.commaDelimitedListToStringArray(rolesPropertyValue); 			} 		}
public String getName() { 			return this.name; 		}
@Bean 	@ConditionalOnExpression("'${shell.auth:simple}' == 'spring'") 	@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 	public CrshShellAuthenticationProperties springAuthenticationProperties() { 		return new SpringAuthenticationProperties(); 	}
@Bean 		@ConditionalOnExpression("'${shell.auth:default_spring}' == 'default_spring'") 		@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 		public CrshShellAuthenticationProperties springAuthenticationProperties() { 			// In case no shell.auth property is provided fall back to Spring Security 			// based authentication and get role to access shell from SecurityProperties. 			SpringAuthenticationProperties authenticationProperties = new SpringAuthenticationProperties(); 			if (this.securityProperties != null) { 				authenticationProperties.setRoles(new String[] { this.securityProperties 						.getManagement().getRole() }); 			} 			return authenticationProperties; 		}
@Bean 		@ConditionalOnExpression("'${shell.auth:default_spring}' == 'default_spring'") 		@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 		public CrshShellAuthenticationProperties springAuthenticationProperties() { 			// In case no shell.auth property is provided fall back to Spring Security 			// based authentication and get role to access shell from SecurityProperties. 			SpringAuthenticationProperties authenticationProperties = new SpringAuthenticationProperties(); 			if (this.securityProperties != null) { 				authenticationProperties.setRoles(new String[] { this.securityProperties 						.getManagement().getRole() }); 			} 			return authenticationProperties; 		}
@PostConstruct 		public void init() throws Exception { 			FS commandFileSystem = createFileSystem(this.properties 					.getCommandPathPatterns()); 			FS configurationFileSystem = createFileSystem(this.properties 					.getConfigPathPatterns());  			PluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery( 					this.resourceLoader.getClassLoader(), this.beanFactory, 					this.properties.getDisabledPlugins());  			PluginContext context = new PluginContext(discovery, 					createPluginContextAttributes(), commandFileSystem, 					configurationFileSystem, this.resourceLoader.getClassLoader());  			context.refresh(); 			start(context); 		}
@Override 		public String getName() { 			return "spring"; 		}
@Override 		public void init() { 			String rolesPropertyValue = getContext().getProperty(ROLES); 			if (rolesPropertyValue != null) { 				this.roles = StringUtils 						.commaDelimitedListToStringArray(rolesPropertyValue); 			} 		}
public String getName() { 			return this.name; 		}
public static ManagementServerPort get(ApplicationContext beanFactory) {  			ServerProperties serverProperties; 			try { 				serverProperties = beanFactory.getBean(ServerProperties.class); 			} 			catch (NoSuchBeanDefinitionException ex) { 				serverProperties = new ServerProperties(); 			}  			ManagementServerProperties managementServerProperties; 			try { 				managementServerProperties = beanFactory 						.getBean(ManagementServerProperties.class); 			} 			catch (NoSuchBeanDefinitionException ex) { 				managementServerProperties = new ManagementServerProperties(); 			}  			if (DISABLED_PORT.equals(managementServerProperties.getPort())) { 				return DISABLE; 			} 			if (!(beanFactory instanceof GenericWebApplicationContext)) { 				// Current context is no a a webapp 				return DIFFERENT; 			} 			return managementServerProperties.getPort() == null 					|| serverProperties.getPort() == null 					&& managementServerProperties.getPort().equals(8080) 					|| managementServerProperties.getPort().equals( 							serverProperties.getPort()) ? SAME : DIFFERENT; 		}
@Test 	public void securityDependencies() throws Exception { 		this.cli.run("secure.groovy"); 		assertThat(this.cli.getHttpOutput(), 				containsString("{\"message\":\"Hello World\"}")); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return SpringApplication.run( 										SampleActuatorApplication.class, 										"--security.management.enabled=false"); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@Override 							public ConfigurableApplicationContext call() throws Exception { 								return SpringApplication.run( 										SampleActuatorApplication.class, 										"--security.management.enabled=false"); 							}
@Override 	public void initialize(SpringApplication springApplication, String[] args) { 		if (System.getProperty("PID") == null) { 			System.setProperty("PID", getPid()); 		} 		LoggingSystem loggingSystem = LoggingSystem.get(springApplication.getClass() 				.getClassLoader()); 		loggingSystem.beforeInitialize(); 		if (this.parseArgs && this.springBootLogging == null 				&& !ObjectUtils.isEmpty(args)) { 			SimpleCommandLinePropertySource parsedArgs = new SimpleCommandLinePropertySource( 					args); 			if (parsedArgs.containsProperty("debug")) { 				this.springBootLogging = LogLevel.DEBUG; 			} 			if (parsedArgs.containsProperty("trace")) { 				this.springBootLogging = LogLevel.TRACE; 			} 		} 	}
@Override 	public void initialize(ConfigurableApplicationContext applicationContext) {  		ConfigurableEnvironment environment = applicationContext.getEnvironment();  		for (Map.Entry<String, String> mapping : ENVIRONMENT_SYSTEM_PROPERTY_MAPPING 				.entrySet()) { 			if (environment.containsProperty(mapping.getKey())) { 				System.setProperty(mapping.getValue(), 						environment.getProperty(mapping.getKey())); 			} 		}  		LoggingSystem system = LoggingSystem.get(applicationContext.getClassLoader());  		// User specified configuration 		if (environment.containsProperty("logging.config")) { 			String value = environment.getProperty("logging.config"); 			try { 				ResourceUtils.getURL(value).openStream().close(); 				system.initialize(value); 				return; 			} 			catch (Exception ex) { 				// Swallow exception and continue 			} 			this.logger.warn("Logging environment value '" + value 					+ "' cannot be opened and will be ignored"); 		}  		system.initialize(); 		if (this.springBootLogging != null) { 			initializeLogLevel(system, this.springBootLogging); 		} 	}
@Test 	public void parseDebugArg() throws Exception { 		this.initializer.initialize(this.springApplication, new String[] { "--debug" }); 		this.initializer.initialize(this.context); 		this.logger.debug("testatdebug"); 		this.logger.trace("testattrace"); 		assertThat(this.outputCapture.toString(), containsString("testatdebug")); 		assertThat(this.outputCapture.toString(), not(containsString("testattrace"))); 	}
@Test 	public void parseTraceArg() throws Exception { 		this.context = new GenericApplicationContext(); 		this.initializer.initialize(this.springApplication, new String[] { "--trace" }); 		this.initializer.initialize(this.context); 		this.logger.debug("testatdebug"); 		this.logger.trace("testattrace"); 		assertThat(this.outputCapture.toString(), containsString("testatdebug")); 		assertThat(this.outputCapture.toString(), containsString("testattrace")); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping, true); 			if (paths.length > 0 && this.security.getManagement().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.security.getManagement().getSessions());  				SecurityAutoConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = new ArrayList<String>(this.security.getIgnored()); 			if (!this.security.getManagement().isEnabled()) { 				ignored.addAll(Arrays.asList(getEndpointPaths( 						this.endpointHandlerMapping, true))); 			} 			if (ignored.isEmpty()) { 				ignored.addAll(DEFAULT_IGNORED); 			} 			else if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(this.errorController.getErrorPath()); 			} 			ignoring.antMatchers(ignored.toArray(new String[0])); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping, true); 			if (paths.length > 0 && this.security.getManagement().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.security.getManagement().getSessions());  				SecurityAutoConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = new ArrayList<String>(); 			if (!this.security.getBasic().isEnabled()) { 				ignored.addAll(this.security.getIgnored()); 				if (ignored.isEmpty()) { 					ignored.addAll(DEFAULT_IGNORED); 				} 				else if (ignored.contains("none")) { 					ignored.remove("none"); 				} 			} 			ignored.addAll(Arrays.asList(getEndpointPaths(this.endpointHandlerMapping, 					false))); 			ignoring.antMatchers(ignored.toArray(new String[0])); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = new ArrayList<String>(this.security.getIgnored()); 			if (ignored.isEmpty()) { 				ignored.addAll(DEFAULT_IGNORED); 			} 			else if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(this.errorController.getErrorPath()); 			} 			ignoring.antMatchers(ignored.toArray(new String[0])); 		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = new ArrayList<String>(this.security.getIgnored()); 			if (ignored.isEmpty()) { 				ignored.addAll(DEFAULT_IGNORED); 			} 			else if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(this.errorController.getErrorPath()); 			} 			ignoring.antMatchers(ignored.toArray(new String[0])); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			String[] paths = getEndpointPaths(true); // secure endpoints 			if (paths.length > 0 && this.security.getManagement().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.security.getManagement().getSessions());  				SecurityAutoConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			String[] paths = getEndpointPaths(true); // secure endpoints 			if (paths.length > 0 && this.security.getManagement().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.security.getManagement().getSessions());  				SecurityAutoConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(getEndpointPaths(false)); 		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(getEndpointPaths(false)); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			List<String> ignored = new ArrayList<String>(this.security.getIgnored()); 			if (ignored.isEmpty()) { 				ignored.addAll(DEFAULT_IGNORED); 			} 			else if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(this.errorController.getErrorPath()); 			} 			ignoring.antMatchers(ignored.toArray(new String[0])); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getEndpointPaths(true); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// No cookies for management endpoints by default 			http.csrf().disable(); 			http.sessionManagement().sessionCreationPolicy( 					this.security.getManagement().getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getEndpointPaths(true); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// No cookies for management endpoints by default 			http.csrf().disable(); 			http.sessionManagement().sessionCreationPolicy( 					this.security.getManagement().getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(getEndpointPaths(false)); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception {  			InMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder> builder = new AuthenticationManagerBuilder( 					ObjectPostProcessor.QUIESCENT_POSTPROCESSOR).inMemoryAuthentication(); 			User user = this.security.getUser();  			if (user.isDefaultPassword()) { 				logger.info("Using default password for application endpoints: " 						+ user.getPassword()); 			}  			Set<String> roles = new LinkedHashSet<String>(Arrays.asList(this.security 					.getManagement().getRole(), user.getRole()));  			builder.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()]));  			return builder.and().build();  		}
public SessionCreationPolicy getSessions() { 		return this.sessions; 	}
public void setSessions(SessionCreationPolicy sessions) { 		this.sessions = sessions; 	}
public SessionCreationPolicy getSessions() { 			return this.sessions; 		}
public void setSessions(SessionCreationPolicy sessions) { 			this.sessions = sessions; 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(this.security.getIgnoredPaths()); 			if (this.errorController != null) { 				ignoring.antMatchers(this.errorController.getErrorPath()); 			} 		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(this.security.getIgnoredPaths()); 			if (this.errorController != null) { 				ignoring.antMatchers(this.errorController.getErrorPath()); 			} 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getEndpointPaths(true); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// No cookies for management endpoints by default 			http.csrf().disable(); 			http.sessionManagement().sessionCreationPolicy( 					this.security.getManagement().getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(getEndpointPaths(false)); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception {  			InMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder> builder = new AuthenticationManagerBuilder( 					ObjectPostProcessor.QUIESCENT_POSTPROCESSOR).inMemoryAuthentication(); 			User user = this.security.getUser();  			if (user.isDefaultPassword()) { 				logger.info("Using default password for application endpoints: " 						+ user.getPassword()); 			}  			Set<String> roles = new LinkedHashSet<String>(Arrays.asList(this.security 					.getManagement().getRole(), user.getRole()));  			builder.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()]));  			return builder.and().build();  		}
public SessionCreationPolicy getSessions() { 		return this.sessions; 	}
public void setSessions(SessionCreationPolicy sessions) { 		this.sessions = sessions; 	}
public SessionCreationPolicy getSessions() { 			return this.sessions; 		}
public void setSessions(SessionCreationPolicy sessions) { 			this.sessions = sessions; 		}
@Test 	public void testDisableIgnoredStaticApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		TestUtils.addEnviroment(this.context, "security.ignored:"); 		this.context.refresh(); 		// Just the application and\ management endpoints now 		assertEquals(2, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testBindingIgnoredMultiValuedList() { 		SecurityProperties security = new SecurityProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.setConversionService(new DefaultConversionService()); 		Map<String, String> map = new HashMap<String, String>(); 		map.put("security.ignored[0]", "/css/**"); 		map.put("security.ignored[1]", "images/**"); 		binder.bind(new MutablePropertyValues(map)); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertEquals(2, security.getIgnored().size()); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(this.security.getIgnored()); 			if (this.errorController != null) { 				ignoring.antMatchers(this.errorController.getErrorPath()); 			} 		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(this.security.getIgnored()); 			if (this.errorController != null) { 				ignoring.antMatchers(this.errorController.getErrorPath()); 			} 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getEndpointPaths(true); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// No cookies for management endpoints by default 			http.csrf().disable(); 			http.sessionManagement().sessionCreationPolicy( 					this.security.getManagement().getSessions());  			SecurityAutoConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(getEndpointPaths(false)); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception {  			InMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder> builder = new AuthenticationManagerBuilder( 					ObjectPostProcessor.QUIESCENT_POSTPROCESSOR).inMemoryAuthentication(); 			User user = this.security.getUser();  			if (user.isDefaultPassword()) { 				logger.info("Using default password for application endpoints: " 						+ user.getPassword()); 			}  			Set<String> roles = new LinkedHashSet<String>(Arrays.asList(this.security 					.getManagement().getRole(), user.getRole()));  			builder.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()]));  			return builder.and().build();  		}
public SessionCreationPolicy getSessions() { 		return this.sessions; 	}
public void setSessions(SessionCreationPolicy sessions) { 		this.sessions = sessions; 	}
public SessionCreationPolicy getSessions() { 			return this.sessions; 		}
public void setSessions(SessionCreationPolicy sessions) { 			this.sessions = sessions; 		}
@Test 	public void testBindingIgnoredSingleValued() { 		SecurityProperties security = new SecurityProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.ignored", "/css/**"))); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertEquals(1, security.getIgnored().length); 	}
@Test 	public void testBindingIgnoredMultiValued() { 		SecurityProperties security = new SecurityProperties(); 		RelaxedDataBinder binder = new RelaxedDataBinder(security, "security"); 		binder.setConversionService(new DefaultConversionService()); 		binder.bind(new MutablePropertyValues(Collections.singletonMap( 				"security.ignored", "/css/**,/images/**"))); 		assertFalse(binder.getBindingResult().hasErrors()); 		assertEquals(2, security.getIgnored().length); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// Remove this when session creation is disabled by default 			http.csrf().disable(); 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// Remove this when session creation is disabled by default 			http.csrf().disable(); 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(this.security.getIgnored()); 			if (this.errorController != null) { 				ignoring.antMatchers(this.errorController.getErrorPath()); 			} 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getEndpointPaths(true); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// No cookies for management endpoints by default 			http.csrf().disable(); 			http.sessionManagement().sessionCreationPolicy( 					this.security.getManagement().getSessions());  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getEndpointPaths(true); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// No cookies for management endpoints by default 			http.csrf().disable(); 			http.sessionManagement().sessionCreationPolicy( 					this.security.getManagement().getSessions());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(getEndpointPaths(false)); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception {  			InMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder> builder = new AuthenticationManagerBuilder( 					ObjectPostProcessor.QUIESCENT_POSTPROCESSOR).inMemoryAuthentication(); 			User user = this.security.getUser();  			if (user.isDefaultPassword()) { 				logger.info("Using default password for application endpoints: " 						+ user.getPassword()); 			}  			Set<String> roles = new LinkedHashSet<String>(Arrays.asList(this.security 					.getManagement().getRole(), user.getRole()));  			builder.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()]));  			return builder.and().build();  		}
public SessionCreationPolicy getSessions() { 		return this.sessions; 	}
public void setSessions(SessionCreationPolicy sessions) { 		this.sessions = sessions; 	}
public SessionCreationPolicy getSessions() { 			return this.sessions; 		}
public void setSessions(SessionCreationPolicy sessions) { 			this.sessions = sessions; 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getUser().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// Remove this when session creation is disabled by default 			http.csrf().disable(); 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(this.security.getIgnored()); 			if (this.errorController != null) { 				ignoring.antMatchers(this.errorController.getErrorPath()); 			} 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getEndpointPaths(true); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.security.getManagement().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			// No cookies for management endpoints by default 			http.csrf().disable(); 			http.sessionManagement().sessionCreationPolicy( 					this.security.getManagement().getSessions());  		}
@Override 		public void configure(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			ignoring.antMatchers(getEndpointPaths(false)); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception {  			InMemoryUserDetailsManagerConfigurer<AuthenticationManagerBuilder> builder = new AuthenticationManagerBuilder( 					ObjectPostProcessor.QUIESCENT_POSTPROCESSOR).inMemoryAuthentication(); 			User user = this.security.getUser();  			if (user.isDefaultPassword()) { 				logger.info("Using default password for application endpoints: " 						+ user.getPassword()); 			}  			Set<String> roles = new LinkedHashSet<String>(Arrays.asList(this.security 					.getManagement().getRole(), user.getRole()));  			builder.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()]));  			return builder.and().build();  		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (this.security.getBasic().isEnabled()) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.httpBasic().and().anonymous().disable(); 				ExpressionUrlAuthorizationConfigurer<HttpSecurity> authorizeUrls = http 						.authorizeUrls(); 				if (getEndpointPaths(true).length > 0) { 					authorizeUrls.antMatchers(getEndpointPaths(true)).hasRole( 							this.management.getUser().getRole()); 				} 				authorizeUrls.antMatchers(getSecureApplicationPaths()) 						.hasRole(this.security.getBasic().getRole()).and().httpBasic(); 			}  			// No cookies for service endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 		}
private String[] getSecureApplicationPaths() { 			List<String> list = new ArrayList<String>(); 			for (String path : this.security.getBasic().getPath()) { 				path = (path == null ? "" : path.trim()); 				if (path.equals("/**")) { 					return new String[] { path }; 				} 				if (!path.equals("")) { 					list.add(path); 				} 			} 			list.addAll(Arrays.asList(getEndpointPaths(true))); 			return list.toArray(new String[list.size()]); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			User user = this.management.getUser(); 			if (user.isDefaultPassword()) { 				logger.info("Using default password for management endpoints: " 						+ user.getPassword()); 			} 			List<String> roles = new ArrayList<String>(); 			roles.add("USER"); 			if (!"USER".equals(user.getRole())) { 				roles.add(user.getRole()); 			} 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser(user.getName()).password(user.getPassword()) 					.roles(roles.toArray(new String[roles.size()])).and().and().build(); 		}
@BeforeClass 	public static void start() throws Exception { 		final String[] args = new String[] { "--server.port=" + port, 				"--management.port=" + managementPort, "--management.address=127.0.0.1" }; 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorUiApplication.class, args); 							} 						}); 		context = future.get(10, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorUiApplication.class); 							} 						}); 		context = future.get(30, TimeUnit.SECONDS); 	}
private void start(final Class<?> configuration, final String... args) 			throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(configuration, args); 							} 						}); 		this.context = future.get(10, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		final String[] args = new String[] { "--server.port=" + port, 				"--management.port=" + managementPort }; 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorApplication.class, args); 							} 						}); 		context = future.get(30, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		final String[] args = new String[] { "--server.port=" + port, 				"--management.port=" + managementPort, "--management.address=127.0.0.1" }; 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorApplication.class, args); 							} 						}); 		context = future.get(30, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		final String[] args = new String[] { "--management.port=" + managementPort }; 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorApplication.class, args); 							} 						}); 		context = future.get(10, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorApplication.class); 							} 						}); 		context = future.get(30, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorApplication.class); 							} 						}); 		context = future.get(10, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleActuatorApplication.class, 												"--security.basic.enabled=false"); 							} 						}); 		context = future.get(10, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleJettyApplication.class); 							} 						}); 		context = future.get(10, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleTraditionalApplication.class); 							} 						}); 		context = future.get(30, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleWebStaticApplication.class); 							} 						}); 		context = future.get(30, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleWebUiApplication.class); 							} 						}); 		context = future.get(30, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleWebSocketsApplication.class); 							} 						}); 		context = future.get(30, TimeUnit.SECONDS); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (this.security.getBasic().isEnabled()) { 				String[] paths = getSecurePaths(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint()).and() 						.requestMatchers().antMatchers(paths); 				http.httpBasic().and().anonymous().disable(); 				http.authorizeUrls().anyRequest() 						.hasRole(this.security.getBasic().getRole()); 			}  			// No cookies for service endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser("user").password("password").roles("USER").and().and() 					.build(); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser("user").password("password").roles("USER").and().and() 					.build(); 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testOverrideAuthenticationManager() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(TestConfiguration.class, SecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertEquals(this.context.getBean(TestConfiguration.class).authenticationManager, 				this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:" + port, Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:8080", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test(expected = ResourceAccessException.class) 	public void testMetricsNotAvailable() throws Exception { 		testHome(); // makes sure some requests have been made 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:" + managementPort + "/metrics", Map.class); 		assertEquals(HttpStatus.NOT_FOUND, entity.getStatusCode()); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:8080", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testMetrics() throws Exception { 		testHome(); // makes sure some requests have been made 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:8080/metrics", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertTrue("Wrong body: " + body, body.containsKey("counter.status.200.root")); 	}
@Test 	public void testEnv() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:8080/env", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertTrue("Wrong body: " + body, body.containsKey("systemProperties")); 	}
@Test 	public void testErrorPage() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:8080/foo", Map.class); 		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals(500, body.get("status")); 	}
@Test 	public void testBeans() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<List> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:8080/beans", List.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertEquals(1, entity.getBody().size()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = (Map<String, Object>) entity.getBody().get(0); 		assertTrue("Wrong body: " + body, 				((String) body.get("context")).startsWith("application")); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:8080", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testShutdown() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").postForEntity( 				"http://localhost:8080/shutdown", null, Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertTrue("Wrong body: " + body, 				((String) body.get("message")).contains("Shutting down")); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(NonAutoConfigurationSampleTomcatApplication.class); 							} 						}); 		context = future.get(10, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleTomcatApplication.class); 							} 						}); 		context = future.get(10, TimeUnit.SECONDS); 	}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 					} 					catch (Exception ex) { 						return true; 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 					} 					catch (Exception ex) { 						return true; 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 					} 					catch (Exception ex) { 						return true; 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 					} 					catch (Exception ex) { 						return true; 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 					} 					catch (Exception ex) { 						return true; 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String classname : classNames) { 					try { 						DependencyCustomizer.this.loader.loadClass(classname); 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) == null) { 							return false; 						} 						return true; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) == null) { 							return false; 						} 						return true; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) == null) { 							return false; 						} 						return true; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) == null) { 							return false; 						} 						return true; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) == null) { 							return false; 						} 						return true; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) != null) { 							return true; 						} 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) != null) { 							return true; 						} 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) != null) { 							return true; 						} 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) != null) { 							return true; 						} 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				for (String path : paths) { 					try { 						if (DependencyCustomizer.this.loader.getResource(path) != null) { 							return true; 						} 						return false; 					} 					catch (Exception ex) { 						// swallow exception and continue 					} 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				if (DependencyCustomizer.this.contains(group, module)) { 					return false; 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				if (DependencyCustomizer.this.contains(group, module)) { 					return false; 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				if (DependencyCustomizer.this.contains(group, module)) { 					return false; 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				if (DependencyCustomizer.this.contains(group, module)) { 					return false; 				} 				return DependencyCustomizer.this.canAdd(); 			}
@Override 			protected boolean canAdd() { 				if (DependencyCustomizer.this.contains(group, module)) { 					return false; 				} 				return DependencyCustomizer.this.canAdd(); 			}
@SuppressWarnings("unchecked") 	public DependencyCustomizer add(String group, String module, String version) { 		if (canAdd()) { 			Map<String, Object> dependency = new HashMap<String, Object>(); 			dependency.put("group", group); 			dependency.put("module", module); 			dependency.put("version", version); 			dependency.put("transitive", true); 			return add(dependency); 		} 		return this; 	}
protected boolean canAdd() { 		return true; 	}
protected boolean canAdd() { 		return true; 	}
protected boolean canAdd() { 		return true; 	}
protected boolean canAdd() { 		return true; 	}
protected boolean canAdd() { 		return true; 	}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(8081); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			return properties; 		}
@Bean 		public SpringTemplateEngine templateEngine() { 			SpringTemplateEngine engine = new SpringTemplateEngine(); 			for (ITemplateResolver templateResolver : this.templateResolvers) { 				engine.addTemplateResolver(templateResolver); 			} 			return engine; 		}
@Bean 		public SpringTemplateEngine templateEngine() { 			SpringTemplateEngine engine = new SpringTemplateEngine(); 			for (ITemplateResolver templateResolver : this.templateResolvers) { 				engine.addTemplateResolver(templateResolver); 			} 			engine.addDialect(new LayoutDialect()); 			return engine; 		}
@Bean 		@ConditionalOnMissingBean(name = "thymeleafViewResolver") 		public ThymeleafViewResolver thymeleafViewResolver() { 			ThymeleafViewResolver resolver = new ThymeleafViewResolver(); 			resolver.setTemplateEngine(this.templateEngine); 			return resolver; 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser("user").password("password").roles("USER").and().and() 					.build(); 		}
@Override 		protected void configure(HttpConfiguration http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().antMatchers("/**").requiresSecure(); 			} 			if (this.security.getBasic().isEnabled()) { 				HttpConfiguration matcher = http.antMatcher(this.security.getBasic() 						.getPath()); 				matcher.authenticationEntryPoint(entryPoint()).antMatcher("/**") 						.httpBasic().authenticationEntryPoint(entryPoint()).and() 						.anonymous().disable(); 				matcher.authorizeUrls().antMatchers("/**") 						.hasRole(this.security.getBasic().getRole()); 			} 			// No cookies for service endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 		}
@Override 		public void configure(WebSecurityBuilder builder) throws Exception { 			builder.ignoring().antMatchers(this.endpoints.getHealth().getPath(), 					this.endpoints.getInfo().getPath(), 					this.endpoints.getError().getPath()); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser("user").password("password").roles("USER").and().and() 					.build(); 		}
@Bean 		public EmbeddedServletContainerFactory factory() { 			return new EmbeddedServletContainerFactory() {  				@Override 				public EmbeddedServletContainer getEmbdeddedServletContainer( 						ServletContextInitializer... initializers) { 					ServletContext servletContext = new MockServletContext() { 						@Override 						public Dynamic addServlet(String servletName, Servlet servlet) { 							return Mockito.mock(Dynamic.class); 						} 					}; 					for (ServletContextInitializer initializer : initializers) { 						try { 							initializer.onStartup(servletContext); 						} catch (ServletException ex) { 							throw new IllegalStateException(ex); 						} 					} 					return new EmbeddedServletContainer() { 						@Override 						public void stop() throws EmbeddedServletContainerException { 						} 					}; 				} 			}; 		}
@Override 				public EmbeddedServletContainer getEmbdeddedServletContainer( 						ServletContextInitializer... initializers) { 					ServletContext servletContext = new MockServletContext() { 						@Override 						public Dynamic addServlet(String servletName, Servlet servlet) { 							return Mockito.mock(Dynamic.class); 						} 					}; 					for (ServletContextInitializer initializer : initializers) { 						try { 							initializer.onStartup(servletContext); 						} catch (ServletException ex) { 							throw new IllegalStateException(ex); 						} 					} 					return new EmbeddedServletContainer() { 						@Override 						public void stop() throws EmbeddedServletContainerException { 						} 					}; 				}
@Override 	public void applyImports(ImportCustomizer imports) { 		imports.addImports("javax.sql.DataSource", "javax.annotation.PostConstruct", 				"javax.annotation.PreDestroy", "groovy.util.logging.Log", 				"org.springframework.stereotype.Controller", 				"org.springframework.stereotype.Service", 				"org.springframework.stereotype.Component", 				"org.springframework.beans.factory.annotation.Autowired", 				"org.springframework.beans.factory.annotation.Value", 				"org.springframework.context.annotation.Import", 				"org.springframework.context.annotation.ImportResource", 				"org.springframework.context.annotation.Profile", 				"org.springframework.context.annotation.Scope", 				"org.springframework.context.annotation.Configuration", 				"org.springframework.context.annotation.ComponentScan", 				"org.springframework.context.annotation.Bean", 				"org.springframework.context.ApplicationContext", 				"org.springframework.context.MessageSource", 				"org.springframework.core.io.ResourceLoader", 				"org.springframework.bootstrap.CommandLineRunner", 				"org.springframework.bootstrap.context.annotation.EnableAutoConfiguration"); 		imports.addStarImports("org.springframework.stereotype"); 	}
@Test 	public void testMetrics() throws Exception { 		testHome(); // makes sure some requests have been made 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate().getForEntity( 				"http://localhost:" + managementPort + "/metrics", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertTrue("Wrong body: " + body, body.containsKey("counter.status.200.root")); 	}
@Override 	public Object postProcessAfterInitialization(Object bean, String beanName) 			throws BeansException { 		ConfigurationProperties annotation = AnnotationUtils.findAnnotation( 				bean.getClass(), ConfigurationProperties.class); 		Object target = bean; 		if (annotation != null || bean instanceof ConfigurationPropertiesHolder) { 			if (bean instanceof ConfigurationPropertiesHolder) { 				target = ((ConfigurationPropertiesHolder) bean).getTarget(); 			} 			PropertiesConfigurationFactory<Object> factory = new PropertiesConfigurationFactory<Object>( 					target); 			factory.setPropertySources(this.propertySources); 			factory.setValidator(this.validator); 			factory.setConversionService(this.conversionService); 			String targetName = null; 			if (annotation != null) { 				factory.setIgnoreInvalidFields(annotation.ignoreInvalidFields()); 				factory.setIgnoreUnknownFields(annotation.ignoreUnknownFields()); 				targetName = "".equals(annotation.value()) ? ("" 						.equals(annotation.name()) ? null : annotation.name()) 						: annotation.value(); 			} 			factory.setTargetName(targetName); 			try { 				target = factory.getObject(); // throwaway 			} catch (BeansException e) { 				throw e; 			} catch (Exception e) { 				throw new BeanCreationException(beanName, "Could not bind", e); 			} 		} 		return bean; 	}
@ConditionalOnMissingBean(TestProperties.class) 		@Bean(name = "org.springframework.bootstrap.context.annotation.EnableConfigurationPropertiesTests$TestProperties") 		public TestProperties testProperties() { 			return new TestProperties(); 		}
@Bean 		@AssertMissingBean(TestProperties.class) 		public TestProperties testProperties() { 			TestProperties test = new TestProperties(); 			test.setName("bar"); 			return test; 		}
public String getName() { 			return this.properties.getName(); 		}
public String getName() { 			return this.properties.getName(); 		}
public String getName() { 			return this.name; 		}
public String getName() { 			return this.name; 		}
@Override 		protected void configure(HttpConfiguration http) throws Exception { 			http.antMatcher("/**").httpBasic().and().anonymous().disable(); 			if (this.security.isRequireSsl()) { 				http.requiresChannel().antMatchers("/**").requiresSecure(); 			} 			http.authorizeUrls().antMatchers("/**").hasRole("USER"); 		}
@Override 		public void configure(WebSecurityConfiguration builder) throws Exception { 			builder.ignoring().antMatchers(this.healthPath, this.infoPath); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser("user").password("password").roles("USER").and().and() 					.build(); 		}
public boolean isRequireSsl() { 		return requireSsl; 	}
@Override 	public void onApplicationEvent(ContextRefreshedEvent event) { 		if (event.getSource() != this.parent) { 			return; 		} 		if (this.configuration.getPort() != this.management.getPort()) { 			AnnotationConfigEmbeddedWebApplicationContext context = new AnnotationConfigEmbeddedWebApplicationContext(); 			context.setParent(this.parent); 			context.register(ManagementServerConfiguration.class, 					VarzConfiguration.class, HealthzConfiguration.class, 					ShutdownConfiguration.class, TraceConfiguration.class); 			context.refresh(); 			this.context = context; 		} 	}
@Bean 		@ConditionalOnMissingBean(TraceRepository.class) 		protected TraceRepository traceRepository() { 			return this.traceRepository; 		}
@Test 	public void testHealthz() throws Exception { 		ResponseEntity<String> entity = getRestTemplate().getForEntity( 				"http://localhost:" + managementPort + "healthz", String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertEquals("ok", entity.getBody()); 	}
@Override 	public void onApplicationEvent(ContextRefreshedEvent event) { 		if (event.getSource() != this.parent) { 			return; 		} 		if (this.configuration.getPort() != this.configuration.getManagementPort()) { 			AnnotationConfigEmbeddedWebApplicationContext context = new AnnotationConfigEmbeddedWebApplicationContext(); 			context.setParent(this.parent); 			context.register(ManagementContainerConfiguration.class, 					VarzAutoConfiguration.class, HealthzAutoConfiguration.class, 					ShutdownAutoConfiguration.class); 			context.refresh(); 			this.context = context; 		} 	}
@Bean 	public PropertySourcesBindingPostProcessor propertySourcesBinder() { 		PropertySources propertySources;  		if (this.configurer != null) { 			propertySources = extractPropertySources(this.configurer); 		} else { 			if (this.environment instanceof ConfigurableEnvironment) { 				propertySources = flattenPropertySources(((ConfigurableEnvironment) this.environment) 						.getPropertySources()); 			} else { 				// empty, so not very useful, but fulfils the contract 				propertySources = new MutablePropertySources(); 			} 		} 		PropertySourcesBindingPostProcessor processor = new PropertySourcesBindingPostProcessor(); 		LocalValidatorFactoryBean validator = new LocalValidatorFactoryBean(); 		validator.afterPropertiesSet(); 		processor.setValidator(validator); 		processor.setPropertySources(propertySources); 		return processor; 	}
@Override 	public void afterPropertiesSet() throws Exception {  		Assert.state(this.properties != null || this.propertySources != null, 				"Properties or propertySources should not be null");  		try { 			if (this.properties != null) { 				logger.trace("Properties:\n" + this.properties); 			} else { 				logger.trace("Property Sources: " + this.propertySources); 			} 			this.initialized = true;  			RelaxedDataBinder dataBinder; 			if (this.targetName != null) { 				dataBinder = new RelaxedDataBinder(this.configuration, this.targetName); 			} else { 				dataBinder = new RelaxedDataBinder(this.configuration); 			} 			if (this.validator != null) { 				dataBinder.setValidator(this.validator); 			} 			dataBinder.setIgnoreInvalidFields(this.ignoreInvalidFields); 			dataBinder.setIgnoreUnknownFields(this.ignoreUnknownFields); 			customizeBinder(dataBinder); 			PropertyValues pvs; 			if (this.properties != null) { 				pvs = new MutablePropertyValues(this.properties); 			} else { 				pvs = new PropertySourcesPropertyValues(this.propertySources); 			} 			dataBinder.bind(pvs);  			if (this.validator != null) { 				dataBinder.validate(); 				BindingResult errors = dataBinder.getBindingResult();  				if (errors.hasErrors()) { 					logger.error("Properties configuration failed validation"); 					for (ObjectError error : errors.getAllErrors()) { 						logger.error(this.messageSource != null ? this.messageSource 								.getMessage(error, Locale.getDefault()) 								+ " (" 								+ error 								+ ")" : error); 					} 					if (this.exceptionIfInvalid) { 						BindException summary = new BindException(errors); 						throw summary; 					} 				} 			} 		} catch (BindException e) { 			if (this.exceptionIfInvalid) { 				throw e; 			} 			logger.error( 					"Failed to load Properties validation bean. Your Properties may be invalid.", 					e); 		} 	}
@Override 	public Object postProcessAfterInitialization(Object bean, String beanName) 			throws BeansException { 		ConfigurationProperties annotation = AnnotationUtils.findAnnotation( 				bean.getClass(), ConfigurationProperties.class); 		if (annotation != null) { 			PropertiesConfigurationFactory<Object> factory = new PropertiesConfigurationFactory<Object>( 					bean); 			factory.setPropertySources(this.propertySources); 			factory.setValidator(this.validator); 			factory.setIgnoreInvalidFields(annotation.ignoreInvalidFields()); 			factory.setIgnoreUnknownFields(annotation.ignoreUnknownFields()); 			String targetName = "".equals(annotation.value()) ? ("".equals(annotation 					.name()) ? null : annotation.name()) : annotation.value(); 			factory.setTargetName(targetName); 			try { 				bean = factory.getObject(); 			} catch (BeansException e) { 				throw e; 			} catch (Exception e) { 				throw new BeanCreationException(beanName, "Could not bind", e); 			} 		} 		return bean; 	}
@Override 	public synchronized void stop() { 		try { 			this.server.setGracefulShutdown(10000); 			this.server.stop(); 		} catch (InterruptedException ex) { 			Thread.currentThread().interrupt(); 			// No drama 		} catch (Exception ex) { 			throw new EmbeddedServletContainerException( 					"Unable to stop embedded Jetty servlet container", ex); 		} 	}
private BindingResult bind(Object target, String values, String namePrefix) 			throws Exception { 		Properties properties = PropertiesLoaderUtils 				.loadProperties(new ByteArrayResource(values.getBytes())); 		DataBinder binder = new RelaxedDataBinder(target, namePrefix); 		binder.setIgnoreUnknownFields(false); 		LocalValidatorFactoryBean validatorFactoryBean = new LocalValidatorFactoryBean(); 		validatorFactoryBean.afterPropertiesSet(); 		binder.setValidator(validatorFactoryBean); 		binder.bind(new MutablePropertyValues(properties)); 		binder.validate();  		return binder.getBindingResult(); 	}
@Bean 	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 		http.authorizeExchange((exchanges) -> { 			exchanges.matchers(EndpointRequest.to(HealthEndpoint.class, InfoEndpoint.class)).permitAll(); 			exchanges.anyExchange().authenticated(); 		}); 		http.httpBasic(Customizer.withDefaults()); 		http.formLogin(Customizer.withDefaults()); 		return http.build(); 	}
@Bean 	SecurityFilterChain managementSecurityFilterChain(HttpSecurity http) throws Exception { 		http.authorizeRequests((requests) -> { 			requests.requestMatchers(EndpointRequest.to(HealthEndpoint.class, InfoEndpoint.class)).permitAll(); 			requests.anyRequest().authenticated(); 		}); 		http.formLogin(Customizer.withDefaults()); 		http.httpBasic(Customizer.withDefaults()); 		return http.build(); 	}
@Test 	void outcomeShouldMatchDefaults() { 		this.contextRunner.run((context) -> assertThat(context).hasBean("info").hasBean("health") 				.doesNotHaveBean("spring").doesNotHaveBean("test").doesNotHaveBean("shutdown")); 	}
@Test 	void outcomeWhenIncludeAllJmxButJmxDisabledShouldMatchDefaults() { 		this.contextRunner.withPropertyValues("management.endpoints.jmx.exposure.include=*") 				.run((context) -> assertThat(context).hasBean("info").hasBean("health").doesNotHaveBean("spring") 						.doesNotHaveBean("test").doesNotHaveBean("shutdown")); 	}
@Test 	void outcomeWhenIncludeAllJmxAndJmxEnabledAndEnablingEndpointDisabledByDefaultShouldMatchAll() { 		this.contextRunner 				.withPropertyValues("management.endpoints.jmx.exposure.include=*", "spring.jmx.enabled=true", 						"management.endpoint.shutdown.enabled=true") 				.run((context) -> assertThat(context).hasBean("info").hasBean("health").hasBean("test") 						.hasBean("spring").hasBean("shutdown")); 	}
@Test 	void webEndpointsAreDisabledByDefault() { 		this.contextRunner.run((context) -> { 			WebTestClient client = createClient(context); 			assertThat(isExposed(client, HttpMethod.GET, "beans")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "conditions")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "configprops")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "custommvc")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "customservlet")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "env")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "health")).isTrue(); 			assertThat(isExposed(client, HttpMethod.GET, "info")).isTrue(); 			assertThat(isExposed(client, HttpMethod.GET, "mappings")).isFalse(); 			assertThat(isExposed(client, HttpMethod.POST, "shutdown")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "threaddump")).isFalse(); 			assertThat(isExposed(client, HttpMethod.GET, "httptrace")).isFalse(); 		}); 	}
@Bean 	SecurityFilterChain configure(HttpSecurity http) throws Exception { 		http.authorizeRequests((requests) -> { 			requests.mvcMatchers("/actuator/beans").hasRole("BEANS"); 			requests.requestMatchers(EndpointRequest.to("health", "info")).permitAll(); 			requests.requestMatchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)) 					.hasRole("ACTUATOR"); 			requests.requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll(); 			requests.antMatchers("/foo").permitAll(); 			requests.antMatchers("/**").hasRole("USER"); 		}); 		http.cors(Customizer.withDefaults()); 		http.httpBasic(); 		return http.build(); 	}
@Bean 	SecurityFilterChain configure(HttpSecurity http) throws Exception { 		// @formatter:off 		http.authorizeRequests() 				.requestMatchers(EndpointRequest.to("health", "info")).permitAll() 				.requestMatchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)).hasRole("ACTUATOR") 				.antMatchers("/**").hasRole("USER") 				.and() 			.httpBasic(); 		return http.build(); 		// @formatter:on 	}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			http.authorizeExchange((exchanges) -> { 				exchanges.matchers(EndpointRequest.to("health", "info")).permitAll(); 				exchanges.matchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)) 						.hasRole("ACTUATOR"); 				exchanges.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll(); 				exchanges.pathMatchers("/login").permitAll(); 				exchanges.anyExchange().authenticated(); 			}); 			http.httpBasic(); 			return http.build(); 		}
@Bean 		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) throws Exception { 			http.authorizeExchange((exchanges) -> { 				exchanges.matchers(EndpointRequest.to("health", "info")).permitAll(); 				exchanges.matchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class)) 						.hasRole("ACTUATOR"); 				exchanges.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll(); 				exchanges.pathMatchers("/login").permitAll(); 				exchanges.anyExchange().authenticated(); 			}); 			http.httpBasic(Customizer.withDefaults()); 			return http.build(); 		}
private URI buildUrl(String path, String... params) { 		try { 			URIBuilder builder = new URIBuilder("docker://localhost/" + API_VERSION + path); 			int param = 0; 			while (param < params.length) { 				builder.addParameter(params[param++], params[param++]); 			} 			return builder.build(); 		} 		catch (URISyntaxException ex) { 			throw new IllegalStateException(ex); 		} 	}
private Response execute(HttpUriRequest request) { 		try { 			CloseableHttpResponse response = this.client.execute(request); 			StatusLine statusLine = response.getStatusLine(); 			int statusCode = statusLine.getStatusCode(); 			HttpEntity entity = response.getEntity();  			if (statusCode >= 400 && statusCode < 500) { 				Errors errors = SharedObjectMapper.get().readValue(entity.getContent(), Errors.class); 				throw new DockerException(request.getURI(), statusCode, statusLine.getReasonPhrase(), errors); 			} 			if (statusCode == 500) { 				throw new DockerException(request.getURI(), statusCode, statusLine.getReasonPhrase(), null); 			} 			return new HttpClientResponse(response); 		} 		catch (IOException ioe) { 			throw new DockerException(request.getURI(), 500, ioe.getMessage(), null); 		} 	}
@Override 		public InputStream getContent() throws UnsupportedOperationException { 			throw new UnsupportedOperationException(); 		}
@Override 		public InputStream getContent() throws IOException { 			return this.response.getEntity().getContent(); 		}
@BeforeEach 	void setup() { 		MockitoAnnotations.initMocks(this); 		this.dockerApi = new DockerApi(this.httpClient); 	}
@BeforeEach 	void setup() { 		MockitoAnnotations.initMocks(this); 		this.dockerApi = new DockerApi(this.httpClient); 	}
@BeforeEach 	void setup() { 		MockitoAnnotations.initMocks(this); 		this.dockerApi = new DockerApi(this.httpClient); 	}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.image(); 		}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.image(); 		}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.image(); 		}
@Test 		void removeRemovesContainer() throws Exception { 			ImageReference reference = ImageReference 					.of("ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d"); 			URI removeUri = new URI(IMAGES_URL 					+ "/docker.io/library/ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d"); 			given(httpClient().delete(removeUri)).willReturn(emptyResponse()); 			this.api.remove(reference, false); 			verify(httpClient()).delete(removeUri); 		}
@Test 		void removeWhenForceIsTrueRemovesContainer() throws Exception { 			ImageReference reference = ImageReference 					.of("ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d"); 			URI removeUri = new URI(IMAGES_URL 					+ "/docker.io/library/ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d?force=1"); 			given(httpClient().delete(removeUri)).willReturn(emptyResponse()); 			this.api.remove(reference, true); 			verify(httpClient()).delete(removeUri); 		}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.container(); 		}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.container(); 		}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.container(); 		}
@Test 		void removeRemovesContainer() throws Exception { 			ContainerReference reference = ContainerReference.of("e90e34656806"); 			URI removeUri = new URI(CONTAINERS_URL + "/e90e34656806"); 			given(httpClient().delete(removeUri)).willReturn(emptyResponse()); 			this.api.remove(reference, false); 			verify(httpClient()).delete(removeUri); 		}
@Test 		void removeWhenForceIsTrueRemovesContainer() throws Exception { 			ContainerReference reference = ContainerReference.of("e90e34656806"); 			URI removeUri = new URI(CONTAINERS_URL + "/e90e34656806?force=1"); 			given(httpClient().delete(removeUri)).willReturn(emptyResponse()); 			this.api.remove(reference, true); 			verify(httpClient()).delete(removeUri); 		}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.volume(); 		}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.volume(); 		}
@BeforeEach 		void setup() { 			MockitoAnnotations.initMocks(this); 			this.api = DockerApiTests.this.dockerApi.volume(); 		}
@Test 	void createWhenUriIsNullThrowsException() { 		assertThatIllegalArgumentException().isThrownBy(() -> new DockerException(null, 404, null, NO_ERRORS)) 				.withMessage("URI must not be null"); 	}
@Test 	void create() { 		DockerException exception = new DockerException(URI, 404, "missing", ERRORS); 		assertThat(exception.getMessage()).isEqualTo( 				"Docker API call to 'docker://localhost' failed with status code 404 \"missing\" [code: message]"); 		assertThat(exception.getStatusCode()).isEqualTo(404); 		assertThat(exception.getReasonPhrase()).isEqualTo("missing"); 		assertThat(exception.getErrors()).isSameAs(ERRORS); 	}
@Test 	void createWhenReasonPhraseIsNull() { 		DockerException exception = new DockerException(URI, 404, null, ERRORS); 		assertThat(exception.getMessage()) 				.isEqualTo("Docker API call to 'docker://localhost' failed with status code 404 [code: message]"); 		assertThat(exception.getStatusCode()).isEqualTo(404); 		assertThat(exception.getReasonPhrase()).isNull(); 		assertThat(exception.getErrors()).isSameAs(ERRORS); 	}
@Test 	void createWhenErrorsIsNull() { 		DockerException exception = new DockerException(URI, 404, "missing", null); 		assertThat(exception.getErrors()).isNull(); 	}
@Test 	void createWhenErrorsIsEmpty() { 		DockerException exception = new DockerException(URI, 404, "missing", NO_ERRORS); 		assertThat(exception.getMessage()) 				.isEqualTo("Docker API call to 'docker://localhost' failed with status code 404 \"missing\""); 		assertThat(exception.getStatusCode()).isEqualTo(404); 		assertThat(exception.getReasonPhrase()).isEqualTo("missing"); 		assertThat(exception.getErrors()).isSameAs(NO_ERRORS);  	}
@BeforeEach 	void setup() throws Exception { 		MockitoAnnotations.initMocks(this); 		given(this.client.execute(any())).willReturn(this.response); 		given(this.response.getEntity()).willReturn(this.entity); 		given(this.response.getStatusLine()).willReturn(this.statusLine); 		this.http = new HttpClientHttp(this.client); 		this.uri = new URI("docker://localhost/example"); 	}
@Test 	void getShouldExecuteHttpGet() throws Exception { 		given(this.entity.getContent()).willReturn(this.content); 		given(this.statusLine.getStatusCode()).willReturn(200); 		Response response = this.http.get(this.uri); 		verify(this.client).execute(this.requestCaptor.capture()); 		HttpUriRequest request = this.requestCaptor.getValue(); 		assertThat(request).isInstanceOf(HttpGet.class); 		assertThat(request.getURI()).isEqualTo(this.uri); 		assertThat(request.getFirstHeader(HttpHeaders.CONTENT_TYPE)).isNull(); 		assertThat(response.getContent()).isSameAs(this.content); 	}
@Test 	void postShouldExecuteHttpPost() throws Exception { 		given(this.entity.getContent()).willReturn(this.content); 		given(this.statusLine.getStatusCode()).willReturn(200); 		Response response = this.http.post(this.uri); 		verify(this.client).execute(this.requestCaptor.capture()); 		HttpUriRequest request = this.requestCaptor.getValue(); 		assertThat(request).isInstanceOf(HttpPost.class); 		assertThat(request.getURI()).isEqualTo(this.uri); 		assertThat(request.getFirstHeader(HttpHeaders.CONTENT_TYPE)).isNull(); 		assertThat(response.getContent()).isSameAs(this.content); 	}
@Test 	void postWithContentShouldExecuteHttpPost() throws Exception { 		given(this.entity.getContent()).willReturn(this.content); 		given(this.statusLine.getStatusCode()).willReturn(200); 		Response response = this.http.post(this.uri, APPLICATION_JSON, 				(out) -> StreamUtils.copy("test", StandardCharsets.UTF_8, out)); 		verify(this.client).execute(this.requestCaptor.capture()); 		HttpUriRequest request = this.requestCaptor.getValue(); 		HttpEntity entity = ((HttpEntityEnclosingRequest) request).getEntity(); 		assertThat(request).isInstanceOf(HttpPost.class); 		assertThat(request.getURI()).isEqualTo(this.uri); 		assertThat(request.getFirstHeader(HttpHeaders.CONTENT_TYPE).getValue()).isEqualTo(APPLICATION_JSON); 		assertThat(entity.isRepeatable()).isFalse(); 		assertThat(entity.getContentLength()).isEqualTo(-1); 		assertThat(entity.isStreaming()).isTrue(); 		assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(entity::getContent); 		assertThat(writeToString(entity)).isEqualTo("test"); 		assertThat(response.getContent()).isSameAs(this.content); 	}
@Test 	void putWithContentShouldExecuteHttpPut() throws Exception { 		given(this.entity.getContent()).willReturn(this.content); 		given(this.statusLine.getStatusCode()).willReturn(200); 		Response response = this.http.put(this.uri, APPLICATION_JSON, 				(out) -> StreamUtils.copy("test", StandardCharsets.UTF_8, out)); 		verify(this.client).execute(this.requestCaptor.capture()); 		HttpUriRequest request = this.requestCaptor.getValue(); 		HttpEntity entity = ((HttpEntityEnclosingRequest) request).getEntity(); 		assertThat(request).isInstanceOf(HttpPut.class); 		assertThat(request.getURI()).isEqualTo(this.uri); 		assertThat(request.getFirstHeader(HttpHeaders.CONTENT_TYPE).getValue()).isEqualTo(APPLICATION_JSON); 		assertThat(entity.isRepeatable()).isFalse(); 		assertThat(entity.getContentLength()).isEqualTo(-1); 		assertThat(entity.isStreaming()).isTrue(); 		assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(entity::getContent); 		assertThat(writeToString(entity)).isEqualTo("test"); 		assertThat(response.getContent()).isSameAs(this.content); 	}
@Test 	void deleteShouldExecuteHttpDelete() throws IOException { 		given(this.entity.getContent()).willReturn(this.content); 		given(this.statusLine.getStatusCode()).willReturn(200); 		Response response = this.http.delete(this.uri); 		verify(this.client).execute(this.requestCaptor.capture()); 		HttpUriRequest request = this.requestCaptor.getValue(); 		assertThat(request).isInstanceOf(HttpDelete.class); 		assertThat(request.getURI()).isEqualTo(this.uri); 		assertThat(request.getFirstHeader(HttpHeaders.CONTENT_TYPE)).isNull(); 		assertThat(response.getContent()).isSameAs(this.content); 	}
@Test 	void executeWhenClientThrowsIOExceptionRethrowsAsDockerException() throws IOException { 		given(this.client.execute(any())).willThrow(new IOException("test IO exception")); 		assertThatExceptionOfType(DockerException.class).isThrownBy(() -> this.http.get(this.uri)) 				.satisfies((ex) -> assertThat(ex.getErrors()).isNull()).satisfies(DockerException::getStatusCode) 				.withMessageContaining("500") 				.satisfies((ex) -> assertThat(ex.getReasonPhrase()).contains("test IO exception")); 	}
public boolean determineEnabled() { 			if (CollectionUtils.isEmpty(RabbitProperties.this.parsedAddresses)) { 				return isEnabled(); 			} 			Address address = RabbitProperties.this.parsedAddresses.get(0); 			return address.secureConnection; 		}
@Override 	@SuppressWarnings("deprecation") 	protected Set<Class<?>> getDefaultIncludes() { 		if (this.annotation.secure()) { 			if (ObjectUtils.isEmpty(this.annotation.controllers())) { 				return DEFAULT_INCLUDES_SECURITY_CONFIGURER_AND_CONTROLLER; 			} 			return DEFAULT_INCLUDES_AND_SECURITY_CONFIGURER; 		} 		if (ObjectUtils.isEmpty(this.annotation.controllers())) { 			return DEFAULT_INCLUDES_AND_CONTROLLER; 		} 		return DEFAULT_INCLUDES; 	}
@Override 	protected Set<Class<?>> getDefaultIncludes() { 		if (ObjectUtils.isEmpty(this.annotation.controllers())) { 			return DEFAULT_INCLUDES_AND_CONTROLLER; 		} 		return DEFAULT_INCLUDES; 	}
@Test 	public void matchWhenHasNoControllers() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				WithNoControllers.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 	}
@Test 	public void matchWhenHasController() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				WithController.class); 		assertThat(excludes(filter, Controller1.class)).isFalse(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 	}
@Test 	public void matchNotUsingDefaultFilters() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				NotUsingDefaultFilters.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isTrue(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isTrue(); 		assertThat(excludes(filter, ExampleWeb.class)).isTrue(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isTrue(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 	}
@Test 	public void matchWithExcludeFilter() throws Exception { 		WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( 				WithExcludeFilter.class); 		assertThat(excludes(filter, Controller1.class)).isTrue(); 		assertThat(excludes(filter, Controller2.class)).isFalse(); 		assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); 		assertThat(excludes(filter, ExampleWeb.class)).isFalse(); 		assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); 		assertThat(excludes(filter, ExampleService.class)).isTrue(); 		assertThat(excludes(filter, ExampleRepository.class)).isTrue(); 	}
@Bean 	@ConditionalOnMissingBean(WebDriver.class) 	@ConditionalOnBean(MockMvcHtmlUnitDriverBuilder.class) 	public HtmlUnitDriver htmlUnitDriver(MockMvcHtmlUnitDriverBuilder builder) { 		return builder.build(); 	}
@Bean 	@ConditionalOnMissingBean 	@ConditionalOnEnabledEndpoint 	@ConditionalOnBean(value = HealthEndpoint.class, search = SearchStrategy.CURRENT) 	public HealthWebEndpointExtension healthWebEndpointExtension(HealthEndpoint delegate, 			HealthWebEndpointExtensionProperties extensionProperties) { 		HealthWebEndpointExtension webExtension = new HealthWebEndpointExtension( 				delegate); 		if (extensionProperties.getMapping() != null) { 			webExtension.addStatusMapping(extensionProperties.getMapping()); 		} 		return webExtension; 	}
@ReadOperation 	public WebEndpointResponse<Health> getHealth() { 		Health health = this.delegate.health(); 		Integer status = getStatus(health); 		return new WebEndpointResponse<>(health, status); 	}
@Test 	public void healthStatusMappingCanBeCustomized() { 		ApplicationContextRunner contextRunner = contextRunner() 				.withPropertyValues("endpoints.health.mapping.CUSTOM=500") 				.withUserConfiguration(HealthEndpointConfiguration.class); 		contextRunner.run((context) -> { 			HealthWebEndpointExtension extension = context 					.getBean(HealthWebEndpointExtension.class); 			@SuppressWarnings("unchecked") 			Map<String, Integer> statusMappings = (Map<String, Integer>) ReflectionTestUtils 					.getField(extension, "statusMapping"); 			assertThat(statusMappings).containsEntry("DOWN", 503); 			assertThat(statusMappings).containsEntry("OUT_OF_SERVICE", 503); 			assertThat(statusMappings).containsEntry("CUSTOM", 500); 		}); 	}
@Bean 		public HealthEndpoint healthEndpoint() { 			return new HealthEndpoint(new OrderedHealthAggregator(), 					Collections.emptyMap()); 		}
@Bean 		public HealthEndpoint healthEndpoint( 				Map<String, HealthIndicator> healthIndicators) { 			return new HealthEndpoint(new OrderedHealthAggregator(), healthIndicators); 		}
@Bean 		public HealthWebEndpointExtension healthWebEndpointExtension( 				HealthEndpoint delegate) { 			return new HealthWebEndpointExtension(delegate); 		}
@Bean 		public HealthEndpoint healthEndpoint( 				Map<String, HealthIndicator> healthIndicators) { 			return new HealthEndpoint(new OrderedHealthAggregator(), healthIndicators); 		}
@Bean 		public HealthWebEndpointExtension healthWebEndpointExtension( 				HealthEndpoint delegate) { 			return new HealthWebEndpointExtension(delegate); 		}
@Test 	public void testInsecureNestedPath() throws Exception { 		ResponseEntity<String> entity = this.restTemplate.getForEntity("/env", 				String.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK); 		ResponseEntity<String> user = this.restTemplate.getForEntity("/env/user", 				String.class); 		assertThat(user.getStatusCode()).isEqualTo(HttpStatus.OK); 		assertThat(user.getBody()).contains("{\"user\":"); 	}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnEnabledEndpoint("health") 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		Security security = this.managementServerProperties.getSecurity(); 		boolean secure = (security != null && security.isEnabled()); 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate, secure); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint 					.addStatusMapping(this.healthMvcEndpointProperties.getMapping()); 		} 		return healthMvcEndpoint; 	}
private <T extends ActiveMQConnectionFactory> T createNativeConnectionFactory( 			Class<T> factoryClass) throws Exception { 		Map<String, Object> params = new HashMap<String, Object>(); 		params.put(TransportConstants.HOST_PROP_NAME, this.properties.getHost()); 		params.put(TransportConstants.PORT_PROP_NAME, this.properties.getPort()); 		TransportConfiguration transportConfiguration = new TransportConfiguration( 				NettyConnectorFactory.class.getName(), params); 		Constructor<T> constructor = factoryClass.getConstructor(boolean.class, 				TransportConfiguration[].class); 		return constructor.newInstance(false, 				new TransportConfiguration[] { transportConfiguration }); 	}
@Test 	public void nativeConnectionFactory() { 		load(EmptyConfiguration.class, "spring.artemis.mode:native"); 		JmsTemplate jmsTemplate = this.context.getBean(JmsTemplate.class); 		ActiveMQConnectionFactory connectionFactory = this.context 				.getBean(ActiveMQConnectionFactory.class); 		assertThat(connectionFactory).isEqualTo(jmsTemplate.getConnectionFactory()); 		assertNettyConnectionFactory(connectionFactory, "localhost", 61616); 	}
@Bean 	public HornetQConnectionFactory jmsConnectionFactory(ListableBeanFactory beanFactory, 			HornetQProperties properties) { 		return new HornetQConnectionFactoryFactory(beanFactory, properties) 				.createConnectionFactory(HornetQConnectionFactory.class); 	}
private <T extends HornetQConnectionFactory> T createEmbeddedConnectionFactory( 			Class<T> factoryClass) throws Exception { 		try { 			TransportConfiguration transportConfiguration = new TransportConfiguration( 					InVMConnectorFactory.class.getName(), 					this.properties.getEmbedded().generateTransportParameters()); 			ServerLocator serviceLocator = HornetQClient 					.createServerLocatorWithoutHA(transportConfiguration); 			return factoryClass.getConstructor(ServerLocator.class) 					.newInstance(serviceLocator); 		} 		catch (NoClassDefFoundError ex) { 			throw new IllegalStateException("Unable to create InVM " 					+ "HornetQ connection, ensure that hornet-jms-server.jar " 					+ "is in the classpath", ex); 		} 	}
private <T extends HornetQConnectionFactory> T createNativeConnectionFactory( 			Class<T> factoryClass) throws Exception { 		Map<String, Object> params = new HashMap<String, Object>(); 		params.put(TransportConstants.HOST_PROP_NAME, this.properties.getHost()); 		params.put(TransportConstants.PORT_PROP_NAME, this.properties.getPort()); 		TransportConfiguration transportConfiguration = new TransportConfiguration( 				NettyConnectorFactory.class.getName(), params); 		Constructor<T> constructor = factoryClass.getConstructor(boolean.class, 				TransportConfiguration[].class); 		return constructor.newInstance(false, 				new TransportConfiguration[] { transportConfiguration }); 	}
@Primary 	@Bean(name = { "jmsConnectionFactory", "xaJmsConnectionFactory" }) 	public ConnectionFactory jmsConnectionFactory(ListableBeanFactory beanFactory, 			HornetQProperties properties, XAConnectionFactoryWrapper wrapper) 					throws Exception { 		return wrapper.wrapConnectionFactory( 				new HornetQConnectionFactoryFactory(beanFactory, properties) 						.createConnectionFactory(HornetQXAConnectionFactory.class)); 	}
@Bean 	public HornetQConnectionFactory nonXaJmsConnectionFactory( 			ListableBeanFactory beanFactory, HornetQProperties properties) { 		return new HornetQConnectionFactoryFactory(beanFactory, properties) 				.createConnectionFactory(HornetQConnectionFactory.class); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertThat(this.context.getBean(AuthenticationManagerBuilder.class)).isNotNull(); 		// 4 for static resources and one for the rest 		assertThat(this.context.getBean(FilterChainProxy.class).getFilterChains()) 				.hasSize(5); 	}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return new TestingAuthenticationToken("foo", "bar"); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.authenticationManager = new AuthenticationManager() { 				@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				} 			}; 		}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.userDetails = http.getSharedObject(UserDetailsService.class); 		}
@Autowired 		public void handlerMapping(MvcEndpoints endpoints, 				ListableBeanFactory beanFactory, EndpointHandlerMapping mapping) { 			// In a child context we definitely want to see the parent endpoints 			mapping.setDetectHandlerMethodsInAncestorContexts(true); 			postProcessMapping(beanFactory, mapping); 		}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			// The ignores are not cumulative, so to prevent overwriting the defaults we 			// add them back. 			List<String> ignored = SpringBootWebSecurityConfiguration 					.getIgnored(this.security); 			if (!this.management.getSecurity().isEnabled()) { 				ignored.addAll(Arrays 						.asList(EndpointPaths.ALL.getPaths(this.endpointHandlerMapping))); 			} 			if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			if (this.server != null) { 				String[] paths = this.server.getPathsArray(ignored); 				if (!ObjectUtils.isEmpty(paths)) { 					ignoring.antMatchers(paths); 				} 			} 		}
protected final EndpointHandlerMapping getRequiredEndpointHandlerMapping() { 			if (this.endpointHandlerMapping == null) { 				ApplicationContext context = (this.contextResolver == null ? null 						: this.contextResolver.getApplicationContext()); 				if (context != null && context 						.getBeanNamesForType(EndpointHandlerMapping.class).length > 0) { 					this.endpointHandlerMapping = context 							.getBean(EndpointHandlerMapping.class); 				} 				if (this.endpointHandlerMapping == null) { 					this.endpointHandlerMapping = new EndpointHandlerMapping( 							Collections.<MvcEndpoint>emptySet()); 				} 			} 			return this.endpointHandlerMapping; 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			// secure endpoints 			RequestMatcher matcher = getRequestMatcher(); 			if (matcher != null) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				// Match all the requests for actuator endpoints ... 				http.requestMatcher(matcher); 				// ... but permitAll() for the non-sensitive ones 				configurePermittedRequests(http.authorizeRequests()); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions()); 				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders()); 			} 		}
private void configurePermittedRequests( 				ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry requests) { 			// Permit access to the non-sensitive endpoints 			requests.requestMatchers( 					new EndpointPathRequestMatcher(EndpointPaths.NON_SENSITIVE)) 					.permitAll(); 			// Restrict the rest to the configured role 			requests.anyRequest().hasRole(this.management.getSecurity().getRole()); 		}
@Override 			public boolean matches(HttpServletRequest request) { 				if (this.delegate == null) { 					this.delegate = createDelegate(); 				} 				return this.delegate.matches(request); 			}
private RequestMatcher createDelegate() { 				ServerProperties server = ManagementWebSecurityConfigurerAdapter.this.server; 				List<RequestMatcher> matchers = new ArrayList<RequestMatcher>(); 				EndpointHandlerMapping endpointHandlerMapping = ManagementWebSecurityConfigurerAdapter.this 						.getRequiredEndpointHandlerMapping(); 				for (String path : this.endpointPaths.getPaths(endpointHandlerMapping)) { 					matchers.add(new AntPathRequestMatcher(server.getPath(path))); 				} 				return (matchers.isEmpty() ? MATCH_NONE : new OrRequestMatcher(matchers)); 			}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@Test 	public void onDifferentPortAndContext() throws Exception { 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				DifferentPortConfig.class, BaseConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class); 		management.setContextPath("/admin"); 		this.applicationContext.refresh(); 		assertContent("/controller", ports.get().server, "controlleroutput"); 		assertContent("/admin/endpoint", ports.get().management, "endpointoutput"); 		assertContent("/admin/error", ports.get().management, startsWith("{")); 		this.applicationContext.close(); 		assertAllClosed(); 	}
@Test 	public void onDifferentPortAndMainContext() throws Exception { 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				DifferentPortConfig.class, BaseConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class); 		management.setContextPath("/admin"); 		server.setContextPath("/spring"); 		this.applicationContext.refresh(); 		assertContent("/spring/controller", ports.get().server, "controlleroutput"); 		assertContent("/admin/endpoint", ports.get().management, "endpointoutput"); 		assertContent("/admin/error", ports.get().management, startsWith("{")); 		this.applicationContext.close(); 		assertAllClosed(); 	}
public int getCount() { 			return this.count; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
public int getCount() { 				return this.count; 			}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				WebMvcAutoConfiguration.class, 				ManagementWebSecurityAutoConfiguration.class, 				JacksonAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		FilterChainProxy filterChainProxy = this.context.getBean(FilterChainProxy.class); 		// 4 for static resources, one for management endpoints and one for the rest 		assertThat(filterChainProxy.getFilterChains(), hasSize(6)); 		assertThat(filterChainProxy.getFilters("/beans"), hasSize(greaterThan(0))); 		assertThat(filterChainProxy.getFilters("/beans/"), hasSize(greaterThan(0))); 		assertThat(filterChainProxy.getFilters("/beans.foo"), hasSize(greaterThan(0))); 		assertThat(filterChainProxy.getFilters("/beans/foo/bar"), 				hasSize(greaterThan(0))); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(WebConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Just the management endpoints (one filter) and ignores now plus the backup 		// filter on app endpoints 		assertEquals(6, 				this.context.getBean(FilterChainProxy.class).getFilterChains().size()); 	}
@Test 	public void testCustomErrorPath() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = new TestRestTemplate("user", "password") 				.getForEntity("http://localhost:" + this.port + "/oops", Map.class); 		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("None", body.get("error")); 		assertEquals(999, body.get("status")); 	}
private RequestMatcher createDelegate() { 				ServerProperties server = ManagementWebSecurityConfigurerAdapter.this.server; 				List<RequestMatcher> matchers = new ArrayList<RequestMatcher>(); 				EndpointHandlerMapping endpointHandlerMapping = ManagementWebSecurityConfigurerAdapter.this 						.getRequiredEndpointHandlerMapping(); 				for (String path : this.endpointPaths.getPaths(endpointHandlerMapping)) { 					matchers.add(new AntPathRequestMatcher(server.getPath(path))); 				} 				return (matchers.isEmpty() ? AnyRequestMatcher.INSTANCE 						: new OrRequestMatcher(matchers)); 			}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@PostConstruct 		public void applyConfigurationProperties() { 			if (this.serverProperties.getSessionTimeout() != null) { 				this.sessionRepository 						.setDefaultMaxInactiveInterval(this.serverProperties 								.getSessionTimeout()); 			} 		}
public Integer getSessionTimeout() { 		return this.sessionTimeout; 	}
public void setSessionTimeout(Integer sessionTimeout) { 		this.sessionTimeout = sessionTimeout; 	}
@Override 	public void customize(ConfigurableEmbeddedServletContainer container) { 		if (getPort() != null) { 			container.setPort(getPort()); 		} 		if (getAddress() != null) { 			container.setAddress(getAddress()); 		} 		if (getContextPath() != null) { 			container.setContextPath(getContextPath()); 		} 		if (getDisplayName() != null) { 			container.setDisplayName(getDisplayName()); 		} 		if (getSessionTimeout() != null) { 			container.setSessionTimeout(getSessionTimeout()); 		} 		if (getSsl() != null) { 			container.setSsl(getSsl()); 		} 		if (getJspServlet() != null) { 			container.setJspServlet(getJspServlet()); 		} 		if (getCompression() != null) { 			container.setCompression(getCompression()); 		} 		if (container instanceof TomcatEmbeddedServletContainerFactory) { 			getTomcat() 					.customizeTomcat((TomcatEmbeddedServletContainerFactory) container); 		} 		if (container instanceof UndertowEmbeddedServletContainerFactory) { 			getUndertow().customizeUndertow( 					(UndertowEmbeddedServletContainerFactory) container); 		} 		container.addInitializers(new InitParameterConfiguringServletContextInitializer( 				getContextParameters())); 	}
@Override 				public void customize(Connector connector) {  					ProtocolHandler handler = connector.getProtocolHandler(); 					if (handler instanceof AbstractProtocol) { 						AbstractProtocol protocol = (AbstractProtocol) handler; 						protocol.setMaxThreads(Tomcat.this.maxThreads); 					}  				}
@Override 				public void customize(Connector connector) { 					ProtocolHandler handler = connector.getProtocolHandler(); 					if (handler instanceof AbstractHttp11Protocol) { 						AbstractHttp11Protocol protocol = (AbstractHttp11Protocol) handler; 						protocol.setMaxHttpHeaderSize(Tomcat.this.maxHttpHeaderSize); 					} 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers("/css/**").permitAll().anyRequest() 					.fullyAuthenticated().and().formLogin().loginPage("/login") 					.failureUrl("/login?error").permitAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers("/css/**").permitAll().anyRequest() 					.fullyAuthenticated().and().formLogin().loginPage("/login") 					.failureUrl("/login?error").permitAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().fullyAuthenticated().and().formLogin() 					.loginPage("/login").failureUrl("/login?error").permitAll(); 		}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnEnabledEndpoint("health") 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		Security security = this.managementServerProperties.getSecurity(); 		boolean secure = (security == null || security.isEnabled()); 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate, secure); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint.addStatusMapping(this.healthMvcEndpointProperties 					.getMapping()); 		} 		return healthMvcEndpoint; 	}
private boolean isUnrestricted() { 		Boolean sensitive = this.propertyResolver.getProperty("sensitive", Boolean.class); 		return !this.secure || Boolean.FALSE.equals(sensitive); 	}
@Test 	public void unsecureAnonymousAccessUnrestricted() { 		this.environment.getPropertySources().addLast(NON_SENSITIVE); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity( 				"http://localhost:" + port, Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testSecureHealth() throws Exception { 		ResponseEntity<String> entity = new TestRestTemplate().getForEntity( 				"http://localhost:" + this.port + "/health", String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertTrue("Wrong body: " + entity.getBody(), 				entity.getBody().contains("\"hello\":1")); 	}
private Health getHealth(Principal principal) { 		long accessTime = System.currentTimeMillis(); 		if (isCacheStale(accessTime) || isSecure(principal) || isUnrestricted()) { 			this.lastAccess = accessTime; 			this.cached = this.delegate.invoke(); 		} 		if (isSecure(principal) || isUnrestricted()) { 			return this.cached; 		} 		return Health.status(this.cached.getStatus()).build(); 	}
private static String[] getEndpointPaths( 			EndpointHandlerMapping endpointHandlerMapping, boolean secure) { 		if (endpointHandlerMapping == null) { 			return NO_PATHS; 		}  		Set<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints(); 		List<String> paths = new ArrayList<String>(endpoints.size()); 		for (MvcEndpoint endpoint : endpoints) { 			if (endpoint.isSensitive() == secure) { 				String path = endpointHandlerMapping.getPrefix() + endpoint.getPath(); 				paths.add(path); 				if (secure) { 					// Add Spring MVC-generated additional paths 					paths.add(path + "/"); 					paths.add(path + ".*"); 				} 			} 		} 		return paths.toArray(new String[paths.size()]); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 6 for static resources, one for management endpoints and one for the rest 		assertEquals(8, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Override 			public void configure(WebAppContext context) throws Exception { 				ErrorHandler errorHandler = context.getErrorHandler(); 				addJettyErrorPages(errorHandler, getErrorPages()); 			}
@Override 			public void configure(WebAppContext context) throws Exception { 				MimeTypes mimeTypes = context.getMimeTypes(); 				for (MimeMappings.Mapping mapping : getMimeMappings()) { 					mimeTypes.addMimeMapping(mapping.getExtension(), 							mapping.getMimeType()); 				} 			}
@Override 		public ServerConnector getConnector(Server server, 				SslContextFactory sslContextFactory, int port) { 			HttpConfiguration config = new HttpConfiguration(); 			config.setSecureScheme("https"); 			config.setSecurePort(port); 			config.addCustomizer(new SecureRequestCustomizer()); 			HttpConnectionFactory connectionFactory = new HttpConnectionFactory(config); 			SslConnectionFactory sslConnectionFactory = new SslConnectionFactory( 					sslContextFactory, HttpVersion.HTTP_1_1.asString()); 			ServerConnector serverConnector = new ServerConnector(server, 					sslConnectionFactory, connectionFactory); 			serverConnector.setPort(port); 			return serverConnector; 		}
@Override 		public ServerConnector getConnector(Server server, 				SslContextFactory sslContextFactory, int port) { 			HttpConfiguration config = new HttpConfiguration(); 			config.setSecureScheme("https"); 			config.setSecurePort(port); 			config.addCustomizer(new SecureRequestCustomizer()); 			HttpConnectionFactory connectionFactory = new HttpConnectionFactory(config); 			SslConnectionFactory sslConnectionFactory = new SslConnectionFactory( 					sslContextFactory, HttpVersion.HTTP_1_1.asString()); 			ServerConnector serverConnector = new ServerConnector(server, 					sslConnectionFactory, connectionFactory); 			serverConnector.setPort(port); 			return serverConnector; 		}
@Override 		public AbstractConnector getConnector(Server server, 				SslContextFactory sslContextFactory, int port) { 			try { 				Class<?> connectorClass = Class 						.forName("org.eclipse.jetty.server.ssl.SslSocketConnector"); 				AbstractConnector connector = (AbstractConnector) connectorClass 						.getConstructor(SslContextFactory.class).newInstance( 								sslContextFactory); 				connector.getClass().getMethod("setPort", int.class) 						.invoke(connector, port); 				return connector; 			} 			catch (Exception ex) { 				throw new IllegalStateException(ex); 			} 		}
@Bean 	@ConditionalOnBean(HealthEndpoint.class) 	@ConditionalOnProperty(prefix = "endpoints.health", name = "enabled", matchIfMissing = true) 	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) { 		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate); 		if (this.healthMvcEndpointProperties.getMapping() != null) { 			healthMvcEndpoint.addStatusMapping(this.healthMvcEndpointProperties 					.getMapping()); 		} 		return healthMvcEndpoint; 	}
private Health getHealth(Principal principal) { 		Health health = (useCachedValue(principal) ? this.cached : (Health) this.delegate 				.invoke()); 		// Not too worried about concurrent access here, the worst that can happen is the 		// odd extra call to delegate.invoke() 		this.cached = health; 		if (this.delegate.isRestrictAnonymousAccess() && !secure(principal)) { 			// If not secure we only expose the status 			health = Health.status(health.getStatus()).build(); 		} 		return health; 	}
private boolean useCachedValue(Principal principal) { 		long accessTime = System.currentTimeMillis(); 		if (cacheIsStale(accessTime) || secure(principal) 				|| !this.delegate.isRestrictAnonymousAccess()) { 			this.lastAccess = accessTime; 			return false; 		} 		return this.cached != null; 	}
@Test 	public void secure() { 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		given(this.endpoint.isRestrictAnonymousAccess()).willReturn(true); 		Object result = this.mvc.invoke(this.user); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void secureNotCached() { 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.isRestrictAnonymousAccess()).willReturn(true); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(this.user); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(this.user); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertTrue(health.getStatus() == Status.DOWN); 	}
@Test 	public void unsecureCached() { 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.isRestrictAnonymousAccess()).willReturn(true); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(this.user); 		assertTrue(result instanceof Health); 		Health health = (Health) result; 		assertTrue(health.getStatus() == Status.UP); 		assertThat(health.getDetails().size(), is(equalTo(1))); 		assertThat(health.getDetails().get("foo"), is(equalTo((Object) "bar"))); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); // insecure now 		assertTrue(result instanceof Health); 		health = (Health) result; 		// so the result is cached 		assertTrue(health.getStatus() == Status.UP); 		// but the details are hidden 		assertThat(health.getDetails().size(), is(equalTo(0))); 	}
@Test 	public void unsecureAnonymousAccessUnrestricted() { 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		given(this.endpoint.isRestrictAnonymousAccess()).willReturn(false); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void unsecureIsNotCachedWhenAnonymousAccessIsUnrestricted() { 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.isRestrictAnonymousAccess()).willReturn(false); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertTrue(health.getStatus() == Status.DOWN); 	}
@Test 	public void newValueIsReturnedOnceTtlExpires() throws InterruptedException { 		given(this.endpoint.getTimeToLive()).willReturn(50L); 		given(this.endpoint.isRestrictAnonymousAccess()).willReturn(true); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(null); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		Thread.sleep(100); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertTrue(health.getStatus() == Status.DOWN); 	}
private void runSchemaScripts() { 		List<Resource> scripts = getScripts(this.properties.getSchema(), "schema"); 		if (!scripts.isEmpty()) { 			runScripts(scripts); 			try { 				this.applicationContext.publishEvent(new DataSourceInitializedEvent( 						this.dataSource)); 			} 			catch (IllegalStateException ex) { 				logger.warn("Could not send event to complete DataSource initialization (" 						+ ex.getMessage() + ")"); 			} 		} 	}
@Test 	public void testLogin() throws Exception { 		HttpHeaders headers = getHeaders(); 		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML)); 		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); 		MultiValueMap<String, String> form = new LinkedMultiValueMap<String, String>(); 		form.set("username", "user"); 		form.set("password", "password"); 		ResponseEntity<String> entity = new TestRestTemplate().exchange( 				"http://localhost:" + this.port + "/login", HttpMethod.POST, 				new HttpEntity<MultiValueMap<String, String>>(form, headers), 				String.class); 		assertEquals(HttpStatus.FOUND, entity.getStatusCode()); 		assertTrue("Wrong location:\n" + entity.getHeaders(), 				entity.getHeaders().getLocation().toString().endsWith(port + "/")); 		assertNotNull("Missing cookie:\n" + entity.getHeaders(), 				entity.getHeaders().get("Set-Cookie")); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  			String[] paths = getSecureApplicationPaths(); 			configureAdditionalRules(http, paths);  		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  			String[] paths = getSecureApplicationPaths(); 			configureAdditionalRules(http, paths);  		}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Ignores and permitAll() security on application endpoints 		assertEquals(1, this.context.getBeanNamesForType(FilterChainProxy.class).length); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				FallbackWebSecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Just the management endpoints (one filter) and ignores now 		assertEquals(7, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Bean 	@Lazy 	@Scope(proxyMode = ScopedProxyMode.INTERFACES) 	protected AuthenticationManager lazyAuthenticationManager() { 		return this.configurer.getAuthenticationManagerBuilder().getOrBuild(); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			String[] paths = getSecureApplicationPaths(); 			if (this.security.getBasic().isEnabled() && paths.length > 0) { 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests() 						.anyRequest() 						.hasAnyRole( 								this.security.getUser().getRole().toArray(new String[0])) // 						.and().httpBasic() // 						.and().anonymous().disable(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions());  			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders());  		}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// No security at all not even ignores 		assertEquals(0, this.context.getBeanNamesForType(FilterChainProxy.class).length); 	}
public static void main(String[] args) throws Exception { 		// Set user password to "password" for demo purposes only 		new SpringApplicationBuilder(SampleWebSecureApplication.class).properties( 				"security.user.password=password").run(args); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().fullyAuthenticated().and().formLogin() 					.loginPage("/login").failureUrl("/login?error").permitAll(); 		}
@Test 	public void testHome() throws Exception { 		HttpHeaders headers = new HttpHeaders(); 		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML)); 		ResponseEntity<String> entity = new TestRestTemplate().exchange( 				"http://localhost:" + this.port, HttpMethod.GET, new HttpEntity<Void>( 						headers), String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertTrue("Wrong body (title doesn't match):\n" + entity.getBody(), entity 				.getBody().contains("<title>Login")); 	}
@Test 	@Ignore("https://github.com/spring-projects/spring-boot/issues/699") 	public void testManagementAuthorizedAccess() throws Exception { 		ResponseEntity<String> entity = new TestRestTemplate("user", "user") 				.getForEntity("http://localhost:" + port + "/beans", String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 	}
public ConfigurableApplicationContext run(String... args) {  		StopWatch stopWatch = new StopWatch(); 		stopWatch.start(); 		ConfigurableApplicationContext context = null;  		System.setProperty("java.awt.headless", Boolean.toString(this.headless));  		Collection<SpringApplicationRunListener> runListeners = getRunListeners(args); 		for (SpringApplicationRunListener runListener : runListeners) { 			runListener.started(); 		}  		try { 			// Create and configure the environment 			ConfigurableEnvironment environment = getOrCreateEnvironment(); 			configureEnvironment(environment, args); 			for (SpringApplicationRunListener runListener : runListeners) { 				runListener.environmentPrepared(environment); 			}  			if (this.showBanner) { 				printBanner(); 			}  			// Create, load, refresh and run the ApplicationContext 			context = createApplicationContext(); 			if (this.registerShutdownHook) { 				context.registerShutdownHook(); 			} 			context.setEnvironment(environment); 			postProcessApplicationContext(context); 			applyInitializers(context); 			for (SpringApplicationRunListener runListener : runListeners) { 				runListener.contextPrepared(context); 			} 			if (this.logStartupInfo) { 				logStartupInfo(context.getParent() == null); 			}  			// Load the sources 			Set<Object> sources = getSources(); 			Assert.notEmpty(sources, "Sources must not be empty"); 			load(context, sources.toArray(new Object[sources.size()])); 			for (SpringApplicationRunListener runListener : runListeners) { 				runListener.contextLoaded(context); 			}  			// Refresh the context 			refresh(context); 			afterRefresh(context, args); 			for (SpringApplicationRunListener runListener : runListeners) { 				runListener.finished(context, null); 			}  			stopWatch.stop(); 			if (this.logStartupInfo) { 				new StartupInfoLogger(this.mainApplicationClass).logStarted( 						getApplicationLog(), stopWatch); 			} 			return context; 		} 		catch (Exception ex) { 			for (SpringApplicationRunListener runListener : runListeners) { 				finishWithException(runListener, context, ex); 			} 			if (context != null) { 				context.close(); 			} 			ReflectionUtils.rethrowRuntimeException(ex); 			return context; 		} 		finally { 		} 	}
private StringBuilder getStartedMessage(StopWatch stopWatch) { 		StringBuilder message = new StringBuilder(); 		message.append("Started "); 		message.append(getApplicationName()); 		message.append(" in "); 		message.append(stopWatch.getTotalTimeSeconds()); 		message.append(" seconds (JVM running for "); 		message.append(ManagementFactory.getRuntimeMXBean().getUptime() / 1000.0); 		message.append(")"); 		return message; 	}
@Override 			public Object call() throws Exception { 				return source.getPackage().getImplementationVersion(); 			}
@Override 			public Object call() throws Exception { 				return source.getPackage().getImplementationVersion(); 			}
@Override 			public Object call() throws Exception { 				return source.getPackage().getImplementationVersion(); 			}
@Override 			public Object call() throws Exception { 				return InetAddress.getLocalHost().getHostName(); 			}
@Override 			public Object call() throws Exception { 				return InetAddress.getLocalHost().getHostName(); 			}
@Override 			public Object call() throws Exception { 				return InetAddress.getLocalHost().getHostName(); 			}
@Override 			public Object call() throws Exception { 				return System.getProperty("PID"); 			}
@Override 			public Object call() throws Exception { 				return System.getProperty("PID"); 			}
@Override 			public Object call() throws Exception { 				return System.getProperty("PID"); 			}
@Override 			public Object call() throws Exception { 				return System.getProperty("user.name"); 			}
@Override 			public Object call() throws Exception { 				return System.getProperty("user.name"); 			}
@Override 			public Object call() throws Exception { 				return System.getProperty("user.name"); 			}
private String getPid() { 		String name = ManagementFactory.getRuntimeMXBean().getName(); 		if (name != null) { 			return name.split("@")[0]; 		} 		return "????"; 	}
@Override 	public void beforeInitialize() { 		super.beforeInitialize(); 		if (ClassUtils.isPresent("org.slf4j.bridge.SLF4JBridgeHandler", getClassLoader())) { 			try { 				SLF4JBridgeHandler.removeHandlersForRootLogger(); 			} 			catch (NoSuchMethodError ex) { 				// Method missing in older versions of SLF4J like in JBoss AS 7.1 				SLF4JBridgeHandler.uninstall(); 			} 			SLF4JBridgeHandler.install(); 		} 	}
@Bean 	@ConditionalOnMissingBean 	public EndpointHandlerMapping endpointHandlerMapping() { 		EndpointHandlerMapping mapping = new EndpointHandlerMapping(mvcEndpoints() 				.getEndpoints()); 		mapping.setDisabled(ManagementServerPort.get(this.applicationContext) != ManagementServerPort.SAME); 		mapping.setPrefix(this.managementServerProperties.getContextPath()); 		return mapping; 	}
private static String[] getEndpointPaths( 			EndpointHandlerMapping endpointHandlerMapping, boolean secure) { 		if (endpointHandlerMapping == null) { 			return NO_PATHS; 		}  		Set<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints(); 		List<String> paths = new ArrayList<String>(endpoints.size()); 		for (MvcEndpoint endpoint : endpoints) { 			if (endpoint.isSensitive() == secure) { 				paths.add(endpoint.getPath()); 			} 		} 		return paths.toArray(new String[paths.size()]); 	}
@BeforeClass 	public static void start() throws Exception { 		final String[] args = new String[] { "--server.port=" + port, 				"--management.port=" + managementPort, "--management.address=127.0.0.1" }; 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return SpringApplication.run( 										SampleActuatorApplication.class, args); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@Test 	public void testHealth() throws Exception { 		ResponseEntity<String> entity = getRestTemplate().getForEntity( 				"http://localhost:" + managementPort + "/health", String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertEquals("ok", entity.getBody()); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 		// 6 for static resources, one for management endpoints and one for the rest 		assertEquals(8, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testWebConfigurationWithExtraRole() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(EndpointAutoConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		debugRefresh(this.context); 		UserDetails user = getUser(); 		assertTrue(user.getAuthorities().containsAll( 				AuthorityUtils 						.commaSeparatedStringToAuthorityList("ROLE_USER,ROLE_ADMIN"))); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		debugRefresh(this.context); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 		// 4 for static resources and one for the rest 		assertEquals(5, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
public static void main(String[] args) throws Exception { 		SpringApplication.run(SampleSecureApplication.class, args); 	}
private List<RemoteRepository> createRepositories( 			List<RepositoryConfiguration> repositoryConfigurations) { 		List<RemoteRepository> repositories = new ArrayList<RemoteRepository>( 				repositoryConfigurations.size()); 		for (RepositoryConfiguration repositoryConfiguration : repositoryConfigurations) { 			RemoteRepository.Builder builder = new RemoteRepository.Builder( 					repositoryConfiguration.getName(), "default", repositoryConfiguration 							.getUri().toASCIIString());  			if (!repositoryConfiguration.getSnapshotsEnabled()) { 				builder.setSnapshotPolicy(new RepositoryPolicy(false, 						RepositoryPolicy.UPDATE_POLICY_NEVER, 						RepositoryPolicy.CHECKSUM_POLICY_IGNORE)); 			}  			repositories.add(builder.build()); 		} 		return repositories; 	}
@Override 	public void addResolver(Map<String, Object> args) { 		String name = (String) args.get("name"); 		String root = (String) args.get("root");  		this.repositories 				.add(new RemoteRepository.Builder(name, "default", root).build()); 	}
@Bean 	@ConditionalOnExpression("'${shell.auth:simple}' == 'spring'") 	@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 	public CrshShellAuthenticationProperties springAuthenticationProperties() { 		return new SpringAuthenticationProperties(); 	}
@Bean 		@ConditionalOnExpression("'${shell.auth:default_spring}' == 'default_spring'") 		@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 		public CrshShellAuthenticationProperties springAuthenticationProperties() { 			// In case no shell.auth property is provided fall back to Spring Security 			// based authentication and get role to access shell from SecurityProperties. 			SpringAuthenticationProperties authenticationProperties = new SpringAuthenticationProperties(); 			if (this.securityProperties != null) { 				authenticationProperties.setRoles(new String[] { this.securityProperties 						.getManagement().getRole() }); 			} 			return authenticationProperties; 		}
@Bean 		@ConditionalOnExpression("'${shell.auth:default_spring}' == 'default_spring'") 		@ConditionalOnMissingBean({ CrshShellAuthenticationProperties.class }) 		public CrshShellAuthenticationProperties springAuthenticationProperties() { 			// In case no shell.auth property is provided fall back to Spring Security 			// based authentication and get role to access shell from SecurityProperties. 			SpringAuthenticationProperties authenticationProperties = new SpringAuthenticationProperties(); 			if (this.securityProperties != null) { 				authenticationProperties.setRoles(new String[] { this.securityProperties 						.getManagement().getRole() }); 			} 			return authenticationProperties; 		}
@PostConstruct 		public void init() throws Exception { 			FS commandFileSystem = createFileSystem(this.properties 					.getCommandPathPatterns()); 			FS configurationFileSystem = createFileSystem(this.properties 					.getConfigPathPatterns());  			PluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery( 					this.resourceLoader.getClassLoader(), this.beanFactory, 					this.properties.getDisabledPlugins());  			PluginContext context = new PluginContext(discovery, 					createPluginContextAttributes(), commandFileSystem, 					configurationFileSystem, this.resourceLoader.getClassLoader());  			context.refresh(); 			start(context); 		}
@Override 		public String getName() { 			return "spring"; 		}
@Override 		public void init() { 			String rolesPropertyValue = getContext().getProperty(ROLES); 			if (rolesPropertyValue != null) { 				this.roles = StringUtils 						.commaDelimitedListToStringArray(rolesPropertyValue); 			} 		}
public String getName() { 			return this.name; 		}
public static ManagementServerPort get(ApplicationContext beanFactory) {  			ServerProperties serverProperties; 			try { 				serverProperties = beanFactory.getBean(ServerProperties.class); 			} 			catch (NoSuchBeanDefinitionException ex) { 				serverProperties = new ServerProperties(); 			}  			ManagementServerProperties managementServerProperties; 			try { 				managementServerProperties = beanFactory 						.getBean(ManagementServerProperties.class); 			} 			catch (NoSuchBeanDefinitionException ex) { 				managementServerProperties = new ManagementServerProperties(); 			}  			if (DISABLED_PORT.equals(managementServerProperties.getPort())) { 				return DISABLE; 			} 			if (!(beanFactory instanceof GenericWebApplicationContext)) { 				// Current context is no a a webapp 				return DIFFERENT; 			} 			return managementServerProperties.getPort() == null 					|| serverProperties.getPort() == null 					&& managementServerProperties.getPort().equals(8080) 					|| managementServerProperties.getPort().equals( 							serverProperties.getPort()) ? SAME : DIFFERENT; 		}
@Test 	public void securityDependencies() throws Exception { 		this.cli.run("secure.groovy"); 		assertThat(this.cli.getHttpOutput(), 				containsString("{\"message\":\"Hello World\"}")); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return SpringApplication.run( 										SampleActuatorApplication.class, 										"--security.management.enabled=false"); 							} 						}); 		context = future.get(60, TimeUnit.SECONDS); 	}
@Override 							public ConfigurableApplicationContext call() throws Exception { 								return SpringApplication.run( 										SampleActuatorApplication.class, 										"--security.management.enabled=false"); 							}
@Override 	public void initialize(SpringApplication springApplication, String[] args) { 		if (System.getProperty("PID") == null) { 			System.setProperty("PID", getPid()); 		} 		LoggingSystem loggingSystem = LoggingSystem.get(springApplication.getClass() 				.getClassLoader()); 		loggingSystem.beforeInitialize(); 		if (this.parseArgs && this.springBootLogging == null 				&& !ObjectUtils.isEmpty(args)) { 			SimpleCommandLinePropertySource parsedArgs = new SimpleCommandLinePropertySource( 					args); 			if (parsedArgs.containsProperty("debug")) { 				this.springBootLogging = LogLevel.DEBUG; 			} 			if (parsedArgs.containsProperty("trace")) { 				this.springBootLogging = LogLevel.TRACE; 			} 		} 	}
@Override 	public void initialize(ConfigurableApplicationContext applicationContext) {  		ConfigurableEnvironment environment = applicationContext.getEnvironment();  		for (Map.Entry<String, String> mapping : ENVIRONMENT_SYSTEM_PROPERTY_MAPPING 				.entrySet()) { 			if (environment.containsProperty(mapping.getKey())) { 				System.setProperty(mapping.getValue(), 						environment.getProperty(mapping.getKey())); 			} 		}  		LoggingSystem system = LoggingSystem.get(applicationContext.getClassLoader());  		// User specified configuration 		if (environment.containsProperty("logging.config")) { 			String value = environment.getProperty("logging.config"); 			try { 				ResourceUtils.getURL(value).openStream().close(); 				system.initialize(value); 				return; 			} 			catch (Exception ex) { 				// Swallow exception and continue 			} 			this.logger.warn("Logging environment value '" + value 					+ "' cannot be opened and will be ignored"); 		}  		system.initialize(); 		if (this.springBootLogging != null) { 			initializeLogLevel(system, this.springBootLogging); 		} 	}
@Test 	public void parseDebugArg() throws Exception { 		this.initializer.initialize(this.springApplication, new String[] { "--debug" }); 		this.initializer.initialize(this.context); 		this.logger.debug("testatdebug"); 		this.logger.trace("testattrace"); 		assertThat(this.outputCapture.toString(), containsString("testatdebug")); 		assertThat(this.outputCapture.toString(), not(containsString("testattrace"))); 	}
@Test 	public void parseTraceArg() throws Exception { 		this.context = new GenericApplicationContext(); 		this.initializer.initialize(this.springApplication, new String[] { "--trace" }); 		this.initializer.initialize(this.context); 		this.logger.debug("testatdebug"); 		this.logger.trace("testattrace"); 		assertThat(this.outputCapture.toString(), containsString("testatdebug")); 		assertThat(this.outputCapture.toString(), containsString("testattrace")); 	}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			}  			if (this.security.getBasic().isEnabled()) { 				String[] paths = getSecurePaths(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint()).and() 						.requestMatchers().antMatchers(paths); 				http.httpBasic().and().anonymous().disable(); 				http.authorizeUrls().anyRequest() 						.hasRole(this.security.getBasic().getRole()); 			}  			// No cookies for service endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser("user").password("password").roles("USER").and().and() 					.build(); 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser("user").password("password").roles("USER").and().and() 					.build(); 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testOverrideAuthenticationManager() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(TestConfiguration.class, SecurityAutoConfiguration.class, 				EndpointAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertEquals(this.context.getBean(TestConfiguration.class).authenticationManager, 				this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:" + port, Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:8080", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test(expected = ResourceAccessException.class) 	public void testMetricsNotAvailable() throws Exception { 		testHome(); // makes sure some requests have been made 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:" + managementPort + "/metrics", Map.class); 		assertEquals(HttpStatus.NOT_FOUND, entity.getStatusCode()); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:8080", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testMetrics() throws Exception { 		testHome(); // makes sure some requests have been made 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:8080/metrics", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertTrue("Wrong body: " + body, body.containsKey("counter.status.200.root")); 	}
@Test 	public void testEnv() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:8080/env", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertTrue("Wrong body: " + body, body.containsKey("systemProperties")); 	}
@Test 	public void testErrorPage() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:8080/foo", Map.class); 		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals(500, body.get("status")); 	}
@Test 	public void testBeans() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<List> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:8080/beans", List.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertEquals(1, entity.getBody().size()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = (Map<String, Object>) entity.getBody().get(0); 		assertTrue("Wrong body: " + body, 				((String) body.get("context")).startsWith("application")); 	}
@Test 	public void testHome() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").getForEntity( 				"http://localhost:8080", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertEquals("Hello Phil", body.get("message")); 	}
@Test 	public void testShutdown() throws Exception { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate("user", "password").postForEntity( 				"http://localhost:8080/shutdown", null, Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertTrue("Wrong body: " + body, 				((String) body.get("message")).contains("Shutting down")); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(NonAutoConfigurationSampleTomcatApplication.class); 							} 						}); 		context = future.get(10, TimeUnit.SECONDS); 	}
@BeforeClass 	public static void start() throws Exception { 		Future<ConfigurableApplicationContext> future = Executors 				.newSingleThreadExecutor().submit( 						new Callable<ConfigurableApplicationContext>() { 							@Override 							public ConfigurableApplicationContext call() throws Exception { 								return (ConfigurableApplicationContext) SpringApplication 										.run(SampleTomcatApplication.class); 							} 						}); 		context = future.get(10, TimeUnit.SECONDS); 	}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser("user").password("password").roles("USER").and().and() 					.build(); 		}
@Override 		protected void configure(HttpConfiguration http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().antMatchers("/**").requiresSecure(); 			} 			if (this.security.getBasic().isEnabled()) { 				HttpConfiguration matcher = http.antMatcher(this.security.getBasic() 						.getPath()); 				matcher.authenticationEntryPoint(entryPoint()).antMatcher("/**") 						.httpBasic().authenticationEntryPoint(entryPoint()).and() 						.anonymous().disable(); 				matcher.authorizeUrls().antMatchers("/**") 						.hasRole(this.security.getBasic().getRole()); 			} 			// No cookies for service endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 		}
@Override 		public void configure(WebSecurityBuilder builder) throws Exception { 			builder.ignoring().antMatchers(this.endpoints.getHealth().getPath(), 					this.endpoints.getInfo().getPath(), 					this.endpoints.getError().getPath()); 		}
@Override 		protected AuthenticationManager authenticationManager() throws Exception { 			AuthenticationManager manager = super.authenticationManager(); 			if (manager instanceof ProviderManager) { 				((ProviderManager) manager) 						.setAuthenticationEventPublisher(this.authenticationEventPublisher); 			} 			return manager; 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			return new AuthenticationManagerBuilder().inMemoryAuthentication() 					.withUser("user").password("password").roles("USER").and().and() 					.build(); 		}
@Bean 		public EmbeddedServletContainerFactory factory() { 			return new EmbeddedServletContainerFactory() {  				@Override 				public EmbeddedServletContainer getEmbdeddedServletContainer( 						ServletContextInitializer... initializers) { 					ServletContext servletContext = new MockServletContext() { 						@Override 						public Dynamic addServlet(String servletName, Servlet servlet) { 							return Mockito.mock(Dynamic.class); 						} 					}; 					for (ServletContextInitializer initializer : initializers) { 						try { 							initializer.onStartup(servletContext); 						} catch (ServletException ex) { 							throw new IllegalStateException(ex); 						} 					} 					return new EmbeddedServletContainer() { 						@Override 						public void stop() throws EmbeddedServletContainerException { 						} 					}; 				} 			}; 		}
@Override 				public EmbeddedServletContainer getEmbdeddedServletContainer( 						ServletContextInitializer... initializers) { 					ServletContext servletContext = new MockServletContext() { 						@Override 						public Dynamic addServlet(String servletName, Servlet servlet) { 							return Mockito.mock(Dynamic.class); 						} 					}; 					for (ServletContextInitializer initializer : initializers) { 						try { 							initializer.onStartup(servletContext); 						} catch (ServletException ex) { 							throw new IllegalStateException(ex); 						} 					} 					return new EmbeddedServletContainer() { 						@Override 						public void stop() throws EmbeddedServletContainerException { 						} 					}; 				}
@Override 	public void applyImports(ImportCustomizer imports) { 		imports.addImports("javax.sql.DataSource", "javax.annotation.PostConstruct", 				"javax.annotation.PreDestroy", "groovy.util.logging.Log", 				"org.springframework.stereotype.Controller", 				"org.springframework.stereotype.Service", 				"org.springframework.stereotype.Component", 				"org.springframework.beans.factory.annotation.Autowired", 				"org.springframework.beans.factory.annotation.Value", 				"org.springframework.context.annotation.Import", 				"org.springframework.context.annotation.ImportResource", 				"org.springframework.context.annotation.Profile", 				"org.springframework.context.annotation.Scope", 				"org.springframework.context.annotation.Configuration", 				"org.springframework.context.annotation.ComponentScan", 				"org.springframework.context.annotation.Bean", 				"org.springframework.context.ApplicationContext", 				"org.springframework.context.MessageSource", 				"org.springframework.core.io.ResourceLoader", 				"org.springframework.bootstrap.CommandLineRunner", 				"org.springframework.bootstrap.context.annotation.EnableAutoConfiguration"); 		imports.addStarImports("org.springframework.stereotype"); 	}
@Test 	public void testMetrics() throws Exception { 		testHome(); // makes sure some requests have been made 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = getRestTemplate().getForEntity( 				"http://localhost:" + managementPort + "/metrics", Map.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertTrue("Wrong body: " + body, body.containsKey("counter.status.200.root")); 	}
@Override 	public Object postProcessAfterInitialization(Object bean, String beanName) 			throws BeansException { 		ConfigurationProperties annotation = AnnotationUtils.findAnnotation( 				bean.getClass(), ConfigurationProperties.class); 		Object target = bean; 		if (annotation != null || bean instanceof ConfigurationPropertiesHolder) { 			if (bean instanceof ConfigurationPropertiesHolder) { 				target = ((ConfigurationPropertiesHolder) bean).getTarget(); 			} 			PropertiesConfigurationFactory<Object> factory = new PropertiesConfigurationFactory<Object>( 					target); 			factory.setPropertySources(this.propertySources); 			factory.setValidator(this.validator); 			factory.setConversionService(this.conversionService); 			String targetName = null; 			if (annotation != null) { 				factory.setIgnoreInvalidFields(annotation.ignoreInvalidFields()); 				factory.setIgnoreUnknownFields(annotation.ignoreUnknownFields()); 				targetName = "".equals(annotation.value()) ? ("" 						.equals(annotation.name()) ? null : annotation.name()) 						: annotation.value(); 			} 			factory.setTargetName(targetName); 			try { 				target = factory.getObject(); // throwaway 			} catch (BeansException e) { 				throw e; 			} catch (Exception e) { 				throw new BeanCreationException(beanName, "Could not bind", e); 			} 		} 		return bean; 	}
@ConditionalOnMissingBean(TestProperties.class) 		@Bean(name = "org.springframework.bootstrap.context.annotation.EnableConfigurationPropertiesTests$TestProperties") 		public TestProperties testProperties() { 			return new TestProperties(); 		}
@Bean 		@AssertMissingBean(TestProperties.class) 		public TestProperties testProperties() { 			TestProperties test = new TestProperties(); 			test.setName("bar"); 			return test; 		}
public String getName() { 			return this.properties.getName(); 		}
public String getName() { 			return this.properties.getName(); 		}
public String getName() { 			return this.name; 		}
public String getName() { 			return this.name; 		}
@Test 	public void testManagementConfiguration() throws Exception { 		this.context = new AnnotationConfigApplicationContext(); 		this.context 				.register(MetricRepositoryConfiguration.class, 						TraceFilterConfiguration.class, 						ServerPropertiesConfiguration.class, 						ActuatorAutoConfiguration.ServerPropertiesConfiguration.class, 						ManagementConfiguration.class, 						PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(HealthEndpoint.class)); 	}
@Test 	public void testChildContextCreated() throws Exception { 		this.context = new AnnotationConfigApplicationContext(); 		TestUtils.addEnviroment(this.context, "server.port:7000", "management.port:7001"); 		this.context 				.register(ParentContext.class, MetricRepositoryConfiguration.class, 						TraceFilterConfiguration.class, 						ServerPropertiesConfiguration.class, 						ActuatorAutoConfiguration.ServerPropertiesConfiguration.class, 						ManagementConfiguration.class, 						PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertEquals(0, this.context.getBeanNamesForType(HealthEndpoint.class).length); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityConfiguration.class, EndpointsProperties.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 	}
@Test 	public void testOverrideAuthenticationManager() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(TestConfiguration.class, SecurityConfiguration.class, 				EndpointsProperties.class, PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertEquals(this.context.getBean(TestConfiguration.class).authenticationManager, 				this.context.getBean(AuthenticationManager.class)); 	}
@Override 	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {  		String checking = ConditionLogUtils.getPrefix(logger, metadata);  		String value = (String) metadata.getAnnotationAttributes( 				ConditionalOnExpression.class.getName()).get("value"); 		if (!value.startsWith("#{")) { 			// For convenience allow user to provide bare expression with no #{} wrapper 			value = "#{" + value + "}"; 		} 		if (logger.isDebugEnabled()) { 			StringBuilder builder = new StringBuilder(checking) 					.append("Evaluating expression"); 			if (metadata instanceof ClassMetadata) { 				builder.append(" on " + ((ClassMetadata) metadata).getClassName()); 			} 			builder.append(": " + value); 			logger.debug(builder.toString()); 		} 		// Explicitly allow environment placeholders inside the expression 		value = context.getEnvironment().resolvePlaceholders(value); 		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); 		BeanExpressionResolver resolver = beanFactory.getBeanExpressionResolver(); 		BeanExpressionContext expressionContext = (beanFactory != null) ? new BeanExpressionContext( 				beanFactory, null) : null; 		if (resolver == null) { 			resolver = new StandardBeanExpressionResolver(); 		} 		Boolean result = (Boolean) resolver.evaluate(value, expressionContext); 		if (logger.isDebugEnabled()) { 			logger.debug(checking + "Finished matching and result is matches=" + result); 		} 		return result; 	}
static SQLDialect getDialect(DataSource dataSource) { 		try { 			Connection connection = (dataSource != null) ? dataSource.getConnection() : null; 			return JDBCUtils.dialect(connection); 		} 		catch (SQLException ex) { 			logger.warn("Unable to determine dialect from datasource", ex); 		} 		return SQLDialect.DEFAULT; 	}
public ConfigurableApplicationContext run(String... args) { 		long startTime = System.nanoTime(); 		DefaultBootstrapContext bootstrapContext = createBootstrapContext(); 		ConfigurableApplicationContext context = null; 		configureHeadlessProperty(); 		SpringApplicationRunListeners listeners = getRunListeners(args); 		listeners.starting(bootstrapContext, this.mainApplicationClass); 		try { 			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); 			ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments); 			Banner printedBanner = printBanner(environment); 			context = createApplicationContext(); 			context.setApplicationStartup(this.applicationStartup); 			prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner); 			refreshContext(context); 			afterRefresh(context, applicationArguments); 			Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime); 			if (this.logStartupInfo) { 				new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup); 			} 			listeners.started(context, timeTakenToStartup); 			callRunners(context, applicationArguments); 		} 		catch (Throwable ex) { 			if (ex instanceof AbandonedRunException) { 				throw ex; 			} 			handleRunFailure(context, ex, listeners); 			throw new IllegalStateException(ex); 		} 		try { 			if (context.isRunning()) { 				Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime); 				listeners.ready(context, timeTakenToReady); 			} 		} 		catch (Throwable ex) { 			if (ex instanceof AbandonedRunException) { 				throw ex; 			} 			handleRunFailure(context, ex, null); 			throw new IllegalStateException(ex); 		} 		return context; 	}
public ConfigurableApplicationContext run(String... args) { 		long startTime = System.nanoTime(); 		DefaultBootstrapContext bootstrapContext = createBootstrapContext(); 		ConfigurableApplicationContext context = null; 		configureHeadlessProperty(); 		SpringApplicationRunListeners listeners = getRunListeners(args); 		listeners.starting(bootstrapContext, this.mainApplicationClass); 		try { 			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); 			ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments); 			Banner printedBanner = printBanner(environment); 			context = createApplicationContext(); 			context.setApplicationStartup(this.applicationStartup); 			prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner); 			refreshContext(context); 			afterRefresh(context, applicationArguments); 			Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime); 			if (this.logStartupInfo) { 				new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup); 			} 			listeners.started(context, timeTakenToStartup); 			callRunners(context, applicationArguments); 		} 		catch (Throwable ex) { 			if (ex instanceof AbandonedRunException) { 				throw ex; 			} 			handleRunFailure(context, ex, listeners); 			throw new IllegalStateException(ex); 		} 		try { 			if (context.isRunning()) { 				Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime); 				listeners.ready(context, timeTakenToReady); 			} 		} 		catch (Throwable ex) { 			if (ex instanceof AbandonedRunException) { 				throw ex; 			} 			handleRunFailure(context, ex, null); 			throw new IllegalStateException(ex); 		} 		return context; 	}
public SpringApplication.Running run(String... args) { 			RunListener runListener = new RunListener(); 			SpringApplicationHook hook = new SingleUseSpringApplicationHook((springApplication) -> { 				springApplication.addPrimarySources(this.sources); 				return runListener; 			}); 			withHook(hook, () -> this.main.accept(args)); 			return runListener; 		}
@Override 			public ConfigurableApplicationContext getApplicationContext() { 				List<ConfigurableApplicationContext> rootContexts = this.contexts.stream() 					.filter((context) -> context.getParent() == null) 					.toList(); 				Assert.state(!rootContexts.isEmpty(), "No root application context located"); 				Assert.state(rootContexts.size() == 1, "No unique root application context located"); 				return rootContexts.get(0); 			}
public ConfigurableApplicationContext getApplicationContext() { 			return this.applicationContext; 		}
private void addRuntimeShutdownHookIfNecessary() { 		if (this.shutdownHookAdded.compareAndSet(false, true)) { 			addRuntimeShutdownHook(); 		} 	}
@Override 	public void run() { 		Set<ConfigurableApplicationContext> contexts; 		Set<ConfigurableApplicationContext> closedContexts; 		Set<Runnable> actions; 		synchronized (SpringApplicationShutdownHook.class) { 			this.inProgress = true; 			contexts = new LinkedHashSet<>(this.contexts); 			closedContexts = new LinkedHashSet<>(this.closedContexts); 			actions = new LinkedHashSet<>(this.handlers.getActions()); 		} 		contexts.forEach(this::closeAndWait); 		closedContexts.forEach(this::closeAndWait); 		actions.forEach(Runnable::run); 	}
@Override 		public void run() { 			SpringApplicationShutdownHook.this.run(); 			SpringApplicationShutdownHook.this.reset(); 		}
@Test 	void shutdownHookIsNotAddedUntilContextIsRegistered() { 		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook(); 		assertThat(shutdownHook.isRuntimeShutdownHookAdded()).isFalse(); 		ConfigurableApplicationContext context = new GenericApplicationContext(); 		shutdownHook.registerApplicationContext(context); 		assertThat(shutdownHook.isRuntimeShutdownHookAdded()).isTrue(); 	}
@Test 	void shutdownHookIsNotAddedUntilHandlerIsRegistered() { 		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook(); 		assertThat(shutdownHook.isRuntimeShutdownHookAdded()).isFalse(); 		shutdownHook.getHandlers().add(() -> { 		}); 		assertThat(shutdownHook.isRuntimeShutdownHookAdded()).isTrue(); 	}
@Override 		public void afterPropertiesSet() throws Exception { 			this.context.close(); 			// Simulate System.exit by running the hook on a separate thread and waiting 			// for it to complete 			Thread thread = new Thread(this.shutdownHook); 			thread.start(); 			thread.join(15000); 			assertThat(thread.isAlive()).isFalse(); 		}
@Override 		public void afterPropertiesSet() throws Exception { 			throw new IllegalArgumentException("test failure"); 		}
private void handleRunFailure(ConfigurableApplicationContext context, Throwable exception, 			SpringApplicationRunListeners listeners) { 		try { 			try { 				handleExitCode(context, exception); 				if (listeners != null) { 					listeners.failed(context, exception); 				} 			} 			finally { 				reportFailure(getExceptionReporters(context), exception); 				if (context != null) { 					context.close(); 				} 			} 		} 		catch (Exception ex) { 			logger.warn("Unable to close ApplicationContext", ex); 		} 		ReflectionUtils.rethrowRuntimeException(exception); 	}
@Override 		public void afterPropertiesSet() throws Exception { 			this.context.close(); 			// Simulate System.exit by running the hook on a separate thread and waiting 			// for it to complete 			Thread thread = new Thread(this.shutdownHook); 			thread.start(); 			thread.join(15000); 			assertThat(thread.isAlive()).isFalse(); 		}
@Test 	void run() { 		this.context = SpringApplication.run(ExampleWebConfig.class); 		assertThat(this.context).isNotNull(); 	}
@Test 	void registerShutdownHook() { 		SpringApplication application = new SpringApplication(ExampleConfig.class); 		application.setWebApplicationType(WebApplicationType.NONE); 		this.context = application.run(); 		assertThat(SpringApplicationShutdownHookInstance.get()).registeredApplicationContext(this.context); 	}
@Override 			public void run() { 				SpringApplication application = new SpringApplication(FailingConfig.class); 				application.setWebApplicationType(WebApplicationType.NONE); 				application.run(); 			}
@Override 		public void registerShutdownHook() { 			this.applicationContext.registerShutdownHook(); 		}
@Bean 		String someBean() { 			return "test"; 		}
@Bean 		String someBean() { 			return "override"; 		}
@Bean 		Object fail() { 			throw new RuntimeException("ExpectedError"); 		}
@Bean 		CommandLineRunner runner() { 			return (args) -> { 				throw new IllegalStateException(new ExitStatusException()); 			}; 		}
@Bean 		CommandLineRunner runner() { 			return (args) -> { 				throw new IllegalStateException(); 			}; 		}
@PostConstruct 		void fail() { 			throw new RefreshFailureException(); 		}
@Override 		public int getExitCode() { 			return 11; 		}
Integer getExitCode() { 			return this.exitCode; 		}
protected void addRuntimeShutdownHook() { 		Runtime.getRuntime().addShutdownHook(new Thread(this, "SpringApplicationShutdownHook")); 	}
void registerApplicationContext(ConfigurableApplicationContext context) { 		synchronized (SpringApplicationShutdownHook.class) { 			assertNotInProgress(); 			context.addApplicationListener(this.contextCloseListener); 			this.contexts.add(context); 		} 	}
@Override 	public void apply(Project project) { 		Configuration optional = project.getConfigurations().create(OPTIONAL_CONFIGURATION_NAME); 		optional.attributes((attributes) -> attributes.attribute(Usage.USAGE_ATTRIBUTE, 				project.getObjects().named(Usage.class, Usage.JAVA_RUNTIME))); 		project.getPlugins().withType(JavaPlugin.class, (javaPlugin) -> { 			SourceSetContainer sourceSets = project.getConvention().getPlugin(JavaPluginConvention.class) 					.getSourceSets(); 			sourceSets.all((sourceSet) -> { 				sourceSet.setCompileClasspath(sourceSet.getCompileClasspath().plus(optional)); 				sourceSet.setRuntimeClasspath(sourceSet.getRuntimeClasspath().plus(optional)); 			}); 			project.getTasks().withType(Javadoc.class) 					.all((javadoc) -> javadoc.setClasspath(javadoc.getClasspath().plus(optional))); 		}); 		project.getPlugins().withType(EclipsePlugin.class, 				(eclipsePlugin) -> project.getExtensions().getByType(EclipseModel.class) 						.classpath((classpath) -> classpath.getPlusConfigurations().add(optional))); 	}
private List<File> pluginClasspath() { 		return Arrays.asList(new File("bin/main"), new File("build/classes/java/main"), 				new File("build/resources/main"), new File(pathOfJarContaining(LaunchScript.class)), 				new File(pathOfJarContaining(ClassVisitor.class)), 				new File(pathOfJarContaining(DependencyManagementPlugin.class)), 				new File(pathOfJarContaining(PropertiesKt.class)), new File(pathOfJarContaining(KotlinLogger.class)), 				new File(pathOfJarContaining(KotlinPlugin.class)), new File(pathOfJarContaining(KotlinProject.class)), 				new File(pathOfJarContaining(KotlinCompilerClient.class)), 				new File(pathOfJarContaining(KotlinGradleSubplugin.class)), 				new File(pathOfJarContaining(ArchiveEntry.class)), new File(pathOfJarContaining(BuildRequest.class)), 				new File(pathOfJarContaining(HttpClientConnectionManager.class)), 				new File(pathOfJarContaining(HttpRequest.class)), new File(pathOfJarContaining(Module.class)), 				new File(pathOfJarContaining(Versioned.class)), 				new File(pathOfJarContaining(ParameterNamesModule.class)), 				new File(pathOfJarContaining(JsonView.class)), new File(pathOfJarContaining(Platform.class))); 	}
@TaskAction 	void documentConfigurationProperties() throws IOException { 		Builder builder = DocumentOptions.builder(); 		builder.addSection("core") 				.withKeyPrefixes("debug", "trace", "logging", "spring.aop", "spring.application", 						"spring.autoconfigure", "spring.banner", "spring.beaninfo", "spring.codec", "spring.config", 						"spring.info", "spring.jmx", "spring.lifecycle", "spring.main", "spring.messages", "spring.pid", 						"spring.profiles", "spring.quartz", "spring.reactor", "spring.task", 						"spring.mandatory-file-encoding", "info", "spring.output.ansi.enabled") 				.addSection("mail").withKeyPrefixes("spring.mail", "spring.sendgrid").addSection("cache") 				.withKeyPrefixes("spring.cache").addSection("server").withKeyPrefixes("server").addSection("web") 				.withKeyPrefixes("spring.hateoas", "spring.http", "spring.servlet", "spring.jersey", "spring.mvc", 						"spring.resources", "spring.session", "spring.web", "spring.webflux") 				.addSection("json").withKeyPrefixes("spring.jackson", "spring.gson").addSection("rsocket") 				.withKeyPrefixes("spring.rsocket").addSection("templating") 				.withKeyPrefixes("spring.freemarker", "spring.groovy", "spring.mustache", "spring.thymeleaf") 				.addOverride("spring.groovy.template.configuration", "See GroovyMarkupConfigurer") 				.addSection("security").withKeyPrefixes("spring.security").addSection("data-migration") 				.withKeyPrefixes("spring.flyway", "spring.liquibase", "spring.sql.init").addSection("data") 				.withKeyPrefixes("spring.couchbase", "spring.elasticsearch", "spring.h2", "spring.influx", 						"spring.ldap", "spring.mongodb", "spring.neo4j", "spring.redis", "spring.dao", "spring.data", 						"spring.datasource", "spring.jooq", "spring.jdbc", "spring.jpa", "spring.r2dbc") 				.addOverride("spring.datasource.oracleucp", 						"Oracle UCP specific settings bound to an instance of Oracle UCP's PoolDataSource") 				.addOverride("spring.datasource.dbcp2", 						"Commons DBCP2 specific settings bound to an instance of DBCP2's BasicDataSource") 				.addOverride("spring.datasource.tomcat", 						"Tomcat datasource specific settings bound to an instance of Tomcat JDBC's DataSource") 				.addOverride("spring.datasource.hikari", 						"Hikari specific settings bound to an instance of Hikari's HikariDataSource") 				.addSection("transaction").withKeyPrefixes("spring.jta", "spring.transaction").addSection("integration") 				.withKeyPrefixes("spring.activemq", "spring.artemis", "spring.batch", "spring.integration", 						"spring.jms", "spring.kafka", "spring.rabbitmq", "spring.hazelcast", "spring.webservices") 				.addSection("actuator").withKeyPrefixes("management").addSection("devtools") 				.withKeyPrefixes("spring.devtools").addSection("testing").withKeyPrefixes("spring.test"); 		DocumentOptions options = builder.build(); 		new ConfigurationMetadataDocumentWriter().writeDocument(this.outputDir.toPath(), options, 				this.configurationPropertyMetadata); 	}
private JarFile createJarFileFromDirectoryEntry(JarEntry entry) throws IOException { 		AsciiBytes name = entry.getAsciiBytesName(); 		JarEntryFilter filter = (candidate) -> { 			if (candidate.startsWith(name) && !candidate.equals(name)) { 				return candidate.substring(name.length()); 			} 			return null; 		}; 		return new JarFile(this, this.rootFile, 				this.pathFromRoot + "!/" + entry.getName().substring(0, name.length() - 1), this.data, filter, 				JarFileType.NESTED_DIRECTORY, this.manifestSupplier); 	}
@Override 	public void close() throws IOException { 		if (this.closed) { 			return; 		} 		this.closed = true; 		if (this.type == JarFileType.DIRECT && this.parent == null) { 			this.rootFile.close(); 		} 	}
@Override 	public InputStream getInputStream() throws IOException { 		if (this.jarFile == null) { 			throw FILE_NOT_FOUND_EXCEPTION; 		} 		if (this.jarEntryName.isEmpty() && this.jarFile.getType() == JarFile.JarFileType.DIRECT) { 			throw new IOException("no entry name specified"); 		} 		connect(); 		InputStream inputStream = (this.jarEntryName.isEmpty() ? this.jarFile.getData().getInputStream() 				: this.jarFile.getInputStream(this.jarEntry)); 		if (inputStream == null) { 			throwFileNotFound(this.jarEntryName, this.jarFile); 		} 		return inputStream; 	}
@Override 	public long getContentLengthLong() { 		if (this.jarFile == null) { 			return -1; 		} 		try { 			if (this.jarEntryName.isEmpty()) { 				return this.jarFile.size(); 			} 			JarEntry entry = getJarEntry(); 			return (entry != null) ? (int) entry.getSize() : -1; 		} 		catch (IOException ex) { 			return -1; 		} 	}
@Override 	public String getContentType() { 		return (this.jarEntryName != null) ? this.jarEntryName.getContentType() : null; 	}
@Override 	public Permission getPermission() throws IOException { 		if (this.jarFile == null) { 			throw FILE_NOT_FOUND_EXCEPTION; 		} 		if (this.permission == null) { 			this.permission = new FilePermission(this.jarFile.getRootJarFile().getFile().getPath(), READ_ACTION); 		} 		return this.permission; 	}
@Override 	public long getLastModified() { 		if (this.jarFile == null || this.jarEntryName.isEmpty()) { 			return 0; 		} 		try { 			JarEntry entry = getJarEntry(); 			return (entry != null) ? entry.getTime() : 0; 		} 		catch (IOException ex) { 			return 0; 		} 	}
static JarURLConnection get(URL url, JarFile jarFile) throws IOException { 		StringSequence spec = new StringSequence(url.getFile()); 		int index = indexOfRootSpec(spec, jarFile.getPathFromRoot()); 		if (index == -1) { 			return (Boolean.TRUE.equals(useFastExceptions.get()) ? NOT_FOUND_CONNECTION 					: new JarURLConnection(url, null, EMPTY_JAR_ENTRY_NAME)); 		} 		int separator; 		while ((separator = spec.indexOf(SEPARATOR, index)) > 0) { 			JarEntryName entryName = JarEntryName.get(spec.subSequence(index, separator)); 			JarEntry jarEntry = jarFile.getJarEntry(entryName.toCharSequence()); 			if (jarEntry == null) { 				return JarURLConnection.notFound(jarFile, entryName); 			} 			jarFile = jarFile.getNestedJarFile(jarEntry); 			index = separator + SEPARATOR.length(); 		} 		JarEntryName jarEntryName = JarEntryName.get(spec, index); 		if (Boolean.TRUE.equals(useFastExceptions.get()) && !jarEntryName.isEmpty() 				&& !jarFile.containsEntry(jarEntryName.toString())) { 			return NOT_FOUND_CONNECTION; 		} 		return new JarURLConnection(url, new JarFile(jarFile), jarEntryName); 	}
String getContentType() { 			if (this.contentType == null) { 				this.contentType = deduceContentType(); 			} 			return this.contentType; 		}
@Test 	void whenJarHasAPlusInItsPathConnectionJarFileMatchesOriginalJarFile(@TempDir File tempDir) throws Exception { 		File testJar = new File(tempDir, "t+e+s+t.jar"); 		TestJarCreator.createTestJar(testJar); 		URL url = new URL(null, "jar:" + testJar.toURI().toURL() + "!/nested.jar!/3.dat", this.handler); 		JarURLConnection connection = (JarURLConnection) url.openConnection(); 		try { 			assertThat(connection.getJarFile().getRootJarFile().getFile()).isEqualTo(testJar); 		} 		finally { 			connection.getJarFile().close(); 		} 	}
@Test 	void whenJarHasASpaceInItsPathConnectionJarFileMatchesOriginalJarFile(@TempDir File tempDir) throws Exception { 		File testJar = new File(tempDir, "t e s t.jar"); 		TestJarCreator.createTestJar(testJar); 		URL url = new URL(null, "jar:" + testJar.toURI().toURL() + "!/nested.jar!/3.dat", this.handler); 		JarURLConnection connection = (JarURLConnection) url.openConnection(); 		try { 			assertThat(connection.getJarFile().getRootJarFile().getFile()).isEqualTo(testJar); 		} 		finally { 			connection.getJarFile().close(); 		} 	}
@Test 	void getUrl() throws Exception { 		URL url = this.jarFile.getUrl(); 		assertThat(url.toString()).isEqualTo("jar:" + this.rootJarFile.toURI() + "!/"); 		JarURLConnection jarURLConnection = (JarURLConnection) url.openConnection(); 		assertThat(jarURLConnection.getJarFile().getParent()).isSameAs(this.jarFile); 		assertThat(jarURLConnection.getJarEntry()).isNull(); 		assertThat(jarURLConnection.getContentLength()).isGreaterThan(1); 		assertThat(((JarFile) jarURLConnection.getContent()).getParent()).isSameAs(this.jarFile); 		assertThat(jarURLConnection.getContentType()).isEqualTo("x-java/jar"); 		assertThat(jarURLConnection.getJarFileURL().toURI()).isEqualTo(this.rootJarFile.toURI()); 	}
@Test 	void createEntryUrl() throws Exception { 		URL url = new URL(this.jarFile.getUrl(), "1.dat"); 		assertThat(url.toString()).isEqualTo("jar:" + this.rootJarFile.toURI() + "!/1.dat"); 		JarURLConnection jarURLConnection = (JarURLConnection) url.openConnection(); 		assertThat(jarURLConnection.getJarFile().getParent()).isSameAs(this.jarFile); 		assertThat(jarURLConnection.getJarEntry()).isSameAs(this.jarFile.getJarEntry("1.dat")); 		assertThat(jarURLConnection.getContentLength()).isEqualTo(1); 		assertThat(jarURLConnection.getContent()).isInstanceOf(InputStream.class); 		assertThat(jarURLConnection.getContentType()).isEqualTo("content/unknown"); 		assertThat(jarURLConnection.getPermission()).isInstanceOf(FilePermission.class); 		FilePermission permission = (FilePermission) jarURLConnection.getPermission(); 		assertThat(permission.getActions()).isEqualTo("read"); 		assertThat(permission.getName()).isEqualTo(this.rootJarFile.getPath()); 	}
@Test 	void getNestedJarFile() throws Exception { 		try (JarFile nestedJarFile = this.jarFile.getNestedJarFile(this.jarFile.getEntry("nested.jar"))) { 			assertThat(nestedJarFile.getComment()).isEqualTo("nested"); 			Enumeration<java.util.jar.JarEntry> entries = nestedJarFile.entries(); 			assertThat(entries.nextElement().getName()).isEqualTo("META-INF/"); 			assertThat(entries.nextElement().getName()).isEqualTo("META-INF/MANIFEST.MF"); 			assertThat(entries.nextElement().getName()).isEqualTo("3.dat"); 			assertThat(entries.nextElement().getName()).isEqualTo("4.dat"); 			assertThat(entries.nextElement().getName()).isEqualTo("\u00E4.dat"); 			assertThat(entries.hasMoreElements()).isFalse();  			InputStream inputStream = nestedJarFile.getInputStream(nestedJarFile.getEntry("3.dat")); 			assertThat(inputStream.read()).isEqualTo(3); 			assertThat(inputStream.read()).isEqualTo(-1);  			URL url = nestedJarFile.getUrl(); 			assertThat(url.toString()).isEqualTo("jar:" + this.rootJarFile.toURI() + "!/nested.jar!/"); 			JarURLConnection conn = (JarURLConnection) url.openConnection(); 			assertThat(conn.getJarFile().getParent()).isSameAs(nestedJarFile); 			assertThat(conn.getJarFileURL().toString()).isEqualTo("jar:" + this.rootJarFile.toURI() + "!/nested.jar"); 			assertThat(conn.getInputStream()).isNotNull(); 			JarInputStream jarInputStream = new JarInputStream(conn.getInputStream()); 			assertThat(jarInputStream.getNextJarEntry().getName()).isEqualTo("3.dat"); 			assertThat(jarInputStream.getNextJarEntry().getName()).isEqualTo("4.dat"); 			assertThat(jarInputStream.getNextJarEntry().getName()).isEqualTo("\u00E4.dat"); 			jarInputStream.close(); 			assertThat(conn.getPermission()).isInstanceOf(FilePermission.class); 			FilePermission permission = (FilePermission) conn.getPermission(); 			assertThat(permission.getActions()).isEqualTo("read"); 			assertThat(permission.getName()).isEqualTo(this.rootJarFile.getPath()); 		} 	}
@Test 	void getNestedJarDirectory() throws Exception { 		try (JarFile nestedJarFile = this.jarFile.getNestedJarFile(this.jarFile.getEntry("d/"))) { 			Enumeration<java.util.jar.JarEntry> entries = nestedJarFile.entries(); 			assertThat(entries.nextElement().getName()).isEqualTo("9.dat"); 			assertThat(entries.hasMoreElements()).isFalse();  			try (InputStream inputStream = nestedJarFile.getInputStream(nestedJarFile.getEntry("9.dat"))) { 				assertThat(inputStream.read()).isEqualTo(9); 				assertThat(inputStream.read()).isEqualTo(-1); 			}  			URL url = nestedJarFile.getUrl(); 			assertThat(url.toString()).isEqualTo("jar:" + this.rootJarFile.toURI() + "!/d!/"); 			assertThat(((JarURLConnection) url.openConnection()).getJarFile().getParent()).isSameAs(nestedJarFile); 		} 	}
@Test 	void connectionToRootUsingAbsoluteUrl() throws Exception { 		URL url = new URL("jar:" + this.rootJarFile.toURI().toURL() + "!/"); 		Object content = JarURLConnection.get(url, this.jarFile).getContent(); 		assertThat(((JarFile) content).getParent()).isSameAs(this.jarFile); 	}
@Test 	void connectionToRootUsingRelativeUrl() throws Exception { 		URL url = new URL("jar:file:" + getRelativePath() + "!/"); 		Object content = JarURLConnection.get(url, this.jarFile).getContent(); 		assertThat(((JarFile) content).getParent()).isSameAs(this.jarFile); 	}
@Test 	void openConnectionCanBeClosedWithoutClosingSourceJar() throws Exception { 		URL url = new URL("jar:" + this.rootJarFile.toURI().toURL() + "!/"); 		JarURLConnection connection = JarURLConnection.get(url, this.jarFile); 		JarFile connectionJarFile = connection.getJarFile(); 		connectionJarFile.close(); 		assertThat(this.jarFile.isClosed()).isFalse(); 	}
ResourcePatternResolver getResourcePatternResolver(AbstractApplicationContext applicationContext, 				ResourceLoader resourceLoader) { 			ResourceLoader targetResourceLoader = (resourceLoader != null) ? resourceLoader 					: new ApplicationContextResourceLoader(applicationContext::getProtocolResolvers); 			return new PathMatchingResourcePatternResolver(targetResourceLoader); 		}
@Override 		public ResourcePatternResolver getResourcePatternResolver(AbstractApplicationContext applicationContext, 				ResourceLoader resourceLoader) { 			if (applicationContext instanceof WebApplicationContext) { 				return getServletContextResourcePatternResolver(applicationContext, resourceLoader); 			} 			return super.getResourcePatternResolver(applicationContext, resourceLoader); 		}
@Override 	public int getOrder() { 		return this.order; 	}
@Override 		public int getOrder() { 			return Ordered.HIGHEST_PRECEDENCE; 		}
@Override 		public boolean equals(Object obj) { 			if (obj == this) { 				return true; 			} 			if (obj == null || obj.getClass() != getClass()) { 				return false; 			} 			return ((Profile) obj).name.equals(this.name); 		}
@Override 		public int hashCode() { 			return this.name.hashCode(); 		}
@Override 		public String toString() { 			return this.name; 		}
@Override 		public boolean equals(Object obj) { 			if (this == obj) { 				return true; 			} 			if (obj == null || getClass() != obj.getClass()) { 				return false; 			} 			DocumentsCacheKey other = (DocumentsCacheKey) obj; 			return this.loader.equals(other.loader) && this.resource.equals(other.resource); 		}
@Override 		public int hashCode() { 			return this.loader.hashCode() * 31 + this.resource.hashCode(); 		}
@Override 		public String toString() { 			return this.propertySource.toString(); 		}
@RequestMapping("${server.error.path:${error.path:/error}}") 	@ResponseBody 	public Map<String, Object> invoke(ServletWebRequest request) { 		return this.errorAttributes.getErrorAttributes(request, false); 	}
@Test // gh-17938 	void errorPageAndErrorControllerAreUsed() { 		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new) 				.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class, 						ServletWebServerFactoryAutoConfiguration.class, ServletManagementContextAutoConfiguration.class, 						WebEndpointAutoConfiguration.class, EndpointAutoConfiguration.class, 						DispatcherServletAutoConfiguration.class, ErrorMvcAutoConfiguration.class)) 				.withUserConfiguration(FailingEndpoint.class) 				.withInitializer(new ServerPortInfoApplicationContextInitializer()).withPropertyValues("server.port=0", 						"management.server.port=0", "management.endpoints.web.exposure.include=*") 				.run((context) -> { 					String port = context.getEnvironment().getProperty("local.management.port"); 					WebClient client = WebClient.create("http://localhost:" + port); 					ClientResponse response = client.get().uri("actuator/fail").accept(MediaType.APPLICATION_JSON) 							.exchange().block(); 					assertThat(response.bodyToMono(String.class).block()).contains("message\":\"Epic Fail"); 				}); 	}
private void load(Consumer<T> contextCustomizer, String endpointPath, 			BiConsumer<ApplicationContext, WebTestClient> consumer) { 		T applicationContext = this.applicationContextSupplier.get(); 		contextCustomizer.accept(applicationContext); 		applicationContext.getEnvironment().getPropertySources() 				.addLast(new MapPropertySource("test", Collections.singletonMap("endpointPath", endpointPath))); 		applicationContext.refresh(); 		try { 			InetSocketAddress address = new InetSocketAddress(getPort(applicationContext)); 			String url = "http://" + address.getHostString() + ":" + address.getPort() + endpointPath; 			consumer.accept(applicationContext, 					WebTestClient.bindToServer().baseUrl(url).responseTimeout(TIMEOUT).build()); 		} 		finally { 			applicationContext.close(); 		} 	}
@Bean 		public TestEndpoint testEndpoint(EndpointDelegate endpointDelegate) { 			return new TestEndpoint(endpointDelegate); 		}
@Bean 		QueryEndpoint queryEndpoint() { 			return new QueryEndpoint(); 		}
@Bean 		QueryWithListEndpoint queryEndpoint() { 			return new QueryWithListEndpoint(); 		}
@Bean 		public ResourceEndpoint resourceEndpoint() { 			return new ResourceEndpoint(); 		}
@Bean 		ResourceWebEndpointResponseEndpoint resourceEndpoint() { 			return new ResourceWebEndpointResponseEndpoint(); 		}
@Bean 		MonoResponseEndpoint testEndpoint(EndpointDelegate endpointDelegate) { 			return new MonoResponseEndpoint(); 		}
@WriteOperation 		void write() { 			this.delegate.write(); 		}
@WriteOperation 		Object write() { 			this.delegate.write(); 			return null; 		}
@ReadOperation 		Resource read() { 			return new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }); 		}
@ReadOperation 		Resource read() { 			return new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }); 		}
@ReadOperation 		WebEndpointResponse<Resource> read() { 			return new WebEndpointResponse<>(new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }), 200); 		}
@ReadOperation 		WebEndpointResponse<Resource> read() { 			return new WebEndpointResponse<>(new ByteArrayResource(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }), 200); 		}
@ReadOperation(produces = "text/plain") 		String read() { 			return "read"; 		}
@ReadOperation(produces = "text/plain") 		String read() { 			return "read"; 		}
protected Map<String, Object> getErrorAttributes(ServerRequest request, boolean includeStackTrace) { 		return this.errorAttributes.getErrorAttributes(request, includeStackTrace); 	}
protected boolean isTraceEnabled(ServerRequest request) { 		String parameter = request.queryParam("trace").orElse("false"); 		return !"false".equalsIgnoreCase(parameter); 	}
protected Mono<ServerResponse> renderErrorView(ServerRequest request) { 		boolean includeStackTrace = isIncludeStackTrace(request, MediaType.TEXT_HTML); 		Map<String, Object> error = getErrorAttributes(request, includeStackTrace); 		int errorStatus = getHttpStatus(error); 		ServerResponse.BodyBuilder responseBody = ServerResponse.status(errorStatus).contentType(TEXT_HTML_UTF8); 		return Flux.just(getData(errorStatus).toArray(new String[] {})) 				.flatMap((viewName) -> renderErrorView(viewName, responseBody, error)) 				.switchIfEmpty(this.errorProperties.getWhitelabel().isEnabled() 						? renderDefaultErrorView(responseBody, error) : Mono.error(getError(request))) 				.next(); 	}
protected Mono<ServerResponse> renderErrorResponse(ServerRequest request) { 		boolean includeStackTrace = isIncludeStackTrace(request, MediaType.ALL); 		Map<String, Object> error = getErrorAttributes(request, includeStackTrace); 		return ServerResponse.status(getHttpStatus(error)).contentType(MediaType.APPLICATION_JSON) 				.body(BodyInserters.fromValue(error)); 	}
protected Map<String, Object> getErrorAttributes(HttpServletRequest request, boolean includeStackTrace) { 		WebRequest webRequest = new ServletWebRequest(request); 		return this.errorAttributes.getErrorAttributes(webRequest, includeStackTrace); 	}
protected boolean getTraceParameter(HttpServletRequest request) { 		String parameter = request.getParameter("trace"); 		if (parameter == null) { 			return false; 		} 		return !"false".equalsIgnoreCase(parameter); 	}
@RequestMapping(produces = MediaType.TEXT_HTML_VALUE) 	public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { 		HttpStatus status = getStatus(request); 		Map<String, Object> model = Collections 				.unmodifiableMap(getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); 		response.setStatus(status.value()); 		ModelAndView modelAndView = resolveErrorView(request, response, status, model); 		return (modelAndView != null) ? modelAndView : new ModelAndView("error", model); 	}
@RequestMapping 	public ResponseEntity<Map<String, Object>> error(HttpServletRequest request) { 		HttpStatus status = getStatus(request); 		if (status == HttpStatus.NO_CONTENT) { 			return new ResponseEntity<>(status); 		} 		Map<String, Object> body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); 		return new ResponseEntity<>(body, status); 	}
@Test 	void jsonError(CapturedOutput output) { 		this.contextRunner.run((context) -> { 			WebTestClient client = getWebClient(context); 			client.get().uri("/").exchange().expectStatus().isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR).expectBody() 					.jsonPath("status").isEqualTo("500").jsonPath("error") 					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase()).jsonPath("path").isEqualTo(("/")) 					.jsonPath("message").isEqualTo("Expected!").jsonPath("exception").doesNotExist().jsonPath("trace") 					.doesNotExist().jsonPath("requestId").isEqualTo(this.logIdFilter.getLogId()); 			assertThat(output).contains("500 Server Error for HTTP GET \"/\"") 					.contains("java.lang.IllegalStateException: Expected!"); 		}); 	}
@Test 	void htmlError() { 		this.contextRunner.run((context) -> { 			WebTestClient client = getWebClient(context); 			String body = client.get().uri("/").accept(MediaType.TEXT_HTML).exchange().expectStatus() 					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR).expectHeader().contentType(TEXT_HTML_UTF8) 					.expectBody(String.class).returnResult().getResponseBody(); 			assertThat(body).contains("status: 500").contains("message: Expected!"); 		}); 	}
@Test 	void bindingResultError() { 		this.contextRunner.run((context) -> { 			WebTestClient client = getWebClient(context); 			client.post().uri("/bind").contentType(MediaType.APPLICATION_JSON).bodyValue("{}").exchange().expectStatus() 					.isBadRequest().expectBody().jsonPath("status").isEqualTo("400").jsonPath("error") 					.isEqualTo(HttpStatus.BAD_REQUEST.getReasonPhrase()).jsonPath("path").isEqualTo(("/bind")) 					.jsonPath("exception").doesNotExist().jsonPath("errors").isArray().jsonPath("message").isNotEmpty() 					.jsonPath("requestId").isEqualTo(this.logIdFilter.getLogId()); 		}); 	}
@Test 	void defaultErrorView() { 		this.contextRunner.withPropertyValues("spring.mustache.prefix=classpath:/unknown/", 				"server.error.include-stacktrace=always").run((context) -> { 					WebTestClient client = getWebClient(context); 					String body = client.get().uri("/").accept(MediaType.TEXT_HTML).exchange().expectStatus() 							.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR).expectHeader().contentType(TEXT_HTML_UTF8) 							.expectBody(String.class).returnResult().getResponseBody(); 					assertThat(body).contains("Whitelabel Error Page").contains(this.logIdFilter.getLogId()) 							.contains("<div>Expected!</div>") 							.contains("<div style='white-space:pre-wrap;'>java.lang.IllegalStateException"); 				}); 	}
@Test 	void escapeHtmlInDefaultErrorView() { 		this.contextRunner.withPropertyValues("spring.mustache.prefix=classpath:/unknown/").run((context) -> { 			WebTestClient client = getWebClient(context); 			String body = client.get().uri("/html").accept(MediaType.TEXT_HTML).exchange().expectStatus() 					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR).expectHeader().contentType(TEXT_HTML_UTF8) 					.expectBody(String.class).returnResult().getResponseBody(); 			assertThat(body).contains("Whitelabel Error Page").contains(this.logIdFilter.getLogId()) 					.doesNotContain("<script>").contains("&lt;script&gt;"); 		}); 	}
@Test 	void nonStandardErrorStatusCodeShouldNotFail() { 		ErrorAttributes errorAttributes = mock(ErrorAttributes.class); 		ResourceProperties resourceProperties = new ResourceProperties(); 		ErrorProperties errorProperties = new ErrorProperties(); 		ApplicationContext context = new AnnotationConfigReactiveWebApplicationContext(); 		given(errorAttributes.getErrorAttributes(any(), anyBoolean())).willReturn(getErrorAttributes()); 		DefaultErrorWebExceptionHandler exceptionHandler = new DefaultErrorWebExceptionHandler(errorAttributes, 				resourceProperties, errorProperties, context); 		setupViewResolver(exceptionHandler); 		ServerWebExchange exchange = MockServerWebExchange 				.from(MockServerHttpRequest.get("/some-other-path").accept(MediaType.TEXT_HTML)); 		exceptionHandler.handle(exchange, new RuntimeException()).block(); 	}
@Test 	@SuppressWarnings("rawtypes") 	void testRequestBodyValidationForMachineClient() { 		load("--server.error.include-exception=true"); 		RequestEntity request = RequestEntity.post(URI.create(createUrl("/bodyValidation"))) 				.accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON).body("{}"); 		ResponseEntity<Map> entity = new TestRestTemplate().exchange(request, Map.class); 		String resp = entity.getBody().toString(); 		assertThat(resp).contains("Error count: 1"); 		assertThat(resp).contains("errors=[{"); 		assertThat(resp).contains("codes=["); 		assertThat(resp).contains(MethodArgumentNotValidException.class.getName()); 	}
private void assertErrorAttributes(Map<?, ?> content, String status, String error, Class<?> exception, 			String message, String path) { 		assertThat(content.get("status")).as("Wrong status").isEqualTo(status); 		assertThat(content.get("error")).as("Wrong error").isEqualTo(error); 		if (exception != null) { 			assertThat(content.get("exception")).as("Wrong exception").isEqualTo(exception.getName()); 		} 		else { 			assertThat(content.containsKey("exception")).as("Exception attribute should not be set").isFalse(); 		} 		assertThat(content.get("message")).as("Wrong message").isEqualTo(message); 		assertThat(content.get("path")).as("Wrong path").isEqualTo(path); 	}
@Test 	void testBindingExceptionForMachineClient() throws Exception { 		// In a real server the response is carried over into the error dispatcher, but 		// in the mock a new one is created so we have to assert the status at this 		// intermediate point 		MvcResult result = this.mockMvc.perform(get("/bind")).andExpect(status().is4xxClientError()).andReturn(); 		MvcResult response = this.mockMvc.perform(new ErrorDispatcher(result, "/error")).andReturn(); 		// And the rendered status code is always wrong (but would be 400 in a real 		// system) 		String content = response.getResponse().getContentAsString(); 		assertThat(content).contains("Error count: 1"); 	}
@Test 	void renderContainsViewWithExceptionDetails() throws Exception { 		this.contextRunner.run((context) -> { 			View errorView = context.getBean("error", View.class); 			ErrorAttributes errorAttributes = context.getBean(ErrorAttributes.class); 			DispatcherServletWebRequest webRequest = createWebRequest(new IllegalStateException("Exception message"), 					false); 			errorView.render(errorAttributes.getErrorAttributes(webRequest, true), webRequest.getRequest(), 					webRequest.getResponse()); 			assertThat(webRequest.getResponse().getContentType()).isEqualTo("text/html;charset=UTF-8"); 			String responseString = ((MockHttpServletResponse) webRequest.getResponse()).getContentAsString(); 			assertThat(responseString).contains( 					"<p>This application has no explicit mapping for /error, so you are seeing this as a fallback.</p>") 					.contains("<div>Exception message</div>") 					.contains("<div style='white-space:pre-wrap;'>java.lang.IllegalStateException"); 		}); 	}
@Test 	void renderWhenAlreadyCommittedLogsMessage(CapturedOutput output) { 		this.contextRunner.run((context) -> { 			View errorView = context.getBean("error", View.class); 			ErrorAttributes errorAttributes = context.getBean(ErrorAttributes.class); 			DispatcherServletWebRequest webRequest = createWebRequest(new IllegalStateException("Exception message"), 					true); 			errorView.render(errorAttributes.getErrorAttributes(webRequest, true), webRequest.getRequest(), 					webRequest.getResponse()); 			assertThat(output).contains("Cannot render error page for request [/path] " 					+ "and exception [Exception message] as the response has " 					+ "already been committed. As a result, the response may have the wrong status code."); 		}); 	}
@Test 	void postProcessEnablesIncludeStackTraceProperty() throws Exception { 		SpringApplication application = new SpringApplication(TestConfiguration.class); 		application.setWebApplicationType(WebApplicationType.NONE); 		this.context = getContext(application::run); 		ConfigurableEnvironment environment = this.context.getEnvironment(); 		String property = environment.getProperty("server.error.include-stacktrace"); 		assertThat(property).isEqualTo(ErrorProperties.IncludeStacktrace.ALWAYS.toString()); 	}
@Override 	public Map<String, Object> getErrorAttributes(ServerRequest request, boolean includeStackTrace) { 		Map<String, Object> errorAttributes = new LinkedHashMap<>(); 		errorAttributes.put("timestamp", new Date()); 		errorAttributes.put("path", request.path()); 		Throwable error = getError(request); 		MergedAnnotation<ResponseStatus> responseStatusAnnotation = MergedAnnotations 				.from(error.getClass(), SearchStrategy.TYPE_HIERARCHY).get(ResponseStatus.class); 		HttpStatus errorStatus = determineHttpStatus(error, responseStatusAnnotation); 		errorAttributes.put("status", errorStatus.value()); 		errorAttributes.put("error", errorStatus.getReasonPhrase()); 		errorAttributes.put("message", determineMessage(error, responseStatusAnnotation)); 		errorAttributes.put("requestId", request.exchange().getRequest().getId()); 		handleException(errorAttributes, determineException(error), includeStackTrace); 		return errorAttributes; 	}
@Override 	public Map<String, Object> getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) { 		Map<String, Object> errorAttributes = new LinkedHashMap<>(); 		errorAttributes.put("timestamp", new Date()); 		addStatus(errorAttributes, webRequest); 		addErrorDetails(errorAttributes, webRequest, includeStackTrace); 		addPath(errorAttributes, webRequest); 		return errorAttributes; 	}
@Test 	void missingExceptionAttribute() { 		MockServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get("/test").build()); 		ServerRequest request = ServerRequest.create(exchange, this.readers); 		assertThatIllegalStateException().isThrownBy(() -> this.errorAttributes.getErrorAttributes(request, false)) 				.withMessageContaining("Missing exception attribute in ServerWebExchange"); 	}
@Test 	void includeTimeStamp() { 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, NOT_FOUND), 				false); 		assertThat(attributes.get("timestamp")).isInstanceOf(Date.class); 	}
@Test 	void defaultStatusCode() { 		Error error = new OutOfMemoryError("Test error"); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), 				false); 		assertThat(attributes.get("error")).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase()); 		assertThat(attributes.get("status")).isEqualTo(500); 	}
@Test 	void annotatedResponseStatusCode() { 		Exception error = new CustomException(); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), 				false); 		assertThat(attributes.get("error")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase()); 		assertThat(attributes.get("message")).isEqualTo(""); 		assertThat(attributes.get("status")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.value()); 	}
@Test 	void annotatedResponseStatusCodeWithExceptionMessage() { 		Exception error = new CustomException("Test Message"); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), 				false); 		assertThat(attributes.get("error")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase()); 		assertThat(attributes.get("message")).isEqualTo("Test Message"); 		assertThat(attributes.get("status")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.value()); 	}
@Test 	void annotatedResponseStatusCodeWithCustomReasonPhrase() { 		Exception error = new Custom2Exception(); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), 				false); 		assertThat(attributes.get("error")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase()); 		assertThat(attributes.get("status")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.value()); 		assertThat(attributes.get("message")).isEqualTo("Nope!"); 	}
@Test 	void includeStatusCode() { 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, NOT_FOUND), 				false); 		assertThat(attributes.get("error")).isEqualTo(HttpStatus.NOT_FOUND.getReasonPhrase()); 		assertThat(attributes.get("status")).isEqualTo(404); 	}
@Test 	void getError() { 		Error error = new OutOfMemoryError("Test error"); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		ServerRequest serverRequest = buildServerRequest(request, error); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false); 		assertThat(this.errorAttributes.getError(serverRequest)).isSameAs(error); 		assertThat(attributes.get("exception")).isNull(); 		assertThat(attributes.get("message")).isEqualTo("Test error"); 	}
@Test 	void includeException() { 		RuntimeException error = new RuntimeException("Test"); 		this.errorAttributes = new DefaultErrorAttributes(true); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		ServerRequest serverRequest = buildServerRequest(request, error); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false); 		assertThat(this.errorAttributes.getError(serverRequest)).isSameAs(error); 		assertThat(attributes.get("exception")).isEqualTo(RuntimeException.class.getName()); 		assertThat(attributes.get("message")).isEqualTo("Test"); 	}
@Test 	void processResponseStatusException() { 		RuntimeException nested = new RuntimeException("Test"); 		ResponseStatusException error = new ResponseStatusException(HttpStatus.BAD_REQUEST, "invalid request", nested); 		this.errorAttributes = new DefaultErrorAttributes(true); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		ServerRequest serverRequest = buildServerRequest(request, error); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false); 		assertThat(attributes.get("status")).isEqualTo(400); 		assertThat(attributes.get("message")).isEqualTo("invalid request"); 		assertThat(attributes.get("exception")).isEqualTo(RuntimeException.class.getName()); 		assertThat(this.errorAttributes.getError(serverRequest)).isSameAs(error); 	}
@Test 	void processResponseStatusExceptionWithNoNestedCause() { 		ResponseStatusException error = new ResponseStatusException(HttpStatus.NOT_ACCEPTABLE, 				"could not process request"); 		this.errorAttributes = new DefaultErrorAttributes(true); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		ServerRequest serverRequest = buildServerRequest(request, error); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false); 		assertThat(attributes.get("status")).isEqualTo(406); 		assertThat(attributes.get("message")).isEqualTo("could not process request"); 		assertThat(attributes.get("exception")).isEqualTo(ResponseStatusException.class.getName()); 		assertThat(this.errorAttributes.getError(serverRequest)).isSameAs(error); 	}
@Test 	void notIncludeTrace() { 		RuntimeException ex = new RuntimeException("Test"); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, ex), 				false); 		assertThat(attributes.get("trace")).isNull(); 	}
@Test 	void includeTrace() { 		RuntimeException ex = new RuntimeException("Test"); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, ex), true); 		assertThat(attributes.get("trace").toString()).startsWith("java.lang"); 	}
@Test 	void includePath() { 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, NOT_FOUND), 				false); 		assertThat(attributes.get("path")).isEqualTo("/test"); 	}
@Test 	void includeLogPrefix() { 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		ServerRequest serverRequest = buildServerRequest(request, NOT_FOUND); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false); 		assertThat(attributes.get("requestId")).isEqualTo(serverRequest.exchange().getRequest().getId()); 	}
@Test 	void extractBindingResultErrors() throws Exception { 		Method method = getClass().getDeclaredMethod("method", String.class); 		MethodParameter stringParam = new MethodParameter(method, 0); 		BindingResult bindingResult = new MapBindingResult(Collections.singletonMap("a", "b"), "objectName"); 		bindingResult.addError(new ObjectError("c", "d")); 		Exception ex = new WebExchangeBindException(stringParam, bindingResult); 		MockServerHttpRequest request = MockServerHttpRequest.get("/test").build(); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, ex), 				false); 		assertThat(attributes.get("message")).asString() 				.startsWith("Validation failed for argument at index 0 in method: " 						+ "int org.springframework.boot.web.reactive.error.DefaultErrorAttributesTests" 						+ ".method(java.lang.String), with 1 error(s)"); 		assertThat(attributes.get("errors")).isEqualTo(bindingResult.getAllErrors()); 	}
@Test 	void includeTimeStamp() { 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest, false); 		assertThat(attributes.get("timestamp")).isInstanceOf(Date.class); 	}
@Test 	void specificStatusCode() { 		this.request.setAttribute("javax.servlet.error.status_code", 404); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest, false); 		assertThat(attributes.get("error")).isEqualTo(HttpStatus.NOT_FOUND.getReasonPhrase()); 		assertThat(attributes.get("status")).isEqualTo(404); 	}
@Test 	void missingStatusCode() { 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest, false); 		assertThat(attributes.get("error")).isEqualTo("None"); 		assertThat(attributes.get("status")).isEqualTo(999); 	}
@Test 	void mvcError() { 		RuntimeException ex = new RuntimeException("Test"); 		ModelAndView modelAndView = this.errorAttributes.resolveException(this.request, null, null, ex); 		this.request.setAttribute("javax.servlet.error.exception", new RuntimeException("Ignored")); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest, false); 		assertThat(this.errorAttributes.getError(this.webRequest)).isSameAs(ex); 		assertThat(modelAndView).isNull(); 		assertThat(attributes.get("exception")).isNull(); 		assertThat(attributes.get("message")).isEqualTo("Test"); 	}
@Test 	void unwrapServletException() { 		RuntimeException ex = new RuntimeException("Test"); 		ServletException wrapped = new ServletException(new ServletException(ex)); 		this.request.setAttribute("javax.servlet.error.exception", wrapped); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest, false); 		assertThat(this.errorAttributes.getError(this.webRequest)).isSameAs(wrapped); 		assertThat(attributes.get("exception")).isNull(); 		assertThat(attributes.get("message")).isEqualTo("Test"); 	}
@Test 	void getError() { 		Error error = new OutOfMemoryError("Test error"); 		this.request.setAttribute("javax.servlet.error.exception", error); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest, false); 		assertThat(this.errorAttributes.getError(this.webRequest)).isSameAs(error); 		assertThat(attributes.get("exception")).isNull(); 		assertThat(attributes.get("message")).isEqualTo("Test error"); 	}
@Test 	void withExceptionAttribute() { 		DefaultErrorAttributes errorAttributes = new DefaultErrorAttributes(true); 		RuntimeException ex = new RuntimeException("Test"); 		this.request.setAttribute("javax.servlet.error.exception", ex); 		Map<String, Object> attributes = errorAttributes.getErrorAttributes(this.webRequest, false); 		assertThat(attributes.get("exception")).isEqualTo(RuntimeException.class.getName()); 		assertThat(attributes.get("message")).isEqualTo("Test"); 	}
@Test 	void path() { 		this.request.setAttribute("javax.servlet.error.request_uri", "path"); 		Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(this.webRequest, false); 		assertThat(attributes.get("path")).isEqualTo("path"); 	}
@Test 	public void jarFileEntryWithEpochTimeOfZeroShouldNotFail() throws Exception { 		File file = this.temporaryFolder.newFile(); 		FileOutputStream fileOutputStream = new FileOutputStream(file); 		try (JarOutputStream jarOutputStream = new JarOutputStream(fileOutputStream)) { 			jarOutputStream.setComment("outer"); 			JarEntry entry = new JarEntry("1.dat"); 			entry.setLastModifiedTime(FileTime.from(Instant.EPOCH)); 			ReflectionTestUtils.setField(entry, "xdostime", 0); 			jarOutputStream.putNextEntry(entry); 			jarOutputStream.write(new byte[] { (byte) 1 }); 			jarOutputStream.closeEntry(); 		} 		JarFile jarFile = new JarFile(file); 		Enumeration<java.util.jar.JarEntry> entries = jarFile.entries(); 		JarEntry entry = entries.nextElement(); 		assertThat(entry.getLastModifiedTime().toInstant()).isEqualTo(Instant.EPOCH); 		assertThat(entry.getName()).isEqualTo("1.dat"); 	}
@Test 	void nestedZip64ArchivesAreHandledGracefully() throws Exception { 		File file = new File(this.tempDir, "test.jar"); 		try (JarOutputStream output = new JarOutputStream(new FileOutputStream(file))) { 			JarEntry zip64JarEntry = new JarEntry("nested/zip64.jar"); 			output.putNextEntry(zip64JarEntry); 			byte[] zip64JarData = writeZip64Jar(); 			zip64JarEntry.setSize(zip64JarData.length); 			zip64JarEntry.setCompressedSize(zip64JarData.length); 			zip64JarEntry.setMethod(ZipEntry.STORED); 			CRC32 crc32 = new CRC32(); 			crc32.update(zip64JarData); 			zip64JarEntry.setCrc(crc32.getValue()); 			output.write(zip64JarData); 			output.closeEntry(); 		} 		try (JarFile jarFile = new JarFile(file)) { 			ZipEntry nestedEntry = jarFile.getEntry("nested/zip64.jar"); 			JarFile nestedJarFile = jarFile.getNestedJarFile(nestedEntry); 			Iterator<JarEntry> iterator = nestedJarFile.iterator(); 			for (int i = 0; i < 65537; i++) { 				assertThat(iterator.hasNext()).as(i + "nth file is present").isTrue(); 				iterator.next(); 			} 		} 	}
@Override 	public Resource getResource(String path) throws IOException { 		URL url = new URL("jar:file:" + this.jarPath + "!" + (path.startsWith("/") ? path : "/" + path)); 		URLResource resource = new URLResource(url, path); 		if (resource.getContentLength() < 0) { 			return null; 		} 		return resource; 	}
@ResponseBody 	private Publisher<ResponseEntity<Object>> links(ServerWebExchange exchange) { 		ServerHttpRequest request = exchange.getRequest(); 		return this.securityInterceptor.preHandle(exchange, "") 				.map((securityResponse) -> { 					if (!securityResponse.getStatus().equals(HttpStatus.OK)) { 						return new ResponseEntity<>(securityResponse.getStatus()); 					} 					AccessLevel accessLevel = exchange 							.getAttribute(AccessLevel.REQUEST_ATTRIBUTE); 					Map<String, Link> links = this.endpointLinksResolver 							.resolveLinks(getEndpoints(), request.getURI().toString()); 					return new ResponseEntity<>( 							Collections.singletonMap("_links", 									getAccessibleLinks(accessLevel, links)), 							HttpStatus.OK); 				}); 	}
private ReactiveCloudFoundrySecurityInterceptor getSecurityInterceptor( 			WebClient.Builder restTemplateBuilder, Environment environment) { 		ReactiveCloudFoundrySecurityService cloudfoundrySecurityService = getCloudFoundrySecurityService( 				restTemplateBuilder, environment); 		ReactiveTokenValidator tokenValidator = new ReactiveTokenValidator( 				cloudfoundrySecurityService); 		return new ReactiveCloudFoundrySecurityInterceptor(tokenValidator, 				cloudfoundrySecurityService, 				environment.getProperty("vcap.application.application_id")); 	}
@ResponseBody 	private Map<String, Map<String, Link>> links(HttpServletRequest request, 			HttpServletResponse response) { 		SecurityResponse securityResponse = this.securityInterceptor.preHandle(request, 				""); 		if (!securityResponse.getStatus().equals(HttpStatus.OK)) { 			sendFailureResponse(response, securityResponse); 		} 		AccessLevel accessLevel = (AccessLevel) request 				.getAttribute(AccessLevel.REQUEST_ATTRIBUTE); 		Map<String, Link> links = this.endpointLinksResolver.resolveLinks(getEndpoints(), 				request.getRequestURL().toString()); 		Map<String, Link> filteredLinks = new LinkedHashMap<>(); 		if (accessLevel == null) { 			return Collections.singletonMap("_links", filteredLinks); 		} 		filteredLinks = links.entrySet().stream() 				.filter((e) -> e.getKey().equals("self") 						|| accessLevel.isAccessAllowed(e.getKey())) 				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)); 		return Collections.singletonMap("_links", filteredLinks); 	}
private void sendFailureResponse(HttpServletResponse response, 			SecurityResponse securityResponse) { 		try { 			response.sendError(securityResponse.getStatus().value(), 					securityResponse.getMessage()); 		} 		catch (Exception ex) { 			logger.debug("Failed to send error response", ex); 		} 	}
@Bean 	public ParameterMapper endpointOperationParameterMapper() { 		return new ConversionServiceParameterMapper(); 	}
private String getStaticNames() { 		if (this.properties.getStaticNames().isEmpty()) { 			return ""; 		} 		StringBuilder builder = new StringBuilder(); 		for (Map.Entry<Object, Object> name : this.properties.getStaticNames() 				.entrySet()) { 			builder.append(",").append(name.getKey()).append("=").append(name.getValue()); 		} 		return builder.toString(); 	}
@Bean 	public ExposeExcludePropertyEndpointFilter<JmxOperation> jmxIncludeExcludePropertyEndpointFilter() { 		return new ExposeExcludePropertyEndpointFilter<>( 				JmxAnnotationEndpointDiscoverer.class, this.properties.getExpose(), 				this.properties.getExclude(), "*"); 	}
@Override 	public List<String> getPaths() { 		return getEndpoints().map(this::getPath).collect(Collectors.toList()); 	}
@Override 	public String getPath(String id) { 		Assert.notNull(id, "ID must not be null"); 		return getEndpoints().filter((info) -> id.equals(info.getId())).findFirst() 				.map(this::getPath).orElse(null); 	}
@Bean 	public ExposeExcludePropertyEndpointFilter<WebOperation> webIncludeExcludePropertyEndpointFilter() { 		return new ExposeExcludePropertyEndpointFilter<>( 				WebAnnotationEndpointDiscoverer.class, this.properties.getExpose(), 				this.properties.getExclude(), "info", "health"); 	}
@Test 	public void matchIfDiscovererCloudFoundryShouldReturnFalse() { 		CloudFoundryWebAnnotationEndpointDiscoverer discoverer = Mockito 				.mock(CloudFoundryWebAnnotationEndpointDiscoverer.class); 		assertThat(this.filter.match(null, discoverer)).isTrue(); 	}
@Test 	public void matchIfDiscovererNotCloudFoundryShouldReturnFalse() { 		WebAnnotationEndpointDiscoverer discoverer = Mockito 				.mock(WebAnnotationEndpointDiscoverer.class); 		assertThat(this.filter.match(null, discoverer)).isFalse(); 	}
@Bean 		public ReactiveCloudFoundrySecurityInterceptor interceptor() { 			return new ReactiveCloudFoundrySecurityInterceptor(tokenValidator, 					securityService, "app-id"); 		}
@Bean 		public WebAnnotationEndpointDiscoverer webEndpointDiscoverer( 				ApplicationContext applicationContext, 				EndpointMediaTypes endpointMediaTypes) { 			ParameterMapper parameterMapper = new ConversionServiceParameterMapper( 					DefaultConversionService.getSharedInstance()); 			return new WebAnnotationEndpointDiscoverer(applicationContext, 					parameterMapper, endpointMediaTypes, 					EndpointPathResolver.useEndpointId(), null, null); 		}
@Test 	public void allEndpointsAvailableUnderCloudFoundryWithoutEnablingWebIncludes() { 		setupContextWithCloudEnabled(); 		this.context.register(TestConfiguration.class); 		this.context.refresh(); 		CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(); 		List<EndpointInfo<WebOperation>> endpoints = (List<EndpointInfo<WebOperation>>) handlerMapping 				.getEndpoints(); 		List<String> endpointIds = endpoints.stream().map(EndpointInfo::getId) 				.collect(Collectors.toList()); 		assertThat(endpointIds).contains("test"); 	}
@Test 	public void endpointPathCustomizationIsNotApplied() { 		setupContextWithCloudEnabled(); 		this.context.register(TestConfiguration.class); 		this.context.refresh(); 		CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(); 		List<EndpointInfo<WebOperation>> endpoints = (List<EndpointInfo<WebOperation>>) handlerMapping 				.getEndpoints(); 		EndpointInfo<WebOperation> endpoint = endpoints.stream() 				.filter((candidate) -> "test".equals(candidate.getId())).findFirst() 				.get(); 		assertThat(endpoint.getOperations()).hasSize(1); 		WebOperation operation = endpoint.getOperations().iterator().next(); 		assertThat(operation.getRequestPredicate().getPath()).isEqualTo("test"); 	}
@Test 	public void healthEndpointInvokerShouldBeCloudFoundryWebExtension() { 		setupContextWithCloudEnabled(); 		this.context.refresh(); 		Collection<EndpointInfo<WebOperation>> endpoints = getHandlerMapping() 				.getEndpoints(); 		EndpointInfo<WebOperation> endpointInfo = endpoints.iterator().next(); 		WebOperation webOperation = endpointInfo.getOperations().iterator().next(); 		ReflectiveOperationInvoker invoker = (ReflectiveOperationInvoker) webOperation 				.getInvoker(); 		assertThat(ReflectionTestUtils.getField(invoker, "target")) 				.isInstanceOf(CloudFoundryReactiveHealthEndpointWebExtension.class); 	}
@Before 	public void setup() { 		MockitoAnnotations.initMocks(this); 		this.interceptor = new ReactiveCloudFoundrySecurityInterceptor( 				this.tokenValidator, this.securityService, "my-app-id"); 	}
@Test 	public void preHandleWhenApplicationIdIsNullShouldReturnError() { 		this.interceptor = new ReactiveCloudFoundrySecurityInterceptor( 				this.tokenValidator, this.securityService, null); 		MockServerWebExchange request = MockServerWebExchange 				.from(MockServerHttpRequest.get("/a") 						.header(HttpHeaders.AUTHORIZATION, "bearer " + mockAccessToken()) 						.build()); 		StepVerifier.create(this.interceptor.preHandle(request, "/a")) 				.consumeErrorWith((ex) -> assertThat( 						((CloudFoundryAuthorizationException) ex).getReason()) 								.isEqualTo(Reason.SERVICE_UNAVAILABLE)) 				.verify(); 	}
@Test 	public void preHandleWhenCloudFoundrySecurityServiceIsNullShouldReturnError() { 		this.interceptor = new ReactiveCloudFoundrySecurityInterceptor( 				this.tokenValidator, null, "my-app-id"); 		MockServerWebExchange request = MockServerWebExchange.from(MockServerHttpRequest 				.get("/a").header(HttpHeaders.AUTHORIZATION, mockAccessToken()).build()); 		StepVerifier.create(this.interceptor.preHandle(request, "/a")) 				.consumeErrorWith((ex) -> assertThat( 						((CloudFoundryAuthorizationException) ex).getReason()) 								.isEqualTo(Reason.SERVICE_UNAVAILABLE)) 				.verify(); 	}
@Test 	public void cloudFoundryPlatformActive() { 		CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(); 		assertThat(handlerMapping.getEndpointMapping().getPath()) 				.isEqualTo("/cloudfoundryapplication"); 		CorsConfiguration corsConfiguration = (CorsConfiguration) ReflectionTestUtils 				.getField(handlerMapping, "corsConfiguration"); 		assertThat(corsConfiguration.getAllowedOrigins()).contains("*"); 		assertThat(corsConfiguration.getAllowedMethods()).containsAll( 				Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name())); 		assertThat(corsConfiguration.getAllowedHeaders()).containsAll( 				Arrays.asList("Authorization", "X-Cf-App-Instance", "Content-Type")); 	}
@Test 	public void allEndpointsAvailableUnderCloudFoundryWithoutExposeAllOnWeb() { 		this.context.register(TestConfiguration.class); 		this.context.refresh(); 		CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(); 		List<EndpointInfo<WebOperation>> endpoints = (List<EndpointInfo<WebOperation>>) handlerMapping 				.getEndpoints(); 		assertThat(endpoints.stream() 				.filter((candidate) -> "test".equals(candidate.getId())).findFirst()) 						.isNotEmpty(); 	}
@Test 	public void endpointPathCustomizationIsNotApplied() { 		TestPropertyValues.of("management.endpoints.web.path-mapping.test=custom") 				.applyTo(this.context); 		this.context.register(TestConfiguration.class); 		this.context.refresh(); 		CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(); 		List<EndpointInfo<WebOperation>> endpoints = (List<EndpointInfo<WebOperation>>) handlerMapping 				.getEndpoints(); 		EndpointInfo<WebOperation> endpoint = endpoints.stream() 				.filter((candidate) -> "test".equals(candidate.getId())).findFirst() 				.get(); 		Collection<WebOperation> operations = endpoint.getOperations(); 		assertThat(operations).hasSize(1); 		assertThat(operations.iterator().next().getRequestPredicate().getPath()) 				.isEqualTo("test"); 	}
@Test 	public void healthEndpointInvokerShouldBeCloudFoundryWebExtension() { 		TestPropertyValues 				.of("VCAP_APPLICATION:---", "vcap.application.application_id:my-app-id", 						"vcap.application.cf_api:http://my-cloud-controller.com") 				.applyTo(this.context); 		this.context.refresh(); 		Collection<EndpointInfo<WebOperation>> endpoints = this.context 				.getBean("cloudFoundryWebEndpointServletHandlerMapping", 						CloudFoundryWebEndpointServletHandlerMapping.class) 				.getEndpoints(); 		EndpointInfo<WebOperation> endpointInfo = endpoints.iterator().next(); 		WebOperation webOperation = endpointInfo.getOperations().iterator().next(); 		ReflectiveOperationInvoker invoker = (ReflectiveOperationInvoker) webOperation 				.getInvoker(); 		assertThat(ReflectionTestUtils.getField(invoker, "target")) 				.isInstanceOf(CloudFoundryHealthEndpointWebExtension.class); 	}
@Bean 		public WebAnnotationEndpointDiscoverer webEndpointDiscoverer( 				ApplicationContext applicationContext, 				EndpointMediaTypes endpointMediaTypes) { 			ParameterMapper parameterMapper = new ConversionServiceParameterMapper( 					DefaultConversionService.getSharedInstance()); 			return new WebAnnotationEndpointDiscoverer(applicationContext, 					parameterMapper, endpointMediaTypes, 					EndpointPathResolver.useEndpointId(), null, null); 		}
@Test 	public void createWhenEnvironmentIsNullShouldThrowException() { 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("Environment must not be null"); 		new ExposeExcludePropertyEndpointFilter<>(TestEndpointDiscoverer.class, null, 				"foo"); 	}
@Test 	public void createWhenPrefixIsNullShouldThrowException() { 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("Prefix must not be empty"); 		new ExposeExcludePropertyEndpointFilter<>(TestEndpointDiscoverer.class, 				this.environment, null); 	}
@Test 	public void createWhenPrefixIsEmptyShouldThrowException() { 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("Prefix must not be empty"); 		new ExposeExcludePropertyEndpointFilter<>(TestEndpointDiscoverer.class, 				this.environment, ""); 	}
@Test 	public void matchWhenDiscovererDoesNotMatchShouldMatch() { 		this.environment.setProperty("foo.expose", "bar"); 		this.environment.setProperty("foo.exclude", ""); 		this.filter = new ExposeExcludePropertyEndpointFilter<>( 				DifferentTestEndpointDiscoverer.class, this.environment, "foo"); 		assertThat(match("baz")).isTrue(); 	}
private void setupFilter(String expose, String exclude) { 		this.environment.setProperty("foo.expose", expose); 		this.environment.setProperty("foo.exclude", exclude); 		this.filter = new ExposeExcludePropertyEndpointFilter<>( 				TestEndpointDiscoverer.class, this.environment, "foo", "def"); 	}
private boolean match(String id) { 		EndpointInfo<Operation> info = new EndpointInfo<>(id, true, 				Collections.emptyList()); 		return this.filter.match(info, this.discoverer); 	}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultTrue foo() { 			return new FooEndpointEnabledByDefaultTrue(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultTrue foo() { 			return new FooEndpointEnabledByDefaultTrue(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultFalse foo() { 			return new FooEndpointEnabledByDefaultFalse(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultFalse foo() { 			return new FooEndpointEnabledByDefaultFalse(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultTrue foo() { 			return new FooEndpointEnabledByDefaultTrue(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultTrue foo() { 			return new FooEndpointEnabledByDefaultTrue(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointExtensionEnabledByDefaultTrue fooExt() { 			return new FooEndpointExtensionEnabledByDefaultTrue(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultFalse foo() { 			return new FooEndpointEnabledByDefaultFalse(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointEnabledByDefaultFalse foo() { 			return new FooEndpointEnabledByDefaultFalse(); 		}
@Bean 		@ConditionalOnEnabledEndpoint 		public FooEndpointExtensionEnabledByDefaultFalse fooExt() { 			return new FooEndpointExtensionEnabledByDefaultFalse(); 		}
@Test 	public void generateObjectNameWithUniqueNames() { 		this.properties.setUniqueNames(true); 		EndpointMBean endpoint = endpoint("test"); 		String id = ObjectUtils.getIdentityHexString(endpoint); 		ObjectName objectName = generateObjectName(endpoint); 		assertThat(objectName.toString()).isEqualTo( 				"org.springframework.boot:type=Endpoint,name=Test,identity=" + id); 	}
private EndpointMBean endpoint(String id) { 		EndpointMBean endpointMBean = mock(EndpointMBean.class); 		given(endpointMBean.getEndpointId()).willReturn(id); 		return endpointMBean; 	}
private DefaultEndpointPathProvider createProvider(String contextPath) { 		Collection<EndpointInfo<WebOperation>> endpoints = new ArrayList<>(); 		endpoints.add(new EndpointInfo<>("foo", true, Collections.emptyList())); 		endpoints.add(new EndpointInfo<>("bar", true, Collections.emptyList())); 		given(this.discoverer.discoverEndpoints()).willReturn(endpoints); 		WebEndpointProperties webEndpointProperties = new WebEndpointProperties(); 		webEndpointProperties.setBasePath(contextPath); 		return new DefaultEndpointPathProvider(this.discoverer, webEndpointProperties); 	}
@Override 	public MBeanInfo getMBeanInfo() { 		return this.endpointInfo.getMbeanInfo(); 	}
@Override 	public Object invoke(String actionName, Object[] params, String[] signature) 			throws MBeanException, ReflectionException { 		JmxOperation operation = this.endpointInfo.getOperations().get(actionName); 		if (operation != null) { 			Map<String, Object> arguments = getArguments(params, 					operation.getParameters()); 			try { 				Object result = operation.getInvoker().invoke(arguments); 				if (REACTOR_PRESENT) { 					result = ReactiveHandler.handle(result); 				} 				return this.operationResponseConverter.apply(result); 			} 			catch (ParametersMissingException | ParameterMappingException ex) { 				throw new IllegalArgumentException(ex.getMessage()); 			}  		} 		throw new ReflectionException(new IllegalArgumentException( 				String.format("Endpoint with id '%s' has no operation named %s", 						this.endpointInfo.getEndpointId(), actionName))); 	}
@Override 	public Object getAttribute(String attribute) 			throws AttributeNotFoundException, MBeanException, ReflectionException { 		throw new AttributeNotFoundException(); 	}
@Override 	public void setAttribute(Attribute attribute) throws AttributeNotFoundException, 			InvalidAttributeValueException, MBeanException, ReflectionException { 		throw new AttributeNotFoundException(); 	}
private Resource createResource(EndpointMapping endpointMapping, 			WebOperation operation) { 		OperationRequestPredicate requestPredicate = operation.getRequestPredicate(); 		Builder resourceBuilder = Resource.builder() 				.path(endpointMapping.createSubPath(requestPredicate.getPath())); 		resourceBuilder.addMethod(requestPredicate.getHttpMethod().name()) 				.consumes(toStringArray(requestPredicate.getConsumes())) 				.produces(toStringArray(requestPredicate.getProduces())) 				.handledBy(new EndpointInvokingInflector(operation.getInvoker(), 						!requestPredicate.getConsumes().isEmpty())); 		return resourceBuilder.build(); 	}
@Override 		public Response apply(ContainerRequestContext data) { 			Map<String, Object> arguments = new HashMap<>(); 			if (this.readBody) { 				arguments.putAll(extractBodyArguments(data)); 			} 			arguments.putAll(extractPathParameters(data)); 			arguments.putAll(extractQueryParameters(data)); 			try { 				Object response = this.operationInvoker.invoke(arguments); 				return convertToJaxRsResponse(response, data.getRequest().getMethod()); 			} 			catch (ParametersMissingException | ParameterMappingException ex) { 				return Response.status(Status.BAD_REQUEST).build(); 			} 		}
@Override 		public Object apply(Object body) { 			if (body instanceof org.springframework.core.io.Resource) { 				try { 					return ((org.springframework.core.io.Resource) body).getInputStream(); 				} 				catch (IOException ex) { 					throw new IllegalStateException(); 				} 			} 			return body; 		}
@Override 		public Object apply(Object body) { 			if (body instanceof Mono) { 				return ((Mono<?>) body).block(); 			} 			return body; 		}
@Override 	protected void initHandlerMethods() { 		this.webEndpoints.stream() 				.flatMap((webEndpoint) -> webEndpoint.getOperations().stream()) 				.forEach(this::registerMappingForOperation); 		if (StringUtils.hasText(this.endpointMapping.getPath())) { 			registerLinksMapping(); 		} 	}
private void registerLinksMapping() { 		PatternsRequestCondition patterns = new PatternsRequestCondition( 				pathPatternParser.parse(this.endpointMapping.getPath())); 		RequestMethodsRequestCondition methods = new RequestMethodsRequestCondition( 				RequestMethod.GET); 		ProducesRequestCondition produces = new ProducesRequestCondition( 				this.endpointMediaTypes.getProduced().toArray( 						new String[this.endpointMediaTypes.getProduced().size()])); 		RequestMappingInfo mapping = new RequestMappingInfo(patterns, methods, null, null, 				null, produces, null); 		registerMapping(mapping, this, getLinks()); 	}
public Collection<EndpointInfo<WebOperation>> getEndpoints() { 		return this.webEndpoints; 	}
private void invoke(Map<String, Object> arguments, MonoSink<Object> sink) { 			try { 				Object result = this.delegate.invoke(arguments); 				sink.success(result); 			} 			catch (Exception ex) { 				sink.error(ex); 			} 		}
public Collection<EndpointInfo<WebOperation>> getEndpoints() { 		return this.webEndpoints; 	}
@Override 	protected void initHandlerMethods() { 		this.webEndpoints.stream() 				.flatMap((webEndpoint) -> webEndpoint.getOperations().stream()) 				.forEach(this::registerMappingForOperation); 		if (StringUtils.hasText(this.endpointMapping.getPath())) { 			registerLinksRequestMapping(); 		} 	}
@Test 	public void resolvedLinksContainsALinkForEachEndpointOperation() { 		Map<String, Link> links = this.linksResolver 				.resolveLinks( 						Arrays.asList(new EndpointInfo<>("alpha", true, 								Arrays.asList(operationWithPath("/alpha", "alpha"), 										operationWithPath("/alpha/{name}", 												"alpha-name")))), 				"https://api.example.com/actuator"); 		assertThat(links).hasSize(3); 		assertThat(links).hasEntrySatisfying("self", 				linkWithHref("https://api.example.com/actuator")); 		assertThat(links).hasEntrySatisfying("alpha", 				linkWithHref("https://api.example.com/actuator/alpha")); 		assertThat(links).hasEntrySatisfying("alpha-name", 				linkWithHref("https://api.example.com/actuator/alpha/{name}")); 	}
private WebOperation operationWithPath(String path, String id) { 		return new WebOperation(OperationType.READ, null, false, 				new OperationRequestPredicate(path, WebEndpointHttpMethod.GET, 						Collections.emptyList(), Collections.emptyList()), 				id); 	}
private void customize(ResourceConfig config) { 			List<String> mediaTypes = Arrays.asList(MediaType.APPLICATION_JSON, 					ActuatorMediaType.V2_JSON); 			EndpointMediaTypes endpointMediaTypes = new EndpointMediaTypes(mediaTypes, 					mediaTypes); 			WebAnnotationEndpointDiscoverer discoverer = new WebAnnotationEndpointDiscoverer( 					this.applicationContext, new ConversionServiceParameterMapper(), 					endpointMediaTypes, EndpointPathResolver.useEndpointId(), null, null); 			Collection<Resource> resources = new JerseyEndpointResourceFactory() 					.createEndpointResources(new EndpointMapping("/actuator"), 							discoverer.discoverEndpoints(), endpointMediaTypes); 			config.registerResources(new HashSet<>(resources)); 		}
@Bean 		public WebFluxEndpointHandlerMapping webEndpointReactiveHandlerMapping() { 			List<String> mediaTypes = Arrays.asList(MediaType.APPLICATION_JSON_VALUE, 					ActuatorMediaType.V2_JSON); 			EndpointMediaTypes endpointMediaTypes = new EndpointMediaTypes(mediaTypes, 					mediaTypes); 			WebAnnotationEndpointDiscoverer discoverer = new WebAnnotationEndpointDiscoverer( 					this.applicationContext, new ConversionServiceParameterMapper(), 					endpointMediaTypes, EndpointPathResolver.useEndpointId(), null, null); 			return new WebFluxEndpointHandlerMapping(new EndpointMapping("/actuator"), 					discoverer.discoverEndpoints(), endpointMediaTypes, 					new CorsConfiguration()); 		}
@Bean 		public WebMvcEndpointHandlerMapping webEndpointServletHandlerMapping() { 			List<String> mediaTypes = Arrays.asList(MediaType.APPLICATION_JSON_VALUE, 					ActuatorMediaType.V2_JSON); 			EndpointMediaTypes endpointMediaTypes = new EndpointMediaTypes(mediaTypes, 					mediaTypes); 			WebAnnotationEndpointDiscoverer discoverer = new WebAnnotationEndpointDiscoverer( 					this.applicationContext, new ConversionServiceParameterMapper(), 					endpointMediaTypes, EndpointPathResolver.useEndpointId(), null, null); 			return new WebMvcEndpointHandlerMapping(new EndpointMapping("/actuator"), 					discoverer.discoverEndpoints(), endpointMediaTypes, 					new CorsConfiguration()); 		}
@Test 	public void homeIsSecure() { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = this.restTemplate.getForEntity("/", Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertThat(body.get("error")).isEqualTo("Unauthorized"); 		assertThat(entity.getHeaders()).doesNotContainKey("Set-Cookie"); 	}
@Test 	public void testInsecureApplicationPath() { 		@SuppressWarnings("rawtypes") 		ResponseEntity<Map> entity = this.restTemplate.getForEntity("/foo", Map.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); 		@SuppressWarnings("unchecked") 		Map<String, Object> body = entity.getBody(); 		assertThat((String) body.get("message")) 				.contains("Expected exception in controller"); 	}
@Test 	public void testInsecureStaticResources() { 		ResponseEntity<String> entity = this.restTemplate 				.getForEntity("/css/bootstrap.min.css", String.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK); 		assertThat(entity.getBody()).contains("body"); 	}
@Override 		public void destroy() throws Exception { 			if (dataSourceRequiresShutdown()) { 				this.dataSource.getConnection().createStatement().execute("SHUTDOWN"); 			} 		}
@Override 	public void writeLoaderClasses(String loaderJarResourceName) throws IOException { 		URL loaderJar = getClass().getClassLoader().getResource(loaderJarResourceName); 		JarInputStream inputStream = new JarInputStream( 				new BufferedInputStream(loaderJar.openStream())); 		JarEntry entry; 		while ((entry = inputStream.getNextJarEntry()) != null) { 			if (entry.getName().endsWith(".class")) { 				writeEntry(new JarArchiveEntry(entry), 						new InputStreamEntryWriter(inputStream, false)); 			} 		} 		inputStream.close(); 	}
@Override 	public Manifest getManifest() throws IOException { 		Manifest manifest = (this.manifest == null ? null : this.manifest.get()); 		if (manifest == null) { 			if (this.type == JarFileType.NESTED_DIRECTORY) { 				manifest = new JarFile(this.getRootJarFile()).getManifest(); 			} 			else { 				try (InputStream inputStream = getInputStream(MANIFEST_NAME, 						ResourceAccess.ONCE)) { 					if (inputStream == null) { 						return null; 					} 					manifest = new Manifest(inputStream); 				} 			} 			this.manifest = new SoftReference<>(manifest); 		} 		return manifest; 	}
@SuppressWarnings("resource") 	private boolean checkForDevtools() { 		try { 			URL[] urls = getClassPathUrls(); 			URLClassLoader classLoader = new URLClassLoader(urls); 			return (classLoader.findResource(RESTARTER_CLASS_LOCATION) != null); 		} 		catch (Exception ex) { 			return false; 		} 	}
@Override 	public Map<String, Object> invoke() {  		if (this.context == null) { 			return Collections.<String, Object>singletonMap("message", 					"No context to shutdown."); 		}  		try { 			return Collections.<String, Object>singletonMap("message", 					"Shutting down, bye..."); 		} 		finally {  			new Thread(new Runnable() { 				@Override 				public void run() { 					try { 						Thread.sleep(500L); 					} 					catch (InterruptedException ex) { 						// Swallow exception and continue 					} 					ShutdownEndpoint.this.context.close(); 				} 			}).start();  		} 	}
@Test 	public void invoke() throws Exception { 		CountDownLatch latch = this.context.getBean(Config.class).latch; 		assertThat((String) getEndpointBean().invoke().get("message"), 				startsWith("Shutting down")); 		assertTrue(this.context.isActive()); 		assertTrue(latch.await(10, TimeUnit.SECONDS)); 	}
@Bean 		public ApplicationListener<ContextClosedEvent> listener() { 			return new ApplicationListener<ContextClosedEvent>() { 				@Override 				public void onApplicationEvent(ContextClosedEvent event) { 					Config.this.latch.countDown(); 				} 			};  		}
@Override 				public void onApplicationEvent(ContextClosedEvent event) { 					Config.this.latch.countDown(); 				}
@Override 	public Map<String, Object> invoke() {  		if (this.context == null) { 			return Collections.<String, Object>singletonMap("message", 					"No context to shutdown."); 		}  		try { 			return Collections.<String, Object>singletonMap("message", 					"Shutting down, bye..."); 		} 		finally {  			new Thread(new Runnable() { 				@Override 				public void run() { 					try { 						Thread.sleep(500L); 					} 					catch (InterruptedException ex) { 						// Swallow exception and continue 					} 					ShutdownEndpoint.this.context.close(); 				} 			}).start();  		} 	}
@Test 	public void invoke() throws Exception { 		CountDownLatch latch = this.context.getBean(Config.class).latch; 		assertThat((String) getEndpointBean().invoke().get("message"), 				startsWith("Shutting down")); 		assertTrue(this.context.isActive()); 		assertTrue(latch.await(10, TimeUnit.SECONDS)); 	}
@Bean 		public ApplicationListener<ContextClosedEvent> listener() { 			return new ApplicationListener<ContextClosedEvent>() { 				@Override 				public void onApplicationEvent(ContextClosedEvent event) { 					Config.this.latch.countDown(); 				} 			};  		}
@Override 				public void onApplicationEvent(ContextClosedEvent event) { 					Config.this.latch.countDown(); 				}
private Template createTemplate(Resource resource) throws IOException { 		return this.compiler.compile(getReader(resource)); 	}
private ConfigurableApplicationContext doRun(SpringApplicationRunListeners listeners, 			String... args) { 		ConfigurableApplicationContext context; 		// Create and configure the environment 		ConfigurableEnvironment environment = getOrCreateEnvironment(); 		configureEnvironment(environment, args); 		listeners.environmentPrepared(environment); 		if (isWebEnvironment(environment) && !this.webEnvironment) { 			environment = convertToStandardEnvironment(environment); 		}  		if (this.showBanner) { 			printBanner(environment); 		}  		// Create, load, refresh and run the ApplicationContext 		context = createApplicationContext(); 		if (this.registerShutdownHook) { 			try { 				context.registerShutdownHook(); 			} 			catch (AccessControlException ex) { 				// Not allowed in some environments. 			} 		} 		context.setEnvironment(environment); 		postProcessApplicationContext(context); 		applyInitializers(context); 		listeners.contextPrepared(context); 		if (this.logStartupInfo) { 			logStartupInfo(context.getParent() == null); 		}  		// Add boot specific singleton beans 		ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); 		context.getBeanFactory().registerSingleton("springApplicationArguments", 				applicationArguments);  		// Load the sources 		Set<Object> sources = getSources(); 		Assert.notEmpty(sources, "Sources must not be empty"); 		load(context, sources.toArray(new Object[sources.size()])); 		listeners.contextLoaded(context);  		// Refresh the context 		refresh(context); 		afterRefresh(context, applicationArguments); 		listeners.finished(context, null); 		return context; 	}
private String[] getArgs(String... args) { 		List<String> list = new ArrayList<String>(Arrays.asList( 				"--spring.main.webEnvironment=false", "--spring.main.showBanner=false")); 		if (args.length > 0) { 			list.add("--spring.main.sources=" 					+ StringUtils.arrayToCommaDelimitedString(args)); 		} 		return list.toArray(new String[list.size()]); 	}
@After 	public void close() { 		if (this.context != null) { 			this.context.close(); 		} 	}
@Override 			public void onApplicationEvent(ApplicationEvent event) { 				events.add((event)); 			}
@Override 			public void onApplicationEvent(ApplicationEvent event) { 				events.add((event)); 			}
@Test 	public void registerShutdownHook() throws Exception { 		SpringApplication application = new SpringApplication(ExampleConfig.class); 		application.setApplicationContextClass(SpyApplicationContext.class); 		this.context = application.run(); 		SpyApplicationContext applicationContext = (SpyApplicationContext) this.context; 		verify(applicationContext.getApplicationContext()).registerShutdownHook(); 	}
@Override 			public void onApplicationEvent(ApplicationEvent event) { 				events.add(event); 			}
@Override 			public void onApplicationEvent(ApplicationEvent event) { 				events.add(event); 			}
@Override 		public void registerShutdownHook() { 			this.applicationContext.registerShutdownHook(); 		}
@After 	public void close() { 		ApplicationContextTestUtils.closeAll(this.context); 	}
private Process runCliProcess(String... args) throws IOException { 		List<String> command = new ArrayList<String>(); 		command.add(findLaunchScript().getAbsolutePath()); 		command.addAll(Arrays.asList(args)); 		return new ProcessBuilder(command).directory(this.workingDirectory).start(); 	}
private Process runCliProcess(String... args) throws IOException { 		List<String> command = new ArrayList<String>(); 		command.add(findLaunchScript().getAbsolutePath()); 		command.addAll(Arrays.asList(args)); 		return new ProcessBuilder(command).directory(this.workingDirectory).start(); 	}
@Override 	public boolean supportsEventType(Class<? extends ApplicationEvent> eventType) { 		for (Class<?> type : EVENT_TYPES) { 			if (type.isAssignableFrom(eventType)) { 				return true; 			} 		} 		return false; 	}
@Override 	public boolean supportsSourceType(Class<?> sourceType) { 		return SpringApplication.class.isAssignableFrom(sourceType); 	}
@Override 	public void onApplicationEvent(ApplicationEvent event) { 		if (event instanceof ApplicationEnvironmentPreparedEvent) { 			ApplicationEnvironmentPreparedEvent available = (ApplicationEnvironmentPreparedEvent) event; 			initialize(available.getEnvironment(), available.getSpringApplication() 					.getClassLoader()); 		} 		else { 			if (System.getProperty(PID_KEY) == null) { 				System.setProperty(PID_KEY, new ApplicationPid().toString()); 			} 			LoggingSystem loggingSystem = LoggingSystem.get(ClassUtils 					.getDefaultClassLoader()); 			loggingSystem.beforeInitialize(); 		} 	}
@Override 	public void beforeInitialize() { 		super.beforeInitialize(); 		if (ClassUtils.isPresent("org.slf4j.bridge.SLF4JBridgeHandler", getClassLoader())) { 			SLF4JBridgeHandler.removeHandlersForRootLogger(); 			SLF4JBridgeHandler.install(); 		} 	}
private void configureJdkLoggingBridgeHandler() { 		try { 			if (ClassUtils.isPresent("org.slf4j.bridge.SLF4JBridgeHandler", 					getClassLoader())) { 				try { 					SLF4JBridgeHandler.removeHandlersForRootLogger(); 				} 				catch (NoSuchMethodError ex) { 					// Method missing in older versions of SLF4J like in JBoss AS 7.1 					SLF4JBridgeHandler.uninstall(); 				} 				SLF4JBridgeHandler.install(); 			} 		} 		catch (Throwable ex) { 			// Ignore. No java.util.logging bridge is installed. 		} 	}
@After 	public void clear() { 		System.clearProperty("LOG_FILE"); 		System.clearProperty("LOG_PATH"); 		System.clearProperty("PID"); 	}
@After 	public void clear() { 		System.clearProperty("LOG_FILE"); 		System.clearProperty("LOG_PATH"); 		System.clearProperty("PID"); 	}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return failureAnalyzer.analyze(failure); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return failureAnalyzer.analyze(failure); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return null; 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return null; 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			throw new NoClassDefFoundError(); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			throw new NoClassDefFoundError(); 		}
@BeforeEach 	void configureMock() { 		failureAnalyzer = mock(AwareFailureAnalyzer.class); 	}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return failureAnalyzer.analyze(failure); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return failureAnalyzer.analyze(failure); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return null; 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return null; 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			throw new NoClassDefFoundError(); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			throw new NoClassDefFoundError(); 		}
public Bindable<T> withExistingValue(T existingValue) { 		Assert.isTrue( 				existingValue == null || this.type.isArray() || this.boxedType.resolve().isInstance(existingValue), 				() -> "ExistingValue must be an instance of " + this.type); 		Supplier<T> value = (existingValue != null) ? new ExistingValueSupplier(existingValue) : null; 		return new Bindable<>(this.type, this.boxedType, value, this.annotations, this.bindRestrictions); 	}
@Override 	public Constructor<?> getBindConstructor(Bindable<?> bindable, boolean isNestedConstructorBinding) { 		return getBindConstructor(bindable.getType().resolve(), bindable.hasExistingValue(), 				isNestedConstructorBinding); 	}
@Override 	public Constructor<?> getBindConstructor(Class<?> type, boolean isNestedConstructorBinding) { 		return getBindConstructor(type, false, isNestedConstructorBinding); 	}
@Test // gh-33710 	void loadWhenConstructorUsedInBeanMethodAndNotAsConstructorBinding() { 		load(ConstructorUsedInBeanMethodConfiguration.class, "test.two=bound-2"); 		ConstructorUsedInBeanMethod bean = this.context.getBean(ConstructorUsedInBeanMethod.class); 		assertThat(bean.getOne()).isEqualTo("bean-method-1"); 		assertThat(bean.getTwo()).isEqualTo("bound-2"); 	}
@PostConstruct 		void init() { 			assertThat(this.bar).isNotNull(); 			this.initialized = true; 		}
@Bean 		static PropertySourcesPlaceholderConfigurer configurer() { 			return new PropertySourcesPlaceholderConfigurer(); 		}
@Bean 		static PropertySourcesPlaceholderConfigurer configurer() { 			PropertySourcesPlaceholderConfigurer placeholderConfigurer = new PropertySourcesPlaceholderConfigurer(); 			Properties properties = new Properties(); 			properties.put("com.example.bar", "b"); 			placeholderConfigurer.setProperties(properties); 			return placeholderConfigurer; 		}
public void setName(String name) { 			// Must be public for XML 			this.name = name; 		}
public void setName(String name) { 			// Must be public for XML 			this.name = name; 		}
public void setName(String name) { 			// Must be public for XML 			this.name = name; 		}
void setName(String name) { 			this.name = name; 		}
void setName(String name) { 			this.name = name; 		}
Nested getNested() { 			return this.nested; 		}
void setName(String name) { 				this.name = name; 			}
void setName(String name) { 				this.name = name; 			}
void setName(String name) { 				this.name = name; 			}
void setName(String name) { 			this.name = name; 		}
void setName(String name) { 			this.name = name; 		}
@PostConstruct 		void init() { 			assertThat(this.properties).isNotNull(); 		}
String getName() { 			return this.properties.name; 		}
String getName() { 			return this.properties.name; 		}
String getName() { 			return this.properties.name; 		}
void setFoo(String foo) { 			this.foo = foo; 		}
@Override 		public boolean supports(Class<?> type) { 			return type == ValidatorProperties.class; 		}
void setFoo(String foo) { 			this.foo = foo; 		}
void setFoo(String foo) { 			this.foo = foo; 			if (!foo.equals("bar")) { 				throw new IllegalArgumentException("Wrong value for foo"); 			} 		}
void setFoo(String foo) { 			this.foo = foo; 			if (!foo.equals("bar")) { 				throw new IllegalArgumentException("Wrong value for foo"); 			} 		}
void setFoo(String foo) { 			this.foo = foo; 			if (!foo.equals("bar")) { 				throw new IllegalArgumentException("Wrong value for foo"); 			} 		}
void setFoo(String foo) { 			this.foo = foo; 		}
@Override 		public boolean supports(Class<?> type) { 			return type == WithCustomValidatorProperties.class; 		}
@Override 		public Person convert(String source) { 			String[] content = StringUtils.split(source, " "); 			return new Person(content[0], content[1]); 		}
@Override 		public Person convert(String source) { 			String[] content = StringUtils.split(source, " "); 			return new Person(content[0], content[1]); 		}
@Override 		public Alien convert(String source) { 			String[] content = StringUtils.split(source, " "); 			return new Alien(content[0], content[1]); 		}
@Override 		public Alien convert(String source) { 			String[] content = StringUtils.split(source, " "); 			return new Alien(content[0], content[1]); 		}
String getName() { 			return this.name; 		}
Nested getNested() { 			return this.nested; 		}
int getAge() { 				return this.age; 			}
String getName() { 			return this.name; 		}
Nested getNested() { 			return this.nested; 		}
int getAge() { 				return this.age; 			}
Nested getNested() { 			return this.nested; 		}
Nested getNested() { 			return this.nested; 		}
int getAge() { 				return this.age; 			}
int getAge() { 			return this.age; 		}
int getAge() { 			return this.age; 		}
int getAge() { 			return this.age; 		}
int getAge() { 			return this.age; 		}
int getAge() { 			return this.age; 		}
int getAge() { 			return this.age; 		}
int getAge() { 			return this.age; 		}
List<MultiConstructorConfigurationProperties> getNested() { 			return this.nested; 		}
Nested getNested() { 			return this.nested; 		}
int getAge() { 				return this.age; 			}
Nested getNested() { 			return this.nested; 		}
int getAge() { 				return this.age; 			}
void setAge(int age) { 				this.age = age + 5; 			}
Nested getNested() { 			return this.nested; 		}
int getAge() { 				return this.age; 			}
void setAge(int age) { 				this.age = age; 			}
Nested getNested() { 					return this.nested; 				}
Nested getNested() { 					return this.nested; 				}
Nested getNested() { 					return this.nested; 				}
Nested getNested() { 					return this.nested; 				}
Nested getNested() { 					return this.nested; 				}
Nested getNested() { 					return this.nested; 				}
Nested getNested() { 					return this.nested; 				}
Nested getNested() { 					return this.nested; 				}
Nested getNested() { 					return this.nested; 				}
Nested getNested() { 					return this.nested; 				}
Nested getNested() { 					return this.nested; 				}
String getName() { 			return this.name; 		}
Nested getNested() { 			return this.nested; 		}
int getAge() { 				return this.age; 			}
@Override 		public WithPublicObjectToObjectMethod convert(String source) { 			return new WithPublicObjectToObjectMethod(source); 		}
@Override 		public WithPublicObjectToObjectMethod convert(String source) { 			return new WithPublicObjectToObjectMethod(source); 		}
@Bean 		@ConfigurationProperties("test") 		ConstructorUsedInBeanMethod constructorUsedInBeanMethod() { 			return new ConstructorUsedInBeanMethod("bean-method-1", "bean-method-2"); 		}
@Override 		public String toString() { 			return String.format("Bean method '%s' in '%s' not loaded because %s", this.methodMetadata.getMethodName(), 					ClassUtils.getShortName(this.methodMetadata.getDeclaringClassName()), 					this.conditionOutcome.getMessage()); 		}
@Override 		public String toString() { 			StringBuilder sb = new StringBuilder("User-defined bean"); 			if (this.methodMetadata != null) { 				sb.append(String.format(" method '%s' in '%s'", this.methodMetadata.getMethodName(), 						ClassUtils.getShortName(this.methodMetadata.getDeclaringClassName()))); 			} 			if (this.nullBean) { 				sb.append(" ignored as the bean value is null"); 			} 			return sb.toString(); 		}
private FatalBeanException createFailure(Class<?> config, String... environment) { 		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) { 			this.analyzer.setBeanFactory(context.getBeanFactory()); 			TestPropertyValues.of(environment).applyTo(context); 			context.register(config); 			context.refresh(); 			return null; 		} 		catch (FatalBeanException ex) { 			return ex; 		} 	}
@ConditionalOnProperty("spring.string.enabled") 		@Bean 		String string() { 			return "Test"; 		}
@Bean 		String string() { 			return "Test"; 		}
@ConditionalOnBean(Integer.class) 		@Bean(name = "test-string") 		String string() { 			return "Test"; 		}
@Bean 		String string() { 			return null; 		}
@Bean 		String string() { 			return null; 		}
@Bean 		String string() { 			return null; 		}
private Exception createFailure(Class<?> configuration, boolean allowCircularReferences) { 		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) { 			context.register(configuration); 			AbstractAutowireCapableBeanFactory beanFactory = (AbstractAutowireCapableBeanFactory) context 					.getBeanFactory(); 			this.analyzer.setBeanFactory(beanFactory); 			beanFactory.setAllowCircularReferences(allowCircularReferences); 			context.refresh(); 			fail("Expected failure did not occur"); 			return null; 		} 		catch (Exception ex) { 			return ex; 		} 	}
@Bean 		BeanThree three(BeanOne one) { 			return new BeanThree(); 		}
@Bean 			BeanTwo two(BeanThree three) { 				return new BeanTwo(); 			}
@Bean 				BeanOne one(BeanTwo two) { 					return new BeanOne(); 				}
@Bean 				BeanOne one(BeanTwo two) { 					return new BeanOne(); 				}
@Bean 		BeanOne one(BeanTwo two) { 			return new BeanOne(); 		}
@Bean 		BeanTwo two(BeanThree three) { 			return new BeanTwo(); 		}
@Bean 		BeanOne one(BeanTwo two) { 			return new BeanOne(); 		}
@Bean 			BeanThree three(BeanOne one) { 				return new BeanThree(); 			}
@Test 	void analysisWithNullEnvironment() { 		InvalidConfigurationPropertyValueException failure = new InvalidConfigurationPropertyValueException( 				"test.property", "invalid", "This is not valid."); 		FailureAnalysis analysis = new InvalidConfigurationPropertyValueFailureAnalyzer().analyze(failure); 		assertThat(analysis).isNull(); 	}
private FailureAnalysis performAnalysis(InvalidConfigurationPropertyValueException failure) { 		InvalidConfigurationPropertyValueFailureAnalyzer analyzer = new InvalidConfigurationPropertyValueFailureAnalyzer(); 		analyzer.setEnvironment(this.environment); 		return analyzer.analyze(failure); 	}
@Test 	void analyzeWhenEnvironmentIsNullShouldReturnNull() { 		MutuallyExclusiveConfigurationPropertiesException failure = new MutuallyExclusiveConfigurationPropertiesException( 				new HashSet<>(Arrays.asList("com.example.a", "com.example.b")), 				new HashSet<>(Arrays.asList("com.example.a", "com.example.b"))); 		FailureAnalysis failureAnalysis = new MutuallyExclusiveConfigurationPropertiesFailureAnalyzer() 				.analyze(failure); 		assertThat(failureAnalysis).isNull(); 	}
private FailureAnalysis performAnalysis(MutuallyExclusiveConfigurationPropertiesException failure) { 		MutuallyExclusiveConfigurationPropertiesFailureAnalyzer analyzer = new MutuallyExclusiveConfigurationPropertiesFailureAnalyzer(); 		analyzer.setEnvironment(this.environment); 		return analyzer.analyze(failure); 	}
private BeanCreationException createFailure(Class<?> consumer) { 		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) { 			context.register(DuplicateBeansProducer.class, consumer); 			context.setParent(new AnnotationConfigApplicationContext(ParentProducer.class)); 			try { 				context.refresh(); 			} 			catch (BeanCreationException ex) { 				this.analyzer.setBeanFactory(context.getBeanFactory()); 				return ex; 			} 			return null; 		} 	}
private FailureAnalysis performAnalysis(Class<?> configuration) { 		BeanCreationException failure = createFailure(configuration); 		assertThat(failure).isNotNull(); 		DataSourceBeanCreationFailureAnalyzer failureAnalyzer = new DataSourceBeanCreationFailureAnalyzer(); 		failureAnalyzer.setEnvironment(this.environment); 		return failureAnalyzer.analyze(failure); 	}
@Test 	void noAnalysisWithoutR2dbcAutoConfiguration() { 		new ApplicationContextRunner().run((context) -> { 			this.failureAnalyzer.setBeanFactory(context.getBeanFactory()); 			assertThat(this.failureAnalyzer.analyze(new NoSuchBeanDefinitionException(DSLContext.class))).isNull(); 		}); 	}
@Test 	void analysisWithR2dbcAutoConfiguration() { 		new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class)) 				.run((context) -> { 					this.failureAnalyzer.setBeanFactory(context.getBeanFactory()); 					assertThat(this.failureAnalyzer.analyze(new NoSuchBeanDefinitionException(DSLContext.class))) 							.isNotNull(); 				}); 	}
private FailureAnalysis performAnalysis(Class<?> configuration) { 		BeanCreationException failure = createFailure(configuration); 		assertThat(failure).isNotNull(); 		ConnectionFactoryBeanCreationFailureAnalyzer failureAnalyzer = new ConnectionFactoryBeanCreationFailureAnalyzer(); 		failureAnalyzer.setEnvironment(this.environment); 		return failureAnalyzer.analyze(failure); 	}
private T instantiate(TypeSupplier typeSupplier) { 		try { 			Class<?> type = typeSupplier.get(); 			Assert.isAssignable(this.type, type); 			return instantiate(type); 		} 		catch (Throwable ex) { 			throw new IllegalArgumentException( 					"Unable to instantiate " + this.type.getName() + " [" + typeSupplier.getName() + "]", ex); 		} 	}
@SuppressWarnings("unchecked") 	private T instantiate(Class<?> type) throws Exception { 		Constructor<?>[] constructors = type.getDeclaredConstructors(); 		Arrays.sort(constructors, CONSTRUCTOR_COMPARATOR); 		for (Constructor<?> constructor : constructors) { 			Object[] args = getArgs(constructor.getParameterTypes()); 			if (args != null) { 				ReflectionUtils.makeAccessible(constructor); 				return (T) constructor.newInstance(args); 			} 		} 		throw new IllegalAccessException("Unable to find suitable constructor"); 	}
@Override 				public String getName() { 					return name; 				}
@Override 				public Class<?> get() throws ClassNotFoundException { 					return ClassUtils.forName(name, classLoader); 				}
@Override 				public String getName() { 					return type.getName(); 				}
@Override 				public Class<?> get() throws ClassNotFoundException { 					return type; 				}
@Test 	void analyzersAreLoadedAndCalled() { 		RuntimeException failure = new RuntimeException(); 		analyzeAndReport("basic.factories", failure); 		then(failureAnalyzer).should(times(2)).analyze(failure); 	}
@Test 	void environmentIsInjectedIntoEnvironmentAwareFailureAnalyzers() { 		RuntimeException failure = new RuntimeException(); 		analyzeAndReport("basic.factories", failure); 		then(failureAnalyzer).should().setEnvironment(any(Environment.class)); 	}
@Test 	void analyzerThatFailsDuringInitializationDoesNotPreventOtherAnalyzersFromBeingCalled() { 		RuntimeException failure = new RuntimeException(); 		analyzeAndReport("broken-initialization.factories", failure); 		then(failureAnalyzer).should().analyze(failure); 	}
@Test 	void analyzerThatFailsDuringAnalysisDoesNotPreventOtherAnalyzersFromBeingCalled() { 		RuntimeException failure = new RuntimeException(); 		analyzeAndReport("broken-analysis.factories", failure); 		then(failureAnalyzer).should().analyze(failure); 	}
@Test 	void createWithNullContextSkipsAwareAnalyzers() { 		RuntimeException failure = new RuntimeException(); 		analyzeAndReport("basic.factories", failure, null); 		then(failureAnalyzer).should().analyze(failure); 	}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return failureAnalyzer.analyze(failure); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return failureAnalyzer.analyze(failure); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return null; 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			return null; 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			throw new NoClassDefFoundError(); 		}
@Override 		public FailureAnalysis analyze(Throwable failure) { 			throw new NoClassDefFoundError(); 		}
public ApiVersion getApiVersion() { 		return this.apiVersion; 	}
public SecurityContext getSecurityContext() { 		return this.securityContext; 	}
private boolean isMissing(InvocationContext context, OperationParameter parameter) { 		if (!parameter.isMandatory()) { 			return false; 		} 		if (ApiVersion.class.equals(parameter.getType())) { 			return false; 		} 		if (Principal.class.equals(parameter.getType())) { 			return context.getSecurityContext().getPrincipal() == null; 		} 		if (SecurityContext.class.equals(parameter.getType())) { 			return false; 		} 		return context.getArguments().get(parameter.getName()) == null; 	}
private Object resolveArgument(OperationParameter parameter, InvocationContext context) { 		if (ApiVersion.class.equals(parameter.getType())) { 			return context.getApiVersion(); 		} 		if (Principal.class.equals(parameter.getType())) { 			return context.getSecurityContext().getPrincipal(); 		} 		if (SecurityContext.class.equals(parameter.getType())) { 			return context.getSecurityContext(); 		} 		Object value = context.getArguments().get(parameter.getName()); 		return this.parameterValueMapper.mapParameterValue(parameter, value); 	}
@Override 	public Object invoke(InvocationContext context) { 		if (hasInput(context)) { 			return this.invoker.invoke(context); 		} 		long accessTime = System.currentTimeMillis(); 		ApiVersion contextApiVersion = context.getApiVersion(); 		CacheKey cacheKey = new CacheKey(contextApiVersion, context.getSecurityContext().getPrincipal()); 		CachedResponse cached = this.cachedResponses.get(cacheKey); 		if (cached == null || cached.isStale(accessTime, this.timeToLive)) { 			Object response = this.invoker.invoke(context); 			cached = createCachedResponse(response, accessTime); 			this.cachedResponses.put(cacheKey, cached); 		} 		return cached.getResponse(); 	}
@Override 		public Response apply(ContainerRequestContext data) { 			Map<String, Object> arguments = new HashMap<>(); 			if (this.readBody) { 				arguments.putAll(extractBodyArguments(data)); 			} 			arguments.putAll(extractPathParameters(data)); 			arguments.putAll(extractQueryParameters(data)); 			try { 				ApiVersion apiVersion = ApiVersion.fromHttpHeaders(data.getHeaders()); 				JerseySecurityContext securityContext = new JerseySecurityContext(data.getSecurityContext()); 				InvocationContext invocationContext = new InvocationContext(apiVersion, securityContext, arguments); 				Object response = this.operation.invoke(invocationContext); 				return convertToJaxRsResponse(response, data.getRequest().getMethod()); 			} 			catch (InvalidEndpointRequestException ex) { 				return Response.status(Status.BAD_REQUEST).build(); 			} 		}
private Response convertToJaxRsResponse(Object response, String httpMethod) { 			if (response == null) { 				boolean isGet = HttpMethod.GET.equals(httpMethod); 				Status status = isGet ? Status.NOT_FOUND : Status.NO_CONTENT; 				return Response.status(status).build(); 			} 			try { 				if (!(response instanceof WebEndpointResponse)) { 					return Response.status(Status.OK).entity(convertIfNecessary(response)).build(); 				} 				WebEndpointResponse<?> webEndpointResponse = (WebEndpointResponse<?>) response; 				return Response.status(webEndpointResponse.getStatus()) 						.entity(convertIfNecessary(webEndpointResponse.getBody())).build(); 			} 			catch (IOException ex) { 				return Response.status(Status.INTERNAL_SERVER_ERROR).build(); 			} 		}
@Override 		public Object apply(Object body) { 			if (body instanceof org.springframework.core.io.Resource) { 				try { 					return ((org.springframework.core.io.Resource) body).getInputStream(); 				} 				catch (IOException ex) { 					throw new IllegalStateException(); 				} 			} 			return body; 		}
@Override 		public Object apply(Object body) { 			if (body instanceof Mono) { 				return ((Mono<?>) body).block(); 			} 			return body; 		}
@Override 		public Mono<ResponseEntity<Object>> handle(ServerWebExchange exchange, Map<String, String> body) { 			ApiVersion apiVersion = ApiVersion.fromHttpHeaders(exchange.getRequest().getHeaders()); 			Map<String, Object> arguments = getArguments(exchange, body); 			String matchAllRemainingPathSegmentsVariable = this.operation.getRequestPredicate() 					.getMatchAllRemainingPathSegmentsVariable(); 			if (matchAllRemainingPathSegmentsVariable != null) { 				arguments.put(matchAllRemainingPathSegmentsVariable, 						tokenizePathSegments((String) arguments.get(matchAllRemainingPathSegmentsVariable))); 			} 			return this.securityContextSupplier.get() 					.map((securityContext) -> new InvocationContext(apiVersion, securityContext, arguments)) 					.flatMap((invocationContext) -> handleResult((Publisher<?>) this.invoker.invoke(invocationContext), 							exchange.getRequest().getMethod())); 		}
private ResponseEntity<Object> toResponseEntity(Object response) { 			if (!(response instanceof WebEndpointResponse)) { 				return new ResponseEntity<>(response, HttpStatus.OK); 			} 			WebEndpointResponse<?> webEndpointResponse = (WebEndpointResponse<?>) response; 			return ResponseEntity.status(webEndpointResponse.getStatus()).body(webEndpointResponse.getBody()); 		}
@Override 		public String toString() { 			return "Actuator web endpoint '" + this.operation.getId() + "'"; 		}
@Override 		public String toString() { 			return getBean().toString(); 		}
@Override 		public Object handle(HttpServletRequest request, @RequestBody(required = false) Map<String, String> body) { 			HttpHeaders headers = new ServletServerHttpRequest(request).getHeaders(); 			Map<String, Object> arguments = getArguments(request, body); 			try { 				ApiVersion apiVersion = ApiVersion.fromHttpHeaders(headers); 				ServletSecurityContext securityContext = new ServletSecurityContext(request); 				InvocationContext invocationContext = new InvocationContext(apiVersion, securityContext, arguments); 				return handleResult(this.operation.invoke(invocationContext), HttpMethod.resolve(request.getMethod())); 			} 			catch (InvalidEndpointRequestException ex) { 				throw new BadOperationRequestException(ex.getReason()); 			} 		}
@Override 		public Object handle(HttpServletRequest request, @RequestBody(required = false) Map<String, String> body) { 			HttpHeaders headers = new ServletServerHttpRequest(request).getHeaders(); 			Map<String, Object> arguments = getArguments(request, body); 			try { 				ApiVersion apiVersion = ApiVersion.fromHttpHeaders(headers); 				ServletSecurityContext securityContext = new ServletSecurityContext(request); 				InvocationContext invocationContext = new InvocationContext(apiVersion, securityContext, arguments); 				return handleResult(this.operation.invoke(invocationContext), HttpMethod.resolve(request.getMethod())); 			} 			catch (InvalidEndpointRequestException ex) { 				throw new BadOperationRequestException(ex.getReason()); 			} 		}
@Override 		public String toString() { 			return "Actuator web endpoint '" + this.operation.getId() + "'"; 		}
@Override 		public String toString() { 			return "Actuator web endpoint '" + this.operation.getId() + "'"; 		}
private Object handleResult(Object result, HttpMethod httpMethod) { 			if (result == null) { 				return new ResponseEntity<>( 						(httpMethod != HttpMethod.GET) ? HttpStatus.NO_CONTENT : HttpStatus.NOT_FOUND); 			} 			if (!(result instanceof WebEndpointResponse)) { 				return result; 			} 			WebEndpointResponse<?> response = (WebEndpointResponse<?>) result; 			return ResponseEntity.status(response.getStatus()).body(response.getBody()); 		}
@ResponseBody 		Object handle(HttpServletRequest request, @RequestBody(required = false) Map<String, String> body) { 			return this.operation.handle(request, body); 		}
@Override 		public String toString() { 			return this.operation.toString(); 		}
@Override 		public String toString() { 			return this.operation.toString(); 		}
@Override 		public String toString() { 			return getBean().toString(); 		}
@Override 		public String toString() { 			return getBean().toString(); 		}
@Test 	void targetInvokedWithDifferentApiVersion() { 		OperationInvoker target = mock(OperationInvoker.class); 		Object expectedV2 = new Object(); 		Object expectedV3 = new Object(); 		InvocationContext contextV2 = new InvocationContext(ApiVersion.V2, mock(SecurityContext.class), 				Collections.emptyMap()); 		InvocationContext contextV3 = new InvocationContext(ApiVersion.V3, mock(SecurityContext.class), 				Collections.emptyMap()); 		given(target.invoke(contextV2)).willReturn(expectedV2); 		given(target.invoke(contextV3)).willReturn(expectedV3); 		CachingOperationInvoker invoker = new CachingOperationInvoker(target, CACHE_TTL); 		Object response = invoker.invoke(contextV2); 		assertThat(response).isSameAs(expectedV2); 		verify(target, times(1)).invoke(contextV2); 		Object cachedResponse = invoker.invoke(contextV3); 		assertThat(cachedResponse).isNotSameAs(response); 		verify(target, times(1)).invoke(contextV3); 	}
@Override 		public Mono<String> invoke(InvocationContext context) throws MissingParametersException { 			return Mono.fromCallable(() -> { 				invocations.incrementAndGet(); 				return "test"; 			}); 		}
@Override 		public Flux<String> invoke(InvocationContext context) throws MissingParametersException { 			return Flux.just("spring", "boot").hide().doFirst(invocations::incrementAndGet); 		}
@Bean 	@ConditionalOnMissingBean(JerseyApplicationPath.class) 	public JerseyApplicationPath jerseyApplicationPath(JerseyProperties properties, ResourceConfig config) { 		return new DefaultJerseyApplicationPath(properties.getApplicationPath(), config); 	}
@Override 		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource) throws IOException { 			throw new AssertionError("Unexpected call"); 		}
@Override 		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource) throws IOException { 			throw new AssertionError("Unexpected call"); 		}
@Override 		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource) throws IOException { 			return createConfigData(this, resource); 		}
@Override 		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource) throws IOException { 			return createConfigData(this, resource); 		}
@Override 		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource) throws IOException { 			return createConfigData(this, resource); 		}
private Collection<ApplicationListener<?>> getListeners() { 		List<ApplicationListener<?>> listeners = new ArrayList<>(); 		listeners.add(new AnsiOutputApplicationListener()); 		listeners.add(new ConfigFileApplicationListener()); 		listeners.add(new ClasspathLoggingApplicationListener()); 		listeners.add(new LoggingApplicationListener()); 		listeners.add(new RemoteUrlPropertyExtractor()); 		return listeners; 	}
@Override 	public void initialize(ConfigurableApplicationContext applicationContext) { 		new ConfigFileApplicationListener() { 			public void apply() { 				addPropertySources(applicationContext.getEnvironment(), applicationContext); 				addPostProcessors(applicationContext); 			} 		}.apply(); 	}
private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, 			ApplicationArguments applicationArguments) { 		// Create and configure the environment 		ConfigurableEnvironment environment = getOrCreateEnvironment(); 		configureEnvironment(environment, applicationArguments.getSourceArgs()); 		ConfigurationPropertySources.attach(environment); 		listeners.environmentPrepared(environment); 		DefaultPropertiesPropertySource.moveToEnd(environment); 		bindToSpringApplication(environment); 		if (!this.isCustomEnvironment) { 			environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, 					deduceEnvironmentClass()); 		} 		ConfigurationPropertySources.attach(environment); 		return environment; 	}
protected void configureProfiles(ConfigurableEnvironment environment, String[] args) { 		Set<String> profiles = new LinkedHashSet<>(this.additionalProfiles); 		profiles.addAll(Arrays.asList(environment.getActiveProfiles())); 		environment.setActiveProfiles(StringUtils.toStringArray(profiles)); 	}
public void setAdditionalProfiles(String... profiles) { 		this.additionalProfiles = new LinkedHashSet<>(Arrays.asList(profiles)); 	}
@Override 	public void onApplicationEvent(ApplicationPreparedEvent event) { 		logger.switchTo(CloudFoundryVcapEnvironmentPostProcessor.class); 	}
private Properties getPropertiesFromApplication(Environment environment, JsonParser parser) { 		Properties properties = new Properties(); 		try { 			String property = environment.getProperty(VCAP_APPLICATION, "{}"); 			Map<String, Object> map = parser.parseMap(property); 			extractPropertiesFromApplication(properties, map); 		} 		catch (Exception ex) { 			logger.error("Could not parse VCAP_APPLICATION", ex); 		} 		return properties; 	}
private Properties getPropertiesFromServices(Environment environment, JsonParser parser) { 		Properties properties = new Properties(); 		try { 			String property = environment.getProperty(VCAP_SERVICES, "{}"); 			Map<String, Object> map = parser.parseMap(property); 			extractPropertiesFromServices(properties, map); 		} 		catch (Exception ex) { 			logger.error("Could not parse VCAP_SERVICES", ex); 		} 		return properties; 	}
@Override 	public int getOrder() { 		// Apply after ConfigFileApplicationListener has called EnvironmentPostProcessors 		return ConfigFileApplicationListener.DEFAULT_ORDER + 1; 	}
@Override 	public void onApplicationEvent(ApplicationEvent event) { 		if (event instanceof ApplicationEnvironmentPreparedEvent) { 			onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event); 		} 		if (event instanceof ApplicationPreparedEvent) { 			onApplicationPreparedEvent(event); 		} 	}
@Override 	public int getOrder() { 		return this.order; 	}
@Override 		public int getOrder() { 			return Ordered.HIGHEST_PRECEDENCE; 		}
private void reorderSources(ConfigurableEnvironment environment) { 			PropertySource<?> defaultProperties = environment.getPropertySources().remove(DEFAULT_PROPERTIES); 			if (defaultProperties != null) { 				environment.getPropertySources().addLast(defaultProperties); 			} 		}
void load() { 			FilteredPropertySource.apply(this.environment, DEFAULT_PROPERTIES, LOAD_FILTERED_PROPERTY, 					(defaultProperties) -> { 						this.profiles = new LinkedList<>(); 						this.processedProfiles = new LinkedList<>(); 						this.activatedProfiles = false; 						this.loaded = new LinkedHashMap<>(); 						initializeProfiles(); 						while (!this.profiles.isEmpty()) { 							Profile profile = this.profiles.poll(); 							if (isDefaultProfile(profile)) { 								addProfileToEnvironment(profile.getName()); 							} 							load(profile, this::getPositiveProfileFilter, 									addToLoaded(MutablePropertySources::addLast, false)); 							this.processedProfiles.add(profile); 						} 						load(null, this::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, true)); 						addLoadedPropertySources(); 						applyActiveProfiles(defaultProperties); 					}); 		}
private void addLoadedPropertySource(MutablePropertySources destination, String lastAdded, 				PropertySource<?> source) { 			if (lastAdded == null) { 				if (destination.contains(DEFAULT_PROPERTIES)) { 					destination.addBefore(DEFAULT_PROPERTIES, source); 				} 				else { 					destination.addLast(source); 				} 			} 			else { 				destination.addAfter(lastAdded, source); 			} 		}
@Override 		public boolean equals(Object obj) { 			if (obj == this) { 				return true; 			} 			if (obj == null || obj.getClass() != getClass()) { 				return false; 			} 			return ((Profile) obj).name.equals(this.name); 		}
@Override 		public int hashCode() { 			return this.name.hashCode(); 		}
@Override 		public String toString() { 			return this.name; 		}
@Override 		public boolean equals(Object obj) { 			if (this == obj) { 				return true; 			} 			if (obj == null || getClass() != obj.getClass()) { 				return false; 			} 			DocumentsCacheKey other = (DocumentsCacheKey) obj; 			return this.loader.equals(other.loader) && this.resource.equals(other.resource); 		}
@Override 		public int hashCode() { 			return this.loader.hashCode() * 31 + this.resource.hashCode(); 		}
@Override 		public String toString() { 			return this.propertySource.toString(); 		}
@Override 	public Object getProperty(String name) { 		if (!name.startsWith(PREFIX)) { 			return null; 		} 		if (logger.isTraceEnabled()) { 			logger.trace("Generating random property for '" + name + "'"); 		} 		return getRandomValue(name.substring(PREFIX.length())); 	}
public static void addToEnvironment(ConfigurableEnvironment environment) { 		environment.getPropertySources().addAfter(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, 				new RandomValuePropertySource(RANDOM_PROPERTY_SOURCE_NAME)); 		logger.trace("RandomValuePropertySource add to Environment"); 	}
@Test 	void addProfilesOrder() { 		SpringApplication application = new SpringApplication(ExampleConfig.class); 		application.setWebApplicationType(WebApplicationType.NONE); 		application.setAdditionalProfiles("foo"); 		ConfigurableEnvironment environment = new StandardEnvironment(); 		application.setEnvironment(environment); 		this.context = application.run("--spring.profiles.active=bar,spam"); 		// Command line should always come last 		assertThat(environment.getActiveProfiles()).containsExactly("foo", "bar", "spam"); 	}
@Test 	void run() { 		this.context = SpringApplication.run(ExampleWebConfig.class); 		assertThat(this.context).isNotNull(); 	}
@Test 	void registerShutdownHook() { 		SpringApplication application = new SpringApplication(ExampleConfig.class); 		application.setApplicationContextFactory(ApplicationContextFactory.ofContextClass(SpyApplicationContext.class)); 		this.context = application.run(); 		SpyApplicationContext applicationContext = (SpyApplicationContext) this.context; 		verify(applicationContext.getApplicationContext()).registerShutdownHook(); 	}
@Override 			public void run() { 				SpringApplication application = new SpringApplication(FailingConfig.class); 				application.setWebApplicationType(WebApplicationType.NONE); 				application.run(); 			}
@Override 		public void registerShutdownHook() { 			this.applicationContext.registerShutdownHook(); 		}
@Bean 		String someBean() { 			return "test"; 		}
@Bean 		String someBean() { 			return "override"; 		}
@Bean 		Object fail() { 			throw new RuntimeException("ExpectedError"); 		}
@Bean 		CommandLineRunner runner() { 			return (args) -> { 				throw new IllegalStateException(new ExitStatusException()); 			}; 		}
@Bean 		CommandLineRunner runner() { 			return (args) -> { 				throw new IllegalStateException(); 			}; 		}
@PostConstruct 		void fail() { 			throw new RefreshFailureException(); 		}
@Override 		public int getExitCode() { 			return 11; 		}
Integer getExitCode() { 			return this.exitCode; 		}
@AfterEach 	void cleanUp() { 		if (this.context != null) { 			this.context.close(); 		} 		System.clearProperty("the.property"); 		System.clearProperty("spring.config.location"); 	}
@Test 	void moreSpecificLocationTakesPrecedenceOverRoot() { 		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, "spring.config.name=specific"); 		this.initializer.postProcessEnvironment(this.environment, this.application); 		String property = this.environment.getProperty("my.property"); 		assertThat(property).isEqualTo("specific"); 	}
@Test 	void randomValue() { 		this.initializer.postProcessEnvironment(this.environment, this.application); 		String property = this.environment.getProperty("random.value"); 		assertThat(property).isNotNull(); 	}
@Test 	void loadDefaultYamlDocument() { 		this.environment.setDefaultProfiles("thedefault"); 		this.initializer.setSearchNames("testprofilesdocument"); 		this.initializer.postProcessEnvironment(this.environment, this.application); 		String property = this.environment.getProperty("my.property"); 		assertThat(property).isEqualTo("fromdefaultprofile"); 	}
@Test 	void includedProfilesFromDefaultPropertiesShouldNotTakePrecedence() { 		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, 				"spring.profiles.active=morespecific"); 		this.environment.getPropertySources().addLast( 				new MapPropertySource("defaultProperties", Collections.singletonMap("spring.profiles.include", "dev"))); 		this.initializer.postProcessEnvironment(this.environment, this.application); 		assertThat(this.environment.getActiveProfiles()).containsExactly("dev", "morespecific", "yetmorespecific"); 	}
@Test 	void profilesAddedToEnvironmentAndViaPropertyDuplicateEnvironmentWins(CapturedOutput output) { 		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, "spring.profiles.active=other,dev"); 		this.environment.addActiveProfile("other"); 		this.initializer.postProcessEnvironment(this.environment, this.application); 		assertThat(this.environment.getActiveProfiles()).contains("dev", "other"); 		assertThat(this.environment.getProperty("my.property")).isEqualTo("fromdevpropertiesfile"); 		validateProfilePreference(output, null, "other", "dev"); 	}
private void validateProfilePreference(CapturedOutput output, String... profiles) { 		ApplicationPreparedEvent event = new ApplicationPreparedEvent(new SpringApplication(), new String[0], 				new AnnotationConfigApplicationContext()); 		withDebugLogging(() -> this.initializer.onApplicationEvent(event)); 		String log = output.toString(); 		// First make sure that each profile got processed only once 		for (String profile : profiles) { 			String reason = "Wrong number of occurrences for profile '" + profile + "' --> " + log; 			assertThat(StringUtils.countOccurrencesOf(log, createLogForProfile(profile))).as(reason).isEqualTo(1); 		} 		// Make sure the order of loading is the right one 		for (String profile : profiles) { 			String line = createLogForProfile(profile); 			int index = log.indexOf(line); 			assertThat(index).as("Loading profile '" + profile + "' not found in '" + log + "'").isNotEqualTo(-1); 			log = log.substring(index + line.length()); 		} 	}
@Test 	void absoluteResourceDefaultsToFile() { 		String location = new File("src/test/resources/specificlocation.properties").getAbsolutePath().replace("\\", 				"/"); 		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, 				"spring.config.location=" + location); 		this.initializer.postProcessEnvironment(this.environment, this.application); 		assertThat(this.environment).has( 				matchingPropertySource("applicationConfig: [file:" + location.replace(File.separatorChar, '/') + "]")); 	}
@Override 			public boolean matches(ConfigurableEnvironment value) { 				return value.getPropertySources().contains(sourceName); 			}
@Override 			public boolean matches(ConfigurableEnvironment value) { 				return value.acceptsProfiles(Profiles.of(profile)); 			}
@Test 	void customConfigurableWebBindingInitializer() { 		this.contextRunner.withUserConfiguration(CustomConfigurableWebBindingInitializer.class).run( 				(context) -> assertThat(context.getBean(RequestMappingHandlerAdapter.class).getWebBindingInitializer()) 						.isInstanceOf(CustomWebBindingInitializer.class)); 	}
@Test 	void validatorWithConfigurerShouldUseSpringValidator() { 		this.contextRunner.withUserConfiguration(MvcValidator.class).run((context) -> { 			assertThat(context).doesNotHaveBean(ValidatorFactory.class); 			assertThat(context).doesNotHaveBean(javax.validation.Validator.class); 			assertThat(context).getBeanNames(Validator.class).containsOnly("mvcValidator"); 			assertThat(context.getBean("mvcValidator")).isSameAs(context.getBean(MvcValidator.class).validator); 		}); 	}
@Override 		public void addResourceHandlers(ResourceHandlerRegistry registry) { 			registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/foo/"); 		}
@Override 		public void addResourceHandlers(ResourceHandlerRegistry registry) { 			registry.addResourceHandler("/**").addResourceLocations("classpath:/foo/"); 		}
@Bean 		ConfigurableWebBindingInitializer customConfigurableWebBindingInitializer() { 			return new CustomWebBindingInitializer(); 		}
@Override 	protected FailureAnalysis analyze(Throwable rootFailure, NoSuchBeanDefinitionException cause, String description) { 		if (cause.getNumberOfBeansFound() != 0) { 			return null; 		} 		List<AutoConfigurationResult> autoConfigurationResults = getAutoConfigurationResults(cause); 		List<UserConfigurationResult> userConfigurationResults = getUserConfigurationResults(cause); 		StringBuilder message = new StringBuilder(); 		message.append(String.format("%s required %s that could not be found.%n", 				(description != null) ? description : "A component", getBeanDescription(cause))); 		List<Annotation> injectionAnnotations = findInjectionAnnotations(rootFailure); 		if (!injectionAnnotations.isEmpty()) { 			message.append(String.format("%nThe injection point has the following annotations:%n")); 			for (Annotation injectionAnnotation : injectionAnnotations) { 				message.append(String.format("\t- %s%n", injectionAnnotation)); 			} 		} 		if (!autoConfigurationResults.isEmpty() || !userConfigurationResults.isEmpty()) { 			message.append(String.format("%nThe following candidates were found but could not be injected:%n")); 			for (AutoConfigurationResult result : autoConfigurationResults) { 				message.append(String.format("\t- %s%n", result)); 			} 			for (UserConfigurationResult result : userConfigurationResults) { 				message.append(String.format("\t- %s%n", result)); 			} 		} 		String action = String.format("Consider %s %s in your configuration.", 				(!autoConfigurationResults.isEmpty() || !userConfigurationResults.isEmpty()) 						? "revisiting the entries above or defining" : "defining", 				getBeanDescription(cause)); 		return new FailureAnalysis(message.toString(), action, cause); 	}
@Override 		public String toString() { 			return String.format("Bean method '%s' in '%s' not loaded because %s", this.methodMetadata.getMethodName(), 					ClassUtils.getShortName(this.methodMetadata.getDeclaringClassName()), 					this.conditionOutcome.getMessage()); 		}
@Override 		public String toString() { 			StringBuilder sb = new StringBuilder("User-defined bean"); 			if (this.methodMetadata != null) { 				sb.append(String.format(" method '%s' in '%s'", this.methodMetadata.getMethodName(), 						ClassUtils.getShortName(this.methodMetadata.getDeclaringClassName()))); 			} 			if (this.nullBean) { 				sb.append(" ignored as the bean value is null"); 			} 			return sb.toString(); 		}
private void assertActionMissingType(FailureAnalysis analysis, Class<?> type) { 		assertThat(analysis.getAction()).startsWith(String.format( 				"Consider revisiting the entries above or defining a bean of type '%s' in your configuration.", 				type.getName())); 	}
@ConditionalOnProperty("spring.string.enabled") 		@Bean 		String string() { 			return "Test"; 		}
@Bean 		String string() { 			return "Test"; 		}
@ConditionalOnBean(Integer.class) 		@Bean(name = "test-string") 		String string() { 			return "Test"; 		}
@Bean 		String string() { 			return null; 		}
@Bean 		String string() { 			return null; 		}
@Bean 		String string() { 			return null; 		}
private ContextConfigurationProperties describeConfigurationProperties(ApplicationContext context, 			ObjectMapper mapper) { 		ConfigurationBeanFactoryMetadata beanFactoryMetadata = getBeanFactoryMetadata(context); 		Map<String, Object> beans = getConfigurationPropertiesBeans(context, beanFactoryMetadata); 		Map<String, ConfigurationPropertiesBeanDescriptor> beanDescriptors = new HashMap<>(); 		beans.forEach((beanName, bean) -> { 			String prefix = extractPrefix(context, beanFactoryMetadata, beanName); 			beanDescriptors.put(beanName, new ConfigurationPropertiesBeanDescriptor(prefix, 					sanitize(prefix, safeSerialize(mapper, bean, prefix)))); 		}); 		return new ContextConfigurationProperties(beanDescriptors, 				(context.getParent() != null) ? context.getParent().getId() : null); 	}
@Override 	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { 		this.applicationContext = applicationContext; 		this.propertySources = new PropertySourcesDeducer(applicationContext).getPropertySources(); 		this.configurationPropertiesValidator = getConfigurationPropertiesValidator(applicationContext, 				this.validatorBeanName); 		this.jsr303Present = ConfigurationPropertiesJsr303Validator.isJsr303Present(applicationContext); 	}
@Override 	public void afterPropertiesSet() throws Exception { 		// We can't use constructor injection of the application context because 		// it causes eager factory bean initialization 		this.beanFactoryMetadata = this.applicationContext.getBean(ConfigurationBeanFactoryMetadata.BEAN_NAME, 				ConfigurationBeanFactoryMetadata.class); 		this.configurationPropertiesBinder = this.applicationContext.getBean(ConfigurationPropertiesBinder.BEAN_NAME, 				ConfigurationPropertiesBinder.class); 	}
@Override 	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { 		ConfigurationProperties annotation = getAnnotation(bean, beanName, ConfigurationProperties.class); 		if (annotation != null && !hasBeenBound(beanName)) { 			bind(bean, beanName, annotation); 		} 		return bean; 	}
@Override 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { 		if (!registry.containsBeanDefinition(ConfigurationPropertiesBinder.BEAN_NAME)) { 			registerConfigurationPropertiesBinder(registry); 		} 		if (!registry.containsBeanDefinition(ConfigurationPropertiesBindingPostProcessor.BEAN_NAME)) { 			registerConfigurationPropertiesBindingPostProcessor(registry); 			registerConfigurationBeanFactoryMetadata(registry); 		} 	}
@Override 	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { 		Set<String> packagesToScan = getPackagesToScan(importingClassMetadata); 		register(registry, (ConfigurableListableBeanFactory) registry, packagesToScan); 	}
private Set<String> getPackagesToScan(AnnotationMetadata metadata) { 		AnnotationAttributes attributes = AnnotationAttributes 				.fromMap(metadata.getAnnotationAttributes(ConfigurationPropertiesScan.class.getName())); 		String[] basePackages = attributes.getStringArray("basePackages"); 		Class<?>[] basePackageClasses = attributes.getClassArray("basePackageClasses"); 		Set<String> packagesToScan = new LinkedHashSet<>(Arrays.asList(basePackages)); 		for (Class<?> basePackageClass : basePackageClasses) { 			packagesToScan.add(ClassUtils.getPackageName(basePackageClass)); 		} 		if (packagesToScan.isEmpty()) { 			packagesToScan.add(ClassUtils.getPackageName(metadata.getClassName())); 		} 		return packagesToScan; 	}
PropertySources getPropertySources() { 		PropertySourcesPlaceholderConfigurer configurer = getSinglePropertySourcesPlaceholderConfigurer(); 		if (configurer != null) { 			return configurer.getAppliedPropertySources(); 		} 		MutablePropertySources sources = extractEnvironmentPropertySources(); 		if (sources != null) { 			return sources; 		} 		throw new IllegalStateException( 				"Unable to obtain PropertySources from PropertySourcesPlaceholderConfigurer or Environment"); 	}
@Test 	void registerBeanDefintionsShouldScanForConfigurationProperties() throws IOException { 		this.registrar.registerBeanDefinitions(getAnnotationMetadata(ConfigurationPropertiesScanConfiguration.class), 				this.beanFactory); 		BeanDefinition bingDefinition = this.beanFactory.getBeanDefinition( 				"bing-org.springframework.boot.context.properties.scan.valid.ConfigurationPropertiesScanConfiguration$BingProperties"); 		BeanDefinition fooDefinition = this.beanFactory.getBeanDefinition( 				"foo-org.springframework.boot.context.properties.scan.valid.ConfigurationPropertiesScanConfiguration$FooProperties"); 		BeanDefinition barDefinition = this.beanFactory.getBeanDefinition( 				"bar-org.springframework.boot.context.properties.scan.valid.ConfigurationPropertiesScanConfiguration$BarProperties"); 		assertThat(bingDefinition).isExactlyInstanceOf(GenericBeanDefinition.class); 		assertThat(fooDefinition).isExactlyInstanceOf(GenericBeanDefinition.class); 		assertThat(barDefinition).isExactlyInstanceOf(ConfigurationPropertiesBeanDefinition.class); 	}
@Test 	void scanWhenBasePackagesAndBasePackcageClassesProvidedShouldUseThat() throws IOException { 		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); 		beanFactory.setAllowBeanDefinitionOverriding(false); 		this.registrar.registerBeanDefinitions( 				getAnnotationMetadata(ConfigurationPropertiesScanConfiguration.DifferentPackageConfiguration.class), 				beanFactory); 		assertThat(beanFactory.containsBeanDefinition( 				"foo-org.springframework.boot.context.properties.scan.valid.ConfigurationPropertiesScanConfiguration$FooProperties")) 						.isFalse(); 		BeanDefinition aDefinition = beanFactory.getBeanDefinition( 				"a-org.springframework.boot.context.properties.scan.valid.a.AScanConfiguration$AProperties"); 		BeanDefinition bFirstDefinition = beanFactory.getBeanDefinition( 				"b.first-org.springframework.boot.context.properties.scan.valid.b.BScanConfiguration$BFirstProperties"); 		BeanDefinition bSecondDefinition = beanFactory.getBeanDefinition( 				"b.second-org.springframework.boot.context.properties.scan.valid.b.BScanConfiguration$BSecondProperties"); 		assertThat(aDefinition).isExactlyInstanceOf(GenericBeanDefinition.class); 		// Constructor injection 		assertThat(bFirstDefinition).isExactlyInstanceOf(ConfigurationPropertiesBeanDefinition.class); 		// Post-processing injection 		assertThat(bSecondDefinition).isExactlyInstanceOf(GenericBeanDefinition.class); 	}
@Test 	void loadWhenBindingWithoutAndAnnotationShouldFail() { 		assertThatIllegalArgumentException().isThrownBy(() -> load(WithoutAndAnnotationConfiguration.class, "name:foo")) 				.withMessageContaining("No ConfigurationProperties annotation found"); 	}
@PostConstruct 		void init() { 			assertThat(this.bar).isNotNull(); 			this.initialized = true; 		}
@Bean 		static PropertySourcesPlaceholderConfigurer configurer() { 			return new PropertySourcesPlaceholderConfigurer(); 		}
@Bean 		static PropertySourcesPlaceholderConfigurer configurer() { 			PropertySourcesPlaceholderConfigurer placeholderConfigurer = new PropertySourcesPlaceholderConfigurer(); 			Properties properties = new Properties(); 			properties.put("com.example.bar", "b"); 			placeholderConfigurer.setProperties(properties); 			return placeholderConfigurer; 		}
public void setName(String name) { 			// Must be public for XML 			this.name = name; 		}
public void setName(String name) { 			// Must be public for XML 			this.name = name; 		}
public void setName(String name) { 			// Must be public for XML 			this.name = name; 		}
void setName(String name) { 			this.name = name; 		}
void setName(String name) { 			this.name = name; 		}
void setName(String name) { 				this.name = name; 			}
void setName(String name) { 				this.name = name; 			}
void setName(String name) { 				this.name = name; 			}
void setName(String name) { 			this.name = name; 		}
void setName(String name) { 			this.name = name; 		}
@PostConstruct 		void init() { 			assertThat(this.properties).isNotNull(); 		}
void setFoo(String foo) { 			this.foo = foo; 		}
@Override 		public boolean supports(Class<?> type) { 			return type == ValidatorProperties.class; 		}
void setFoo(String foo) { 			this.foo = foo; 		}
void setFoo(String foo) { 			this.foo = foo; 			if (!foo.equals("bar")) { 				throw new IllegalArgumentException("Wrong value for foo"); 			} 		}
void setFoo(String foo) { 			this.foo = foo; 			if (!foo.equals("bar")) { 				throw new IllegalArgumentException("Wrong value for foo"); 			} 		}
void setFoo(String foo) { 			this.foo = foo; 			if (!foo.equals("bar")) { 				throw new IllegalArgumentException("Wrong value for foo"); 			} 		}
void setFoo(String foo) { 			this.foo = foo; 		}
@Override 		public boolean supports(Class<?> type) { 			return type == WithCustomValidatorProperties.class; 		}
private void inject(Field field, Object target, String beanName) { 		try { 			field.setAccessible(true); 			Assert.state(ReflectionUtils.getField(field, target) == null, 					() -> "The field " + field + " cannot have an existing value"); 			Object bean = this.beanFactory.getBean(beanName, field.getType()); 			ReflectionUtils.setField(field, target, bean); 		} 		catch (Throwable ex) { 			throw new BeanCreationException("Could not inject field: " + field, ex); 		} 	}
@Override 	public int getOrder() { 		return Ordered.LOWEST_PRECEDENCE - 10; 	}
public static void register(BeanDefinitionRegistry registry) { 		register(registry, null); 	}
@Override 		public int getOrder() { 			return Ordered.HIGHEST_PRECEDENCE; 		}
@Override 		public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException { 			return this.mockitoPostProcessor.createSpyIfNecessary(bean, beanName); 		}
@Override 		public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { 			if (bean instanceof FactoryBean) { 				return bean; 			} 			return this.mockitoPostProcessor.createSpyIfNecessary(bean, beanName); 		}
public static void register(BeanDefinitionRegistry registry) { 			if (!registry.containsBeanDefinition(BEAN_NAME)) { 				RootBeanDefinition definition = new RootBeanDefinition(SpyPostProcessor.class); 				definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); 				ConstructorArgumentValues constructorArguments = definition.getConstructorArgumentValues(); 				constructorArguments.addIndexedArgumentValue(0, 						new RuntimeBeanReference(MockitoPostProcessor.BEAN_NAME)); 				registry.registerBeanDefinition(BEAN_NAME, definition); 			} 		}
@Test 	void customDateFormat() { 		this.contextRunner.withPropertyValues("spring.jackson.date-format:yyyyMMddHHmmss").run((context) -> { 			ObjectMapper mapper = context.getBean(ObjectMapper.class); 			DateFormat dateFormat = mapper.getDateFormat(); 			assertThat(dateFormat).isInstanceOf(SimpleDateFormat.class); 			assertThat(((SimpleDateFormat) dateFormat).toPattern()).isEqualTo("yyyyMMddHHmmss"); 		}); 	}
@Bean 		@Primary 		ObjectMapper objectMapper() { 			return mock(ObjectMapper.class); 		}
@Bean 		CustomModule jacksonModule() { 			return new CustomModule(); 		}
@Bean 		Module jacksonModule() { 			SimpleModule module = new SimpleModule(); 			module.addSerializer(Foo.class, new JsonSerializer<Foo>() {  				@Override 				public void serialize(Foo value, JsonGenerator jgen, SerializerProvider provider) throws IOException { 					jgen.writeStartObject(); 					jgen.writeStringField("foo", "bar"); 					jgen.writeEndObject(); 				} 			}); 			return module; 		}
@Bean 		@Primary 		ObjectMapper objectMapper() { 			ObjectMapper mapper = new ObjectMapper(); 			mapper.registerModule(jacksonModule()); 			return mapper; 		}
@Bean 		Jackson2ObjectMapperBuilderCustomizer customDateFormat() { 			return (builder) -> builder.dateFormat(new MyDateFormat()); 		}
private boolean canBindAtCreationTime(Class<?> type) { 			Constructor<?>[] constructors = type.getDeclaredConstructors(); 			boolean autowiredPresent = Arrays.stream(constructors).anyMatch( 					(c) -> AnnotationUtils.findAnnotation(c, Autowired.class) != null); 			if (autowiredPresent) { 				return false; 			} 			return (constructors.length == 1 && constructors[0].getParameterCount() > 0); 		}
@SuppressWarnings("unchecked") 	private void customize(MeterRegistry registry) { 		LambdaSafe.callbacks(MeterRegistryCustomizer.class, this.customizers, registry) 				.withLogger(MeterRegistryConfigurer.class) 				.invoke((customizer) -> customizer.customize(registry)); 	}
private void addFilters(MeterRegistry registry) { 		this.filters.forEach(registry.config()::meterFilter); 	}
private void addBinders(MeterRegistry registry) { 		this.binders.forEach((binder) -> binder.bindTo(registry)); 	}
private MeterRegistryConfigurer getConfigurer() { 		if (this.configurer == null) { 			this.configurer = new MeterRegistryConfigurer( 					asOrderedList(this.meterBinders), asOrderedList(this.meterFilters), 					asOrderedList(this.meterRegistryCustomizers), 					this.metricsProperties.getObject().isUseGlobalRegistry()); 		} 		return this.configurer; 	}
@Test 	public void configureWhenCompositeShouldApplyCustomizer() { 		this.customizers.add(this.mockCustomizer); 		MeterRegistryConfigurer configurer = new MeterRegistryConfigurer(this.binders, 				this.filters, this.customizers, false); 		CompositeMeterRegistry composite = new CompositeMeterRegistry(); 		configurer.configure(composite); 		verify(this.mockCustomizer).customize(composite); 	}
@Test 	public void configureShouldApplyCustomizer() { 		this.customizers.add(this.mockCustomizer); 		MeterRegistryConfigurer configurer = new MeterRegistryConfigurer(this.binders, 				this.filters, this.customizers, false); 		configurer.configure(this.mockRegistry); 		verify(this.mockCustomizer).customize(this.mockRegistry); 	}
@Test 	public void configureShouldApplyFilter() { 		this.filters.add(this.mockFilter); 		MeterRegistryConfigurer configurer = new MeterRegistryConfigurer(this.binders, 				this.filters, this.customizers, false); 		configurer.configure(this.mockRegistry); 		verify(this.mockConfig).meterFilter(this.mockFilter); 	}
@Test 	public void configureShouldApplyBinder() { 		this.binders.add(this.mockBinder); 		MeterRegistryConfigurer configurer = new MeterRegistryConfigurer(this.binders, 				this.filters, this.customizers, false); 		configurer.configure(this.mockRegistry); 		verify(this.mockBinder).bindTo(this.mockRegistry); 	}
@Test 	public void configureShouldBeCalledInOrderCustomizerFilterBinder() { 		this.customizers.add(this.mockCustomizer); 		this.filters.add(this.mockFilter); 		this.binders.add(this.mockBinder); 		MeterRegistryConfigurer configurer = new MeterRegistryConfigurer(this.binders, 				this.filters, this.customizers, false); 		configurer.configure(this.mockRegistry); 		InOrder ordered = inOrder(this.mockBinder, this.mockConfig, this.mockCustomizer); 		ordered.verify(this.mockCustomizer).customize(this.mockRegistry); 		ordered.verify(this.mockConfig).meterFilter(this.mockFilter); 		ordered.verify(this.mockBinder).bindTo(this.mockRegistry); 	}
@Test 	public void configureWhenAddToGlobalRegistryShouldAddToGlobalRegistry() { 		MeterRegistryConfigurer configurer = new MeterRegistryConfigurer(this.binders, 				this.filters, this.customizers, true); 		try { 			configurer.configure(this.mockRegistry); 			assertThat(Metrics.globalRegistry.getRegistries()) 					.contains(this.mockRegistry); 		} 		finally { 			Metrics.removeRegistry(this.mockRegistry); 		} 	}
@Test 	public void configureWhenNotAddToGlobalRegistryShouldAddToGlobalRegistry() { 		MeterRegistryConfigurer configurer = new MeterRegistryConfigurer(this.binders, 				this.filters, this.customizers, false); 		configurer.configure(this.mockRegistry); 		assertThat(Metrics.globalRegistry.getRegistries()) 				.doesNotContain(this.mockRegistry); 	}
@Override 	protected FailureAnalysis analyze(Throwable rootFailure, 			NoSuchBeanDefinitionException cause, String description) { 		if (cause.getNumberOfBeansFound() != 0) { 			return null; 		} 		List<AutoConfigurationResult> autoConfigurationResults = getAutoConfigurationResults( 				cause); 		StringBuilder message = new StringBuilder(); 		message.append(String.format("%s required %s that could not be found.%n", 				(description != null ? description : "A component"), 				getBeanDescription(cause))); 		if (!autoConfigurationResults.isEmpty()) { 			for (AutoConfigurationResult provider : autoConfigurationResults) { 				message.append(String.format("\t- %s%n", provider)); 			} 		} 		String action = String.format("Consider %s %s in your configuration.", 				(!autoConfigurationResults.isEmpty() 						? "revisiting the conditions above or defining" : "defining"), 				getBeanDescription(cause)); 		return new FailureAnalysis(message.toString(), action, cause); 	}
@Override 		public String toString() { 			if (this.methodEvaluated) { 				return String.format("Bean method '%s' in '%s' not loaded because %s", 						this.methodMetadata.getMethodName(), 						ClassUtils.getShortName( 								this.methodMetadata.getDeclaringClassName()), 						this.conditionOutcome.getMessage()); 			} 			return String.format("Bean method '%s' not loaded because %s", 					this.methodMetadata.getMethodName(), 					this.conditionOutcome.getMessage()); 		}
private void assertActionMissingType(FailureAnalysis analysis, Class<?> type) { 		assertThat(analysis.getAction()).startsWith(String.format( 				"Consider revisiting the conditions above or defining a bean of type '%s' " 						+ "in your configuration.", 				type.getName())); 	}
private void assertActionMissingName(FailureAnalysis analysis, String name) { 		assertThat(analysis.getAction()).startsWith(String.format( 				"Consider revisiting the conditions above or defining a bean named '%s' " 						+ "in your configuration.", 				name)); 	}
@ConditionalOnProperty("spring.string.enabled") 		@Bean 		public String string() { 			return "Test"; 		}
@Bean 		public String string() { 			return "Test"; 		}
@ConditionalOnBean(Integer.class) 		@Bean(name = "test-string") 		public String string() { 			return "Test"; 		}
@Override 		public void setResourceLoader(ResourceLoader resourceLoader) { 			this.resourceLoader = resourceLoader; 		}
@Override 		public void configureMessageConverters(List<HttpMessageConverter<?>> converters) { 			converters.addAll(this.messageConverters.getConverters()); 		}
@Override 			public void setResourceLoader(ResourceLoader resourceLoader) { 				this.resourceLoader = resourceLoader; 			}
private Iterable<String> getBeanNames(ListableBeanFactory beanFactory) { 		Set<String> names = new HashSet<>(); 		names.addAll(Arrays.asList(BeanFactoryUtils.beanNamesForTypeIncludingAncestors( 				beanFactory, this.beanClass, true, false))); 		for (String factoryBeanName : BeanFactoryUtils.beanNamesForTypeIncludingAncestors( 				beanFactory, this.factoryBeanClass, true, false)) { 			names.add(BeanFactoryUtils.transformedBeanName(factoryBeanName)); 		} 		return names; 	}
@EventListener 		public void onClassPathChanged(ClassPathChangedEvent event) { 			if (!event.isRestartRequired()) { 				optionalLiveReloadServer().triggerReload(); 			} 		}
@EventListener 		public void onClassPathChanged(ClassPathChangedEvent event) { 			if (event.isRestartRequired()) { 				Restarter.getInstance().restart( 						new FileWatchingFailureHandler(fileSystemWatcherFactory())); 			} 		}
@PostConstruct 		public void validateMBeans() { 			MBeanExporter exporter = this.mBeanExporter.getIfUnique(); 			if (exporter != null && this.dataSource.isRegisterMbeans()) { 				exporter.addExcludedBean("dataSource"); 			} 		}
@Override 	public void beforeTestMethod(TestContext testContext) throws Exception { 		if (restDocsIsPresent()) { 			new DocumentationHandler().beforeTestMethod(testContext); 		} 	}
@Override 	public void afterTestMethod(TestContext testContext) throws Exception { 		if (restDocsIsPresent()) { 			new DocumentationHandler().afterTestMethod(testContext); 		} 	}
private void beforeTestMethod(TestContext testContext) throws Exception { 			ManualRestDocumentation restDocumentation = findManualRestDocumentation( 					testContext); 			if (restDocumentation != null) { 				restDocumentation.beforeTest(testContext.getTestClass(), 						testContext.getTestMethod().getName()); 			} 		}
private void afterTestMethod(TestContext testContext) { 			ManualRestDocumentation restDocumentation = findManualRestDocumentation( 					testContext); 			if (restDocumentation != null) { 				restDocumentation.afterTest(); 			} 		}
@EventListener 		public void onContextRefreshed(ContextRefreshedEvent event) { 			optionalLiveReloadServer().triggerReload(); 		}
@EventListener 		public void onClassPathChanged(ClassPathChangedEvent event) { 			if (!event.isRestartRequired()) { 				optionalLiveReloadServer().triggerReload(); 			} 		}
@EventListener 		public void onClassPathChanged(ClassPathChangedEvent event) { 			if (!event.isRestartRequired()) { 				optionalLiveReloadServer().triggerReload(); 			} 		}
@EventListener 		public void onClassPathChanged(ClassPathChangedEvent event) { 			if (event.isRestartRequired()) { 				Restarter.getInstance().restart( 						new FileWatchingFailureHandler(fileSystemWatcherFactory())); 			} 		}
@Bean 		public OptionalValidatorFactoryBean customValidator() { 			return new OptionalValidatorFactoryBean(); 		}
@Bean 		public OptionalValidatorFactoryBean customValidator() { 			return new OptionalValidatorFactoryBean(); 		}
@Bean 		public OptionalValidatorFactoryBean customValidator() { 			return new OptionalValidatorFactoryBean(); 		}
@Bean 		public OptionalValidatorFactoryBean customValidator() { 			return new OptionalValidatorFactoryBean(); 		}
@Bean 		public Validator customValidator() { 			return mock(Validator.class); 		}
@Bean 		public Validator customValidator() { 			return mock(Validator.class); 		}
@Bean 		public Validator customValidator() { 			return mock(Validator.class); 		}
@Bean 		public Validator customValidator() { 			return mock(Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public OptionalValidatorFactoryBean customValidator() { 			return new OptionalValidatorFactoryBean(); 		}
@Bean 		public OptionalValidatorFactoryBean customValidator() { 			return new OptionalValidatorFactoryBean(); 		}
@Bean 		public OptionalValidatorFactoryBean customValidator() { 			return new OptionalValidatorFactoryBean(); 		}
@Bean 		public OptionalValidatorFactoryBean customValidator() { 			return new OptionalValidatorFactoryBean(); 		}
@Bean 		public Validator customValidator() { 			return mock(Validator.class); 		}
@Bean 		public Validator customValidator() { 			return mock(Validator.class); 		}
@Bean 		public Validator customValidator() { 			return mock(Validator.class); 		}
@Bean 		public Validator customValidator() { 			return mock(Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public org.springframework.validation.Validator customValidator() { 			return mock(org.springframework.validation.Validator.class); 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			return new DefaultOAuth2ClientContext(new DefaultAccessTokenRequest()); 		}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Bean 			@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 			public DefaultOAuth2ClientContext oauth2ClientContext() { 				return new DefaultOAuth2ClientContext(this.accessTokenRequest); 			}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Bean 		@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES) 		public DefaultOAuth2ClientContext oauth2ClientContext() { 			DefaultOAuth2ClientContext context = new DefaultOAuth2ClientContext( 					new DefaultAccessTokenRequest()); 			Authentication principal = SecurityContextHolder.getContext() 					.getAuthentication(); 			if (principal instanceof OAuth2Authentication) { 				OAuth2Authentication authentication = (OAuth2Authentication) principal; 				Object details = authentication.getDetails(); 				if (details instanceof OAuth2AuthenticationDetails) { 					OAuth2AuthenticationDetails oauthsDetails = (OAuth2AuthenticationDetails) details; 					String token = oauthsDetails.getTokenValue(); 					context.setAccessToken(new DefaultOAuth2AccessToken(token)); 				} 			} 			return context; 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			ConditionMessage.Builder message = ConditionMessage 					.forCondition("PooledDataSource"); 			if (getDataSourceClassLoader(context) != null) { 				return ConditionOutcome 						.match(message.foundExactly("supported DataSource")); 			} 			return ConditionOutcome 					.noMatch(message.didNotFind("supported DataSource").atAll()); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			ConditionMessage.Builder message = ConditionMessage 					.forCondition("PooledDataSource"); 			if (getDataSourceClassLoader(context) != null) { 				return ConditionOutcome 						.match(message.foundExactly("supported DataSource")); 			} 			return ConditionOutcome 					.noMatch(message.didNotFind("supported DataSource").atAll()); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			ConditionMessage.Builder message = ConditionMessage 					.forCondition("EmbeddedDataSource"); 			if (anyMatches(context, metadata, this.pooledCondition)) { 				return ConditionOutcome 						.noMatch(message.foundExactly("supported pooled data source")); 			} 			EmbeddedDatabaseType type = EmbeddedDatabaseConnection 					.get(context.getClassLoader()).getType(); 			if (type == null) { 				return ConditionOutcome 						.noMatch(message.didNotFind("embedded database").atAll()); 			} 			return ConditionOutcome.match(message.found("embedded database").items(type)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			ConditionMessage.Builder message = ConditionMessage 					.forCondition("EmbeddedDataSource"); 			if (anyMatches(context, metadata, this.pooledCondition)) { 				return ConditionOutcome 						.noMatch(message.foundExactly("supported pooled data source")); 			} 			EmbeddedDatabaseType type = EmbeddedDatabaseConnection 					.get(context.getClassLoader()).getType(); 			if (type == null) { 				return ConditionOutcome 						.noMatch(message.didNotFind("embedded database").atAll()); 			} 			return ConditionOutcome.match(message.found("embedded database").items(type)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			ConditionMessage.Builder message = ConditionMessage 					.forCondition("DataSourceAvailable"); 			if (hasBean(context, DataSource.class) 					|| hasBean(context, XADataSource.class)) { 				return ConditionOutcome 						.match(message.foundExactly("existing data source bean")); 			} 			if (anyMatches(context, metadata, this.pooledCondition, 					this.embeddedCondition)) { 				return ConditionOutcome.match(message 						.foundExactly("existing auto-configured data source bean")); 			} 			return ConditionOutcome 					.noMatch(message.didNotFind("any existing data source bean").atAll()); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			ConditionMessage.Builder message = ConditionMessage 					.forCondition("DataSourceAvailable"); 			if (hasBean(context, DataSource.class) 					|| hasBean(context, XADataSource.class)) { 				return ConditionOutcome 						.match(message.foundExactly("existing data source bean")); 			} 			if (anyMatches(context, metadata, this.pooledCondition, 					this.embeddedCondition)) { 				return ConditionOutcome.match(message 						.foundExactly("existing auto-configured data source bean")); 			} 			return ConditionOutcome 					.noMatch(message.didNotFind("any existing data source bean").atAll()); 		}
@Bean 	@ConditionalOnMissingBean 	public EndpointHandlerMapping endpointHandlerMapping() { 		Set<MvcEndpoint> endpoints = mvcEndpoints().getEndpoints(); 		CorsConfiguration corsConfiguration = getCorsConfiguration(this.corsProperties); 		EndpointHandlerMapping mapping = new EndpointHandlerMapping(endpoints, 				corsConfiguration); 		mapping.setPrefix(this.managementServerProperties.getContextPath()); 		if (this.mappingCustomizers != null) { 			for (EndpointHandlerMappingCustomizer customizer : this.mappingCustomizers) { 				customizer.customize(mapping); 			} 		} 		return mapping; 	}
@Bean 	@ConditionalOnBean(DispatcherServlet.class) 	@ConditionalOnMissingBean 	public DefaultErrorViewResolver conventionErrorViewResolver() { 		return new DefaultErrorViewResolver(this.applicationContext, 				this.resourceProperties); 	}
private Map<String, Expression> getExpressions() { 			if (this.expressions == null) { 				synchronized (this) { 					ExpressionCollector expressionCollector = new ExpressionCollector(); 					this.helper.replacePlaceholders(this.template, expressionCollector); 					this.expressions = expressionCollector.getExpressions(); 				} 			} 			return this.expressions; 		}
public Map<String, Expression> getExpressions() { 			return Collections.unmodifiableMap(this.expressions); 		}
private void parseMockBeanAnnotation(MockBean annotation, AnnotatedElement element) { 		Set<ResolvableType> typesToMock = getOrDeduceTypes(element, annotation.value()); 		Assert.state(!typesToMock.isEmpty(), 				"Unable to deduce type to mock from " + element); 		if (StringUtils.hasLength(annotation.name())) { 			Assert.state(typesToMock.size() == 1, 					"The name attribute can only be used when mocking a single class"); 		} 		for (ResolvableType typeToMock : typesToMock) { 			MockDefinition definition = new MockDefinition(annotation.name(), typeToMock, 					annotation.extraInterfaces(), annotation.answer(), 					annotation.serializable(), annotation.reset()); 			addDefinition(element, definition, "mock"); 		} 	}
private void parseSpyBeanAnnotation(SpyBean annotation, AnnotatedElement element) { 		Set<ResolvableType> typesToSpy = getOrDeduceTypes(element, annotation.value()); 		Assert.state(!typesToSpy.isEmpty(), 				"Unable to deduce type to spy from " + element); 		if (StringUtils.hasLength(annotation.name())) { 			Assert.state(typesToSpy.size() == 1, 					"The name attribute can only be used when spying a single class"); 		} 		for (ResolvableType typeToSpy : typesToSpy) { 			SpyDefinition definition = new SpyDefinition(annotation.name(), typeToSpy, 					annotation.reset(), annotation.proxyTargetAware()); 			addDefinition(element, definition, "spy"); 		} 	}
private RootBeanDefinition createBeanDefinition(MockDefinition mockDefinition) { 		RootBeanDefinition definition = new RootBeanDefinition( 				mockDefinition.getTypeToMock().resolve()); 		definition.setTargetType(mockDefinition.getTypeToMock()); 		definition.setFactoryBeanName(BEAN_NAME); 		definition.setFactoryMethodName("createMock"); 		definition.getConstructorArgumentValues().addIndexedArgumentValue(0, 				mockDefinition); 		return definition; 	}
private String getBeanName(ConfigurableListableBeanFactory beanFactory, 			BeanDefinitionRegistry registry, MockDefinition mockDefinition, 			RootBeanDefinition beanDefinition) { 		if (StringUtils.hasLength(mockDefinition.getName())) { 			return mockDefinition.getName(); 		} 		String[] existingBeans = getExistingBeans(beanFactory, 				mockDefinition.getTypeToMock()); 		if (ObjectUtils.isEmpty(existingBeans)) { 			return this.beanNameGenerator.generateBeanName(beanDefinition, registry); 		} 		if (existingBeans.length == 1) { 			return existingBeans[0]; 		} 		throw new IllegalStateException( 				"Unable to register mock bean " + mockDefinition.getTypeToMock() 						+ " expected a single existing bean to replace but found " 						+ new TreeSet<String>(Arrays.asList(existingBeans))); 	}
protected Object createSpyIfNecessary(Object bean, String beanName) 			throws BeansException { 		SpyDefinition definition = this.spies.get(beanName); 		if (definition != null) { 			bean = definition.createSpy(beanName, bean); 		} 		return bean; 	}
@Override 	public int getOrder() { 		return Ordered.LOWEST_PRECEDENCE - 10; 	}
public static void register(BeanDefinitionRegistry registry) { 		register(registry, null); 	}
@Override 		public int getOrder() { 			return Ordered.HIGHEST_PRECEDENCE; 		}
private Object createSpyIfNecessary(Object bean, String beanName) { 			return this.mockitoPostProcessor.createSpyIfNecessary(bean, beanName); 		}
public static void register(BeanDefinitionRegistry registry) { 			if (!registry.containsBeanDefinition(BEAN_NAME)) { 				RootBeanDefinition definition = new RootBeanDefinition( 						SpyPostProcessor.class); 				definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); 				ConstructorArgumentValues constructorArguments = definition 						.getConstructorArgumentValues(); 				constructorArguments.addIndexedArgumentValue(0, 						new RuntimeBeanReference(MockitoPostProcessor.BEAN_NAME)); 				registry.registerBeanDefinition(BEAN_NAME, definition); 			} 		}
@Test 	public void parseMockBeanAttributes() throws Exception { 		this.parser.parse(MockBeanAttributes.class); 		assertThat(getDefinitions()).hasSize(1); 		MockDefinition definition = getMockDefinition(0); 		assertThat(definition.getName()).isEqualTo("Name"); 		assertThat(definition.getTypeToMock().resolve()).isEqualTo(ExampleService.class); 		assertThat(definition.getExtraInterfaces()) 				.containsExactly(ExampleExtraInterface.class); 		assertThat(definition.getAnswer()).isEqualTo(Answers.RETURNS_SMART_NULLS); 		assertThat(definition.isSerializable()).isEqualTo(true); 		assertThat(definition.getReset()).isEqualTo(MockReset.NONE); 	}
@Test 	public void parseMockBeanOnClassAndField() throws Exception { 		this.parser.parse(MockBeanOnClassAndField.class); 		assertThat(getDefinitions()).hasSize(2); 		assertThat(getMockDefinition(0).getTypeToMock().resolve()) 				.isEqualTo(ExampleService.class); 		assertThat(getMockDefinition(1).getTypeToMock().resolve()) 				.isEqualTo(ExampleServiceCaller.class); 	}
@Test 	public void parseSpyBeanAttributes() throws Exception { 		this.parser.parse(SpyBeanAttributes.class); 		assertThat(getDefinitions()).hasSize(1); 		SpyDefinition definition = getSpyDefinition(0); 		assertThat(definition.getName()).isEqualTo("Name"); 		assertThat(definition.getTypeToSpy().resolve()) 				.isEqualTo(RealExampleService.class); 		assertThat(definition.getReset()).isEqualTo(MockReset.NONE); 	}
@Test 	public void parseSpyBeanOnClassAndField() throws Exception { 		this.parser.parse(SpyBeanOnClassAndField.class); 		assertThat(getDefinitions()).hasSize(2); 		assertThat(getSpyDefinition(0).getTypeToSpy().resolve()) 				.isEqualTo(RealExampleService.class); 		assertThat(getSpyDefinition(1).getTypeToSpy().resolve()) 				.isEqualTo(ExampleServiceCaller.class); 	}
@Test 	public void classToMockMustNotBeNull() throws Exception { 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("TypeToMock must not be null"); 		new MockDefinition(null, null, null, null, false, null); 	}
@Test 	public void createWithDefaults() throws Exception { 		MockDefinition definition = new MockDefinition(null, EXAMPLE_SERVICE_TYPE, null, 				null, false, null); 		assertThat(definition.getName()).isNull(); 		assertThat(definition.getTypeToMock()).isEqualTo(EXAMPLE_SERVICE_TYPE); 		assertThat(definition.getExtraInterfaces()).isEmpty(); 		assertThat(definition.getAnswer()).isEqualTo(Answers.RETURNS_DEFAULTS); 		assertThat(definition.isSerializable()).isFalse(); 		assertThat(definition.getReset()).isEqualTo(MockReset.AFTER); 	}
@Test 	public void createExplicit() throws Exception { 		MockDefinition definition = new MockDefinition("name", EXAMPLE_SERVICE_TYPE, 				new Class<?>[] { ExampleExtraInterface.class }, 				Answers.RETURNS_SMART_NULLS, true, MockReset.BEFORE); 		assertThat(definition.getName()).isEqualTo("name"); 		assertThat(definition.getTypeToMock()).isEqualTo(EXAMPLE_SERVICE_TYPE); 		assertThat(definition.getExtraInterfaces()) 				.containsExactly(ExampleExtraInterface.class); 		assertThat(definition.getAnswer()).isEqualTo(Answers.RETURNS_SMART_NULLS); 		assertThat(definition.isSerializable()).isTrue(); 		assertThat(definition.getReset()).isEqualTo(MockReset.BEFORE); 		assertThat(definition.isProxyTargetAware()).isFalse(); 	}
@Test 	public void createMock() throws Exception { 		MockDefinition definition = new MockDefinition("name", EXAMPLE_SERVICE_TYPE, 				new Class<?>[] { ExampleExtraInterface.class }, 				Answers.RETURNS_SMART_NULLS, true, MockReset.BEFORE); 		ExampleService mock = definition.createMock(); 		MockCreationSettings<?> settings = new MockUtil().getMockSettings(mock); 		assertThat(mock).isInstanceOf(ExampleService.class); 		assertThat(mock).isInstanceOf(ExampleExtraInterface.class); 		assertThat(settings.getMockName().toString()).isEqualTo("name"); 		assertThat(settings.getDefaultAnswer()) 				.isEqualTo(Answers.RETURNS_SMART_NULLS.get()); 		assertThat(settings.isSerializable()).isTrue(); 		assertThat(MockReset.get(mock)).isEqualTo(MockReset.BEFORE); 	}
@Test 	public void hashCodeAndEquals() { 		MockDefinition d1 = new MockDefinition(ExampleService.class); 		MockDefinition d2 = new MockDefinition(ExampleServiceCaller.class); 		MockitoContextCustomizer c1 = new MockitoContextCustomizer(NO_DEFINITIONS); 		MockitoContextCustomizer c2 = new MockitoContextCustomizer( 				new LinkedHashSet<MockDefinition>(Arrays.asList(d1, d2))); 		MockitoContextCustomizer c3 = new MockitoContextCustomizer( 				new LinkedHashSet<MockDefinition>(Arrays.asList(d2, d1))); 		assertThat(c2.hashCode()).isEqualTo(c3.hashCode()); 		assertThat(c1).isEqualTo(c1).isNotEqualTo(c2); 		assertThat(c2).isEqualTo(c2).isEqualTo(c3).isNotEqualTo(c1); 	}
@Test 	public void cannotMockMultipleBeans() { 		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); 		MockitoPostProcessor.register(context); 		context.register(MultipleBeans.class); 		this.thrown.expect(IllegalStateException.class); 		this.thrown.expectMessage( 				"Unable to register mock bean " + ExampleService.class.getName() 						+ " expected a single existing bean to replace " 						+ "but found [example1, example2]"); 		context.refresh(); 	}
@Test 	public void classToSpyMustNotBeNull() throws Exception { 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("TypeToSpy must not be null"); 		new SpyDefinition(null, null, null, true); 	}
@Test 	public void createWithDefaults() throws Exception { 		SpyDefinition definition = new SpyDefinition(null, REAL_SERVICE_TYPE, null, true); 		assertThat(definition.getName()).isNull(); 		assertThat(definition.getTypeToSpy()).isEqualTo(REAL_SERVICE_TYPE); 		assertThat(definition.getReset()).isEqualTo(MockReset.AFTER); 		assertThat(definition.isProxyTargetAware()).isTrue(); 	}
@Test 	public void createExplicit() throws Exception { 		SpyDefinition definition = new SpyDefinition("name", REAL_SERVICE_TYPE, 				MockReset.BEFORE, false); 		assertThat(definition.getName()).isEqualTo("name"); 		assertThat(definition.getTypeToSpy()).isEqualTo(REAL_SERVICE_TYPE); 		assertThat(definition.getReset()).isEqualTo(MockReset.BEFORE); 		assertThat(definition.isProxyTargetAware()).isFalse(); 	}
@Test 	public void createSpy() throws Exception { 		SpyDefinition definition = new SpyDefinition("name", REAL_SERVICE_TYPE, 				MockReset.BEFORE, true); 		RealExampleService spy = definition.createSpy(new RealExampleService("hello")); 		MockCreationSettings<?> settings = new MockUtil().getMockSettings(spy); 		assertThat(spy).isInstanceOf(ExampleService.class); 		assertThat(settings.getMockName().toString()).isEqualTo("name"); 		assertThat(settings.getDefaultAnswer()) 				.isEqualTo(Answers.CALLS_REAL_METHODS.get()); 		assertThat(MockReset.get(spy)).isEqualTo(MockReset.BEFORE); 	}
@Test 	public void createSpyWhenNullInstanceShouldThrowException() throws Exception { 		SpyDefinition definition = new SpyDefinition("name", REAL_SERVICE_TYPE, 				MockReset.BEFORE, true); 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("Instance must not be null"); 		definition.createSpy(null); 	}
@Test 	public void createSpyWhenWrongInstanceShouldThrowException() throws Exception { 		SpyDefinition definition = new SpyDefinition("name", REAL_SERVICE_TYPE, 				MockReset.BEFORE, true); 		this.thrown.expect(IllegalArgumentException.class); 		this.thrown.expectMessage("must be an instance of"); 		definition.createSpy(new ExampleServiceCaller(null)); 	}
@Test 	public void createSpyTwice() throws Exception { 		SpyDefinition definition = new SpyDefinition("name", REAL_SERVICE_TYPE, 				MockReset.BEFORE, true); 		Object instance = new RealExampleService("hello"); 		instance = definition.createSpy(instance); 		instance = definition.createSpy(instance); 	}
private void parseMockBeanAnnotation(MockBean annotation, AnnotatedElement element) { 		Set<ResolvableType> typesToMock = getOrDeduceTypes(element, annotation.value()); 		Assert.state(!typesToMock.isEmpty(), 				"Unable to deduce type to mock from " + element); 		if (StringUtils.hasLength(annotation.name())) { 			Assert.state(typesToMock.size() == 1, 					"The name attribute can only be used when mocking a single class"); 		} 		for (ResolvableType typeToMock : typesToMock) { 			MockDefinition definition = new MockDefinition(annotation.name(), typeToMock, 					annotation.extraInterfaces(), annotation.answer(), 					annotation.serializable(), annotation.reset(), 					annotation.proxyTargetAware()); 			addDefinition(element, definition, "mock"); 		} 	}
private void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory, 			BeanDefinitionRegistry registry) { 		DefinitionsParser parser = new DefinitionsParser(this.definitions); 		for (Class<?> configurationClass : getConfigurationClasses(beanFactory)) { 			parser.parse(configurationClass); 		} 		Set<Definition> definitions = parser.getDefinitions(); 		for (Definition definition : definitions) { 			Field field = parser.getField(definition); 			register(beanFactory, registry, definition, field); 		} 	}
private void registerMock(ConfigurableListableBeanFactory beanFactory, 			BeanDefinitionRegistry registry, MockDefinition definition, Field field) { 		RootBeanDefinition beanDefinition = createBeanDefinition(definition); 		String beanName = getBeanName(beanFactory, registry, definition, beanDefinition); 		beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(1, 				beanName); 		registry.registerBeanDefinition(beanName, beanDefinition); 		this.beanNameRegistry.put(definition, beanName); 		if (field != null) { 			this.fieldRegistry.put(field, new RegisteredField(definition, beanName)); 		} 	}
protected Object createSpyIfNecessary(Object bean, String beanName) 			throws BeansException { 		SpyDefinition definition = this.spies.get(beanName); 		if (definition != null) { 			bean = definition.createSpy(beanName, bean); 		} 		return bean; 	}
@Override 	public int getOrder() { 		return Ordered.LOWEST_PRECEDENCE - 10; 	}
public static void register(BeanDefinitionRegistry registry) { 		register(registry, null); 	}
@Override 		public int getOrder() { 			return Ordered.HIGHEST_PRECEDENCE; 		}
private Object createSpyIfNecessary(Object bean, String beanName) { 			return this.mockitoPostProcessor.createSpyIfNecessary(bean, beanName); 		}
public static void register(BeanDefinitionRegistry registry) { 			if (!registry.containsBeanDefinition(BEAN_NAME)) { 				RootBeanDefinition definition = new RootBeanDefinition( 						SpyPostProcessor.class); 				definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); 				ConstructorArgumentValues constructorArguments = definition 						.getConstructorArgumentValues(); 				constructorArguments.addIndexedArgumentValue(0, 						new RuntimeBeanReference(MockitoPostProcessor.BEAN_NAME)); 				registry.registerBeanDefinition(BEAN_NAME, definition); 			} 		}
private void resetMocks(ConfigurableApplicationContext applicationContext, 			MockReset reset) { 		ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory(); 		String[] names = beanFactory.getBeanDefinitionNames(); 		Set<String> instantiatedSingletons = new HashSet<String>( 				Arrays.asList(beanFactory.getSingletonNames())); 		for (String name : names) { 			BeanDefinition definition = beanFactory.getBeanDefinition(name); 			if (definition.isSingleton() && instantiatedSingletons.contains(name)) { 				Object bean = beanFactory.getBean(name); 				if (reset.equals(MockReset.get(bean))) { 					Mockito.reset(bean); 				} 			} 		} 		if (applicationContext.getParent() != null) { 			resetMocks(applicationContext.getParent(), reset); 		} 	}
@Test 	public void verifyShouldUseProxyTarget() throws Exception { 		Long d1 = this.dateService.getDate(); 		Thread.sleep(200); 		Long d2 = this.dateService.getDate(); 		assertThat(d1).isEqualTo(d2); 		verify(this.dateService, times(1)).getDate(); 	}
@Test 	public void createWithDefaults() throws Exception { 		MockDefinition definition = new MockDefinition(null, EXAMPLE_SERVICE_TYPE, null, 				null, false, null, true); 		assertThat(definition.getName()).isNull(); 		assertThat(definition.getTypeToMock()).isEqualTo(EXAMPLE_SERVICE_TYPE); 		assertThat(definition.getExtraInterfaces()).isEmpty(); 		assertThat(definition.getAnswer()).isEqualTo(Answers.RETURNS_DEFAULTS); 		assertThat(definition.isSerializable()).isFalse(); 		assertThat(definition.getReset()).isEqualTo(MockReset.AFTER); 	}
@Test 	public void createExplicit() throws Exception { 		MockDefinition definition = new MockDefinition("name", EXAMPLE_SERVICE_TYPE, 				new Class<?>[] { ExampleExtraInterface.class }, 				Answers.RETURNS_SMART_NULLS, true, MockReset.BEFORE, false); 		assertThat(definition.getName()).isEqualTo("name"); 		assertThat(definition.getTypeToMock()).isEqualTo(EXAMPLE_SERVICE_TYPE); 		assertThat(definition.getExtraInterfaces()) 				.containsExactly(ExampleExtraInterface.class); 		assertThat(definition.getAnswer()).isEqualTo(Answers.RETURNS_SMART_NULLS); 		assertThat(definition.isSerializable()).isTrue(); 		assertThat(definition.getReset()).isEqualTo(MockReset.BEFORE); 		assertThat(definition.isProxyTargetAware()).isFalse(); 	}
@Test 	public void createMock() throws Exception { 		MockDefinition definition = new MockDefinition("name", EXAMPLE_SERVICE_TYPE, 				new Class<?>[] { ExampleExtraInterface.class }, 				Answers.RETURNS_SMART_NULLS, true, MockReset.BEFORE, true); 		ExampleService mock = definition.createMock(); 		MockCreationSettings<?> settings = new MockUtil().getMockSettings(mock); 		assertThat(mock).isInstanceOf(ExampleService.class); 		assertThat(mock).isInstanceOf(ExampleExtraInterface.class); 		assertThat(settings.getMockName().toString()).isEqualTo("name"); 		assertThat(settings.getDefaultAnswer()) 				.isEqualTo(Answers.RETURNS_SMART_NULLS.get()); 		assertThat(settings.isSerializable()).isTrue(); 		assertThat(MockReset.get(mock)).isEqualTo(MockReset.BEFORE); 	}
public JsonContent<T> write(T value) throws IOException { 		Assert.notNull(value, "Value must not be null"); 		String json = writeObject(value, this.type); 		return new JsonContent<T>(this.resourceLoadClass, this.type, json); 	}
public T parseObject(byte[] jsonBytes) throws IOException { 		return parse(jsonBytes).getObject(); 	}
public ObjectContent<T> parse(byte[] jsonBytes) throws IOException { 		Assert.notNull(jsonBytes, "JsonBytes must not be null"); 		return read(new ByteArrayResource(jsonBytes)); 	}
public T parseObject(String jsonString) throws IOException { 		return parse(jsonString).getObject(); 	}
public ObjectContent<T> parse(String jsonString) throws IOException { 		Assert.notNull(jsonString, "JsonString must not be null"); 		return read(new StringReader(jsonString)); 	}
public T readObject(String resourcePath) throws IOException { 		return read(resourcePath).getObject(); 	}
public ObjectContent<T> read(String resourcePath) throws IOException { 		Assert.notNull(resourcePath, "ResourcePath must not be null"); 		return read(new ClassPathResource(resourcePath, this.resourceLoadClass)); 	}
public T readObject(File file) throws IOException { 		return read(file).getObject(); 	}
public ObjectContent<T> read(File file) throws IOException { 		Assert.notNull(file, "File must not be null"); 		return read(new FileSystemResource(file)); 	}
public T readObject(InputStream inputStream) throws IOException { 		return read(inputStream).getObject(); 	}
public ObjectContent<T> read(InputStream inputStream) throws IOException { 		Assert.notNull(inputStream, "InputStream must not be null"); 		return read(new InputStreamResource(inputStream)); 	}
public T readObject(Resource resource) throws IOException { 		return read(resource).getObject(); 	}
public ObjectContent<T> read(Resource resource) throws IOException { 		Assert.notNull(resource, "Resource must not be null"); 		InputStream inputStream = resource.getInputStream(); 		T object = readObject(inputStream, this.type); 		closeQuietly(inputStream); 		return new ObjectContent<T>(this.type, object); 	}
public T readObject(Reader reader) throws IOException { 		return read(reader).getObject(); 	}
public ObjectContent<T> read(Reader reader) throws IOException { 		Assert.notNull(reader, "Reader must not be null"); 		T object = readObject(reader, this.type); 		closeQuietly(reader); 		return new ObjectContent<T>(this.type, object); 	}
public JsonContent<Object> from(CharSequence source) { 		return getJsonContent(this.loader.getJson(source)); 	}
public JsonContent<Object> from(String path, Class<?> resourceLoadClass) { 		return getJsonContent(this.loader.getJson(path, resourceLoadClass)); 	}
public JsonContent<Object> from(byte[] source) { 		return getJsonContent(this.loader.getJson(source)); 	}
public JsonContent<Object> from(File source) { 		return getJsonContent(this.loader.getJson(source)); 	}
public JsonContent<Object> from(InputStream source) { 		return getJsonContent(this.loader.getJson(source)); 	}
public JsonContent<Object> from(Resource source) { 		return getJsonContent(this.loader.getJson(source)); 	}
@Bean 		@Primary 		@ConditionalOnMissingBean(ObjectMapper.class) 		public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { 			customize(builder); 			return builder.createXmlMapper(false).build(); 		}
private void customize(Jackson2ObjectMapperBuilder builder) { 			if (this.builderCustomizers != null) { 				AnnotationAwareOrderComparator.sort(this.builderCustomizers); 				for (Jackson2ObjectMapperBuilderCustomizer customizer : this.builderCustomizers) { 					customizer.customize(builder); 				} 			} 		}
private void configureDateFormat(Jackson2ObjectMapperBuilder builder) { 			// We support a fully qualified class name extending DateFormat or a date 			// pattern string value 			String dateFormat = this.jacksonProperties.getDateFormat(); 			if (dateFormat != null) { 				try { 					Class<?> dateFormatClass = ClassUtils.forName(dateFormat, null); 					builder.dateFormat( 							(DateFormat) BeanUtils.instantiateClass(dateFormatClass)); 				} 				catch (ClassNotFoundException ex) { 					SimpleDateFormat simpleDateFormat = new SimpleDateFormat(dateFormat); 					// Since Jackson 2.6.3 we always need to set a TimeZone (see gh-4170) 					// If none in our properties fallback to the Jackson's default 					TimeZone timeZone = this.jacksonProperties.getTimeZone(); 					if (timeZone == null) { 						timeZone = new ObjectMapper().getSerializationConfig() 								.getTimeZone(); 					} 					simpleDateFormat.setTimeZone(timeZone); 					builder.dateFormat(simpleDateFormat); 				} 			} 		}
private void configureModules(Jackson2ObjectMapperBuilder builder) { 			Collection<Module> moduleBeans = getBeans(this.applicationContext, 					Module.class); 			builder.modulesToInstall(moduleBeans.toArray(new Module[moduleBeans.size()])); 		}
private void configureLocale(Jackson2ObjectMapperBuilder builder) { 			Locale locale = this.jacksonProperties.getLocale(); 			if (locale != null) { 				builder.locale(locale); 			} 		}
@Test 	public void customDateFormat() throws Exception { 		this.context.register(JacksonAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.jackson.date-format:yyyyMMddHHmmss"); 		this.context.refresh(); 		ObjectMapper mapper = this.context.getBean(ObjectMapper.class); 		DateFormat dateFormat = mapper.getDateFormat(); 		assertThat(dateFormat).isInstanceOf(SimpleDateFormat.class); 		assertThat(((SimpleDateFormat) dateFormat).toPattern()) 				.isEqualTo("yyyyMMddHHmmss"); 	}
@Bean 		@Primary 		public ObjectMapper objectMapper() { 			return mock(ObjectMapper.class); 		}
@Bean 		public CustomModule jacksonModule() { 			return new CustomModule(); 		}
@Bean 		public Module jacksonModule() { 			SimpleModule module = new SimpleModule(); 			module.addSerializer(Foo.class, new JsonSerializer<Foo>() {  				@Override 				public void serialize(Foo value, JsonGenerator jgen, 						SerializerProvider provider) 								throws IOException, JsonProcessingException { 					jgen.writeStartObject(); 					jgen.writeStringField("foo", "bar"); 					jgen.writeEndObject(); 				} 			}); 			return module; 		}
@Bean 		@Primary 		public ObjectMapper objectMapper() { 			ObjectMapper mapper = new ObjectMapper(); 			mapper.registerModule(jacksonModule()); 			return mapper; 		}
@Bean 		public Jackson2ObjectMapperBuilderCustomizer customDateFormat() { 			return new Jackson2ObjectMapperBuilderCustomizer() { 				@Override 				public void customize(Jackson2ObjectMapperBuilder jackson2ObjectMapperBuilder) { 					jackson2ObjectMapperBuilder.dateFormat(new MyDateFormat()); 				} 			}; 		}
@Bean 		public Jackson2ObjectMapperBuilderCustomizer customDateFormat() { 			return new Jackson2ObjectMapperBuilderCustomizer() { 				@Override 				public void customize(Jackson2ObjectMapperBuilder jackson2ObjectMapperBuilder) { 					jackson2ObjectMapperBuilder.dateFormat(new MyDateFormat()); 				} 			}; 		}
@Override 	protected Map<String, Object> getVendorProperties() { 		Map<String, Object> vendorProperties = new LinkedHashMap<String, Object>(); 		vendorProperties.putAll(this.properties.getHibernateProperties(this.dataSource)); 		return vendorProperties; 	}
@Bean 	@ConditionalOnMissingBean 	public JpaVendorAdapter jpaVendorAdapter() { 		AbstractJpaVendorAdapter adapter = createJpaVendorAdapter(); 		adapter.setShowSql(this.jpaProperties.isShowSql()); 		adapter.setDatabase(this.jpaProperties.getDatabase()); 		adapter.setDatabasePlatform(this.jpaProperties.getDatabasePlatform()); 		adapter.setGenerateDdl(this.jpaProperties.isGenerateDdl()); 		return adapter; 	}
@Bean 	@ConditionalOnProperty(prefix = "shell", name = "auth", havingValue = "jaas") 	@ConditionalOnMissingBean(CrshShellAuthenticationProperties.class) 	public JaasAuthenticationProperties jaasAuthenticationProperties() { 		return new JaasAuthenticationProperties(); 	}
@Bean 	@ConditionalOnProperty(prefix = "shell", name = "auth", havingValue = "key") 	@ConditionalOnMissingBean(CrshShellAuthenticationProperties.class) 	public KeyAuthenticationProperties keyAuthenticationProperties() { 		return new KeyAuthenticationProperties(); 	}
@Bean 	@ConditionalOnProperty(prefix = "shell", name = "auth", havingValue = "simple", matchIfMissing = true) 	@ConditionalOnMissingBean(CrshShellAuthenticationProperties.class) 	public SimpleAuthenticationProperties simpleAuthenticationProperties() { 		return new SimpleAuthenticationProperties(); 	}
@PostConstruct 		public void init() { 			FS commandFileSystem = createFileSystem( 					this.properties.getCommandPathPatterns(), 					this.properties.getDisabledCommands()); 			FS configurationFileSystem = createFileSystem( 					this.properties.getConfigPathPatterns(), new String[0]);  			PluginDiscovery discovery = new BeanFactoryFilteringPluginDiscovery( 					this.resourceLoader.getClassLoader(), this.beanFactory, 					this.properties.getDisabledPlugins());  			PluginContext context = new PluginContext(discovery, 					createPluginContextAttributes(), commandFileSystem, 					configurationFileSystem, this.resourceLoader.getClassLoader());  			context.refresh(); 			start(context); 		}
@Override 		public String getName() { 			return "spring"; 		}
@Override 		public void init() { 			String rolesPropertyValue = getContext().getProperty(ROLES); 			if (rolesPropertyValue != null) { 				this.roles = StringUtils 						.commaDelimitedListToStringArray(rolesPropertyValue); 			} 		}
public String getName() { 			return this.name; 		}
@Bean 	@ConditionalOnMissingBean 	public HealthEndpoint healthEndpoint() { 		return new HealthEndpoint(this.healthAggregator, this.healthIndicators); 	}
@Bean 	@ConditionalOnMissingBean 	public InfoEndpoint infoEndpoint() throws Exception { 		return new InfoEndpoint(this.infoContributors); 	}
@Bean 	@ConditionalOnMissingBean 	public TraceEndpoint traceEndpoint() { 		return new TraceEndpoint(this.traceRepository); 	}
private RequestMatcher getRequestMatcher() { 			if (this.management.getSecurity().isEnabled()) { 				return null; 			} 			return LazyEndpointPathRequestMatcher.getRequestMatcher(this.contextResolver); 		}
private RequestMatcher getRequestMatcher() { 			if (this.management.getSecurity().isEnabled()) { 				return LazyEndpointPathRequestMatcher 						.getRequestMatcher(this.contextResolver); 			} 			return null; 		}
@Override 			protected boolean isIncluded(MvcEndpoint endpoint) { 				return !endpoint.isSensitive(); 			}
protected boolean isIncluded(MvcEndpoint endpoint) { 			return true; 		}
@Bean 	@ConditionalOnMissingBean(name = "metricWritersMetricExporter") 	public SchedulingConfigurer metricWritersMetricExporter() { 		Map<String, GaugeWriter> writers = new HashMap<String, GaugeWriter>(); 		MetricReader reader = this.endpointReader; 		if (reader == null && !CollectionUtils.isEmpty(this.readers)) { 			reader = new CompositeMetricReader( 					this.readers.toArray(new MetricReader[this.readers.size()])); 		} 		if (reader == null && this.exporters.isEmpty()) { 			return new NoOpSchedulingConfigurer(); 		} 		MetricExporters exporters = new MetricExporters(this.properties); 		if (reader != null) { 			writers.putAll(this.writers); 			exporters.setReader(reader); 			exporters.setWriters(writers); 		} 		exporters.setExporters(this.exporters); 		return exporters; 	}
@Bean 	public MetricReaderPublicMetrics metricReaderPublicMetrics() { 		return new MetricReaderPublicMetrics(new CompositeMetricReader( 				this.metricReaders.toArray(new MetricReader[0]))); 	}
@Bean 		@ConditionalOnMissingBean 		public HttpMessageConverters messageConverters() { 			return new HttpMessageConverters(this.converters); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			if (getDataSourceClassLoader(context) != null) { 				return ConditionOutcome.match("supported DataSource class found"); 			} 			return ConditionOutcome.noMatch("missing supported DataSource"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			if (getDataSourceClassLoader(context) != null) { 				return ConditionOutcome.match("supported DataSource class found"); 			} 			return ConditionOutcome.noMatch("missing supported DataSource"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			if (anyMatches(context, metadata, this.pooledCondition)) { 				return ConditionOutcome.noMatch("supported DataSource class found"); 			} 			EmbeddedDatabaseType type = EmbeddedDatabaseConnection 					.get(context.getClassLoader()).getType(); 			if (type == null) { 				return ConditionOutcome.noMatch("no embedded database detected"); 			} 			return ConditionOutcome.match("embedded database " + type + " detected"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			if (anyMatches(context, metadata, this.pooledCondition)) { 				return ConditionOutcome.noMatch("supported DataSource class found"); 			} 			EmbeddedDatabaseType type = EmbeddedDatabaseConnection 					.get(context.getClassLoader()).getType(); 			if (type == null) { 				return ConditionOutcome.noMatch("no embedded database detected"); 			} 			return ConditionOutcome.match("embedded database " + type + " detected"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			if (hasBean(context, DataSource.class) 					|| hasBean(context, XADataSource.class)) { 				return ConditionOutcome 						.match("existing bean configured database detected"); 			} 			if (anyMatches(context, metadata, this.pooledCondition, 					this.embeddedCondition)) { 				return ConditionOutcome.match("existing auto database detected"); 			} 			return ConditionOutcome.noMatch("no existing bean configured database"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			if (hasBean(context, DataSource.class) 					|| hasBean(context, XADataSource.class)) { 				return ConditionOutcome 						.match("existing bean configured database detected"); 			} 			if (anyMatches(context, metadata, this.pooledCondition, 					this.embeddedCondition)) { 				return ConditionOutcome.match("existing auto database detected"); 			} 			return ConditionOutcome.noMatch("no existing bean configured database"); 		}
@Bean 	@ConditionalOnMissingBean(PlatformTransactionManager.class) 	@ConditionalOnBean(DataSource.class) 	public DataSourceTransactionManager transactionManager() { 		return new DataSourceTransactionManager(this.dataSource); 	}
@Bean 	@ConditionalOnMissingBean 	@ConditionalOnClass(Logger.class) 	public IRuntimeConfig embeddedMongoRuntimeConfig() { 		Logger logger = LoggerFactory 				.getLogger(getClass().getPackage().getName() + ".EmbeddedMongo"); 		ProcessOutput processOutput = new ProcessOutput( 				Processors.logTo(logger, Slf4jLevel.INFO), 				Processors.logTo(logger, Slf4jLevel.ERROR), Processors.named("[console>]", 						Processors.logTo(logger, Slf4jLevel.DEBUG))); 		return new RuntimeConfigBuilder().defaultsWithLogger(Command.MongoD, logger) 				.processOutput(processOutput).artifactStore(getArtifactStore(logger)) 				.build(); 	}
private ArtifactStoreBuilder getArtifactStore(Logger logger) { 		return new ExtractedArtifactStoreBuilder().defaults(Command.MongoD) 				.download(new DownloadConfigBuilder().defaultsForCommand(Command.MongoD) 						.progressListener(new Slf4jProgressListener(logger)).build()); 	}
@Bean(name = "userInfoRestTemplate") 		public OAuth2RestTemplate userInfoRestTemplate() { 			if (this.details == null) { 				this.details = DEFAULT_RESOURCE_DETAILS; 			} 			OAuth2RestTemplate template = getTemplate(); 			template.getInterceptors().add(new AcceptJsonRequestInterceptor()); 			AuthorizationCodeAccessTokenProvider accessTokenProvider = new AuthorizationCodeAccessTokenProvider(); 			accessTokenProvider.setTokenRequestEnhancer(new AcceptJsonRequestEnhancer()); 			template.setAccessTokenProvider(accessTokenProvider); 			AnnotationAwareOrderComparator.sort(this.customizers); 			for (UserInfoRestTemplateCustomizer customizer : this.customizers) { 				customizer.customize(template); 			} 			return template; 		}
@Bean 			@ConditionalOnMissingBean({ ConnectionFactoryLocator.class, 					ResourceServerTokenServices.class }) 			public UserInfoTokenServices userInfoTokenServices() { 				UserInfoTokenServices services = new UserInfoTokenServices( 						this.sso.getUserInfoUri(), this.sso.getClientId()); 				services.setTokenType(this.sso.getTokenType()); 				services.setRestTemplate(this.restTemplate); 				if (this.authoritiesExtractor != null) { 					services.setAuthoritiesExtractor(this.authoritiesExtractor); 				} 				return services; 			}
@Bean 			@ConditionalOnMissingBean(ResourceServerTokenServices.class) 			public UserInfoTokenServices userInfoTokenServices() { 				UserInfoTokenServices services = new UserInfoTokenServices( 						this.sso.getUserInfoUri(), this.sso.getClientId()); 				services.setRestTemplate(this.restTemplate); 				services.setTokenType(this.sso.getTokenType()); 				if (this.authoritiesExtractor != null) { 					services.setAuthoritiesExtractor(this.authoritiesExtractor); 				} 				return services; 			}
@Bean 		public JwtAccessTokenConverter jwtTokenEnhancer() { 			JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); 			String keyValue = this.resource.getJwt().getKeyValue(); 			if (!StringUtils.hasText(keyValue)) { 				try { 					keyValue = getKeyFromServer(); 				} 				catch (ResourceAccessException ex) { 					logger.warn("Failed to fetch token key (you may need to refresh " 							+ "when the auth server is back)"); 				} 			} 			if (StringUtils.hasText(keyValue) && !keyValue.startsWith("-----BEGIN")) { 				converter.setSigningKey(keyValue); 			} 			if (keyValue != null) { 				converter.setVerifierKey(keyValue); 			} 			AnnotationAwareOrderComparator.sort(this.configurers); 			for (JwtAccessTokenConverterConfigurer configurer : this.configurers) { 				configurer.configure(converter); 			} 			return converter; 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment 						.resolvePlaceholders("${OAUTH2_RESOURCE_PREFERTOKENINFO:true}") 						.equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match( 						"Token info endpoint " + "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment 						.resolvePlaceholders("${OAUTH2_RESOURCE_PREFERTOKENINFO:true}") 						.equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match( 						"Token info endpoint " + "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment 						.resolvePlaceholders("${OAUTH2_RESOURCE_PREFERTOKENINFO:true}") 						.equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match( 						"Token info endpoint " + "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.tokenInfoCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.tokenInfoCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.tokenInfoCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.jwtTokenCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.jwtTokenCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.jwtTokenCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public UserIdSource getUserIdSource() { 			return new UserIdSource() { 				@Override 				public String getUserId() { 					return "anonymous"; 				} 			}; 		}
@Override 				public String getUserId() { 					return "anonymous"; 				}
@Override 		public UserIdSource getUserIdSource() { 			return new SecurityContextUserIdSource(); 		}
@Override 		public String getUserId() { 			SecurityContext context = SecurityContextHolder.getContext(); 			Authentication authentication = context.getAuthentication(); 			Assert.state(authentication != null, 					"Unable to get a " + "ConnectionRepository: no user signed in"); 			return authentication.getName(); 		}
@Bean 		public SpringTemplateEngine templateEngine() { 			SpringTemplateEngine engine = new SpringTemplateEngine(); 			for (ITemplateResolver templateResolver : this.templateResolvers) { 				engine.addTemplateResolver(templateResolver); 			} 			for (IDialect dialect : this.dialects) { 				engine.addDialect(dialect); 			} 			return engine; 		}
@Bean 	@ConditionalOnMissingBean 	public HttpMessageConverters messageConverters() { 		return new HttpMessageConverters(this.converters); 	}
@Bean 			public LiteDeviceDelegatingViewResolver deviceDelegatingViewResolver() { 				if (logger.isDebugEnabled()) { 					logger.debug("LiteDeviceDelegatingViewResolver delegates to " 							+ "ThymeleafViewResolver"); 				} 				return getConfiguredViewResolver(this.viewResolver, 						this.viewResolver.getOrder()); 			}
@Bean 			public LiteDeviceDelegatingViewResolver deviceDelegatingViewResolver() { 				if (logger.isDebugEnabled()) { 					logger.debug("LiteDeviceDelegatingViewResolver delegates to " 							+ "InternalResourceViewResolver"); 				} 				return getConfiguredViewResolver(this.viewResolver, 						this.viewResolver.getOrder()); 			}
@Bean 		@ConditionalOnMissingBean(DeviceResolverHandlerInterceptor.class) 		public DeviceResolverHandlerInterceptor deviceResolverHandlerInterceptor() { 			return new DeviceResolverHandlerInterceptor(); 		}
@Bean 		public DeviceHandlerMethodArgumentResolver deviceHandlerMethodArgumentResolver() { 			return new DeviceHandlerMethodArgumentResolver(); 		}
@Override 		public void addArgumentResolvers( 				List<HandlerMethodArgumentResolver> argumentResolvers) { 			argumentResolvers.add(deviceHandlerMethodArgumentResolver()); 		}
@Bean 		@ConditionalOnMissingBean(SitePreferenceHandlerInterceptor.class) 		public SitePreferenceHandlerInterceptor sitePreferenceHandlerInterceptor() { 			return new SitePreferenceHandlerInterceptor(); 		}
@Bean 		public SitePreferenceHandlerMethodArgumentResolver sitePreferenceHandlerMethodArgumentResolver() { 			return new SitePreferenceHandlerMethodArgumentResolver(); 		}
@Override 		public void addArgumentResolvers( 				List<HandlerMethodArgumentResolver> argumentResolvers) { 			argumentResolvers.add(sitePreferenceHandlerMethodArgumentResolver()); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Bean 			@ConditionalOnMissingBean({ ConnectionFactoryLocator.class, 					ResourceServerTokenServices.class }) 			public UserInfoTokenServices userInfoTokenServices() { 				UserInfoTokenServices services = new UserInfoTokenServices( 						this.sso.getUserInfoUri(), this.sso.getClientId()); 				services.setTokenType(this.sso.getTokenType()); 				services.setRestTemplate(this.restTemplate); 				if (this.authoritiesExtractor != null) { 					services.setAuthoritiesExtractor(this.authoritiesExtractor); 				} 				return services; 			}
@Bean 			@ConditionalOnMissingBean(ResourceServerTokenServices.class) 			public UserInfoTokenServices userInfoTokenServices() { 				UserInfoTokenServices services = new UserInfoTokenServices( 						this.sso.getUserInfoUri(), this.sso.getClientId()); 				services.setRestTemplate(this.restTemplate); 				services.setTokenType(this.sso.getTokenType()); 				if (this.authoritiesExtractor != null) { 					services.setAuthoritiesExtractor(this.authoritiesExtractor); 				} 				return services; 			}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment 						.resolvePlaceholders("${OAUTH2_RESOURCE_PREFERTOKENINFO:true}") 						.equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match( 						"Token info endpoint " + "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment 						.resolvePlaceholders("${OAUTH2_RESOURCE_PREFERTOKENINFO:true}") 						.equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match( 						"Token info endpoint " + "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			Environment environment = context.getEnvironment(); 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver(environment, 					"security.oauth2.resource."); 			Boolean preferTokenInfo = resolver.getProperty("prefer-token-info", 					Boolean.class); 			if (preferTokenInfo == null) { 				preferTokenInfo = environment 						.resolvePlaceholders("${OAUTH2_RESOURCE_PREFERTOKENINFO:true}") 						.equals("true"); 			} 			String tokenInfoUri = resolver.getProperty("token-info-uri"); 			String userInfoUri = resolver.getProperty("user-info-uri"); 			if (!StringUtils.hasLength(userInfoUri)) { 				return ConditionOutcome.match("No user info provided"); 			} 			if (StringUtils.hasLength(tokenInfoUri) && preferTokenInfo) { 				return ConditionOutcome.match( 						"Token info endpoint " + "is preferred and user info provided"); 			} 			return ConditionOutcome.noMatch("Token info endpoint is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			RelaxedPropertyResolver resolver = new RelaxedPropertyResolver( 					context.getEnvironment(), "security.oauth2.resource.jwt."); 			String keyValue = resolver.getProperty("key-value"); 			String keyUri = resolver.getProperty("key-uri"); 			if (StringUtils.hasText(keyValue) || StringUtils.hasText(keyUri)) { 				return ConditionOutcome.match("public key is provided"); 			} 			return ConditionOutcome.noMatch("public key is not provided"); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.tokenInfoCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.tokenInfoCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.tokenInfoCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.jwtTokenCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.jwtTokenCondition.getMatchOutcome(context, metadata)); 		}
@Override 		public ConditionOutcome getMatchOutcome(ConditionContext context, 				AnnotatedTypeMetadata metadata) { 			return ConditionOutcome 					.inverse(this.jwtTokenCondition.getMatchOutcome(context, metadata)); 		}
@Test 	public void flywayDataSource() throws Exception { 		registerAndRefresh(FlywayDataSourceConfiguration.class, 				EmbeddedDataSourceConfiguration.class, FlywayAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		Flyway flyway = this.context.getBean(Flyway.class); 		assertThat(flyway.getDataSource()).isNotNull(); 	}
@FlywayDataSource 		@Bean 		public DataSource flywayDataSource() { 			return DataSourceBuilder.create().url("jdbc:hsqldb:mem:flywaytest") 					.username("sa").build(); 		}
@Test 	public void defaultJtaPlatform() throws Exception { 		this.context.register(JtaProperties.class, JtaAutoConfiguration.class); 		setupTestConfiguration(); 		this.context.refresh(); 		Map<String, Object> jpaPropertyMap = this.context 				.getBean(LocalContainerEntityManagerFactoryBean.class) 				.getJpaPropertyMap(); 		assertThat(jpaPropertyMap.get("hibernate.transaction.jta.platform")) 				.isInstanceOf(SpringJtaPlatform.class); 	}
@Test 	public void testCustomJtaPlatform() throws Exception { 		EnvironmentTestUtils.addEnvironment(this.context, 				"spring.jpa.properties.hibernate.transaction.jta.platform:" 						+ TestJtaPlatform.class.getName()); 		this.context.register(JtaProperties.class, JtaAutoConfiguration.class); 		setupTestConfiguration(); 		this.context.refresh(); 		Map<String, Object> jpaPropertyMap = this.context 				.getBean(LocalContainerEntityManagerFactoryBean.class) 				.getJpaPropertyMap(); 		assertThat((String) jpaPropertyMap.get("hibernate.transaction.jta.platform")) 				.isEqualTo(TestJtaPlatform.class.getName()); 	}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return new TestingAuthenticationToken("foo", "bar"); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.authenticationManager = new AuthenticationManager() { 				@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				} 			}; 		}
@Override 				public Authentication authenticate(Authentication authentication) 						throws AuthenticationException { 					return WorkaroundSecurityCustomizer.this.builder.getOrBuild() 							.authenticate(authentication); 				}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			this.userDetails = http.getSharedObject(UserDetailsService.class); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().denyAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers(HttpMethod.POST, "/**").denyAll(); 		}
@Bean 		public MockEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new MockEmbeddedServletContainerFactory(); 		}
@Bean 		public EmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return mock(EmbeddedServletContainerFactory.class); 		}
private List<MessageConverter> getCustomizedConverters() { 		List<MessageConverter> customizedConverters = new ArrayList<MessageConverter>(); 		WebSocketMessagingAutoConfiguration.WebSocketMessageConverterConfiguration configuration = new WebSocketMessagingAutoConfiguration.WebSocketMessageConverterConfiguration(); 		ReflectionTestUtils.setField(configuration, "objectMapper", new ObjectMapper()); 		configuration.configureMessageConverters(customizedConverters); 		return customizedConverters; 	}
@Override 					public void handleFrame(StompHeaders headers, Object payload) { 						result.set(payload); 						latch.countDown(); 					}
@Override 			public void handleFrame(StompHeaders headers, Object payload) { 				latch.countDown(); 			}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new TomcatEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new TomcatEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new TomcatEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new JettyEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new JettyEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new JettyEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new UndertowEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new UndertowEmbeddedServletContainerFactory(0); 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			return new UndertowEmbeddedServletContainerFactory(0); 		}
@Bean 		public DispatcherServlet dispatcherServlet() { 			return new DispatcherServlet(); 			// Alternatively you can use ServletContextInitializer beans including 			// ServletRegistration and FilterRegistration. Read the 			// EmbeddedWebApplicationContext javadoc for details 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			JettyEmbeddedServletContainerFactory factory = new JettyEmbeddedServletContainerFactory( 					0); 			factory.setContextPath(this.env.getProperty("context")); 			return factory; 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			JettyEmbeddedServletContainerFactory factory = new JettyEmbeddedServletContainerFactory( 					0); 			factory.setContextPath(this.env.getProperty("context")); 			return factory; 		}
@Bean 		public EmbeddedServletContainerFactory containerFactory() { 			JettyEmbeddedServletContainerFactory factory = new JettyEmbeddedServletContainerFactory( 					0); 			factory.setContextPath(this.env.getProperty("context")); 			return factory; 		}
@Bean 		public DispatcherServlet dispatcherServlet() { 			DispatcherServlet dispatcherServlet = new DispatcherServlet(); 			// Can configure dispatcher servlet here as would usually do via init-params 			return dispatcherServlet; 		}
private void handleRunFailure(ConfigurableApplicationContext context, 			SpringApplicationRunListeners listeners, Throwable exception) { 		try { 			try { 				handleExitCode(context, exception); 				listeners.finished(context, exception); 			} 			finally { 				reportFailure(exception); 				if (context != null) { 					context.close(); 				} 			} 		} 		catch (Exception ex) { 			logger.warn("Unable to close ApplicationContext", ex); 		} 		ReflectionUtils.rethrowRuntimeException(exception); 	}
@Override 		public void render(Map<String, ?> model, HttpServletRequest request, 				HttpServletResponse response) throws Exception { 			if (response.getContentType() == null) { 				response.setContentType(getContentType()); 			} 			Map<String, Object> map = new HashMap<String, Object>(model); 			map.put("path", request.getContextPath()); 			this.context.setRootObject(map); 			String result = this.helper.replacePlaceholders(this.template, this.resolver); 			response.getWriter().append(result); 		}
@Override 		public String resolvePlaceholder(String name) { 			Expression expression = this.parser.parseExpression(name); 			try { 				Object value = expression.getValue(this.context); 				return HtmlUtils.htmlEscape(value == null ? null : value.toString()); 			} 			catch (Exception ex) { 				return null; 			} 		}
@Bean 	@ConditionalOnMissingBean 	public HealthEndpoint healthEndpoint() { 		return new HealthEndpoint(); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 		// 6 for static resources, one for management endpoints and one for the rest 		assertEquals(8, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testWebConfigurationWithExtraRole() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(EndpointAutoConfiguration.class, 				EndpointWebMvcAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		debugRefresh(this.context); 		UserDetails user = getUser(); 		assertTrue(user.getAuthorities().containsAll( 				AuthorityUtils 						.commaSeparatedStringToAuthorityList("ROLE_USER,ROLE_ADMIN"))); 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		debugRefresh(this.context); 		assertNotNull(this.context.getBean(AuthenticationManager.class)); 		// 4 for static resources and one for the rest 		assertEquals(5, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
public static void main(String[] args) throws Exception { 		SpringApplication.run(SampleSecureApplication.class, args); 	}
@RequestMapping("/") 	public String welcome(Map<String,Object> model) { 		model.put("time", new Date()); 		return "welcome"; 	}
@Bean 	@ConditionalOnMissingBean 	public GraphQlSource graphQlSource(ResourcePatternResolver resourcePatternResolver, GraphQlProperties properties, 			ObjectProvider<DataFetcherExceptionResolver> exceptionResolversProvider, 			ObjectProvider<Instrumentation> instrumentationsProvider, 			ObjectProvider<RuntimeWiringConfigurer> wiringConfigurers, 			ObjectProvider<GraphQlSourceBuilderCustomizer> sourceCustomizers) {  		List<Resource> schemaResources = resolveSchemaResources(resourcePatternResolver, 				properties.getSchema().getLocations(), properties.getSchema().getFileExtensions()); 		GraphQlSource.Builder builder = GraphQlSource.builder() 				.schemaResources(schemaResources.toArray(new Resource[0])) 				.exceptionResolvers(exceptionResolversProvider.orderedStream().collect(Collectors.toList())) 				.instrumentation(instrumentationsProvider.orderedStream().collect(Collectors.toList())); 		wiringConfigurers.orderedStream().forEach(builder::configureRuntimeWiring); 		sourceCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder)); 		try { 			return builder.build(); 		} 		catch (MissingSchemaException exc) { 			throw new InvalidSchemaLocationsException(properties.getSchema().getLocations(), resourcePatternResolver, 					exc); 		} 	}
public String getPath() { 		return this.path; 	}
public String getPath() { 		return this.path; 	}
public void setPath(String path) { 		this.path = path; 	}
public void setPath(String path) { 		this.path = path; 	}
public boolean isEnabled() { 				return this.enabled; 			}
public void setEnabled(boolean enabled) { 				this.enabled = enabled; 			}
public String getPath() { 			return this.path; 		}
public void setPath(String path) { 			this.path = path; 		}
public boolean isEnabled() { 			return this.enabled; 		}
public boolean isEnabled() { 			return this.enabled; 		}
public void setEnabled(boolean enabled) { 			this.enabled = enabled; 		}
public void setEnabled(boolean enabled) { 			this.enabled = enabled; 		}
public String getPath() { 			return this.path; 		}
public void setPath(String path) { 			this.path = path; 		}
@Override 	protected Yaml createYaml() { 		BaseConstructor constructor = new OriginTrackingConstructor(); 		Representer representer = new Representer(); 		DumperOptions dumperOptions = new DumperOptions(); 		LimitedResolver resolver = new LimitedResolver(); 		LoaderOptions loaderOptions = new LoaderOptions(); 		loaderOptions.setAllowDuplicateKeys(false); 		return new Yaml(constructor, representer, dumperOptions, loaderOptions, resolver); 	}
@Override 		public void render(Map<String, ?> model, HttpServletRequest request, 				HttpServletResponse response) throws Exception { 			if (response.getContentType() == null) { 				response.setContentType(getContentType()); 			} 			Map<String, Object> map = new HashMap<String, Object>(model); 			map.put("path", request.getContextPath()); 			this.context.setRootObject(map); 			String result = this.helper.replacePlaceholders(this.template, this.resolver); 			response.getWriter().append(result); 		}
@Override 		public String resolvePlaceholder(String name) { 			Expression expression = this.parser.parseExpression(name); 			try { 				Object value = expression.getValue(this.context); 				return HtmlUtils.htmlEscape(value == null ? null : value.toString()); 			} 			catch (Exception ex) { 				return null; 			} 		}
private Health getHealth(Principal principal) { 		Health health = (useCachedValue(principal) ? this.cached : (Health) this.delegate 				.invoke()); 		// Not too worried about concurrent access here, the worst that can happen is the 		// odd extra call to delegate.invoke() 		this.cached = health; 		if (!secure(principal)) { 			// If not secure we only expose the status 			health = Health.status(health.getStatus()).build(); 		} 		return health; 	}
private boolean useCachedValue(Principal principal) { 		long currentAccess = System.currentTimeMillis(); 		if (this.cached == null || secure(principal) 				|| (currentAccess - this.lastAccess) > this.delegate.getTimeToLive()) { 			this.lastAccess = currentAccess; 			return false; 		} 		return this.cached != null; 	}
@Test 	public void secure() { 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(this.user); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		assertEquals("bar", ((Health) result).getDetails().get("foo")); 	}
@Test 	public void secureNotCached() { 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(this.user); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(this.user); 		@SuppressWarnings("unchecked") 		Health health = ((ResponseEntity<Health>) result).getBody(); 		assertTrue(health.getStatus() == Status.DOWN); 	}
@Test 	public void unsecureCached() { 		given(this.endpoint.getTimeToLive()).willReturn(10000L); 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().up().withDetail("foo", "bar").build()); 		Object result = this.mvc.invoke(this.user); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		result = this.mvc.invoke(null); // insecure now 		Health health = (Health) result; 		// so the result is cached 		assertTrue(health.getStatus() == Status.UP); 	}
@Override 		public void init(WebSecurity builder) throws Exception { 			IgnoredRequestConfigurer ignoring = builder.ignoring(); 			// The ignores are not cumulative, so to prevent overwriting the defaults we 			// add them back. 			List<String> ignored = SpringBootWebSecurityConfiguration 					.getIgnored(this.security); 			ignored.addAll(Arrays.asList(getEndpointPaths(this.endpointHandlerMapping, 					false))); 			if (!this.management.getSecurity().isEnabled()) { 				ignored.addAll(Arrays.asList(getEndpointPaths( 						this.endpointHandlerMapping, true))); 			} 			if (ignored.contains("none")) { 				ignored.remove("none"); 			} 			if (this.errorController != null) { 				ignored.add(normalizePath(this.errorController.getErrorPath())); 			} 			if (this.server != null) { 				String[] paths = this.server.getPathsArray(ignored); 				ignoring.antMatchers(paths); 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception {  			// secure endpoints 			String[] paths = getEndpointPaths(this.endpointHandlerMapping, true); 			if (paths.length > 0 && this.management.getSecurity().isEnabled()) { 				// Always protect them if present 				if (this.security.isRequireSsl()) { 					http.requiresChannel().anyRequest().requiresSecure(); 				} 				http.exceptionHandling().authenticationEntryPoint(entryPoint()); 				paths = this.server.getPathsArray(paths); 				http.requestMatchers().antMatchers(paths); 				http.authorizeRequests().anyRequest() 						.hasRole(this.management.getSecurity().getRole()) // 						.and().httpBasic() // 						.and().anonymous().disable();  				// No cookies for management endpoints by default 				http.csrf().disable(); 				http.sessionManagement().sessionCreationPolicy( 						this.management.getSecurity().getSessions());  				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 						this.security.getHeaders());  			}  		}
private static String[] getEndpointPaths( 			EndpointHandlerMapping endpointHandlerMapping, boolean secure) { 		if (endpointHandlerMapping == null) { 			return NO_PATHS; 		}  		Set<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints(); 		List<String> paths = new ArrayList<String>(endpoints.size()); 		for (MvcEndpoint endpoint : endpoints) { 			if (endpoint.isSensitive() == secure) { 				String path = endpointHandlerMapping.getPrefix() + endpoint.getPath(); 				paths.add(path); 				if (secure) { 					// Add Spring MVC-generated additional paths 					paths.add(path + "/"); 					paths.add(path + ".*"); 				} 			} 		} 		return paths.toArray(new String[paths.size()]); 	}
@Override 	public void afterPropertiesSet() { 		super.afterPropertiesSet(); 		if (!this.disabled) { 			for (MvcEndpoint endpoint : this.endpoints) { 				detectHandlerMethods(endpoint); 			} 		} 	}
public Set<? extends MvcEndpoint> getEndpoints() { 		return this.endpoints; 	}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh(); 		assertNotNull(this.context.getBean(AuthenticationManagerBuilder.class)); 		// 6 for static resources, one for management endpoints and one for the rest 		assertEquals(8, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void testDisableBasicAuthOnApplicationPaths() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				SecurityAutoConfiguration.class, 				ManagementSecurityAutoConfiguration.class, 				FallbackWebSecurityAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		// Just the management endpoints (one filter) and ignores now plus the backup 		// filter on app endpoints 		assertEquals(8, this.context.getBean(FilterChainProxy.class).getFilterChains() 				.size()); 	}
@Test 	public void up() { 		given(this.endpoint.invoke()).willReturn(new Health.Builder().up().build()); 		Object result = this.mvc.invoke(); 		assertTrue(result instanceof Health); 		assertTrue(((Health) result).getStatus() == Status.UP); 	}
@SuppressWarnings("unchecked") 	@Test 	public void down() { 		given(this.endpoint.invoke()).willReturn(new Health.Builder().down().build()); 		Object result = this.mvc.invoke(); 		assertTrue(result instanceof ResponseEntity); 		ResponseEntity<Health> response = (ResponseEntity<Health>) result; 		assertTrue(response.getBody().getStatus() == Status.DOWN); 		assertEquals(HttpStatus.SERVICE_UNAVAILABLE, response.getStatusCode()); 	}
@SuppressWarnings("unchecked") 	@Test 	public void customMapping() { 		given(this.endpoint.invoke()).willReturn( 				new Health.Builder().status("OK").build()); 		this.mvc.setStatusMapping(Collections.singletonMap("OK", 				HttpStatus.INTERNAL_SERVER_ERROR)); 		Object result = this.mvc.invoke(); 		assertTrue(result instanceof ResponseEntity); 		ResponseEntity<Health> response = (ResponseEntity<Health>) result; 		assertTrue(response.getBody().getStatus().equals(new Status("OK"))); 		assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode()); 	}
@Test 	public void testHealth() throws Exception { 		ResponseEntity<String> entity = new TestRestTemplate().getForEntity( 				"http://localhost:" + this.port + "/health", String.class); 		assertEquals(HttpStatus.OK, entity.getStatusCode()); 		assertTrue("Wrong body: " + entity.getBody(), 				entity.getBody().contains("\"status\":\"UP\"")); 	}
void processAndApply() { 		ConfigDataImporter importer = new ConfigDataImporter(this.logFactory, this.notFoundAction, this.resolvers, 				this.loaders); 		registerBootstrapBinder(() -> this.contributors.getBinder(null, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE)); 		ConfigDataEnvironmentContributors contributors = processInitial(this.contributors, importer); 		Binder initialBinder = contributors.getBinder(null, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE); 		registerBootstrapBinder(() -> initialBinder); 		ConfigDataActivationContext activationContext = createActivationContext(initialBinder); 		contributors = processWithoutProfiles(contributors, importer, activationContext); 		activationContext = withProfiles(contributors, activationContext); 		contributors = processWithProfiles(contributors, importer, activationContext); 		applyToEnvironment(contributors, activationContext); 	}
private ConfigDataEnvironmentContributors processInitial(ConfigDataEnvironmentContributors contributors, 			ConfigDataImporter importer) { 		this.logger.trace("Processing initial config data environment contributors without activation context"); 		return contributors.withProcessedImports(importer, null); 	}
private ConfigDataEnvironmentContributors processWithoutProfiles(ConfigDataEnvironmentContributors contributors, 			ConfigDataImporter importer, ConfigDataActivationContext activationContext) { 		this.logger.trace("Processing config data environment contributors with initial activation context"); 		return contributors.withProcessedImports(importer, activationContext); 	}
private ConfigDataEnvironmentContributors processWithProfiles(ConfigDataEnvironmentContributors contributors, 			ConfigDataImporter importer, ConfigDataActivationContext activationContext) { 		this.logger.trace("Processing config data environment contributors with profile activation context"); 		return contributors.withProcessedImports(importer, activationContext); 	}
@Test 	void bootstrapsApplicationContext() { 		try (ConfigurableApplicationContext context = this.application 				.run("--spring.config.import=classpath:application-bootstrap-registry-integration-tests.properties")) { 			LoaderHelper bean = context.getBean(TestConfigDataBootstrap.LoaderHelper.class); 			assertThat(bean).isNotNull(); 			assertThat(bean.getBound()).isEqualTo("igotbound"); 			assertThat(bean.getLocation().getResolverHelper().getLocation()) 					.isEqualTo(ConfigDataLocation.of("testbootstrap:test")); 		} 	}
@Test 	void run() { 		this.context = SpringApplication.run(ExampleWebConfig.class); 		assertThat(this.context).isNotNull(); 	}
@Test 	void registerShutdownHook() { 		SpringApplication application = new SpringApplication(ExampleConfig.class); 		application.setWebApplicationType(WebApplicationType.NONE); 		this.context = application.run(); 		assertThat(SpringApplicationShutdownHookInstance.get()).registeredApplicationContext(this.context); 	}
@Override 			public void run() { 				SpringApplication application = new SpringApplication(FailingConfig.class); 				application.setWebApplicationType(WebApplicationType.NONE); 				application.run(); 			}
@Test 	void shouldStopKeepAliveThreadIfContextIsClosed() { 		SpringApplication application = new SpringApplication(ExampleConfig.class); 		application.setWebApplicationType(WebApplicationType.NONE); 		application.setKeepAlive(true); 		this.context = application.run(); 		Set<Thread> threadsBeforeClose = getCurrentThreads(); 		assertThat(threadsBeforeClose).filteredOn((thread) -> thread.getName().equals("keep-alive")).isNotEmpty(); 		this.context.close(); 		Set<Thread> threadsAfterClose = getCurrentThreads(); 		assertThat(threadsAfterClose).filteredOn((thread) -> thread.getName().equals("keep-alive")).isEmpty(); 	}
@Override 		@SuppressWarnings("unchecked") 		public void onApplicationEvent(ApplicationEvent event) { 			this.reference.set((E) event); 		}
@Override 		public void registerShutdownHook() { 			this.applicationContext.registerShutdownHook(); 		}
@Bean 		String someBean() { 			return "test"; 		}
@Bean 		String someBean() { 			return "override"; 		}
@Bean 		Object fail() { 			throw new RuntimeException("ExpectedError"); 		}
@Bean 		TestCommandLineRunner runnerC() { 			return new TestCommandLineRunner(Ordered.LOWEST_PRECEDENCE, "runnerB", "runnerA"); 		}
@Bean 		TestApplicationRunner runnerB() { 			return new TestApplicationRunner(Ordered.LOWEST_PRECEDENCE - 1, "runnerA"); 		}
@Bean 		TestCommandLineRunner runnerA() { 			return new TestCommandLineRunner(Ordered.HIGHEST_PRECEDENCE); 		}
@Bean 		@Order 		CommandLineRunner runnerC() { 			return (args) -> this.runners.add("runnerC"); 		}
@Bean 		@Order(Ordered.LOWEST_PRECEDENCE - 1) 		ApplicationRunner runnerB() { 			return (args) -> this.runners.add("runnerB"); 		}
@Bean 		@Order(Ordered.HIGHEST_PRECEDENCE) 		CommandLineRunner runnerA() { 			return (args) -> this.runners.add("runnerA"); 		}
@Bean 		CommandLineRunner runner() { 			return (args) -> { 				throw new IllegalStateException(new ExitStatusException()); 			}; 		}
@Bean 		CommandLineRunner runner() { 			return (args) -> { 				throw new IllegalStateException(); 			}; 		}
@PostConstruct 		void fail() { 			throw new RefreshFailureException(); 		}
@Override 		public int getExitCode() { 			return 11; 		}
Integer getExitCode() { 			return this.exitCode; 		}
@Override 		public void onApplicationEvent(ApplicationEvent event) { 			this.events.add(event.getClass(), event); 		}
static void main(String[] args) { 			SpringApplication application = new SpringApplication(ExampleConfig.class); 			application.setWebApplicationType(WebApplicationType.NONE); 			application.run(args); 		}
static void main(String[] args) { 			SpringApplication application = new SpringApplication(ExampleConfig.class); 			application.setWebApplicationType(WebApplicationType.NONE); 			application.addListeners(new ApplicationListener<ApplicationEnvironmentPreparedEvent>() {  				@Override 				public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) { 					SpringApplicationBuilder builder = new SpringApplicationBuilder( 							InnerApplicationConfiguration.class); 					builder.web(WebApplicationType.NONE); 					builder.run().close(); 				}  			}); 			application.run(args); 		}
public void build(BuildRequest request) throws DockerEngineException, IOException { 		Assert.notNull(request, "Request must not be null"); 		this.log.start(request); 		Image builderImage = getImage(request, ImageType.BUILDER); 		BuilderMetadata builderMetadata = BuilderMetadata.fromImage(builderImage); 		BuildOwner buildOwner = BuildOwner.fromEnv(builderImage.getConfig().getEnv()); 		request = determineRunImage(request, builderImage, builderMetadata.getStack()); 		EphemeralBuilder builder = new EphemeralBuilder(buildOwner, builderImage, builderMetadata, request.getCreator(), 				request.getEnv()); 		this.docker.image().load(builder.getArchive(), UpdateListener.none()); 		try { 			executeLifecycle(request, builder); 			if (request.isPublish()) { 				pushImage(request.getName()); 			} 		} 		finally { 			this.docker.image().remove(builder.getName(), true); 		} 	}
@BeforeEach 	void setup() throws Exception { 		this.image = Image.of(getContent("image.json")); 		this.metadata = BuilderMetadata.fromImage(this.image); 		this.env = new HashMap<>(); 		this.env.put("spring", "boot"); 		this.env.put("empty", null); 	}
@Test 	void getNameHasRandomName() throws Exception { 		EphemeralBuilder b1 = new EphemeralBuilder(this.owner, this.image, this.metadata, this.creator, this.env); 		EphemeralBuilder b2 = new EphemeralBuilder(this.owner, this.image, this.metadata, this.creator, this.env); 		assertThat(b1.getName().toString()).startsWith("pack.local/builder/").endsWith(":latest"); 		assertThat(b1.getName().toString()).isNotEqualTo(b2.getName().toString()); 	}
@Test 	void getArchiveHasCreatedByConfig() throws Exception { 		EphemeralBuilder builder = new EphemeralBuilder(this.owner, this.image, this.metadata, this.creator, this.env); 		ImageConfig config = builder.getArchive().getImageConfig(); 		BuilderMetadata ephemeralMetadata = BuilderMetadata.fromImageConfig(config); 		assertThat(ephemeralMetadata.getCreatedBy().getName()).isEqualTo("Spring Boot"); 		assertThat(ephemeralMetadata.getCreatedBy().getVersion()).isEqualTo("dev"); 	}
@Test 	void getArchiveHasTag() throws Exception { 		EphemeralBuilder builder = new EphemeralBuilder(this.owner, this.image, this.metadata, this.creator, this.env); 		ImageReference tag = builder.getArchive().getTag(); 		assertThat(tag.toString()).startsWith("pack.local/builder/").endsWith(":latest"); 	}
@Test 	void getArchiveHasFixedCreateDate() throws Exception { 		EphemeralBuilder builder = new EphemeralBuilder(this.owner, this.image, this.metadata, this.creator, this.env); 		Instant createInstant = builder.getArchive().getCreateDate(); 		OffsetDateTime createDateTime = OffsetDateTime.ofInstant(createInstant, ZoneId.of("UTC")); 		assertThat(createDateTime.getYear()).isEqualTo(1980); 		assertThat(createDateTime.getMonthValue()).isEqualTo(1); 		assertThat(createDateTime.getDayOfMonth()).isEqualTo(1); 		assertThat(createDateTime.getHour()).isEqualTo(0); 		assertThat(createDateTime.getMinute()).isEqualTo(0); 		assertThat(createDateTime.getSecond()).isEqualTo(1); 	}
@Test 	void getArchiveContainsEnvLayer() throws Exception { 		EphemeralBuilder builder = new EphemeralBuilder(this.owner, this.image, this.metadata, this.creator, this.env); 		File directory = unpack(getLayer(builder.getArchive(), 0), "env"); 		assertThat(new File(directory, "platform/env/spring")).usingCharset(StandardCharsets.UTF_8).hasContent("boot"); 		assertThat(new File(directory, "platform/env/empty")).usingCharset(StandardCharsets.UTF_8).hasContent(""); 	}
@Test 	void whenARequestIsActiveAfterGracefulShutdownEndsThenStopWillComplete() 			throws InterruptedException, BrokenBarrierException { 		AbstractServletWebServerFactory factory = getFactory(); 		factory.setShutdown(Shutdown.GRACEFUL); 		BlockingServlet blockingServlet = new BlockingServlet(); 		this.webServer = factory 				.getWebServer((context) -> context.addServlet("blockingServlet", blockingServlet).addMapping("/")); 		this.webServer.start(); 		int port = this.webServer.getPort(); 		initiateGetRequest(port, "/"); 		blockingServlet.awaitQueue(); 		AtomicReference<GracefulShutdownResult> result = new AtomicReference<>(); 		this.webServer.shutDownGracefully(result::set); 		this.webServer.stop(); 		Awaitility.await().atMost(Duration.ofSeconds(30)) 				.until(() -> GracefulShutdownResult.REQUESTS_ACTIVE == result.get()); 		try { 			blockingServlet.admitOne(); 		} 		catch (RuntimeException ex) {  		} 	}
@Override 			public void service(ServletRequest request, ServletResponse response) { 				throw new RuntimeException("Planned"); 			}
@Override 			public void service(ServletRequest request, ServletResponse response) throws IOException { 				HttpSession session = ((HttpServletRequest) request).getSession(true); 				long value = System.currentTimeMillis(); 				Object existing = session.getAttribute("boot"); 				session.setAttribute("boot", value); 				PrintWriter writer = response.getWriter(); 				writer.append(String.valueOf(existing)).append(":").append(String.valueOf(value)); 			}
@Override 		public void init() { 			this.initCount++; 		}
@Override 		public void init() throws ServletException { 			throw new FailingServletException(); 		}
@Override 		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { 			CyclicBarrier barrier = new CyclicBarrier(2); 			this.barriers.add(barrier); 			try { 				barrier.await(); 			} 			catch (InterruptedException ex) { 				Thread.currentThread().interrupt(); 			} 			catch (BrokenBarrierException ex) { 				throw new ServletException(ex); 			} 		}
@Override 		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { 			CyclicBarrier barrier = new CyclicBarrier(2); 			this.barriers.add(barrier); 			try { 				barrier.await(); 			} 			catch (InterruptedException ex) { 				Thread.currentThread().interrupt(); 			} 			catch (BrokenBarrierException ex) { 				throw new ServletException(ex); 			} 		}
public void admitOne() { 			try { 				CyclicBarrier barrier = this.barriers.take(); 				if (!barrier.isBroken()) { 					barrier.await(); 				} 			} 			catch (InterruptedException ex) { 				Thread.currentThread().interrupt(); 			} 			catch (BrokenBarrierException ex) { 				throw new RuntimeException(ex); 			} 		}
public void admitOne() { 			try { 				CyclicBarrier barrier = this.barriers.take(); 				if (!barrier.isBroken()) { 					barrier.await(); 				} 			} 			catch (InterruptedException ex) { 				Thread.currentThread().interrupt(); 			} 			catch (BrokenBarrierException ex) { 				throw new RuntimeException(ex); 			} 		}
public void awaitQueue() throws InterruptedException { 			while (this.barriers.isEmpty()) { 				Thread.sleep(100); 			} 		}
public void awaitQueue() throws InterruptedException { 			while (this.barriers.isEmpty()) { 				Thread.sleep(100); 			} 		}
public void awaitQueue(int size) throws InterruptedException { 			while (this.barriers.size() < size) { 				Thread.sleep(100); 			} 		}
@Override 		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { 			CyclicBarrier barrier = new CyclicBarrier(2); 			this.barriers.add(barrier); 			AsyncContext async = req.startAsync(); 			new Thread(() -> { 				try { 					barrier.await(); 				} 				catch (InterruptedException ex) { 					Thread.currentThread().interrupt(); 				} 				catch (BrokenBarrierException ex) {  				} 				async.complete(); 			}).start(); 		}
@Override 		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { 			CyclicBarrier barrier = new CyclicBarrier(2); 			this.barriers.add(barrier); 			AsyncContext async = req.startAsync(); 			new Thread(() -> { 				try { 					barrier.await(); 				} 				catch (InterruptedException ex) { 					Thread.currentThread().interrupt(); 				} 				catch (BrokenBarrierException ex) {  				} 				async.complete(); 			}).start(); 		}
private void admitOne() { 			try { 				this.barriers.take().await(); 			} 			catch (InterruptedException ex) { 				Thread.currentThread().interrupt(); 			} 			catch (BrokenBarrierException ex) { 				throw new RuntimeException(ex); 			} 		}
private void admitOne() { 			try { 				this.barriers.take().await(); 			} 			catch (InterruptedException ex) { 				Thread.currentThread().interrupt(); 			} 			catch (BrokenBarrierException ex) { 				throw new RuntimeException(ex); 			} 		}
private void awaitQueue() throws InterruptedException { 			while (this.barriers.isEmpty()) { 				Thread.sleep(100); 			} 		}
private void awaitQueue() throws InterruptedException { 			while (this.barriers.isEmpty()) { 				Thread.sleep(100); 			} 		}
@Test 	void requestMappingIsInstrumented() { 		this.loopback.getForObject("/api/people", Set.class); 		assertThat(this.registry.get("http.server.requests").timer().count()).isEqualTo(1); 	}
@Test 	void requestMappingIsInstrumented() { 		this.loopback.getForObject("/api/people", Set.class); 		assertThat(this.registry.get("http.server.requests").timer().count()).isEqualTo(1); 	}
@Override 			protected TomcatWebServer getTomcatWebServer(Tomcat tomcat) { 				tomcat.enableNaming(); 				return super.getTomcatWebServer(tomcat); 			}
@Override 			protected TomcatWebServer getTomcatWebServer(Tomcat tomcat) { 				try { 					return super.getTomcatWebServer(tomcat); 				} 				finally { 					assertThat(tomcat.getServer().getState()).isEqualTo(LifecycleState.DESTROYED); 				} 			}
@Test 	void whenServerIsShuttingDownARequestOnAnIdleConnectionResultsInConnectionReset() throws Exception { 		AbstractServletWebServerFactory factory = getFactory(); 		factory.setShutdown(Shutdown.GRACEFUL); 		BlockingServlet blockingServlet = new BlockingServlet(); 		this.webServer = factory.getWebServer((context) -> { 			Dynamic registration = context.addServlet("blockingServlet", blockingServlet); 			registration.addMapping("/blocking"); 			registration.setAsyncSupported(true); 		}); 		HttpClient httpClient = HttpClients.createMinimal(); 		this.webServer.start(); 		int port = this.webServer.getPort(); 		Future<Object> keepAliveRequest = initiateGetRequest(httpClient, port, "/blocking"); 		blockingServlet.awaitQueue(); 		blockingServlet.admitOne(); 		assertThat(keepAliveRequest.get()).isInstanceOf(HttpResponse.class); 		Future<Object> request = initiateGetRequest(port, "/blocking"); 		blockingServlet.awaitQueue(); 		this.webServer.shutDownGracefully((result) -> { 		}); 		Future<Object> idleConnectionRequest = initiateGetRequest(httpClient, port, "/blocking"); 		blockingServlet.admitOne(); 		Object response = request.get(); 		assertThat(response).isInstanceOf(HttpResponse.class); 		Object idleConnectionRequestResult = idleConnectionRequest.get(); 		assertThat(idleConnectionRequestResult).isInstanceOfAny(SocketException.class, NoHttpResponseException.class); 		if (idleConnectionRequestResult instanceof SocketException) { 			assertThat((SocketException) idleConnectionRequestResult).hasMessage("Connection reset"); 		} 		this.webServer.stop(); 	}
@Override 			public void service(ServletRequest request, ServletResponse response) { 				throw new RuntimeException("Planned"); 			}
@Override 			public void service(ServletRequest request, ServletResponse response) throws IOException { 				HttpSession session = ((HttpServletRequest) request).getSession(true); 				long value = System.currentTimeMillis(); 				Object existing = session.getAttribute("boot"); 				session.setAttribute("boot", value); 				PrintWriter writer = response.getWriter(); 				writer.append(String.valueOf(existing)).append(":").append(String.valueOf(value)); 			}
@Override 		public void init() { 			this.initCount++; 		}
@Override 		public void init() throws ServletException { 			throw new FailingServletException(); 		}
@Override 		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { 			CyclicBarrier barrier = new CyclicBarrier(2); 			this.barriers.add(barrier); 			try { 				barrier.await(); 			} 			catch (InterruptedException ex) { 				Thread.currentThread().interrupt(); 			} 			catch (BrokenBarrierException ex) { 				throw new ServletException(ex); 			} 		}
@Override 		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { 			CyclicBarrier barrier = new CyclicBarrier(2); 			this.barriers.add(barrier); 			try { 				barrier.await(); 			} 			catch (InterruptedException ex) { 				Thread.currentThread().interrupt(); 			} 			catch (BrokenBarrierException ex) { 				throw new ServletException(ex); 			} 		}
public void admitOne() { 			try { 				CyclicBarrier barrier = this.barriers.take(); 				if (!barrier.isBroken()) { 					barrier.await(); 				} 			} 			catch (InterruptedException ex) { 				Thread.currentThread().interrupt(); 			} 			catch (BrokenBarrierException ex) { 				throw new RuntimeException(ex); 			} 		}
@Override 		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { 			CyclicBarrier barrier = new CyclicBarrier(2); 			this.barriers.add(barrier); 			AsyncContext async = req.startAsync(); 			new Thread(() -> { 				try { 					barrier.await(); 				} 				catch (InterruptedException ex) { 					Thread.currentThread().interrupt(); 				} 				catch (BrokenBarrierException ex) {  				} 				async.complete(); 			}).start(); 		}
private void admitOne() { 			try { 				this.barriers.take().await(); 			} 			catch (InterruptedException ex) { 				Thread.currentThread().interrupt(); 			} 			catch (BrokenBarrierException ex) { 				throw new RuntimeException(ex); 			} 		}
public boolean isDistributionComplete(ReleaseInfo releaseInfo) { 		RequestEntity<Void> publishedFilesRequest = getRequest(releaseInfo, 0); 		RequestEntity<Void> allFilesRequest = getRequest(releaseInfo, 1); 		Object[] allFiles = this.restTemplate.exchange(allFilesRequest, Object[].class).getBody(); 		int count = 0; 		while (count < 120) { 			Object[] publishedFiles = this.restTemplate.exchange(publishedFilesRequest, Object[].class).getBody(); 			int unpublished = allFiles.length - publishedFiles.length; 			if (unpublished == 0) { 				return true; 			} 			count++; 			try { 				Thread.sleep(20000); 			} 			catch (InterruptedException e) {  			} 		} 		return false; 	}
@Test 	void isDistributionComplete() throws Exception { 		setupGetPackageFiles(1, "all-package-files.json"); 		setupGetPackageFiles(0, "published-files.json"); 		setupGetPackageFiles(0, "all-package-files.json"); 		assertThat(this.service.isDistributionComplete(getReleaseInfo())).isTrue(); 		this.server.verify(); 	}
@Test 	public void enableSchedulingWithNoTaskExecutorAutoConfiguresOne() { 		this.contextRunner 				.withPropertyValues( 						"spring.task.scheduling.thread-name-prefix=scheduling-test-") 				.withUserConfiguration(SchedulingConfiguration.class).run((context) -> { 					assertThat(context).hasSingleBean(TaskExecutor.class); 					TestBean bean = context.getBean(TestBean.class); 					Thread.sleep(15); 					assertThat(bean.threadNames) 							.allMatch((name) -> name.contains("scheduling-test-")); 				}); 	}
@Test 	public void enableSchedulingWithNoTaskExecutorAppliesCustomizers() { 		this.contextRunner 				.withPropertyValues( 						"spring.task.scheduling.thread-name-prefix=scheduling-test-") 				.withUserConfiguration(SchedulingConfiguration.class, 						TaskSchedulerCustomizerConfiguration.class) 				.run((context) -> { 					assertThat(context).hasSingleBean(TaskExecutor.class); 					TestBean bean = context.getBean(TestBean.class); 					Thread.sleep(15); 					assertThat(bean.threadNames) 							.allMatch((name) -> name.contains("customized-scheduler-")); 				}); 	}
@Test 	public void enableSchedulingWithExistingTaskSchedulerBacksOff() { 		this.contextRunner.withUserConfiguration(SchedulingConfiguration.class, 				TaskSchedulerConfiguration.class).run((context) -> { 					assertThat(context).hasSingleBean(TaskScheduler.class); 					assertThat(context.getBean(TaskScheduler.class)) 							.isInstanceOf(TestTaskScheduler.class); 					TestBean bean = context.getBean(TestBean.class); 					Thread.sleep(15); 					assertThat(bean.threadNames).containsExactly("test-1"); 				}); 	}
@Test 	public void enableSchedulingWithExistingScheduledExecutorServiceBacksOff() { 		this.contextRunner.withUserConfiguration(SchedulingConfiguration.class, 				ScheduledExecutorServiceConfiguration.class).run((context) -> { 					assertThat(context).doesNotHaveBean(TaskScheduler.class); 					assertThat(context).hasSingleBean(ScheduledExecutorService.class); 					TestBean bean = context.getBean(TestBean.class); 					Thread.sleep(15); 					assertThat(bean.threadNames) 							.allMatch((name) -> name.contains("pool-")); 				}); 	}
@Test 	public void enableSchedulingWithConfigurerBacksOff() { 		this.contextRunner.withUserConfiguration(SchedulingConfiguration.class, 				SchedulingConfigurerConfiguration.class).run((context) -> { 					assertThat(context).doesNotHaveBean(TaskScheduler.class); 					TestBean bean = context.getBean(TestBean.class); 					Thread.sleep(15); 					assertThat(bean.threadNames).containsExactly("test-1"); 				}); 	}
@Scheduled(fixedRate = 10) 		public void accumulate() { 			this.threadNames.add(Thread.currentThread().getName()); 		}
private Supplier<C> getContext(HttpServletRequest request) { 		if (this.context == null) { 			synchronized (this.contextLock) { 				if (this.context == null) { 					this.context = createContext(request); 					initialized(this.context); 				} 			} 		} 		return this.context; 	}
private Mono<Void> validateKeyIdAndSignature(Token token) { 		String keyId = token.getKeyId(); 		return Mono.just(this.cachedTokenKeys) 				.filter((tokenKeys) -> tokenKeys.containsKey(keyId)) 				.switchIfEmpty(this.securityService.fetchTokenKeys() 						.doOnSuccess((fetchedTokenKeys) -> { 							this.cachedTokenKeys.clear(); 							this.cachedTokenKeys.putAll(fetchedTokenKeys); 						}).filter((tokenKeys) -> tokenKeys.containsKey(keyId)) 						.switchIfEmpty((Mono.error(new CloudFoundryAuthorizationException( 								Reason.INVALID_KEY_ID, 								"Key Id present in token header does not match"))))) 				.filter((tokenKeys) -> hasValidSignature(token, tokenKeys.get(keyId))) 				.switchIfEmpty(Mono.error(new CloudFoundryAuthorizationException( 						Reason.INVALID_SIGNATURE, "RSA Signature did not match content"))) 				.then(); 	}
@Test 	public void getRequestShouldReturnHeapDumpInResponseBody() throws Exception { 		client.get().uri("/application/heapdump").exchange().expectStatus().isOk() 				.expectHeader().contentType(MediaType.APPLICATION_OCTET_STREAM) 				.expectBody(String.class).isEqualTo("HEAPDUMP"); 		assertThat(this.endpoint.file.exists()).isFalse(); 	}
@Override 	protected Class<?> loadClass(String name, boolean resolve) 			throws ClassNotFoundException { 		Handler.setUseFastConnectionExceptions(true); 		try { 			definePackageIfNecessary(name); 			return super.loadClass(name, resolve); 		} 		finally { 			Handler.setUseFastConnectionExceptions(false); 		} 	}
private void definePackageIfNecessary(String className) { 		int lastDot = className.lastIndexOf('.'); 		if (lastDot >= 0) { 			String packageName = className.substring(0, lastDot); 			if (getPackage(packageName) == null) { 				definePackage(packageName); 			} 		} 	}
@Test 	public void clientClose() throws Exception { 		WebSocketClient client = new WebSocketClient(); 		try { 			Socket socket = openSocket(client, new Socket()); 			socket.getSession().close(); 		} 		finally { 			client.stop(); 		} 		assertThat(this.server.getClosedExceptions().size(), greaterThan(0)); 	}
public List<ConnectionClosedException> getClosedExceptions() { 			return this.closedExceptions; 		}
@Override 			public void run() throws Exception { 				try { 					super.run(); 				} 				catch (ConnectionClosedException ex) { 					MonitoredLiveReloadServer.this.closedExceptions.add(ex); 					throw ex; 				} 			}
private String getOutput() throws Exception { 		Future<String> future = Executors.newSingleThreadExecutor().submit( 				new Callable<String>() { 					@Override 					public String call() throws Exception { 						Resource[] resources = new Resource[0]; 						while (resources.length == 0) { 							Thread.sleep(200); 							resources = ResourcePatternUtils.getResourcePatternResolver( 									new DefaultResourceLoader()).getResources( 									"file:target/output/**"); 						} 						StringBuilder builder = new StringBuilder(); 						for (Resource resource : resources) { 							builder.append(new String(StreamUtils 									.copyToByteArray(resource.getInputStream()))); 						} 						return builder.toString(); 					} 				}); 		return future.get(30, TimeUnit.SECONDS); 	}
@Override 					public String call() throws Exception { 						Resource[] resources = new Resource[0]; 						while (resources.length == 0) { 							Thread.sleep(200); 							resources = ResourcePatternUtils.getResourcePatternResolver( 									new DefaultResourceLoader()).getResources( 									"file:target/output/**"); 						} 						StringBuilder builder = new StringBuilder(); 						for (Resource resource : resources) { 							builder.append(new String(StreamUtils 									.copyToByteArray(resource.getInputStream()))); 						} 						return builder.toString(); 					}
protected int run(Collection<String> args) throws IOException { 		ProcessBuilder builder = new ProcessBuilder(this.command); 		builder.command().addAll(args); 		builder.redirectErrorStream(true); 		boolean inheritedIO = inheritIO(builder); 		try { 			this.process = builder.start(); 			if (!inheritedIO) { 				redirectOutput(this.process); 			} 			SignalUtils.attachSignalHandler(new Runnable() { 				@Override 				public void run() { 					handleSigInt(); 				} 			}); 			try { 				this.process.waitFor(); 			} 			catch (InterruptedException ex) { 				Thread.currentThread().interrupt(); 			} 			try { 				return this.process.exitValue(); 			} 			catch (IllegalThreadStateException e) { 				return 1; 			} 		} 		finally { 			this.endTime = System.currentTimeMillis(); 			this.process = null; 		} 	}
@Override 				public void run() { 					handleSigInt(); 				}
@Override 			public void run() { 				try { 					String line = reader.readLine(); 					while (line != null) { 						System.out.println(line); 						line = reader.readLine(); 						System.out.flush(); 					} 					reader.close(); 				} 				catch (Exception ex) { 				} 			}
@Override 		public Iterator<ConditionAndOutcome> iterator() { 			return Collections.unmodifiableList(this.outcomes).iterator(); 		}
@Test 	public void parent() throws Exception { 		this.beanFactory.setParentBeanFactory(new DefaultListableBeanFactory()); 		AutoConfigurationReport.get((ConfigurableListableBeanFactory) this.beanFactory 				.getParentBeanFactory()); 		assertThat(this.report, 				sameInstance(AutoConfigurationReport.get(this.beanFactory))); 		assertThat(this.report, not(nullValue())); 		assertThat(this.report.getParent(), not(nullValue())); 	}
@Test 	public void recordConditionEvaluations() throws Exception { 		this.report.recordConditionEvaluation("a", this.condition1, this.outcome1); 		this.report.recordConditionEvaluation("a", this.condition2, this.outcome2); 		this.report.recordConditionEvaluation("b", this.condition3, this.outcome3);  		Map<String, ConditionAndOutcomes> map = this.report 				.getConditionAndOutcomesBySource(); 		assertThat(map.size(), equalTo(2)); 		Iterator<ConditionAndOutcome> iterator = map.get("a").iterator(); 		ConditionAndOutcome conditionAndOutcome = iterator.next(); 		assertThat(conditionAndOutcome.getCondition(), equalTo(this.condition1)); 		assertThat(conditionAndOutcome.getOutcome(), equalTo(this.outcome1)); 		conditionAndOutcome = iterator.next(); 		assertThat(conditionAndOutcome.getCondition(), equalTo(this.condition2)); 		assertThat(conditionAndOutcome.getOutcome(), equalTo(this.outcome2)); 		assertThat(iterator.hasNext(), equalTo(false)); 		iterator = map.get("b").iterator(); 		conditionAndOutcome = iterator.next(); 		assertThat(conditionAndOutcome.getCondition(), equalTo(this.condition3)); 		assertThat(conditionAndOutcome.getOutcome(), equalTo(this.outcome3)); 		assertThat(iterator.hasNext(), equalTo(false)); 	}
@Test 	@SuppressWarnings("resource") 	public void springBootConditionPopulatesReport() throws Exception { 		AutoConfigurationReport report = AutoConfigurationReport 				.get(new AnnotationConfigApplicationContext(Config.class) 						.getBeanFactory()); 		assertThat(report.getConditionAndOutcomesBySource().size(), not(equalTo(0))); 	}
@Test 	public void emptyServerWhenPortIsZero() throws Exception { 		ConfigurableEmbeddedServletContainerFactory factory = getFactory(); 		factory.setPort(0); 		this.container = factory 				.getEmbeddedServletContainer(exampleServletRegistration()); 		this.container.start(); 		this.thrown.expect(SocketException.class); 		getResponse("http://localhost:8080/hello"); 	}
@Test 	public void stopServlet() throws Exception { 		ConfigurableEmbeddedServletContainerFactory factory = getFactory(); 		this.container = factory 				.getEmbeddedServletContainer(exampleServletRegistration()); 		this.container.start(); 		this.container.stop(); 		this.thrown.expect(SocketException.class); 		getResponse("http://localhost:8080/hello"); 	}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						try { 							Thread.sleep(500); 							date[0] = new Date(); 						} 						catch (InterruptedException ex) { 							throw new ServletException(ex); 						} 					}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						servletContext.addServlet("test", servlet).setLoadOnStartup(1); 					}
@Override 	public void customize(ConfigurableEmbeddedServletContainerFactory factory) { 		Integer port = getPort(); 		if (this.scan) { 			port = scanForPort(port); 		} 		if (port != null) { 			factory.setPort(port); 		} 		if (getAddress() != null) { 			factory.setAddress(getAddress()); 		} 		if (getContextPath() != null) { 			factory.setContextPath(getContextPath()); 		} 		if (getSessionTimeout() != null) { 			factory.setSessionTimeout(getSessionTimeout()); 		} 		if (factory instanceof TomcatEmbeddedServletContainerFactory) { 			getTomcat().customizeTomcat((TomcatEmbeddedServletContainerFactory) factory); 		} 	}
@Override 	public void setPort(int port) { 		checkPort(port); 		this.port = port; 	}
@Override 	public void start() throws EmbeddedServletContainerException { 		if (!this.autoStart) { 			return; 		} 		try { 			this.server.start(); 			Connector[] connectors = this.server.getConnectors(); 			for (Connector connector : connectors) { 				connector.start(); 			} 		} 		catch (Exception ex) { 			throw new EmbeddedServletContainerException( 					"Unable to start embedded Jetty servlet container", ex); 		} 	}
@Override 	public EmbeddedServletContainer getEmbeddedServletContainer( 			ServletContextInitializer... initializers) { 		WebAppContext context = new WebAppContext(); 		Server server = new Server(new InetSocketAddress(getAddress(), getPort()));  		if (this.resourceLoader != null) { 			context.setClassLoader(this.resourceLoader.getClassLoader()); 		} 		String contextPath = getContextPath(); 		context.setContextPath(StringUtils.hasLength(contextPath) ? contextPath : "/"); 		configureDocumentRoot(context); 		if (isRegisterDefaultServlet()) { 			addDefaultServlet(context); 		} 		if (isRegisterJspServlet() 				&& ClassUtils.isPresent(getJspServletClassName(), getClass() 						.getClassLoader())) { 			addJspServlet(context); 		}  		ServletContextInitializer[] initializersToUse = mergeInitializers(initializers); 		Configuration[] configurations = getWebAppContextConfigurations(context, 				initializersToUse); 		context.setConfigurations(configurations); 		context.getSessionHandler().getSessionManager() 				.setMaxInactiveInterval(getSessionTimeout()); 		postProcessWebAppContext(context);  		server.setHandler(context); 		this.logger.info("Server initialized with port: " + getPort()); 		return getJettyEmbeddedServletContainer(server); 	}
@Override 			public void configure(WebAppContext context) throws Exception { 				ErrorHandler errorHandler = context.getErrorHandler(); 				addJettyErrorPages(errorHandler, getErrorPages()); 			}
@Override 			public void configure(WebAppContext context) throws Exception { 				MimeTypes mimeTypes = context.getMimeTypes(); 				for (MimeMappings.Mapping mapping : getMimeMappings()) { 					mimeTypes.addMimeMapping(mapping.getExtension(), 							mapping.getMimeType()); 				} 			}
protected JettyEmbeddedServletContainer getJettyEmbeddedServletContainer(Server server) { 		return new JettyEmbeddedServletContainer(server, getPort() > 0); 	}
@Override 	public void start() throws EmbeddedServletContainerException { 		Connector connector = this.tomcat.getConnector(); 		if (connector != null && this.autoStart) { 			try { 				connector.getProtocolHandler().start(); 			} 			catch (Exception ex) { 				this.logger.error("Cannot start connector: ", ex); 				throw new EmbeddedServletContainerException( 						"Unable to start embdedded Tomcat connectors", ex); 			} 		} 	}
protected void customizeConnector(Connector connector) { 		if (getPort() > 0) { 			connector.setPort(getPort()); 		} 		else { 			connector.setPort(8080); 		} 		if (connector.getProtocolHandler() instanceof AbstractProtocol) { 			if (getAddress() != null) { 				((AbstractProtocol) connector.getProtocolHandler()) 						.setAddress(getAddress()); 			} 		} 		// If ApplicationContext is slow to start we want Tomcat not to bind to the socket 		// prematurely... 		connector.setProperty("bindOnInit", "false"); 		for (TomcatConnectorCustomizer customizer : this.tomcatConnectorCustomizers) { 			customizer.customize(connector); 		} 	}
protected TomcatEmbeddedServletContainer getTomcatEmbeddedServletContainer( 			Tomcat tomcat) { 		return new TomcatEmbeddedServletContainer(tomcat, getPort() > 0); 	}
@Override 	public void increment(String metricName, int amount, Date timestamp) { 		Measurement current = this.metrics.get(metricName); 		if (current != null) { 			Object lock = this.locks.putIfAbsent(metricName, new Object()); 			if (lock == null) { 				lock = this.locks.get(metricName); 			} 			synchronized (lock) { 				current = this.metrics.get(metricName); 				Metric metric = current.getMetric(); 				this.metrics.replace(metricName, current, new Measurement(timestamp, 						metric.increment(amount))); 				return; 			} 		} 		this.metrics.putIfAbsent(metricName, new Measurement(timestamp, new Metric( 				metricName, amount))); 	}
@Override 	public void applyDependencies(DependencyCustomizer dependencies) { 		dependencies 				.ifAnyMissingClasses("org.springframework.web.servlet.mvc.Controller") 				.add("org.springframework", "spring-webmvc", 						dependencies.getProperty("spring.version"));  		dependencies.ifAnyMissingClasses("org.eclipse.jetty.server.Server").add( 				"org.eclipse.jetty", "jetty-webapp", 				dependencies.getProperty("jetty.version"));  		dependencies.add("org.codehaus.groovy", "groovy-templates", 				dependencies.getProperty("groovy.version")); 	}
@Bean 		public SpringTemplateEngine templateEngine() { 			SpringTemplateEngine engine = new SpringTemplateEngine(); 			for (ITemplateResolver templateResolver : this.templateResolvers) { 				engine.addTemplateResolver(templateResolver); 			} 			return engine; 		}
@Bean 		public SpringTemplateEngine templateEngine() { 			SpringTemplateEngine engine = new SpringTemplateEngine(); 			for (ITemplateResolver templateResolver : this.templateResolvers) { 				engine.addTemplateResolver(templateResolver); 			} 			engine.addDialect(new LayoutDialect()); 			return engine; 		}
@Test 	void userDefinedMappingsSecureByDefault() throws Exception { 		WebClient webClient = this.webClientBuilder.baseUrl("http://localhost:" + this.port + "/").build(); 		ClientResponse response = webClient.get().header("Authorization", getBasicAuth()).exchange() 				.block(Duration.ofSeconds(30)); 		assertThat(response.statusCode()).isEqualTo(HttpStatus.OK); 		ResponseCookie sessionCookie = response.cookies().getFirst("SESSION"); 		String sessionId = response.bodyToMono(String.class).block(Duration.ofSeconds(30)); 		response = webClient.get().cookie("SESSION", sessionCookie.getValue()).exchange().block(Duration.ofSeconds(30)); 		assertThat(response.statusCode()).isEqualTo(HttpStatus.OK); 		assertThat(response.bodyToMono(String.class).block(Duration.ofSeconds(30))).isEqualTo(sessionId); 		Thread.sleep(2000); 		response = webClient.get().cookie("SESSION", sessionCookie.getValue()).exchange().block(Duration.ofSeconds(30)); 		assertThat(response.statusCode()).isEqualTo(HttpStatus.UNAUTHORIZED); 	}
private void configureSession(Context context) { 		long sessionTimeout = getSessionTimeoutInMinutes(); 		context.setSessionTimeout((int) sessionTimeout); 		if (isPersistSession()) { 			Manager manager = context.getManager(); 			if (manager == null) { 				manager = new StandardManager(); 				context.setManager(manager); 			} 			Assert.state(manager instanceof StandardManager, 					"Unable to persist HTTP session state using manager type " 							+ manager.getClass().getName()); 			File folder = new ApplicationTemp().getFolder("tomcat-sessions"); 			File file = new File(folder, "SESSIONS.ser"); 			((StandardManager) manager).setPathname(file.getAbsolutePath()); 		} 	}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						try { 							Thread.sleep(500); 							date[0] = new Date(); 						} 						catch (InterruptedException ex) { 							throw new ServletException(ex); 						} 					}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						servletContext.addServlet("test", servlet).setLoadOnStartup(1); 					}
@Override 			public void service(ServletRequest request, ServletResponse response) 					throws ServletException, IOException { 				throw new RuntimeException("Planned"); 			}
@Override 			public void service(ServletRequest request, ServletResponse response) 					throws ServletException, IOException { 				HttpSession session = ((HttpServletRequest) request).getSession(true); 				long value = System.currentTimeMillis(); 				Object existing = session.getAttribute("boot"); 				session.setAttribute("boot", value); 				PrintWriter writer = response.getWriter(); 				writer.append(String.valueOf(existing) + ":" + value); 			}
@Override 			public void run() { 				TomcatEmbeddedServletContainerFactory factory = getFactory(); 				factory.setPort(port);  				try { 					TomcatEmbeddedServletContainerFactoryTests.this.container = factory 							.getEmbeddedServletContainer(); 					TomcatEmbeddedServletContainerFactoryTests.this.container.start(); 					fail(); 				} 				catch (IllegalStateException ex) { 					// Ignore 				} 			}
@Override 			public void run() { 				TomcatEmbeddedServletContainerFactory factory = getFactory(); 				Connector connector = new Connector( 						"org.apache.coyote.http11.Http11NioProtocol"); 				connector.setPort(port); 				factory.addAdditionalTomcatConnectors(connector);  				try { 					TomcatEmbeddedServletContainerFactoryTests.this.container = factory 							.getEmbeddedServletContainer(); 					TomcatEmbeddedServletContainerFactoryTests.this.container.start(); 					fail(); 				} 				catch (IllegalStateException ex) { 					// Ignore 				} 			}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						try { 							Thread.sleep(500); 							date[0] = new Date(); 						} 						catch (InterruptedException ex) { 							throw new ServletException(ex); 						} 					}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						servletContext.addServlet("test", servlet).setLoadOnStartup(1); 					}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						try { 							Thread.sleep(500); 							date[0] = new Date(); 						} 						catch (InterruptedException ex) { 							throw new ServletException(ex); 						} 					}
@Override 					public void onStartup(ServletContext servletContext) 							throws ServletException { 						servletContext.addServlet("test", servlet).setLoadOnStartup(1); 					}
protected void applyProperties(VelocityEngineFactory factory) { 			factory.setResourceLoaderPath(this.properties.getResourceLoaderPath()); 			factory.setPreferFileSystemAccess(this.properties.isPreferFileSystemAccess()); 			Properties velocityProperties = new Properties(); 			velocityProperties.putAll(this.properties.getProperties()); 			factory.setVelocityProperties(velocityProperties); 		}
protected void applyProperties(VelocityEngineFactory factory) { 			factory.setResourceLoaderPath(this.properties.getResourceLoaderPath()); 			factory.setPreferFileSystemAccess(this.properties.isPreferFileSystemAccess()); 			Properties velocityProperties = new Properties(); 			velocityProperties.putAll(this.properties.getProperties()); 			factory.setVelocityProperties(velocityProperties); 		}
@Test 	public void ownAuthenticationAuditListener() { 		registerAndRefresh(CustomAuthenticationAuditListenerConfiguration.class, 				AuditAutoConfiguration.class); 		assertThat(this.context.getBean(AbstractAuthenticationAuditListener.class)) 				.isInstanceOf(TestAuthenticationAuditListener.class); 	}
@Test 	public void ownAuthorizationAuditListener() { 		registerAndRefresh(CustomAuthorizationAuditListenerConfiguration.class, 				AuditAutoConfiguration.class); 		assertThat(this.context.getBean(AbstractAuthorizationAuditListener.class)) 				.isInstanceOf(TestAuthorizationAuditListener.class); 	}
@Test 	public void ownAuditListener() { 		registerAndRefresh(CustomAuditListenerConfiguration.class, 				AuditAutoConfiguration.class); 		assertThat(this.context.getBean(AbstractAuditListener.class)) 				.isInstanceOf(TestAuditListener.class); 	}
@Test 	public void runWhenEnabledPropertyIsFalseShouldNotHaveEndpoint() { 		this.contextRunner 				.withPropertyValues("management.endpoint.auditevents.enabled:false") 				.withPropertyValues("management.endpoints.web.exposure.include=*") 				.run((context) -> assertThat(context) 						.doesNotHaveBean(AuditEventsEndpoint.class)); 	}
public void process(AuthenticationAuditListener listener, 				AbstractAuthenticationEvent input) { 			if (listener != null) { 				AuthenticationSwitchUserEvent event = (AuthenticationSwitchUserEvent) input; 				Map<String, Object> data = new HashMap<>(); 				if (event.getAuthentication().getDetails() != null) { 					data.put("details", event.getAuthentication().getDetails()); 				} 				data.put("target", event.getTargetUser().getUsername()); 				listener.publish(new AuditEvent(event.getAuthentication().getName(), 						AUTHENTICATION_SWITCH, data)); 			}  		}
@Test 	public void filteredAuditEvents() throws Exception { 		OffsetDateTime now = OffsetDateTime.now(); 		String queryTimestamp = DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(now); 		given(this.repository.find("alice", now.toInstant(), "logout")).willReturn( 				Arrays.asList(new AuditEvent("alice", "logout", Collections.emptyMap()))); 		this.mockMvc 				.perform(get("/actuator/auditevents").param("principal", "alice") 						.param("after", queryTimestamp).param("type", "logout")) 				.andExpect(status().isOk()) 				.andDo(document("auditevents/filtered", 						requestParameters( 								parameterWithName("after").description( 										"Restricts the events to those that occurred " 												+ "after the given time. Required."), 								parameterWithName("principal").description( 										"Restricts the events to those with the given " 												+ "principal. Optional."), 						parameterWithName("type").description( 								"Restricts the events to those with the given " 										+ "type. Optional.")))); 		verify(this.repository).find("alice", now.toInstant(), "logout"); 	}
@ReadOperation 	public List<AuditEvent> eventsWithPrincipalDateAfterAndType(String principal, 			Date after, String type) { 		return this.auditEventRepository.find(principal, after, type); 	}
@ReadOperation 	public List<ThreadInfo> threadDump() { 		return Arrays 				.asList(ManagementFactory.getThreadMXBean().dumpAllThreads(true, true)); 	}
@ReadOperation 	public List<Trace> traces() { 		return this.repository.findAll(); 	}
@Test 	public void reactiveHealthWebEndpointExtensionCanBeDisabled() { 		reactiveWebContextRunner(HealthEndpointConfiguration.class) 				.withPropertyValues("endpoints.health.enabled=false").run((context) -> { 			assertThat(context).doesNotHaveBean(HealthReactiveWebEndpointExtension.class); 			assertThat(context).doesNotHaveBean(HealthWebEndpointExtension.class); 		});  	}
@Test 	public void reactiveStatusWebEndpointExtensionCanBeDisabled() { 		reactiveWebContextRunner(StatusEndpointConfiguration.class) 				.withPropertyValues("endpoints.status.enabled=false").run((context) -> { 			assertThat(context).doesNotHaveBean(StatusReactiveWebEndpointExtension.class); 			assertThat(context).doesNotHaveBean(StatusWebEndpointExtension.class); 		}); 	}
@Test 	public void logFileWebEndpointIsAutoConfiguredWhenExternalFileIsSet() { 		webContextRunner().withPropertyValues("endpoints.logfile.external-file:external.log") 				.run((context) -> assertThat( 						context.getBeansOfType(LogFileWebEndpoint.class)).hasSize(1)); 	}
@Test 	public void eventsWithType() { 		given(this.repository.find(null, null, "type")) 				.willReturn(Collections.singletonList(this.event)); 		List<AuditEvent> result = this.endpoint.eventsWithPrincipalDateAfterAndType(null, 				null, "type"); 		assertThat(result).isEqualTo(Collections.singletonList(this.event)); 	}
@Test 	public void eventsWithDateAfter() { 		Date date = new Date(); 		given(this.repository.find(null, date, null)) 				.willReturn(Collections.singletonList(this.event)); 		List<AuditEvent> result = this.endpoint.eventsWithPrincipalDateAfterAndType(null, 				date, null); 		assertThat(result).isEqualTo(Collections.singletonList(this.event)); 	}
@Test 	public void eventsWithPrincipal() { 		given(this.repository.find("Joan", null, null)) 				.willReturn(Collections.singletonList(this.event)); 		List<AuditEvent> result = this.endpoint 				.eventsWithPrincipalDateAfterAndType("Joan", null, null); 		assertThat(result).isEqualTo(Collections.singletonList(this.event)); 	}
@Test 	public void dumpThreads() throws Exception { 		assertThat(new ThreadDumpEndpoint().threadDump().size()).isGreaterThan(0); 	}
@Test 	public void trace() throws Exception { 		TraceRepository repository = new InMemoryTraceRepository(); 		repository.add(Collections.<String, Object>singletonMap("a", "b")); 		Trace trace = new TraceEndpoint(repository).traces().get(0); 		assertThat(trace.getInfo().get("a")).isEqualTo("b"); 	}
@Test 	public void eventsWithDateAfter() { 		Date date = new Date(); 		given(this.repository.find(null, date, null)) 				.willReturn(Collections.singletonList(this.event)); 		List<AuditEvent> result = this.extension.eventsWithDateAfter(date); 		assertThat(result).isEqualTo(Collections.singletonList(this.event)); 	}
@Test 	public void eventsWithPrincipalAndDateAfter() { 		Date date = new Date(); 		given(this.repository.find("Joan", date, null)) 				.willReturn(Collections.singletonList(this.event)); 		List<AuditEvent> result = this.extension.eventsWithPrincipalAndDateAfter("Joan", 				date); 		assertThat(result).isEqualTo(Collections.singletonList(this.event)); 	}
@Test 	public void testTrace() throws Exception { 		this.restTemplate.getForEntity("/health", String.class); 		@SuppressWarnings("rawtypes") 		ResponseEntity<List> entity = this.restTemplate 				.withBasicAuth("user", getPassword()) 				.getForEntity("/application/trace", List.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK); 		@SuppressWarnings("unchecked") 		List<Map<String, Object>> list = entity.getBody(); 		Map<String, Object> trace = list.get(list.size() - 1); 		@SuppressWarnings("unchecked") 		Map<String, Object> map = (Map<String, Object>) ((Map<String, Object>) ((Map<String, Object>) trace 				.get("info")).get("headers")).get("response"); 		assertThat(map.get("status")).isEqualTo("200"); 	}
@Test 	public void traceWithParameterMap() throws Exception { 		this.restTemplate.withBasicAuth("user", getPassword()) 				.getForEntity("/application/health?param1=value1", String.class); 		@SuppressWarnings("rawtypes") 		ResponseEntity<List> entity = this.restTemplate 				.withBasicAuth("user", getPassword()) 				.getForEntity("/application/trace", List.class); 		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK); 		@SuppressWarnings("unchecked") 		List<Map<String, Object>> list = entity.getBody(); 		Map<String, Object> trace = list.get(0); 		@SuppressWarnings("unchecked") 		Map<String, Object> map = (Map<String, Object>) ((Map<String, Object>) trace 				.get("info")).get("parameters"); 		assertThat(map.get("param1")).isNotNull(); 	}
@Override 	public void run(String... args) throws Exception { 		this.auditEventRepository.add(new AuditEvent(Date.from(Instant.parse( 				"2016-11-01T11:00:00Z")), "user", "AUTHENTICATION_FAILURE", 				Collections.emptyMap())); 		this.auditEventRepository.add(new AuditEvent(Date.from(Instant.parse( 				"2016-11-01T12:00:00Z")), "admin", "AUTHENTICATION_SUCCESS", 				Collections.emptyMap())); 	}
@Test 	public void invokeFilterByDateAfter() throws Exception { 		this.mvc.perform(get("/auditevents").param("after", "2016-11-01T13:00:00+0000")) 				.andExpect(status().isOk()).andExpect(content().string("[]")); 	}
@Test 	public void invokeFilterByPrincipalAndDateAfter() throws Exception { 		this.mvc.perform(get("/auditevents").param("principal", "user") 				.param("after", "2016-11-01T10:00:00+0000")) 				.andExpect(status().isOk()) 				.andExpect(content().string(containsString( 						"\"principal\":\"user\",\"type\":\"login\""))) 				.andExpect(content().string(not(containsString("admin")))); 	}
@Test 	public void invokeFilterByPrincipalAndDateAfterAndType() throws Exception { 		this.mvc.perform(get("/auditevents").param("principal", "admin") 				.param("after", "2016-11-01T10:00:00+0000") 				.param("type", "logout")).andExpect(status().isOk()) 				.andExpect(content().string(containsString( 						"\"principal\":\"admin\",\"type\":\"logout\""))) 				.andExpect(content().string(not(containsString("login")))); 	}
@Bean 		public AuditEventRepository auditEventsRepository() { 			AuditEventRepository repository = new InMemoryAuditEventRepository(3); 			repository.add(new AuditEvent(Date.from(Instant.parse( 					"2016-11-01T11:00:00Z")), "admin", "login", Collections.emptyMap())); 			repository.add(new AuditEvent(Date.from(Instant.parse( 					"2016-11-01T12:00:00Z")), "admin", "logout", Collections.emptyMap())); 			repository.add(new AuditEvent(Date.from(Instant.parse( 					"2016-11-01T12:00:00Z")), "user", "login", Collections.emptyMap())); 			return repository; 		}
@Test 	public void contextPath() throws Exception { 		EnvironmentTestUtils.addEnvironment(this.applicationContext, 				"management.contextPath:/test", "management.security.enabled:false"); 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				ServerPortConfig.class, PropertyPlaceholderAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, JacksonAutoConfiguration.class, 				EmbeddedServletContainerAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				DispatcherServletAutoConfiguration.class, WebMvcAutoConfiguration.class, 				EndpointWebMvcAutoConfiguration.class); 		this.applicationContext.refresh(); 		assertContent("/controller", ports.get().server, "controlleroutput"); 		assertContent("/test/endpoint", ports.get().server, "endpointoutput"); 	}
@Test 	public void overrideServerProperties() throws Exception { 		EnvironmentTestUtils.addEnvironment(this.applicationContext, 				"server.displayName:foo"); 		this.applicationContext.register(RootConfig.class, EndpointConfig.class, 				ServerPortConfig.class, PropertyPlaceholderAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				ServerPropertiesAutoConfiguration.class, JacksonAutoConfiguration.class, 				EmbeddedServletContainerAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				DispatcherServletAutoConfiguration.class, WebMvcAutoConfiguration.class, 				EndpointWebMvcAutoConfiguration.class); 		this.applicationContext.refresh(); 		assertContent("/controller", ports.get().server, "controlleroutput"); 		ServerProperties serverProperties = this.applicationContext 				.getBean(ServerProperties.class); 		assertThat(serverProperties.getDisplayName()).isEqualTo("foo"); 	}
@Test 	public void endpointsDefaultConfiguration() throws Exception { 		this.applicationContext.register(LoggingConfig.class, RootConfig.class, 				BaseConfiguration.class, ServerPortConfig.class, 				EndpointWebMvcAutoConfiguration.class); 		this.applicationContext.refresh(); 		// /health, /metrics, /loggers, /env, /actuator, /heapdump (/shutdown is disabled 		// by default) 		assertThat(this.applicationContext.getBeansOfType(MvcEndpoint.class)).hasSize(6); 	}
public int getCount() { 			return this.count; 		}
@Bean 		public SpecificEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new SpecificEmbeddedServletContainerFactory(); 		}
@Bean 		public SpecificEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new SpecificEmbeddedServletContainerFactory(); 		}
@Bean 		public TomcatEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new TomcatEmbeddedServletContainerFactory(); 		}
@Bean 		public TomcatEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new TomcatEmbeddedServletContainerFactory(); 		}
@Bean 		public UndertowEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new UndertowEmbeddedServletContainerFactory(); 		}
@Bean 		public UndertowEmbeddedServletContainerFactory embeddedServletContainerFactory() { 			return new UndertowEmbeddedServletContainerFactory(); 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			return management; 		}
public int getCount() { 				return this.count; 			}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			properties.getSecurity().setEnabled(false); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(0); 			properties.getSecurity().setEnabled(false); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
@Bean 		public ManagementServerProperties managementServerProperties() { 			ManagementServerProperties properties = new ManagementServerProperties(); 			properties.setPort(-1); 			return properties; 		}
@Test 	public void testWebConfiguration() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(SecurityAutoConfiguration.class, 				WebMvcAutoConfiguration.class, 				ManagementWebSecurityAutoConfiguration.class, 				JacksonAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		EnvironmentTestUtils.addEnvironment(this.context, "security.basic.enabled:false"); 		this.context.refresh(); 		assertThat(this.context.getBean(AuthenticationManagerBuilder.class)).isNotNull(); 		FilterChainProxy filterChainProxy = this.context.getBean(FilterChainProxy.class); 		// 1 for static resources, one for management endpoints and one for the rest 		assertThat(filterChainProxy.getFilterChains()).hasSize(3); 		assertThat(filterChainProxy.getFilters("/beans")).isNotEmpty(); 		assertThat(filterChainProxy.getFilters("/beans/")).isNotEmpty(); 		assertThat(filterChainProxy.getFilters("/beans.foo")).isNotEmpty(); 		assertThat(filterChainProxy.getFilters("/beans/foo/bar")).isNotEmpty(); 	}
@Test 	public void realmSameForManagement() throws Exception { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(AuthenticationConfig.class, SecurityAutoConfiguration.class, 				ManagementWebSecurityAutoConfiguration.class, 				JacksonAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				WebMvcAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class); 		this.context.refresh();  		Filter filter = this.context.getBean("springSecurityFilterChain", Filter.class); 		MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context) 				.addFilters(filter).build();  		// no user (Main) 		mockMvc.perform(MockMvcRequestBuilders.get("/home")) 				.andExpect(MockMvcResultMatchers.status().isUnauthorized()) 				.andExpect(springAuthenticateRealmHeader());  		// invalid user (Main) 		mockMvc.perform( 				MockMvcRequestBuilders.get("/home").header("authorization", "Basic xxx")) 				.andExpect(MockMvcResultMatchers.status().isUnauthorized()) 				.andExpect(springAuthenticateRealmHeader());  		// no user (Management) 		mockMvc.perform(MockMvcRequestBuilders.get("/beans")) 				.andExpect(MockMvcResultMatchers.status().isUnauthorized()) 				.andExpect(springAuthenticateRealmHeader());  		// invalid user (Management) 		mockMvc.perform( 				MockMvcRequestBuilders.get("/beans").header("authorization", "Basic xxx")) 				.andExpect(MockMvcResultMatchers.status().isUnauthorized()) 				.andExpect(springAuthenticateRealmHeader()); 	}
@Parameters(name = "{0}") 	public static Object[] parameters() { 		return new Object[] { new Object[] { "actuator", HalJsonMvcEndpoint.class }, 				new Object[] { "autoconfig", AutoConfigurationReportEndpoint.class }, 				new Object[] { "beans", BeansEndpoint.class }, 				new Object[] { "configprops", 						ConfigurationPropertiesReportEndpoint.class }, 				new Object[] { "docs", DocsMvcEndpoint.class }, 				new Object[] { "dump", DumpEndpoint.class }, 				new Object[] { "env", EnvironmentMvcEndpoint.class }, 				new Object[] { "flyway", FlywayEndpoint.class }, 				new Object[] { "health", HealthMvcEndpoint.class }, 				new Object[] { "info", InfoEndpoint.class }, 				new Object[] { "jolokia", JolokiaMvcEndpoint.class }, 				new Object[] { "liquibase", LiquibaseEndpoint.class }, 				new Object[] { "logfile", LogFileMvcEndpoint.class }, 				new Object[] { "loggers", LoggersMvcEndpoint.class }, 				new Object[] { "mappings", RequestMappingEndpoint.class }, 				new Object[] { "metrics", MetricsMvcEndpoint.class }, 				new Object[] { "shutdown", ShutdownEndpoint.class }, 				new Object[] { "trace", TraceEndpoint.class } }; 	}
@Test 	public void endpointsDoNotHaveLinks() throws Exception { 		for (MvcEndpoint endpoint : this.mvcEndpoints.getEndpoints()) { 			String path = endpoint.getPath(); 			if ("/actuator".equals(path) || endpoint instanceof HeapdumpMvcEndpoint) { 				continue; 			} 			path = path.length() > 0 ? path : "/"; 			this.mockMvc.perform(get(path).accept(MediaType.APPLICATION_JSON)) 					.andExpect(status().isOk()) 					.andExpect(jsonPath("$._links").doesNotExist()); 		} 	}
@Test 	public void endpointsEachHaveSelf() throws Exception { 		Set<String> collections = new HashSet<String>( 				Arrays.asList("/trace", "/beans", "/dump", "/heapdump", "/loggers")); 		for (MvcEndpoint endpoint : this.mvcEndpoints.getEndpoints()) { 			String path = endpoint.getPath(); 			if (collections.contains(path)) { 				continue; 			} 			path = path.length() > 0 ? path : "/"; 			this.mockMvc.perform(get(path).accept(MediaType.APPLICATION_JSON)) 					.andExpect(status().isOk()).andExpect(jsonPath("$._links.self.href") 							.value("http://localhost" + endpoint.getPath())); 		} 	}
@After 	public void reset() { 		this.endpoint.reset(); 	}
public void reset() { 			this.available = true; 			this.locked = false; 			this.heapDump = "HEAPDUMP"; 		}
@Override 				public void contribute(Info.Builder builder) { 					Map<String, Object> content = new LinkedHashMap<String, Object>(); 					content.put("key11", "value11"); 					content.put("key12", "value12"); 					builder.withDetail("beanName1", content); 				}
@Override 				public void contribute(Info.Builder builder) { 					Map<String, Object> content = new LinkedHashMap<String, Object>(); 					content.put("key21", "value21"); 					content.put("key22", "value22"); 					builder.withDetail("beanName2", content); 				}
@Before 	public void createContext() { 		this.context = new AnnotationConfigWebApplicationContext(); 		this.context.setServletContext(new MockServletContext()); 		this.context.register(JacksonAutoConfiguration.class, 				HttpMessageConvertersAutoConfiguration.class, 				EndpointAutoConfiguration.class, EndpointWebMvcAutoConfiguration.class, 				ManagementServerPropertiesAutoConfiguration.class, 				PropertyPlaceholderAutoConfiguration.class, 				JolokiaAutoConfiguration.class, WebMvcAutoConfiguration.class); 	}
private void onAuthenticationFailureEvent(AbstractAuthenticationFailureEvent event) { 		Map<String, Object> data = new HashMap<String, Object>(); 		data.put("type", event.getException().getClass().getName()); 		data.put("message", event.getException().getMessage()); 		if (event.getAuthentication().getDetails() != null) { 			data.put("details", event.getAuthentication().getDetails()); 		} 		publish(new AuditEvent(event.getAuthentication().getName(), 				"AUTHENTICATION_FAILURE", data)); 	}
private void onAuthenticationSuccessEvent(AuthenticationSuccessEvent event) { 		Map<String, Object> data = new HashMap<String, Object>(); 		if (event.getAuthentication().getDetails() != null) { 			data.put("details", event.getAuthentication().getDetails()); 		} 		publish(new AuditEvent(event.getAuthentication().getName(), 				"AUTHENTICATION_SUCCESS", data)); 	}
public void process(AuthenticationAuditListener listener, 				AbstractAuthenticationEvent input) { 			if (listener != null) { 				AuthenticationSwitchUserEvent event = (AuthenticationSwitchUserEvent) input; 				Map<String, Object> data = new HashMap<String, Object>(); 				if (event.getAuthentication().getDetails() != null) { 					data.put("details", event.getAuthentication().getDetails()); 				} 				data.put("target", event.getTargetUser().getUsername()); 				listener.publish(new AuditEvent(event.getAuthentication().getName(), 						"AUTHENTICATION_SWITCH", data)); 			}  		}
private void onAuthenticationCredentialsNotFoundEvent( 			AuthenticationCredentialsNotFoundEvent event) { 		Map<String, Object> data = new HashMap<String, Object>(); 		data.put("type", event.getCredentialsNotFoundException().getClass().getName()); 		data.put("message", event.getCredentialsNotFoundException().getMessage()); 		publish(new AuditEvent("<unknown>", "AUTHENTICATION_FAILURE", data)); 	}
private void onAuthorizationFailureEvent(AuthorizationFailureEvent event) { 		Map<String, Object> data = new HashMap<String, Object>(); 		data.put("type", event.getAccessDeniedException().getClass().getName()); 		data.put("message", event.getAccessDeniedException().getMessage()); 		if (event.getAuthentication().getDetails() != null) { 			data.put("details", event.getAuthentication().getDetails()); 		} 		publish(new AuditEvent(event.getAuthentication().getName(), 				"AUTHORIZATION_FAILURE", data)); 	}
@Test 	public void testAuthenticationSuccess() { 		this.listener.onApplicationEvent(new AuthenticationSuccessEvent( 				new UsernamePasswordAuthenticationToken("user", "password"))); 		verify(this.publisher).publishEvent((ApplicationEvent) anyObject()); 	}
@Test 	public void testAuthenticationFailed() { 		this.listener.onApplicationEvent(new AuthenticationFailureExpiredEvent( 				new UsernamePasswordAuthenticationToken("user", "password"), 				new BadCredentialsException("Bad user"))); 		verify(this.publisher).publishEvent((ApplicationEvent) anyObject()); 	}
@Test 	public void testAuthenticationSwitch() { 		this.listener.onApplicationEvent(new AuthenticationSwitchUserEvent( 				new UsernamePasswordAuthenticationToken("user", "password"), 				new User("user", "password", 						AuthorityUtils.commaSeparatedStringToAuthorityList("USER")))); 		verify(this.publisher).publishEvent((ApplicationEvent) anyObject()); 	}
@Test 	public void testDetailsAreIncludedInAuditEvent() throws Exception { 		Object details = new Object(); 		UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken( 				"user", "password"); 		authentication.setDetails(details); 		this.listener.onApplicationEvent(new AuthenticationFailureExpiredEvent( 				authentication, new BadCredentialsException("Bad user"))); 		ArgumentCaptor<AuditApplicationEvent> auditApplicationEvent = ArgumentCaptor 				.forClass(AuditApplicationEvent.class); 		verify(this.publisher).publishEvent(auditApplicationEvent.capture()); 		assertThat(auditApplicationEvent.getValue().getAuditEvent().getData()) 				.containsEntry("details", details); 	}
@Test 	public void testAuthenticationCredentialsNotFound() { 		this.listener.onApplicationEvent(new AuthenticationCredentialsNotFoundEvent(this, 				Arrays.<ConfigAttribute>asList(new SecurityConfig("USER")), 				new AuthenticationCredentialsNotFoundException("Bad user"))); 		verify(this.publisher).publishEvent((ApplicationEvent) anyObject()); 	}
@Test 	public void testAuthorizationFailure() { 		this.listener.onApplicationEvent(new AuthorizationFailureEvent(this, 				Arrays.<ConfigAttribute>asList(new SecurityConfig("USER")), 				new UsernamePasswordAuthenticationToken("user", "password"), 				new AccessDeniedException("Bad user"))); 		verify(this.publisher).publishEvent((ApplicationEvent) anyObject()); 	}
@Test 	public void testDetailsAreIncludedInAuditEvent() throws Exception { 		Object details = new Object(); 		UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken( 				"user", "password"); 		authentication.setDetails(details); 		this.listener.onApplicationEvent(new AuthorizationFailureEvent(this, 				Arrays.<ConfigAttribute>asList(new SecurityConfig("USER")), 				authentication, new AccessDeniedException("Bad user"))); 		ArgumentCaptor<AuditApplicationEvent> auditApplicationEvent = ArgumentCaptor 				.forClass(AuditApplicationEvent.class); 		verify(this.publisher).publishEvent(auditApplicationEvent.capture()); 		assertThat(auditApplicationEvent.getValue().getAuditEvent().getData()) 				.containsEntry("details", details); 	}
@Override 	public void onApplicationEvent(AbstractAuthenticationEvent event) { 		if (event instanceof AbstractAuthenticationFailureEvent) { 			onAuthenticationFailureEvent((AbstractAuthenticationFailureEvent) event); 		} 		else if (this.webListener != null && this.webListener.accepts(event)) { 			this.webListener.process(this, event); 		} 		else { 			onAuthenticationEvent(event); 		} 	}
@Override 	public void onApplicationEvent(AuditApplicationEvent event) { 		logger.info(event.getAuditEvent()); 		this.auditEventRepository.add(event.getAuditEvent()); 	}
@PostConstruct 	protected void initialize() { 		if (!this.properties.isDeferDdl()) { 			boolean initialize = this.properties.isInitialize(); 			if (!initialize) { 				logger.debug("Initialization disabled (not running DDL scripts)"); 				return; 			} 			runSchemaScripts(); 		} 	}
@Override 	protected Map<String, String> getVendorProperties() { 		return this.properties.getInitialHibernateProperties(this.dataSource); 	}
public Map<String, String> getHibernateProperties(DataSource dataSource) { 		return this.hibernate 				.getDeferredAdditionalProperties(this.properties, dataSource); 	}
@Deprecated 		public void setNamingstrategy(Class<?> namingStrategy) { 			logger.warn("The property spring.jpa.namingstrategy has been renamed, " 					+ "please update your configuration to use naming-strategy"); 			this.setNamingStrategy(namingStrategy); 		}
@Override 		public void doFilter(ServletRequest request, ServletResponse response, 				FilterChain chain) throws IOException, ServletException { 			HttpServletRequest servletRequest = (HttpServletRequest) request; 			HttpServletResponse servletResponse = (HttpServletResponse) response; 			UrlPathHelper helper = new UrlPathHelper(); 			String suffix = helper.getPathWithinApplication(servletRequest); 			int status = 999; 			DateTime t0 = new DateTime(); 			try { 				chain.doFilter(request, response); 			} finally { 				try { 					status = servletResponse.getStatus(); 				} catch (Exception e) { 					// ignore 				} 				set("response", suffix, new Duration(t0, new DateTime()).getMillis()); 				increment("status." + status, suffix); 			} 		}
@Override 		protected void configure(HttpConfigurator http) throws Exception { 			http.antMatcher("/**").httpBasic().and().anonymous().disable(); 			if (this.security.isRequireSsl()) { 				http.requiresChannel().antMatchers("/**").requiresSecure(); 			} 		}
@Bean 		public AuthenticationManager authenticationManager() throws Exception { 			return new AuthenticationBuilder().inMemoryAuthentication().withUser("user") 					.password("password").roles("USER").and().and().build(); 		}
@Override 	protected void configureMessageConverters(List<HttpMessageConverter<?>> converters) { 		addDefaultHttpMessageConverters(converters); 		for (HttpMessageConverter<?> converter : converters) { 			if (converter instanceof MappingJackson2HttpMessageConverter) { 				MappingJackson2HttpMessageConverter jacksonConverter = (MappingJackson2HttpMessageConverter) converter; 				jacksonConverter.getObjectMapper().registerModule(new JodaModule()); 				jacksonConverter.getObjectMapper().disable( 						SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); 			} 		} 	}
@Override 	public void onApplicationEvent(AuditApplicationEvent event) { 		this.auditEventRepository.add(event.getAuditEvent()); 	}
@Override 	public void increment(String metricName) { 		this.counterRepository.increment(wrap(metricName), 1, new DateTime()); 	}
@Override 	public void decrement(String metricName) { 		this.counterRepository.increment(wrap(metricName), -1, new DateTime()); 	}
@Override 	public void reset(String metricName) { 		this.counterRepository.set(wrap(metricName), 0, new DateTime()); 	}
@Override 	public void set(String metricName, double value) { 		this.metricRepository.set(wrap(metricName), value, new DateTime()); 	}
@Override 	public String toString() { 		return "Measurement [dateTime=" + this.dateTime + ", metric=" + this.metric + "]"; 	}
@Override 	public int hashCode() { 		final int prime = 31; 		int result = 1; 		result = prime * result 				+ ((this.dateTime == null) ? 0 : this.dateTime.hashCode()); 		result = prime * result + ((this.metric == null) ? 0 : this.metric.hashCode()); 		return result; 	}
@Override 	public boolean equals(Object obj) { 		if (this == obj) 			return true; 		if (obj == null) 			return false; 		if (getClass() != obj.getClass()) 			return false; 		Measurement other = (Measurement) obj; 		if (this.dateTime == null) { 			if (other.dateTime != null) 				return false; 		} else if (!this.dateTime.equals(other.dateTime)) 			return false; 		if (this.metric == null) { 			if (other.metric != null) 				return false; 		} else if (!this.metric.equals(other.metric)) 			return false; 		return true; 	}
@Override 	public void add(Map<String, Object> map) { 		Trace trace = new Trace(new DateTime(), map); 		synchronized (this.traces) { 			while (this.traces.size() >= this.capacity) { 				this.traces.remove(0); 			} 			this.traces.add(trace); 		} 	}
public static void configureHeaders(HeadersConfigurer<?> configurer, 			SecurityProperties.Headers headers) throws Exception { 		if (headers.getHsts() != Headers.HSTS.NONE) { 			boolean includeSubdomains = headers.getHsts() == Headers.HSTS.ALL; 			HstsHeaderWriter writer = new HstsHeaderWriter(includeSubdomains); 			writer.setRequestMatcher(AnyRequestMatcher.INSTANCE); 			configurer.addHeaderWriter(writer); 		} 		if (headers.isContentType()) { 			configurer.contentTypeOptions(); 		} 		if (headers.isXss()) { 			configurer.xssProtection(); 		} 		if (headers.isCache()) { 			configurer.cacheControl(); 		} 		if (headers.isFrame()) { 			configurer.frameOptions(); 		} 	}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.requestMatcher(new RequestMatcher() { 				@Override 				public boolean matches(HttpServletRequest request) { 					return false; 				} 			}); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			if (this.security.isRequireSsl()) { 				http.requiresChannel().anyRequest().requiresSecure(); 			} 			if (!this.security.isEnableCsrf()) { 				http.csrf().disable(); 			} 			// No cookies for application endpoints by default 			http.sessionManagement().sessionCreationPolicy(this.security.getSessions()); 			SpringBootWebSecurityConfiguration.configureHeaders(http.headers(), 					this.security.getHeaders()); 			String[] paths = getSecureApplicationPaths(); 			if (paths.length > 0) { 				AuthenticationEntryPoint entryPoint = entryPoint(); 				http.exceptionHandling().authenticationEntryPoint(entryPoint); 				http.httpBasic().authenticationEntryPoint(entryPoint); 				http.requestMatchers().antMatchers(paths); 				String[] roles = this.security.getUser().getRole().toArray(new String[0]); 				SecurityAuthorizeMode mode = this.security.getBasic().getAuthorizeMode(); 				if (mode == null || mode == SecurityAuthorizeMode.ROLE) { 					http.authorizeRequests().anyRequest().hasAnyRole(roles); 				} 				else if (mode == SecurityAuthorizeMode.AUTHENTICATED) { 					http.authorizeRequests().anyRequest().authenticated(); 				} 			} 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().anyRequest().denyAll(); 		}
@Override 		protected void configure(HttpSecurity http) throws Exception { 			http.authorizeRequests().antMatchers(HttpMethod.POST, "/**").denyAll(); 		}
@Test 	void scheduledTasks() throws Exception { 		this.mockMvc.perform(get("/actuator/scheduledtasks")).andExpect(status().isOk()) 				.andDo(document("scheduled-tasks", 						preprocessResponse(replacePattern( 								Pattern.compile("org.*\\.ScheduledTasksEndpointDocumentationTests\\$TestConfiguration"), 								"com.example.Processor")), 						responseFields(fieldWithPath("cron").description("Cron tasks, if any."), 								targetFieldWithPrefix("cron.[]."), 								fieldWithPath("cron.[].expression").description("Cron expression."), 								fieldWithPath("fixedDelay").description("Fixed delay tasks, if any."), 								targetFieldWithPrefix("fixedDelay.[]."), initialDelayWithPrefix("fixedDelay.[]."), 								fieldWithPath("fixedDelay.[].interval") 										.description("Interval, in milliseconds, between the end of the last" 												+ " execution and the start of the next."), 								fieldWithPath("fixedRate").description("Fixed rate tasks, if any."), 								targetFieldWithPrefix("fixedRate.[]."), 								fieldWithPath("fixedRate.[].interval") 										.description("Interval, in milliseconds, between the start of each execution."), 								initialDelayWithPrefix("fixedRate.[]."), 								fieldWithPath("custom").description("Tasks with custom triggers, if any."), 								targetFieldWithPrefix("custom.[]."), 								fieldWithPath("custom.[].trigger").description("Trigger for the task.")))) 				.andDo(MockMvcResultHandlers.print()); 	}
@Test 	void linksAreProvidedToAllEndpointTypes() throws Exception { 		this.context = new AnnotationConfigServletWebApplicationContext(); 		this.context.register(DefaultConfiguration.class, EndpointsConfiguration.class); 		TestPropertyValues.of("management.endpoints.web.exposure.include=*").applyTo(this.context); 		MockMvc mockMvc = doCreateMockMvc(); 		mockMvc.perform(get("/actuator").accept("*/*")).andExpect(status().isOk()).andExpect(jsonPath("_links", 				both(hasKey("beans")).and(hasKey("servlet")).and(hasKey("restcontroller")).and(hasKey("controller")))); 	}
@Test // gh-17938 	void errorPageAndErrorControllerAreUsed() { 		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new) 				.withConfiguration(AutoConfigurations.of(ManagementContextAutoConfiguration.class, 						ServletWebServerFactoryAutoConfiguration.class, ServletManagementContextAutoConfiguration.class, 						WebEndpointAutoConfiguration.class, EndpointAutoConfiguration.class, 						DispatcherServletAutoConfiguration.class, ErrorMvcAutoConfiguration.class)) 				.withUserConfiguration(FailingEndpoint.class) 				.withInitializer(new ServerPortInfoApplicationContextInitializer()).withPropertyValues("server.port=0", 						"management.server.port=0", "management.endpoints.web.exposure.include=*") 				.run((context) -> { 					String port = context.getEnvironment().getProperty("local.management.port"); 					WebClient client = WebClient.create("http://localhost:" + port); 					ClientResponse response = client.get().uri("actuator/fail").accept(MediaType.APPLICATION_JSON) 							.exchange().block(); 					assertThat(response.bodyToMono(String.class).block()).contains("message\":\"Epic Fail"); 				}); 	}
private WebOperation findOperationWithRequestPath(ExposableWebEndpoint endpoint, String requestPath) { 		for (WebOperation operation : endpoint.getOperations()) { 			if (operation.getRequestPredicate().getPath().equals(requestPath)) { 				return operation; 			} 		} 		throw new IllegalStateException( 				"No operation found with request path " + requestPath + " from " + endpoint.getOperations()); 	}
private WebOperation findOperationWithRequestPath(ExposableWebEndpoint endpoint, String requestPath) { 		for (WebOperation operation : endpoint.getOperations()) { 			if (operation.getRequestPredicate().getPath().equals(requestPath)) { 				return operation; 			} 		} 		throw new IllegalStateException( 				"No operation found with request path " + requestPath + " from " + endpoint.getOperations()); 	}
@Test 	void health() throws Exception { 		FieldDescriptor status = fieldWithPath("status").description("Overall status of the application."); 		FieldDescriptor components = fieldWithPath("details").description("The components that make up the health."); 		FieldDescriptor componentStatus = fieldWithPath("details.*.status") 				.description("Status of a specific part of the application."); 		FieldDescriptor componentDetails = subsectionWithPath("details.*.details") 				.description("Details of the health of a specific part of the application. " 						+ "Presence is controlled by `management.endpoint.health.show-details`. May contain nested " 						+ "components that make up the health.") 				.optional(); 		this.mockMvc.perform(get("/actuator/health")).andExpect(status().isOk()) 				.andDo(document("health", responseFields(status, components, componentStatus, componentDetails))); 	}
@Test 	void healthComponent() throws Exception { 		this.mockMvc.perform(get("/actuator/health/db")).andExpect(status().isOk()) 				.andDo(document("health/component", responseFields(componentFields))); 	}
@Test 	void healthComponentInstance() throws Exception { 		this.mockMvc.perform(get("/actuator/health/broker/us1")).andExpect(status().isOk()) 				.andDo(document("health/instance", responseFields(componentFields))); 	}
@Test 	void runCreatesHealthEndpointWebExtension() { 		this.contextRunner.run((context) -> { 			HealthEndpointWebExtension webExtension = context.getBean(HealthEndpointWebExtension.class); 			WebEndpointResponse<HealthComponent> response = webExtension.health(SecurityContext.NONE, true, "simple"); 			Health health = (Health) response.getBody(); 			assertThat(response.getStatus()).isEqualTo(200); 			assertThat(health.getDetails()).containsEntry("counter", 42); 		}); 	}
@Test 	void runWhenHasHealthEndpointWebExtensionBeanDoesNotCreateExtraHealthEndpointWebExtension() { 		this.contextRunner.withUserConfiguration(HealthEndpointWebExtensionConfiguration.class).run((context) -> { 			HealthEndpointWebExtension webExtension = context.getBean(HealthEndpointWebExtension.class); 			WebEndpointResponse<HealthComponent> response = webExtension.health(SecurityContext.NONE, true, "simple"); 			assertThat(response).isNull(); 		}); 	}
@Test 	void runCreatesReactiveHealthEndpointWebExtension() { 		this.reactiveContextRunner.run((context) -> { 			ReactiveHealthEndpointWebExtension webExtension = context.getBean(ReactiveHealthEndpointWebExtension.class); 			Mono<WebEndpointResponse<? extends HealthComponent>> response = webExtension.health(SecurityContext.NONE, 					true, "simple"); 			Health health = (Health) (response.block().getBody()); 			assertThat(health.getDetails()).containsEntry("counter", 42); 		}); 	}
@Test 	void runWhenHasReactiveHealthEndpointWebExtensionBeanDoesNotCreateExtraReactiveHealthEndpointWebExtension() { 		this.reactiveContextRunner.withUserConfiguration(ReactiveHealthEndpointWebExtensionConfiguration.class) 				.run((context) -> { 					ReactiveHealthEndpointWebExtension webExtension = context 							.getBean(ReactiveHealthEndpointWebExtension.class); 					Mono<WebEndpointResponse<? extends HealthComponent>> response = webExtension 							.health(SecurityContext.NONE, true, "simple"); 					assertThat(response).isNull(); 				}); 	}
public static Builder unknown() { 		return status(Status.UNKNOWN); 	}
public static Builder up() { 		return status(Status.UP); 	}
public static Builder down() { 		return status(Status.DOWN); 	}
public static Builder outOfService() { 		return status(Status.OUT_OF_SERVICE); 	}
public static Builder status(String statusCode) { 		return status(new Status(statusCode)); 	}
public static Builder status(Status status) { 		return new Builder(status); 	}
public Builder unknown() { 			return status(Status.UNKNOWN); 		}
public Builder up() { 			return status(Status.UP); 		}
public Builder down() { 			return status(Status.DOWN); 		}
public Builder outOfService() { 			return status(Status.OUT_OF_SERVICE); 		}
public Builder status(String statusCode) { 			return status(new Status(statusCode)); 		}
public Builder status(Status status) { 			this.status = status; 			return this; 		}
@ReadOperation 	public HealthComponent health() { 		return healthForPath(EMPTY_PATH); 	}
@ReadOperation 	public HealthComponent healthForPath(@Selector(match = Match.ALL_REMAINING) String... path) { 		HealthResult<HealthComponent> result = getHealth(SecurityContext.NONE, true, path); 		return (result != null) ? result.getHealth() : null; 	}
@Test 	void createWhenStatusIsNullThrowsException() { 		assertThatIllegalArgumentException().isThrownBy(() -> new CompositeHealth(null, Collections.emptyMap())) 				.withMessage("Status must not be null"); 	}
@Test 	void getStatusReturnsStatus() { 		CompositeHealth health = new CompositeHealth(Status.UP, Collections.emptyMap()); 		assertThat(health.getStatus()).isEqualTo(Status.UP); 	}
@Test 	void getComponentReturnsComponents() { 		Map<String, HealthComponent> components = new LinkedHashMap<>(); 		components.put("a", Health.up().build()); 		CompositeHealth health = new CompositeHealth(Status.UP, components); 		assertThat(health.getDetails()).isEqualTo(components); 	}
@Test 	void getHealthResultWhenPathIsEmptyUsesPrimaryGroup() { 		this.registry.registerContributor("test", createContributor(this.up)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(SecurityContext.NONE, false); 		assertThat(result.getGroup()).isEqualTo(this.primaryGroup); 		assertThat(getHealth(result)).isNotSameAs(this.up); 		assertThat(getHealth(result).getStatus()).isEqualTo(Status.UP); 	}
@Test 	void getHealthResultWhenPathIsNotGroupReturnsResultFromPrimaryGroup() { 		this.registry.registerContributor("test", createContributor(this.up)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(SecurityContext.NONE, false, "test"); 		assertThat(result.getGroup()).isEqualTo(this.primaryGroup); 		assertThat(getHealth(result)).isEqualTo(this.up);  	}
@Test 	void getHealthResultWhenPathIsGroupReturnsResultFromGroup() { 		this.registry.registerContributor("atest", createContributor(this.up)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(SecurityContext.NONE, false, "alltheas", 				"atest"); 		assertThat(result.getGroup()).isEqualTo(this.allTheAs); 		assertThat(getHealth(result)).isEqualTo(this.up); 	}
@Test 	void getHealthResultWhenAlwaysIncludesDetailsIsFalseAndGroupIsTrueIncludesDetails() { 		this.registry.registerContributor("test", createContributor(this.up)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(SecurityContext.NONE, false, "test"); 		assertThat(((Health) getHealth(result)).getDetails()).containsEntry("spring", "boot"); 	}
@Test 	void getHealthResultWhenAlwaysIncludesDetailsIsFalseAndGroupIsFalseIncludesNoDetails() { 		this.primaryGroup.setIncludeDetails(false); 		this.registry.registerContributor("test", createContributor(this.up)); 		HealthEndpointSupport<C, T> endpoint = create(this.registry, this.groups); 		HealthResult<T> rootResult = endpoint.getHealth(SecurityContext.NONE, false); 		HealthResult<T> componentResult = endpoint.getHealth(SecurityContext.NONE, false, "test"); 		assertThat(((CompositeHealth) getHealth(rootResult)).getStatus()).isEqualTo(Status.UP); 		assertThat(componentResult).isNull(); 	}
@Test 	void getHealthResultWhenAlwaysIncludesDetailsIsTrueIncludesDetails() { 		this.primaryGroup.setIncludeDetails(false); 		this.registry.registerContributor("test", createContributor(this.up)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(SecurityContext.NONE, true, "test"); 		assertThat(((Health) getHealth(result)).getDetails()).containsEntry("spring", "boot"); 	}
@Test 	void getHealthResultWhenCompositeReturnsAggregateResult() { 		Map<String, C> contributors = new LinkedHashMap<>(); 		contributors.put("a", createContributor(this.up)); 		contributors.put("b", createContributor(this.down)); 		this.registry.registerContributor("test", createCompositeContributor(contributors)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(SecurityContext.NONE, false); 		CompositeHealth root = (CompositeHealth) getHealth(result); 		CompositeHealth component = (CompositeHealth) root.getDetails().get("test"); 		assertThat(root.getStatus()).isEqualTo(Status.DOWN); 		assertThat(component.getStatus()).isEqualTo(Status.DOWN); 		assertThat(component.getDetails()).containsOnlyKeys("a", "b"); 	}
@Test 	void getHealthResultWhenPathDoesNotExistReturnsNull() { 		HealthResult<T> result = create(this.registry, this.groups).getHealth(SecurityContext.NONE, false, "missing"); 		assertThat(result).isNull(); 	}
@Test 	void getHealthResultWhenPathIsEmptyIncludesGroups() { 		this.registry.registerContributor("test", createContributor(this.up)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(SecurityContext.NONE, false); 		assertThat(((SystemHealth) getHealth(result)).getGroups()).containsOnly("alltheas"); 	}
@Test 	void getHealthResultWhenPathIsGroupDoesNotIncludesGroups() { 		this.registry.registerContributor("atest", createContributor(this.up)); 		HealthResult<T> result = create(this.registry, this.groups).getHealth(SecurityContext.NONE, false, "alltheas"); 		assertThat(getHealth(result)).isNotInstanceOf(SystemHealth.class); 	}
@Test 	@SuppressWarnings("deprecation") 	void createWhenUsingDeprecatedConstructorThrowsException() { 		HealthEndpoint delegate = mock(HealthEndpoint.class); 		HealthWebEndpointResponseMapper responseMapper = mock(HealthWebEndpointResponseMapper.class); 		assertThatIllegalStateException().isThrownBy(() -> new HealthEndpointWebExtension(delegate, responseMapper)) 				.withMessage( 						"Unable to create class org.springframework.boot.actuate.health.HealthEndpointWebExtension " 								+ "using deprecated constructor"); 	}
@Test 	void healthReturnsSystemHealth() { 		this.registry.registerContributor("test", createContributor(this.up)); 		WebEndpointResponse<HealthComponent> response = create(this.registry, this.groups).health(SecurityContext.NONE); 		HealthComponent health = response.getBody(); 		assertThat(health.getStatus()).isEqualTo(Status.UP); 		assertThat(health).isInstanceOf(SystemHealth.class); 		assertThat(response.getStatus()).isEqualTo(200); 	}
@Test 	void healthWhenPathDoesNotExistReturnsHttp404() { 		this.registry.registerContributor("test", createContributor(this.up)); 		WebEndpointResponse<HealthComponent> response = create(this.registry, this.groups).health(SecurityContext.NONE, 				"missing"); 		assertThat(response.getBody()).isNull(); 		assertThat(response.getStatus()).isEqualTo(404); 	}
@Test 	void healthWhenPathExistsReturnsHealth() { 		this.registry.registerContributor("test", createContributor(this.up)); 		WebEndpointResponse<HealthComponent> response = create(this.registry, this.groups).health(SecurityContext.NONE, 				"test"); 		assertThat(response.getBody()).isEqualTo(this.up); 		assertThat(response.getStatus()).isEqualTo(200); 	}
@WebEndpointTest 	void whenHealthIsUp200ResponseIsReturned(WebTestClient client) { 		client.get().uri("/actuator/health").exchange().expectStatus().isOk().expectBody().jsonPath("status") 				.isEqualTo("UP").jsonPath("details.alpha.status").isEqualTo("UP").jsonPath("details.bravo.status") 				.isEqualTo("UP"); 	}
@WebEndpointTest 	void whenHealthIsDown503ResponseIsReturned(ApplicationContext context, WebTestClient client) { 		HealthIndicator healthIndicator = () -> Health.down().build(); 		ReactiveHealthIndicator reactiveHealthIndicator = () -> Mono.just(Health.down().build()); 		withHealthContributor(context, "charlie", healthIndicator, reactiveHealthIndicator, 				() -> client.get().uri("/actuator/health").exchange().expectStatus() 						.isEqualTo(HttpStatus.SERVICE_UNAVAILABLE).expectBody().jsonPath("status").isEqualTo("DOWN") 						.jsonPath("details.alpha.status").isEqualTo("UP").jsonPath("details.bravo.status") 						.isEqualTo("UP").jsonPath("details.charlie.status").isEqualTo("DOWN")); 	}
@WebEndpointTest 	void whenComponentHealthIsDown503ResponseIsReturned(ApplicationContext context, WebTestClient client) { 		HealthIndicator healthIndicator = () -> Health.down().build(); 		ReactiveHealthIndicator reactiveHealthIndicator = () -> Mono.just(Health.down().build()); 		withHealthContributor(context, "charlie", healthIndicator, reactiveHealthIndicator, 				() -> client.get().uri("/actuator/health/charlie").exchange().expectStatus() 						.isEqualTo(HttpStatus.SERVICE_UNAVAILABLE).expectBody().jsonPath("status").isEqualTo("DOWN")); 	}
@WebEndpointTest 	void whenComponentInstanceHealthIsDown503ResponseIsReturned(ApplicationContext context, WebTestClient client) { 		HealthIndicator healthIndicator = () -> Health.down().build(); 		CompositeHealthContributor composite = CompositeHealthContributor 				.fromMap(Collections.singletonMap("one", healthIndicator)); 		ReactiveHealthIndicator reactiveHealthIndicator = () -> Mono.just(Health.down().build()); 		CompositeReactiveHealthContributor reactiveComposite = CompositeReactiveHealthContributor 				.fromMap(Collections.singletonMap("one", reactiveHealthIndicator)); 		withHealthContributor(context, "charlie", composite, reactiveComposite, 				() -> client.get().uri("/actuator/health/charlie/one").exchange().expectStatus() 						.isEqualTo(HttpStatus.SERVICE_UNAVAILABLE).expectBody().jsonPath("status").isEqualTo("DOWN")); 	}
@WebEndpointTest 	void whenHealthIndicatorIsRemovedResponseIsAltered(WebTestClient client, ApplicationContext context) { 		String name = "bravo"; 		HealthContributorRegistry healthContributorRegistry = getContributorRegistry(context, 				HealthContributorRegistry.class); 		HealthContributor bravo = healthContributorRegistry.unregisterContributor(name); 		ReactiveHealthContributorRegistry reactiveHealthContributorRegistry = getContributorRegistry(context, 				ReactiveHealthContributorRegistry.class); 		ReactiveHealthContributor reactiveBravo = (reactiveHealthContributorRegistry != null) 				? reactiveHealthContributorRegistry.unregisterContributor(name) : null; 		try { 			client.get().uri("/actuator/health").exchange().expectStatus().isOk().expectBody().jsonPath("status") 					.isEqualTo("UP").jsonPath("details.alpha.status").isEqualTo("UP").jsonPath("details.bravo.status") 					.doesNotExist(); 		} 		finally { 			healthContributorRegistry.registerContributor(name, bravo); 			if (reactiveHealthContributorRegistry != null && reactiveBravo != null) { 				reactiveHealthContributorRegistry.registerContributor(name, reactiveBravo); 			} 		} 	}
@Test 	void healthReturnsSystemHealth() { 		this.registry.registerContributor("test", createContributor(this.up)); 		WebEndpointResponse<? extends HealthComponent> response = create(this.registry, this.groups) 				.health(SecurityContext.NONE).block(); 		HealthComponent health = response.getBody(); 		assertThat(health.getStatus()).isEqualTo(Status.UP); 		assertThat(health).isInstanceOf(SystemHealth.class); 		assertThat(response.getStatus()).isEqualTo(200); 	}
@Test 	void healthWhenPathDoesNotExistReturnsHttp404() { 		this.registry.registerContributor("test", createContributor(this.up)); 		WebEndpointResponse<? extends HealthComponent> response = create(this.registry, this.groups) 				.health(SecurityContext.NONE, "missing").block(); 		assertThat(response.getBody()).isNull(); 		assertThat(response.getStatus()).isEqualTo(404); 	}
@Test 	void healthWhenPathExistsReturnsHealth() { 		this.registry.registerContributor("test", createContributor(this.up)); 		WebEndpointResponse<? extends HealthComponent> response = create(this.registry, this.groups) 				.health(SecurityContext.NONE, "test").block(); 		assertThat(response.getBody()).isEqualTo(this.up); 		assertThat(response.getStatus()).isEqualTo(200); 	}
@Test 	void serializeWithJacksonReturnsValidJson() throws Exception { 		Map<String, HealthComponent> components = new LinkedHashMap<>(); 		components.put("db1", Health.up().build()); 		components.put("db2", Health.down().withDetail("a", "b").build()); 		Set<String> groups = new LinkedHashSet<>(Arrays.asList("liveness", "readiness")); 		CompositeHealth health = new SystemHealth(Status.UP, components, groups); 		ObjectMapper mapper = new ObjectMapper(); 		String json = mapper.writeValueAsString(health); 		assertThat(json).isEqualTo("{\"status\":\"UP\",\"details\":{" + "\"db1\":{\"status\":\"UP\"}," 				+ "\"db2\":{\"status\":\"DOWN\",\"details\":{\"a\":\"b\"}}}," 				+ "\"groups\":[\"liveness\",\"readiness\"]}"); 	}
@Bean 	@ConditionalOnMissingBean 	public RSocketStrategies rSocketStrategies( 			ObjectProvider<RSocketStrategiesCustomizer> customizers) { 		RSocketStrategies.Builder builder = RSocketStrategies.builder(); 		builder.reactiveAdapterStrategy(ReactiveAdapterRegistry.getSharedInstance()); 		customizers.stream().forEach((customizer) -> customizer.customize(builder)); 		builder.dataBufferFactory( 				new NettyDataBufferFactory(PooledByteBufAllocator.DEFAULT)); 		return builder.build(); 	}
@Test 	public void shouldCreateDefaultBeans() { 		this.contextRunner.run((context) -> { 			assertThat(context).getBeans(RSocketStrategies.class).hasSize(1); 			RSocketStrategies strategies = context.getBean(RSocketStrategies.class); 			assertThat(strategies.decoders()).hasSize(1) 					.hasOnlyElementsOfType(Jackson2JsonDecoder.class); 			assertThat(strategies.encoders()).hasSize(1) 					.hasOnlyElementsOfType(Jackson2JsonEncoder.class); 		}); 	}
@Test 	public void shouldUseStrategiesCustomizer() { 		this.contextRunner.withUserConfiguration(StrategiesCustomizer.class) 				.run((context) -> { 					assertThat(context).getBeans(RSocketStrategies.class).hasSize(1); 					RSocketStrategies strategies = context 							.getBean(RSocketStrategies.class); 					assertThat(strategies.decoders()).hasSize(2) 							.hasAtLeastOneElementOfType(StringDecoder.class); 					assertThat(strategies.encoders()).hasSize(2) 							.hasAtLeastOneElementOfType(CharSequenceEncoder.class); 				}); 	}
public void willRespond(HttpStatus... response) { 		for (HttpStatus status : response) { 			this.responses.add(new Response(0, null, status)); 		} 	}
@Override 	public Map<String, LoggerLevels> invoke() { 		Collection<LoggerConfiguration> configurations = this.loggingSystem 				.getLoggerConfigurations(); 		if (configurations == null) { 			return Collections.emptyMap(); 		} 		Map<String, LoggerLevels> result = new LinkedHashMap<String, LoggerLevels>( 				configurations.size()); 		for (LoggerConfiguration configuration : configurations) { 			result.put(configuration.getName(), new LoggerLevels(configuration)); 		} 		return result; 	}
@Test 	public void loggersEndpointHasLoggers() throws Exception { 		load(CustomLoggingConfig.class, EndpointAutoConfiguration.class); 		LoggersEndpoint endpoint = this.context.getBean(LoggersEndpoint.class); 		Map<String, LoggerLevels> loggers = endpoint.invoke(); 		assertThat(loggers.size()).isGreaterThan(0); 	}
@Override 				public void contribute(Info.Builder builder) { 					builder.withDetail("name", "bar"); 					builder.withDetail("version", "1.0"); 				}
@Override 			public void contribute(Info.Builder builder) { 				if (!this.content.isEmpty()) { 					builder.withDetail("git", this.content); 				} 			}
@Test 	public void invokeShouldReturnConfigurations() throws Exception { 		given(getLoggingSystem().getLoggerConfigurations()).willReturn(Collections 				.singletonList(new LoggerConfiguration("ROOT", null, LogLevel.DEBUG))); 		LoggerLevels levels = getEndpointBean().invoke().get("ROOT"); 		assertThat(levels.getConfiguredLevel()).isNull(); 		assertThat(levels.getEffectiveLevel()).isEqualTo("DEBUG"); 	}
@Test 	public void getLoggerShouldReturnAllLoggerConfigurations() throws Exception { 		given(this.loggingSystem.getLoggerConfigurations()).willReturn(Collections 				.singletonList(new LoggerConfiguration("ROOT", null, LogLevel.DEBUG))); 		this.mvc.perform(get("/loggers")).andExpect(status().isOk()) 				.andExpect(content().string(equalTo("{\"ROOT\":{\"configuredLevel\":" 						+ "null,\"effectiveLevel\":\"DEBUG\"}}"))); 	}
public void map(LogLevel system, T nativeLevel) { 			this.systemToNative.put(system, nativeLevel); 			this.nativeToSystem.put(nativeLevel, system); 		}
public void setLogLevel(String loggerName, LogLevel level) { 		throw new UnsupportedOperationException("Unable to set log level"); 	}
public List<LoggerConfiguration> getLoggerConfigurations() { 		throw new UnsupportedOperationException("Unable to get logger configurations"); 	}
public LoggerConfiguration getLoggerConfiguration(String loggerName) { 		throw new UnsupportedOperationException("Unable to get logger configuration"); 	}
@Override 		public void setLogLevel(String loggerName, LogLevel level) {  		}
@Override 		public List<LoggerConfiguration> getLoggerConfigurations() { 			return Collections.emptyList(); 		}
@Override 		public LoggerConfiguration getLoggerConfiguration(String loggerName) { 			return null; 		}
public Object getResults(String name) { 		if (!isRegex(name)) { 			return getValue(this.source, name); 		} 		Pattern pattern = Pattern.compile(name); 		ResultCollectingNameCallback resultCollector = new ResultCollectingNameCallback( 				pattern); 		getNames(this.source, resultCollector); 		return resultCollector.getResults();  	}
@Test 	public void sub() throws Exception { 		this.mvc.perform(get("/env/foo")).andExpect(status().isOk()) 				.andExpect(content().string(equalToIgnoringCase("bar"))); 	}
@Test 	public void specificMetric() throws Exception { 		this.mvc.perform(get("/metrics/foo")).andExpect(status().isOk()) 				.andExpect(content().string(equalTo("1"))); 	}
@Test 	public void nonRegex() throws Exception { 		MockNamePatternFilter filter = new MockNamePatternFilter(); 		assertThat(filter.getResults("not.a.regex"), equalTo((Object) "not.a.regex")); 		assertThat(filter.isGetNamesCalled(), equalTo(false)); 	}
@Test 	@SuppressWarnings("unchecked") 	public void regex() throws Exception { 		MockNamePatternFilter filter = new MockNamePatternFilter(); 		Map<String, Object> results = (Map<String, Object>) filter.getResults("fo.*"); 		assertThat(results.get("foo"), equalTo((Object) "foo")); 		assertThat(results.get("fool"), equalTo((Object) "fool")); 		assertThat(filter.isGetNamesCalled(), equalTo(true));  	}
@Override 	public void increment(Delta<?> delta) { 		this.channel.send(MessageBuilder.withPayload(delta) 				.setHeader(METRIC_NAME, delta.getName()).build()); 	}
@Override 	public void set(Metric<?> value) { 		this.channel.send(MessageBuilder.withPayload(value) 				.setHeader(METRIC_NAME, value.getName()).build()); 	}
@Override 	public void reset(String metricName) { 		this.channel.send(MessageBuilder.withPayload(this.DELETE) 				.setHeader(METRIC_NAME, metricName).build()); 	}
@Override 	public void handleMessage(Message<?> message) throws MessagingException { 		Object payload = message.getPayload(); 		if (payload instanceof Delta) { 			Delta<?> value = (Delta<?>) payload; 			this.observer.increment(value); 		} 		else { 			Metric<?> value = (Metric<?>) payload; 			this.observer.set(value); 		} 	}
@Test 	public void messageSentOnAdd() { 		this.observer.increment(new Delta<Integer>("foo", 1)); 		verify(this.channel).send(any(Message.class)); 	}
@Test 	public void messageSentOnSet() { 		this.observer.set(new Metric<Double>("foo", 1d)); 		verify(this.channel).send(any(Message.class)); 	}
private void flatten(Properties properties, Map<String, Object> input, String path) { 		for (Entry<String, Object> entry : input.entrySet()) { 			String key = entry.getKey(); 			if (StringUtils.hasText(path)) { 				if (key.startsWith("[")) { 					key = path + key; 				} 				else { 					key = path + "." + key; 				} 			} 			Object value = entry.getValue(); 			if (value instanceof String) { 				properties.put(key, value); 			} 			else if (value instanceof Number) { 				properties.put(key, value.toString()); 			} 			else if (value instanceof Map) { 				// Need a compound key 				@SuppressWarnings("unchecked") 				Map<String, Object> map = (Map<String, Object>) value; 				flatten(properties, map, key); 			} 			else if (value instanceof Collection) { 				// Need a compound key 				@SuppressWarnings("unchecked") 				Collection<Object> collection = (Collection<Object>) value; 				properties.put(key, 						StringUtils.collectionToCommaDelimitedString(collection)); 				int count = 0; 				for (Object object : collection) { 					flatten(properties, 							Collections.singletonMap("[" + (count++) + "]", object), key); 				} 			} 			else { 				properties.put(key, value == null ? "" : value); 			} 		} 	}
@Test 	public void testServiceProperties() { 		EnvironmentTestUtils 				.addEnvironment( 						this.context, 						"VCAP_SERVICES:{\"rds-mysql-n/a\":[{" 								+ "\"name\":\"mysql\",\"label\":\"rds-mysql-n/a\"," 								+ "\"plan\":\"10mb\",\"credentials\":{" 								+ "\"name\":\"d04fb13d27d964c62b267bbba1cffb9da\"," 								+ "\"hostname\":\"mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\"," 								+ "\"host\":\"mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\"," 								+ "\"port\":3306,\"user\":\"urpRuqTf8Cpe6\",\"username\":" 								+ "\"urpRuqTf8Cpe6\",\"password\":\"pxLsGVpsC9A5S\"}}]}"); 		this.initializer.onApplicationEvent(this.event); 		assertEquals("mysql", getProperty("vcap.services.mysql.name")); 		assertEquals("3306", getProperty("vcap.services.mysql.credentials.port")); 	}
private void flatten(Properties properties, Map<String, Object> input, String path) { 		for (Entry<String, Object> entry : input.entrySet()) { 			String key = entry.getKey(); 			if (StringUtils.hasText(path)) { 				if (key.startsWith("[")) { 					key = path + key; 				} 				else { 					key = path + "." + key; 				} 			} 			Object value = entry.getValue(); 			if (value instanceof String) { 				properties.put(key, value); 			} 			else if (value instanceof Map) { 				// Need a compound key 				@SuppressWarnings("unchecked") 				Map<String, Object> map = (Map<String, Object>) value; 				flatten(properties, map, key); 			} 			else if (value instanceof Collection) { 				// Need a compound key 				@SuppressWarnings("unchecked") 				Collection<Object> collection = (Collection<Object>) value; 				properties.put(key, 						StringUtils.collectionToCommaDelimitedString(collection)); 				int count = 0; 				for (Object object : collection) { 					flatten(properties, 							Collections.singletonMap("[" + (count++) + "]", object), key); 				} 			} 			else { 				properties.put(key, value == null ? "" : value); 			} 		} 	}
@Test 	public void testServiceProperties() { 		EnvironmentTestUtils 				.addEnvironment( 						this.context, 						"VCAP_SERVICES:{\"rds-mysql-n/a\":[{\"name\":\"mysql\",\"label\":\"rds-mysql-n/a\",\"plan\":\"10mb\",\"credentials\":{\"name\":\"d04fb13d27d964c62b267bbba1cffb9da\",\"hostname\":\"mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\",\"host\":\"mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\",\"port\":3306,\"user\":\"urpRuqTf8Cpe6\",\"username\":\"urpRuqTf8Cpe6\",\"password\":\"pxLsGVpsC9A5S\"}}]}"); 		this.initializer.onApplicationEvent(this.event); 		assertEquals("mysql", 				this.context.getEnvironment().getProperty("vcap.services.mysql.name")); 	}
@Test 	public void testServicePropertiesWithoutNA() { 		EnvironmentTestUtils 				.addEnvironment( 						this.context, 						"VCAP_SERVICES:{\"rds-mysql\":[{\"name\":\"mysql\",\"label\":\"rds-mysql\",\"plan\":\"10mb\",\"credentials\":{\"name\":\"d04fb13d27d964c62b267bbba1cffb9da\",\"hostname\":\"mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\",\"host\":\"mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\",\"port\":3306,\"user\":\"urpRuqTf8Cpe6\",\"username\":\"urpRuqTf8Cpe6\",\"password\":\"pxLsGVpsC9A5S\"}}]}"); 		this.initializer.onApplicationEvent(this.event); 		assertEquals("mysql", 				this.context.getEnvironment().getProperty("vcap.services.mysql.name")); 	}
